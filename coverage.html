
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gohugoio/hugo/bufferpool/bufpool.go (100.0%)</option>
				
				<option value="file1">github.com/gohugoio/hugo/cache/filecache/filecache.go (15.5%)</option>
				
				<option value="file2">github.com/gohugoio/hugo/cache/filecache/filecache_config.go (68.3%)</option>
				
				<option value="file3">github.com/gohugoio/hugo/cache/filecache/filecache_pruner.go (0.0%)</option>
				
				<option value="file4">github.com/gohugoio/hugo/cache/namedmemcache/named_cache.go (5.9%)</option>
				
				<option value="file5">github.com/gohugoio/hugo/cache/partitioned_lazy_cache.go (40.0%)</option>
				
				<option value="file6">github.com/gohugoio/hugo/commands/check_darwin.go (100.0%)</option>
				
				<option value="file7">github.com/gohugoio/hugo/commands/commandeer.go (50.7%)</option>
				
				<option value="file8">github.com/gohugoio/hugo/commands/commands.go (84.0%)</option>
				
				<option value="file9">github.com/gohugoio/hugo/commands/config.go (15.8%)</option>
				
				<option value="file10">github.com/gohugoio/hugo/commands/convert.go (9.4%)</option>
				
				<option value="file11">github.com/gohugoio/hugo/commands/deploy.go (50.0%)</option>
				
				<option value="file12">github.com/gohugoio/hugo/commands/env.go (16.7%)</option>
				
				<option value="file13">github.com/gohugoio/hugo/commands/gen.go (100.0%)</option>
				
				<option value="file14">github.com/gohugoio/hugo/commands/genautocomplete.go (46.2%)</option>
				
				<option value="file15">github.com/gohugoio/hugo/commands/genchromastyles.go (33.3%)</option>
				
				<option value="file16">github.com/gohugoio/hugo/commands/gendoc.go (24.0%)</option>
				
				<option value="file17">github.com/gohugoio/hugo/commands/gendocshelper.go (23.5%)</option>
				
				<option value="file18">github.com/gohugoio/hugo/commands/genman.go (29.4%)</option>
				
				<option value="file19">github.com/gohugoio/hugo/commands/helpers.go (0.0%)</option>
				
				<option value="file20">github.com/gohugoio/hugo/commands/hugo.go (30.1%)</option>
				
				<option value="file21">github.com/gohugoio/hugo/commands/import_jekyll.go (2.1%)</option>
				
				<option value="file22">github.com/gohugoio/hugo/commands/limit_darwin.go (6.9%)</option>
				
				<option value="file23">github.com/gohugoio/hugo/commands/list.go (9.8%)</option>
				
				<option value="file24">github.com/gohugoio/hugo/commands/mod.go (17.6%)</option>
				
				<option value="file25">github.com/gohugoio/hugo/commands/new.go (19.0%)</option>
				
				<option value="file26">github.com/gohugoio/hugo/commands/new_site.go (13.6%)</option>
				
				<option value="file27">github.com/gohugoio/hugo/commands/new_theme.go (8.9%)</option>
				
				<option value="file28">github.com/gohugoio/hugo/commands/release_noop.go (100.0%)</option>
				
				<option value="file29">github.com/gohugoio/hugo/commands/server.go (7.1%)</option>
				
				<option value="file30">github.com/gohugoio/hugo/commands/server_errors.go (0.0%)</option>
				
				<option value="file31">github.com/gohugoio/hugo/commands/static_syncer.go (0.0%)</option>
				
				<option value="file32">github.com/gohugoio/hugo/commands/version.go (25.0%)</option>
				
				<option value="file33">github.com/gohugoio/hugo/common/collections/append.go (0.0%)</option>
				
				<option value="file34">github.com/gohugoio/hugo/common/collections/slice.go (52.6%)</option>
				
				<option value="file35">github.com/gohugoio/hugo/common/herrors/error_locator.go (2.4%)</option>
				
				<option value="file36">github.com/gohugoio/hugo/common/herrors/errors.go (0.0%)</option>
				
				<option value="file37">github.com/gohugoio/hugo/common/herrors/file_error.go (0.0%)</option>
				
				<option value="file38">github.com/gohugoio/hugo/common/herrors/line_number_extractors.go (18.8%)</option>
				
				<option value="file39">github.com/gohugoio/hugo/common/hreflect/helpers.go (62.5%)</option>
				
				<option value="file40">github.com/gohugoio/hugo/common/hugio/copy.go (0.0%)</option>
				
				<option value="file41">github.com/gohugoio/hugo/common/hugio/readers.go (0.0%)</option>
				
				<option value="file42">github.com/gohugoio/hugo/common/hugio/writers.go (0.0%)</option>
				
				<option value="file43">github.com/gohugoio/hugo/common/hugo/hugo.go (60.0%)</option>
				
				<option value="file44">github.com/gohugoio/hugo/common/hugo/version.go (43.2%)</option>
				
				<option value="file45">github.com/gohugoio/hugo/common/loggers/loggers.go (64.4%)</option>
				
				<option value="file46">github.com/gohugoio/hugo/common/maps/maps.go (71.4%)</option>
				
				<option value="file47">github.com/gohugoio/hugo/common/maps/maps_get.go (66.7%)</option>
				
				<option value="file48">github.com/gohugoio/hugo/common/maps/params.go (48.4%)</option>
				
				<option value="file49">github.com/gohugoio/hugo/common/maps/scratch.go (3.6%)</option>
				
				<option value="file50">github.com/gohugoio/hugo/common/math/math.go (16.2%)</option>
				
				<option value="file51">github.com/gohugoio/hugo/common/terminal/colors.go (72.7%)</option>
				
				<option value="file52">github.com/gohugoio/hugo/common/text/position.go (48.1%)</option>
				
				<option value="file53">github.com/gohugoio/hugo/common/types/evictingqueue.go (2.9%)</option>
				
				<option value="file54">github.com/gohugoio/hugo/common/types/types.go (41.7%)</option>
				
				<option value="file55">github.com/gohugoio/hugo/compare/compare_strings.go (44.2%)</option>
				
				<option value="file56">github.com/gohugoio/hugo/config/configLoader.go (30.6%)</option>
				
				<option value="file57">github.com/gohugoio/hugo/config/configProvider.go (38.5%)</option>
				
				<option value="file58">github.com/gohugoio/hugo/config/env.go (84.6%)</option>
				
				<option value="file59">github.com/gohugoio/hugo/config/privacy/privacyConfig.go (40.0%)</option>
				
				<option value="file60">github.com/gohugoio/hugo/config/services/servicesConfig.go (100.0%)</option>
				
				<option value="file61">github.com/gohugoio/hugo/config/sitemap.go (28.6%)</option>
				
				<option value="file62">github.com/gohugoio/hugo/create/content.go (0.0%)</option>
				
				<option value="file63">github.com/gohugoio/hugo/create/content_template_handler.go (0.0%)</option>
				
				<option value="file64">github.com/gohugoio/hugo/deploy/cloudfront.go (0.0%)</option>
				
				<option value="file65">github.com/gohugoio/hugo/deploy/deploy.go (0.0%)</option>
				
				<option value="file66">github.com/gohugoio/hugo/deploy/deployConfig.go (0.0%)</option>
				
				<option value="file67">github.com/gohugoio/hugo/deps/deps.go (41.0%)</option>
				
				<option value="file68">github.com/gohugoio/hugo/docshelper/docs.go (50.0%)</option>
				
				<option value="file69">github.com/gohugoio/hugo/helpers/content.go (37.7%)</option>
				
				<option value="file70">github.com/gohugoio/hugo/helpers/content_renderer.go (28.1%)</option>
				
				<option value="file71">github.com/gohugoio/hugo/helpers/docshelper.go (10.0%)</option>
				
				<option value="file72">github.com/gohugoio/hugo/helpers/emoji.go (0.0%)</option>
				
				<option value="file73">github.com/gohugoio/hugo/helpers/general.go (27.6%)</option>
				
				<option value="file74">github.com/gohugoio/hugo/helpers/path.go (24.8%)</option>
				
				<option value="file75">github.com/gohugoio/hugo/helpers/pathspec.go (73.7%)</option>
				
				<option value="file76">github.com/gohugoio/hugo/helpers/processing_stats.go (60.0%)</option>
				
				<option value="file77">github.com/gohugoio/hugo/helpers/pygments.go (19.3%)</option>
				
				<option value="file78">github.com/gohugoio/hugo/helpers/url.go (17.6%)</option>
				
				<option value="file79">github.com/gohugoio/hugo/hugofs/createcounting_fs.go (0.0%)</option>
				
				<option value="file80">github.com/gohugoio/hugo/hugofs/decorators.go (61.0%)</option>
				
				<option value="file81">github.com/gohugoio/hugo/hugofs/fileinfo.go (79.8%)</option>
				
				<option value="file82">github.com/gohugoio/hugo/hugofs/files/classifier.go (76.2%)</option>
				
				<option value="file83">github.com/gohugoio/hugo/hugofs/filter_fs.go (59.7%)</option>
				
				<option value="file84">github.com/gohugoio/hugo/hugofs/fs.go (45.5%)</option>
				
				<option value="file85">github.com/gohugoio/hugo/hugofs/glob.go (0.0%)</option>
				
				<option value="file86">github.com/gohugoio/hugo/hugofs/glob/glob.go (37.5%)</option>
				
				<option value="file87">github.com/gohugoio/hugo/hugofs/hashing_fs.go (0.0%)</option>
				
				<option value="file88">github.com/gohugoio/hugo/hugofs/language_composite_fs.go (23.1%)</option>
				
				<option value="file89">github.com/gohugoio/hugo/hugofs/noop_fs.go (0.0%)</option>
				
				<option value="file90">github.com/gohugoio/hugo/hugofs/nosymlink_fs.go (65.3%)</option>
				
				<option value="file91">github.com/gohugoio/hugo/hugofs/rootmapping_fs.go (53.1%)</option>
				
				<option value="file92">github.com/gohugoio/hugo/hugofs/slice_fs.go (5.2%)</option>
				
				<option value="file93">github.com/gohugoio/hugo/hugofs/stacktracer_fs.go (0.0%)</option>
				
				<option value="file94">github.com/gohugoio/hugo/hugofs/walk.go (62.9%)</option>
				
				<option value="file95">github.com/gohugoio/hugo/hugolib/alias.go (71.0%)</option>
				
				<option value="file96">github.com/gohugoio/hugo/hugolib/collections.go (0.0%)</option>
				
				<option value="file97">github.com/gohugoio/hugo/hugolib/config.go (52.6%)</option>
				
				<option value="file98">github.com/gohugoio/hugo/hugolib/fileInfo.go (14.8%)</option>
				
				<option value="file99">github.com/gohugoio/hugo/hugolib/filesystems/basefs.go (52.0%)</option>
				
				<option value="file100">github.com/gohugoio/hugo/hugolib/gitinfo.go (0.0%)</option>
				
				<option value="file101">github.com/gohugoio/hugo/hugolib/hugo_sites.go (41.5%)</option>
				
				<option value="file102">github.com/gohugoio/hugo/hugolib/hugo_sites_build.go (61.9%)</option>
				
				<option value="file103">github.com/gohugoio/hugo/hugolib/multilingual.go (57.1%)</option>
				
				<option value="file104">github.com/gohugoio/hugo/hugolib/page.go (34.4%)</option>
				
				<option value="file105">github.com/gohugoio/hugo/hugolib/page__content.go (39.1%)</option>
				
				<option value="file106">github.com/gohugoio/hugo/hugolib/page__data.go (60.0%)</option>
				
				<option value="file107">github.com/gohugoio/hugo/hugolib/page__menus.go (43.8%)</option>
				
				<option value="file108">github.com/gohugoio/hugo/hugolib/page__meta.go (38.4%)</option>
				
				<option value="file109">github.com/gohugoio/hugo/hugolib/page__new.go (82.0%)</option>
				
				<option value="file110">github.com/gohugoio/hugo/hugolib/page__output.go (90.9%)</option>
				
				<option value="file111">github.com/gohugoio/hugo/hugolib/page__paginator.go (39.5%)</option>
				
				<option value="file112">github.com/gohugoio/hugo/hugolib/page__paths.go (80.4%)</option>
				
				<option value="file113">github.com/gohugoio/hugo/hugolib/page__per_output.go (40.8%)</option>
				
				<option value="file114">github.com/gohugoio/hugo/hugolib/page__position.go (16.7%)</option>
				
				<option value="file115">github.com/gohugoio/hugo/hugolib/page__ref.go (2.8%)</option>
				
				<option value="file116">github.com/gohugoio/hugo/hugolib/page__tree.go (10.9%)</option>
				
				<option value="file117">github.com/gohugoio/hugo/hugolib/page_kinds.go (0.0%)</option>
				
				<option value="file118">github.com/gohugoio/hugo/hugolib/page_unwrap.go (0.0%)</option>
				
				<option value="file119">github.com/gohugoio/hugo/hugolib/pagecollections.go (64.9%)</option>
				
				<option value="file120">github.com/gohugoio/hugo/hugolib/pages_capture.go (37.2%)</option>
				
				<option value="file121">github.com/gohugoio/hugo/hugolib/pages_map.go (58.5%)</option>
				
				<option value="file122">github.com/gohugoio/hugo/hugolib/paths/baseURL.go (26.9%)</option>
				
				<option value="file123">github.com/gohugoio/hugo/hugolib/paths/paths.go (52.6%)</option>
				
				<option value="file124">github.com/gohugoio/hugo/hugolib/prune_resources.go (0.0%)</option>
				
				<option value="file125">github.com/gohugoio/hugo/hugolib/shortcode.go (4.1%)</option>
				
				<option value="file126">github.com/gohugoio/hugo/hugolib/shortcode_page.go (0.0%)</option>
				
				<option value="file127">github.com/gohugoio/hugo/hugolib/site.go (31.8%)</option>
				
				<option value="file128">github.com/gohugoio/hugo/hugolib/site_output.go (25.8%)</option>
				
				<option value="file129">github.com/gohugoio/hugo/hugolib/site_render.go (49.6%)</option>
				
				<option value="file130">github.com/gohugoio/hugo/hugolib/site_sections.go (0.0%)</option>
				
				<option value="file131">github.com/gohugoio/hugo/hugolib/taxonomy.go (0.0%)</option>
				
				<option value="file132">github.com/gohugoio/hugo/hugolib/translations.go (0.0%)</option>
				
				<option value="file133">github.com/gohugoio/hugo/langs/config.go (33.3%)</option>
				
				<option value="file134">github.com/gohugoio/hugo/langs/i18n/i18n.go (43.9%)</option>
				
				<option value="file135">github.com/gohugoio/hugo/langs/i18n/translationProvider.go (57.4%)</option>
				
				<option value="file136">github.com/gohugoio/hugo/langs/language.go (52.3%)</option>
				
				<option value="file137">github.com/gohugoio/hugo/lazy/init.go (55.4%)</option>
				
				<option value="file138">github.com/gohugoio/hugo/lazy/once.go (76.5%)</option>
				
				<option value="file139">github.com/gohugoio/hugo/livereload/connection.go (0.0%)</option>
				
				<option value="file140">github.com/gohugoio/hugo/livereload/hub.go (0.0%)</option>
				
				<option value="file141">github.com/gohugoio/hugo/livereload/livereload.go (0.0%)</option>
				
				<option value="file142">github.com/gohugoio/hugo/main.go (0.0%)</option>
				
				<option value="file143">github.com/gohugoio/hugo/media/docshelper.go (40.0%)</option>
				
				<option value="file144">github.com/gohugoio/hugo/media/mediaType.go (32.0%)</option>
				
				<option value="file145">github.com/gohugoio/hugo/metrics/metrics.go (0.0%)</option>
				
				<option value="file146">github.com/gohugoio/hugo/minifiers/minifiers.go (77.8%)</option>
				
				<option value="file147">github.com/gohugoio/hugo/modules/client.go (10.9%)</option>
				
				<option value="file148">github.com/gohugoio/hugo/modules/collect.go (65.7%)</option>
				
				<option value="file149">github.com/gohugoio/hugo/modules/config.go (71.8%)</option>
				
				<option value="file150">github.com/gohugoio/hugo/modules/module.go (51.9%)</option>
				
				<option value="file151">github.com/gohugoio/hugo/navigation/menu.go (0.0%)</option>
				
				<option value="file152">github.com/gohugoio/hugo/navigation/pagemenus.go (9.8%)</option>
				
				<option value="file153">github.com/gohugoio/hugo/output/docshelper.go (9.5%)</option>
				
				<option value="file154">github.com/gohugoio/hugo/output/layout.go (86.3%)</option>
				
				<option value="file155">github.com/gohugoio/hugo/output/layout_base.go (88.2%)</option>
				
				<option value="file156">github.com/gohugoio/hugo/output/outputFormat.go (45.5%)</option>
				
				<option value="file157">github.com/gohugoio/hugo/parser/frontmatter.go (0.0%)</option>
				
				<option value="file158">github.com/gohugoio/hugo/parser/metadecoders/decoder.go (27.6%)</option>
				
				<option value="file159">github.com/gohugoio/hugo/parser/metadecoders/format.go (20.5%)</option>
				
				<option value="file160">github.com/gohugoio/hugo/parser/pageparser/item.go (23.8%)</option>
				
				<option value="file161">github.com/gohugoio/hugo/parser/pageparser/itemtype_string.go (0.0%)</option>
				
				<option value="file162">github.com/gohugoio/hugo/parser/pageparser/pagelexer.go (34.5%)</option>
				
				<option value="file163">github.com/gohugoio/hugo/parser/pageparser/pagelexer_intro.go (30.0%)</option>
				
				<option value="file164">github.com/gohugoio/hugo/parser/pageparser/pagelexer_shortcode.go (0.0%)</option>
				
				<option value="file165">github.com/gohugoio/hugo/parser/pageparser/pageparser.go (38.7%)</option>
				
				<option value="file166">github.com/gohugoio/hugo/publisher/publisher.go (74.4%)</option>
				
				<option value="file167">github.com/gohugoio/hugo/related/inverted_index.go (49.0%)</option>
				
				<option value="file168">github.com/gohugoio/hugo/resources/image.go (0.0%)</option>
				
				<option value="file169">github.com/gohugoio/hugo/resources/image_cache.go (1.5%)</option>
				
				<option value="file170">github.com/gohugoio/hugo/resources/images/config.go (11.7%)</option>
				
				<option value="file171">github.com/gohugoio/hugo/resources/images/exif/exif.go (27.4%)</option>
				
				<option value="file172">github.com/gohugoio/hugo/resources/images/filters.go (0.0%)</option>
				
				<option value="file173">github.com/gohugoio/hugo/resources/images/image.go (5.0%)</option>
				
				<option value="file174">github.com/gohugoio/hugo/resources/images/resampling.go (0.0%)</option>
				
				<option value="file175">github.com/gohugoio/hugo/resources/images/smartcrop.go (0.0%)</option>
				
				<option value="file176">github.com/gohugoio/hugo/resources/internal/key.go (0.0%)</option>
				
				<option value="file177">github.com/gohugoio/hugo/resources/page/page.go (100.0%)</option>
				
				<option value="file178">github.com/gohugoio/hugo/resources/page/page_data.go (57.1%)</option>
				
				<option value="file179">github.com/gohugoio/hugo/resources/page/page_kinds.go (0.0%)</option>
				
				<option value="file180">github.com/gohugoio/hugo/resources/page/page_marshaljson.autogen.go (0.0%)</option>
				
				<option value="file181">github.com/gohugoio/hugo/resources/page/page_nop.go (0.9%)</option>
				
				<option value="file182">github.com/gohugoio/hugo/resources/page/page_outputformat.go (91.7%)</option>
				
				<option value="file183">github.com/gohugoio/hugo/resources/page/page_paths.go (75.0%)</option>
				
				<option value="file184">github.com/gohugoio/hugo/resources/page/page_wrappers.autogen.go (21.2%)</option>
				
				<option value="file185">github.com/gohugoio/hugo/resources/page/pagegroup.go (1.2%)</option>
				
				<option value="file186">github.com/gohugoio/hugo/resources/page/pagemeta/page_frontmatter.go (60.8%)</option>
				
				<option value="file187">github.com/gohugoio/hugo/resources/page/pages.go (14.5%)</option>
				
				<option value="file188">github.com/gohugoio/hugo/resources/page/pages_cache.go (23.4%)</option>
				
				<option value="file189">github.com/gohugoio/hugo/resources/page/pages_language_merge.go (0.0%)</option>
				
				<option value="file190">github.com/gohugoio/hugo/resources/page/pages_prev_next.go (0.0%)</option>
				
				<option value="file191">github.com/gohugoio/hugo/resources/page/pages_related.go (56.5%)</option>
				
				<option value="file192">github.com/gohugoio/hugo/resources/page/pages_sort.go (10.0%)</option>
				
				<option value="file193">github.com/gohugoio/hugo/resources/page/pagination.go (29.9%)</option>
				
				<option value="file194">github.com/gohugoio/hugo/resources/page/permalinks.go (18.3%)</option>
				
				<option value="file195">github.com/gohugoio/hugo/resources/page/site.go (0.0%)</option>
				
				<option value="file196">github.com/gohugoio/hugo/resources/page/weighted.go (0.0%)</option>
				
				<option value="file197">github.com/gohugoio/hugo/resources/page/zero_file.autogen.go (7.1%)</option>
				
				<option value="file198">github.com/gohugoio/hugo/resources/resource.go (0.0%)</option>
				
				<option value="file199">github.com/gohugoio/hugo/resources/resource/dates.go (60.0%)</option>
				
				<option value="file200">github.com/gohugoio/hugo/resources/resource/params.go (75.0%)</option>
				
				<option value="file201">github.com/gohugoio/hugo/resources/resource/resource_helpers.go (0.0%)</option>
				
				<option value="file202">github.com/gohugoio/hugo/resources/resource/resources.go (20.6%)</option>
				
				<option value="file203">github.com/gohugoio/hugo/resources/resource/resourcetypes.go (20.0%)</option>
				
				<option value="file204">github.com/gohugoio/hugo/resources/resource_cache.go (0.9%)</option>
				
				<option value="file205">github.com/gohugoio/hugo/resources/resource_factories/bundler/bundler.go (2.0%)</option>
				
				<option value="file206">github.com/gohugoio/hugo/resources/resource_factories/create/create.go (2.9%)</option>
				
				<option value="file207">github.com/gohugoio/hugo/resources/resource_metadata.go (0.0%)</option>
				
				<option value="file208">github.com/gohugoio/hugo/resources/resource_spec.go (11.6%)</option>
				
				<option value="file209">github.com/gohugoio/hugo/resources/resource_transformers/integrity/integrity.go (3.3%)</option>
				
				<option value="file210">github.com/gohugoio/hugo/resources/resource_transformers/minifier/minify.go (14.3%)</option>
				
				<option value="file211">github.com/gohugoio/hugo/resources/resource_transformers/postcss/postcss.go (1.6%)</option>
				
				<option value="file212">github.com/gohugoio/hugo/resources/resource_transformers/templates/execute_as_template.go (23.1%)</option>
				
				<option value="file213">github.com/gohugoio/hugo/resources/resource_transformers/tocss/scss/client.go (7.1%)</option>
				
				<option value="file214">github.com/gohugoio/hugo/resources/resource_transformers/tocss/scss/tocss_notavailable.go (0.0%)</option>
				
				<option value="file215">github.com/gohugoio/hugo/resources/transform.go (0.0%)</option>
				
				<option value="file216">github.com/gohugoio/hugo/source/fileInfo.go (80.0%)</option>
				
				<option value="file217">github.com/gohugoio/hugo/source/filesystem.go (75.0%)</option>
				
				<option value="file218">github.com/gohugoio/hugo/source/sourceSpec.go (37.5%)</option>
				
				<option value="file219">github.com/gohugoio/hugo/tpl/cast/cast.go (7.7%)</option>
				
				<option value="file220">github.com/gohugoio/hugo/tpl/cast/docshelper.go (15.4%)</option>
				
				<option value="file221">github.com/gohugoio/hugo/tpl/cast/init.go (88.9%)</option>
				
				<option value="file222">github.com/gohugoio/hugo/tpl/collections/append.go (0.0%)</option>
				
				<option value="file223">github.com/gohugoio/hugo/tpl/collections/apply.go (10.8%)</option>
				
				<option value="file224">github.com/gohugoio/hugo/tpl/collections/collections.go (8.8%)</option>
				
				<option value="file225">github.com/gohugoio/hugo/tpl/collections/complement.go (0.0%)</option>
				
				<option value="file226">github.com/gohugoio/hugo/tpl/collections/index.go (35.1%)</option>
				
				<option value="file227">github.com/gohugoio/hugo/tpl/collections/init.go (96.9%)</option>
				
				<option value="file228">github.com/gohugoio/hugo/tpl/collections/merge.go (0.0%)</option>
				
				<option value="file229">github.com/gohugoio/hugo/tpl/collections/reflect_helpers.go (12.5%)</option>
				
				<option value="file230">github.com/gohugoio/hugo/tpl/collections/sort.go (0.0%)</option>
				
				<option value="file231">github.com/gohugoio/hugo/tpl/collections/symdiff.go (0.0%)</option>
				
				<option value="file232">github.com/gohugoio/hugo/tpl/collections/where.go (30.0%)</option>
				
				<option value="file233">github.com/gohugoio/hugo/tpl/compare/compare.go (42.6%)</option>
				
				<option value="file234">github.com/gohugoio/hugo/tpl/compare/init.go (94.4%)</option>
				
				<option value="file235">github.com/gohugoio/hugo/tpl/compare/truth.go (52.6%)</option>
				
				<option value="file236">github.com/gohugoio/hugo/tpl/crypto/crypto.go (6.2%)</option>
				
				<option value="file237">github.com/gohugoio/hugo/tpl/crypto/init.go (88.9%)</option>
				
				<option value="file238">github.com/gohugoio/hugo/tpl/data/data.go (2.2%)</option>
				
				<option value="file239">github.com/gohugoio/hugo/tpl/data/init.go (87.5%)</option>
				
				<option value="file240">github.com/gohugoio/hugo/tpl/data/resources.go (0.0%)</option>
				
				<option value="file241">github.com/gohugoio/hugo/tpl/encoding/encoding.go (7.1%)</option>
				
				<option value="file242">github.com/gohugoio/hugo/tpl/encoding/init.go (88.9%)</option>
				
				<option value="file243">github.com/gohugoio/hugo/tpl/fmt/fmt.go (33.3%)</option>
				
				<option value="file244">github.com/gohugoio/hugo/tpl/fmt/init.go (90.0%)</option>
				
				<option value="file245">github.com/gohugoio/hugo/tpl/hugo/init.go (83.3%)</option>
				
				<option value="file246">github.com/gohugoio/hugo/tpl/images/images.go (3.7%)</option>
				
				<option value="file247">github.com/gohugoio/hugo/tpl/images/init.go (85.7%)</option>
				
				<option value="file248">github.com/gohugoio/hugo/tpl/inflect/inflect.go (42.1%)</option>
				
				<option value="file249">github.com/gohugoio/hugo/tpl/inflect/init.go (88.9%)</option>
				
				<option value="file250">github.com/gohugoio/hugo/tpl/internal/templatefuncsRegistry.go (14.1%)</option>
				
				<option value="file251">github.com/gohugoio/hugo/tpl/lang/init.go (87.5%)</option>
				
				<option value="file252">github.com/gohugoio/hugo/tpl/lang/lang.go (7.0%)</option>
				
				<option value="file253">github.com/gohugoio/hugo/tpl/math/init.go (93.8%)</option>
				
				<option value="file254">github.com/gohugoio/hugo/tpl/math/math.go (6.2%)</option>
				
				<option value="file255">github.com/gohugoio/hugo/tpl/math/round.go (0.0%)</option>
				
				<option value="file256">github.com/gohugoio/hugo/tpl/os/init.go (90.0%)</option>
				
				<option value="file257">github.com/gohugoio/hugo/tpl/os/os.go (17.0%)</option>
				
				<option value="file258">github.com/gohugoio/hugo/tpl/partials/init.go (80.0%)</option>
				
				<option value="file259">github.com/gohugoio/hugo/tpl/partials/partials.go (68.9%)</option>
				
				<option value="file260">github.com/gohugoio/hugo/tpl/path/init.go (90.0%)</option>
				
				<option value="file261">github.com/gohugoio/hugo/tpl/path/path.go (2.6%)</option>
				
				<option value="file262">github.com/gohugoio/hugo/tpl/reflect/init.go (87.5%)</option>
				
				<option value="file263">github.com/gohugoio/hugo/tpl/reflect/reflect.go (33.3%)</option>
				
				<option value="file264">github.com/gohugoio/hugo/tpl/resources/init.go (84.6%)</option>
				
				<option value="file265">github.com/gohugoio/hugo/tpl/resources/resources.go (3.8%)</option>
				
				<option value="file266">github.com/gohugoio/hugo/tpl/safe/init.go (92.3%)</option>
				
				<option value="file267">github.com/gohugoio/hugo/tpl/safe/safe.go (33.3%)</option>
				
				<option value="file268">github.com/gohugoio/hugo/tpl/site/init.go (75.0%)</option>
				
				<option value="file269">github.com/gohugoio/hugo/tpl/strings/init.go (96.4%)</option>
				
				<option value="file270">github.com/gohugoio/hugo/tpl/strings/regexp.go (0.0%)</option>
				
				<option value="file271">github.com/gohugoio/hugo/tpl/strings/strings.go (3.1%)</option>
				
				<option value="file272">github.com/gohugoio/hugo/tpl/strings/truncate.go (0.0%)</option>
				
				<option value="file273">github.com/gohugoio/hugo/tpl/template.go (9.6%)</option>
				
				<option value="file274">github.com/gohugoio/hugo/tpl/template_info.go (100.0%)</option>
				
				<option value="file275">github.com/gohugoio/hugo/tpl/templates/init.go (85.7%)</option>
				
				<option value="file276">github.com/gohugoio/hugo/tpl/templates/templates.go (33.3%)</option>
				
				<option value="file277">github.com/gohugoio/hugo/tpl/time/init.go (62.5%)</option>
				
				<option value="file278">github.com/gohugoio/hugo/tpl/time/time.go (8.3%)</option>
				
				<option value="file279">github.com/gohugoio/hugo/tpl/tplimpl/ace.go (0.0%)</option>
				
				<option value="file280">github.com/gohugoio/hugo/tpl/tplimpl/amber_compiler.go (0.0%)</option>
				
				<option value="file281">github.com/gohugoio/hugo/tpl/tplimpl/shortcodes.go (44.7%)</option>
				
				<option value="file282">github.com/gohugoio/hugo/tpl/tplimpl/template.go (58.0%)</option>
				
				<option value="file283">github.com/gohugoio/hugo/tpl/tplimpl/templateFuncster.go (100.0%)</option>
				
				<option value="file284">github.com/gohugoio/hugo/tpl/tplimpl/templateProvider.go (60.0%)</option>
				
				<option value="file285">github.com/gohugoio/hugo/tpl/tplimpl/template_ast_transformers.go (81.0%)</option>
				
				<option value="file286">github.com/gohugoio/hugo/tpl/tplimpl/template_errors.go (0.0%)</option>
				
				<option value="file287">github.com/gohugoio/hugo/tpl/tplimpl/template_funcs.go (85.7%)</option>
				
				<option value="file288">github.com/gohugoio/hugo/tpl/transform/init.go (92.9%)</option>
				
				<option value="file289">github.com/gohugoio/hugo/tpl/transform/remarshal.go (0.0%)</option>
				
				<option value="file290">github.com/gohugoio/hugo/tpl/transform/transform.go (9.7%)</option>
				
				<option value="file291">github.com/gohugoio/hugo/tpl/transform/unmarshal.go (0.0%)</option>
				
				<option value="file292">github.com/gohugoio/hugo/tpl/urls/init.go (92.9%)</option>
				
				<option value="file293">github.com/gohugoio/hugo/tpl/urls/urls.go (6.5%)</option>
				
				<option value="file294">github.com/gohugoio/hugo/transform/chain.go (55.6%)</option>
				
				<option value="file295">github.com/gohugoio/hugo/transform/livereloadinject/livereloadinject.go (0.0%)</option>
				
				<option value="file296">github.com/gohugoio/hugo/transform/metainject/hugogenerator.go (26.7%)</option>
				
				<option value="file297">github.com/gohugoio/hugo/transform/urlreplacers/absurl.go (50.0%)</option>
				
				<option value="file298">github.com/gohugoio/hugo/transform/urlreplacers/absurlreplacer.go (49.4%)</option>
				
				<option value="file299">github.com/gohugoio/hugo/watcher/batcher.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package bufferpool provides a pool of bytes buffers.
package bufferpool

import (
        "bytes"
        "sync"
)

var bufferPool = &amp;sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return &amp;bytes.Buffer{}
        }</span>,
}

// GetBuffer returns a buffer from the pool.
func GetBuffer() (buf *bytes.Buffer) <span class="cov8" title="1">{
        return bufferPool.Get().(*bytes.Buffer)
}</span>

// PutBuffer returns a buffer to the pool.
// The buffer is reset before it is put back into circulation.
func PutBuffer(buf *bytes.Buffer) <span class="cov8" title="1">{
        buf.Reset()
        bufferPool.Put(buf)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package filecache

import (
        "bytes"
        "io"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/gohugoio/hugo/common/hugio"

        "github.com/gohugoio/hugo/helpers"

        "github.com/BurntSushi/locker"
        "github.com/spf13/afero"
)

const (
        filecacheRootDirname = "filecache"
)

// Cache caches a set of files in a directory. This is usually a file on
// disk, but since this is backed by an Afero file system, it can be anything.
type Cache struct {
        Fs afero.Fs

        // Max age for items in this cache. Negative duration means forever,
        // 0 is effectively turning this cache off.
        maxAge time.Duration

        // When set, we just remove this entire root directory on expiration.
        pruneAllRootDir string

        nlocker *lockTracker
}

type lockTracker struct {
        seenMu sync.RWMutex
        seen   map[string]struct{}

        *locker.Locker
}

// Lock tracks the ids in use. We use this information to do garbage collection
// after a Hugo build.
func (l *lockTracker) Lock(id string) <span class="cov0" title="0">{
        l.seenMu.RLock()
        if _, seen := l.seen[id]; !seen </span><span class="cov0" title="0">{
                l.seenMu.RUnlock()
                l.seenMu.Lock()
                l.seen[id] = struct{}{}
                l.seenMu.Unlock()
        }</span> else<span class="cov0" title="0"> {
                l.seenMu.RUnlock()
        }</span>

        <span class="cov0" title="0">l.Locker.Lock(id)</span>
}

// ItemInfo contains info about a cached file.
type ItemInfo struct {
        // This is the file's name relative to the cache's filesystem.
        Name string
}

// NewCache creates a new file cache with the given filesystem and max age.
func NewCache(fs afero.Fs, maxAge time.Duration, pruneAllRootDir string) *Cache <span class="cov8" title="1">{
        return &amp;Cache{
                Fs:              fs,
                nlocker:         &amp;lockTracker{Locker: locker.NewLocker(), seen: make(map[string]struct{})},
                maxAge:          maxAge,
                pruneAllRootDir: pruneAllRootDir,
        }
}</span>

// lockedFile is a file with a lock that is released on Close.
type lockedFile struct {
        afero.File
        unlock func()
}

func (l *lockedFile) Close() error <span class="cov0" title="0">{
        defer l.unlock()
        return l.File.Close()
}</span>

// WriteCloser returns a transactional writer into the cache.
// It's important that it's closed when done.
func (c *Cache) WriteCloser(id string) (ItemInfo, io.WriteCloser, error) <span class="cov0" title="0">{
        id = cleanID(id)
        c.nlocker.Lock(id)

        info := ItemInfo{Name: id}

        f, err := helpers.OpenFileForWriting(c.Fs, id)
        if err != nil </span><span class="cov0" title="0">{
                c.nlocker.Unlock(id)
                return info, nil, err
        }</span>

        <span class="cov0" title="0">return info, &amp;lockedFile{
                File:   f,
                unlock: func() </span><span class="cov0" title="0">{ c.nlocker.Unlock(id) }</span>,
        }, nil
}

// ReadOrCreate tries to lookup the file in cache.
// If found, it is passed to read and then closed.
// If not found a new file is created and passed to create, which should close
// it when done.
func (c *Cache) ReadOrCreate(id string,
        read func(info ItemInfo, r io.Reader) error,
        create func(info ItemInfo, w io.WriteCloser) error) (info ItemInfo, err error) <span class="cov0" title="0">{
        id = cleanID(id)

        c.nlocker.Lock(id)
        defer c.nlocker.Unlock(id)

        info = ItemInfo{Name: id}

        if r := c.getOrRemove(id); r != nil </span><span class="cov0" title="0">{
                err = read(info, r)
                defer r.Close()
                return
        }</span>

        <span class="cov0" title="0">f, err := helpers.OpenFileForWriting(c.Fs, id)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = create(info, f)

        return</span>

}

// GetOrCreate tries to get the file with the given id from cache. If not found or expired, create will
// be invoked and the result cached.
// This method is protected by a named lock using the given id as identifier.
func (c *Cache) GetOrCreate(id string, create func() (io.ReadCloser, error)) (ItemInfo, io.ReadCloser, error) <span class="cov0" title="0">{
        id = cleanID(id)

        c.nlocker.Lock(id)
        defer c.nlocker.Unlock(id)

        info := ItemInfo{Name: id}

        if r := c.getOrRemove(id); r != nil </span><span class="cov0" title="0">{
                return info, r, nil
        }</span>

        <span class="cov0" title="0">r, err := create()
        if err != nil </span><span class="cov0" title="0">{
                return info, nil, err
        }</span>

        <span class="cov0" title="0">if c.maxAge == 0 </span><span class="cov0" title="0">{
                // No caching.
                return info, hugio.ToReadCloser(r), nil
        }</span>

        <span class="cov0" title="0">var buff bytes.Buffer
        return info,
                hugio.ToReadCloser(&amp;buff),
                afero.WriteReader(c.Fs, id, io.TeeReader(r, &amp;buff))</span>
}

// GetOrCreateBytes is the same as GetOrCreate, but produces a byte slice.
func (c *Cache) GetOrCreateBytes(id string, create func() ([]byte, error)) (ItemInfo, []byte, error) <span class="cov0" title="0">{
        id = cleanID(id)

        c.nlocker.Lock(id)
        defer c.nlocker.Unlock(id)

        info := ItemInfo{Name: id}

        if r := c.getOrRemove(id); r != nil </span><span class="cov0" title="0">{
                defer r.Close()
                b, err := ioutil.ReadAll(r)
                return info, b, err
        }</span>

        <span class="cov0" title="0">b, err := create()
        if err != nil </span><span class="cov0" title="0">{
                return info, nil, err
        }</span>

        <span class="cov0" title="0">if c.maxAge == 0 </span><span class="cov0" title="0">{
                return info, b, nil
        }</span>

        <span class="cov0" title="0">if err := afero.WriteReader(c.Fs, id, bytes.NewReader(b)); err != nil </span><span class="cov0" title="0">{
                return info, nil, err
        }</span>
        <span class="cov0" title="0">return info, b, nil</span>

}

// GetBytes gets the file content with the given id from the cahce, nil if none found.
func (c *Cache) GetBytes(id string) (ItemInfo, []byte, error) <span class="cov0" title="0">{
        id = cleanID(id)

        c.nlocker.Lock(id)
        defer c.nlocker.Unlock(id)

        info := ItemInfo{Name: id}

        if r := c.getOrRemove(id); r != nil </span><span class="cov0" title="0">{
                defer r.Close()
                b, err := ioutil.ReadAll(r)
                return info, b, err
        }</span>

        <span class="cov0" title="0">return info, nil, nil</span>
}

// Get gets the file with the given id from the cahce, nil if none found.
func (c *Cache) Get(id string) (ItemInfo, io.ReadCloser, error) <span class="cov0" title="0">{
        id = cleanID(id)

        c.nlocker.Lock(id)
        defer c.nlocker.Unlock(id)

        info := ItemInfo{Name: id}

        r := c.getOrRemove(id)

        return info, r, nil
}</span>

// getOrRemove gets the file with the given id. If it's expired, it will
// be removed.
func (c *Cache) getOrRemove(id string) hugio.ReadSeekCloser <span class="cov0" title="0">{
        if c.maxAge == 0 </span><span class="cov0" title="0">{
                // No caching.
                return nil
        }</span>

        <span class="cov0" title="0">if c.maxAge &gt; 0 </span><span class="cov0" title="0">{
                fi, err := c.Fs.Stat(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if c.isExpired(fi.ModTime()) </span><span class="cov0" title="0">{
                        c.Fs.Remove(id)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">f, err := c.Fs.Open(id)

        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return f</span>
}

func (c *Cache) isExpired(modTime time.Time) bool <span class="cov0" title="0">{
        if c.maxAge &lt; 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return c.maxAge == 0 || time.Since(modTime) &gt; c.maxAge</span>
}

// For testing
func (c *Cache) getString(id string) string <span class="cov0" title="0">{
        id = cleanID(id)

        c.nlocker.Lock(id)
        defer c.nlocker.Unlock(id)

        f, err := c.Fs.Open(id)

        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">defer f.Close()

        b, _ := ioutil.ReadAll(f)
        return string(b)</span>

}

// Caches is a named set of caches.
type Caches map[string]*Cache

// Get gets a named cache, nil if none found.
func (f Caches) Get(name string) *Cache <span class="cov0" title="0">{
        return f[strings.ToLower(name)]
}</span>

// NewCaches creates a new set of file caches from the given
// configuration.
func NewCaches(p *helpers.PathSpec) (Caches, error) <span class="cov8" title="1">{
        var dcfg Configs
        if c, ok := p.Cfg.Get("filecacheConfigs").(Configs); ok </span><span class="cov8" title="1">{
                dcfg = c
        }</span> else<span class="cov0" title="0"> {
                var err error
                dcfg, err = DecodeConfig(p.Fs.Source, p.Cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">fs := p.Fs.Source

        m := make(Caches)
        for k, v := range dcfg </span><span class="cov8" title="1">{
                var cfs afero.Fs

                if v.isResourceDir </span><span class="cov8" title="1">{
                        cfs = p.BaseFs.ResourcesCache
                }</span> else<span class="cov8" title="1"> {
                        cfs = fs
                }</span>

                <span class="cov8" title="1">if cfs == nil </span><span class="cov0" title="0">{
                        // TODO(bep) we still have some places that do not initialize the
                        // full dependencies of a site, e.g. the import Jekyll command.
                        // That command does not need these caches, so let us just continue
                        // for now.
                        continue</span>
                }

                <span class="cov8" title="1">baseDir := v.Dir

                if err := cfs.MkdirAll(baseDir, 0777); err != nil &amp;&amp; !os.IsExist(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">bfs := afero.NewBasePathFs(cfs, baseDir)

                var pruneAllRootDir string
                if k == cacheKeyModules </span><span class="cov8" title="1">{
                        pruneAllRootDir = "pkg"
                }</span>

                <span class="cov8" title="1">m[k] = NewCache(bfs, v.MaxAge, pruneAllRootDir)</span>
        }

        <span class="cov8" title="1">return m, nil</span>
}

func cleanID(name string) string <span class="cov0" title="0">{
        return strings.TrimPrefix(filepath.Clean(name), helpers.FilePathSeparator)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package filecache

import (
        "path"
        "path/filepath"
        "strings"
        "time"

        "github.com/gohugoio/hugo/config"

        "github.com/gohugoio/hugo/helpers"

        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"
        "github.com/spf13/afero"
)

const (
        cachesConfigKey = "caches"

        resourcesGenDir = ":resourceDir/_gen"
)

var defaultCacheConfig = Config{
        MaxAge: -1, // Never expire
        Dir:    ":cacheDir/:project",
}

const (
        cacheKeyGetJSON = "getjson"
        cacheKeyGetCSV  = "getcsv"
        cacheKeyImages  = "images"
        cacheKeyAssets  = "assets"
        cacheKeyModules = "modules"
)

type Configs map[string]Config

func (c Configs) CacheDirModules() string <span class="cov8" title="1">{
        return c[cacheKeyModules].Dir
}</span>

var defaultCacheConfigs = Configs{
        cacheKeyModules: {
                MaxAge: -1,
                Dir:    ":cacheDir/modules",
        },
        cacheKeyGetJSON: defaultCacheConfig,
        cacheKeyGetCSV:  defaultCacheConfig,
        cacheKeyImages: {
                MaxAge: -1,
                Dir:    resourcesGenDir,
        },
        cacheKeyAssets: {
                MaxAge: -1,
                Dir:    resourcesGenDir,
        },
}

type Config struct {
        // Max age of cache entries in this cache. Any items older than this will
        // be removed and not returned from the cache.
        // a negative value means forever, 0 means cache is disabled.
        MaxAge time.Duration

        // The directory where files are stored.
        Dir string

        // Will resources/_gen will get its own composite filesystem that
        // also checks any theme.
        isResourceDir bool
}

// GetJSONCache gets the file cache for getJSON.
func (f Caches) GetJSONCache() *Cache <span class="cov8" title="1">{
        return f[cacheKeyGetJSON]
}</span>

// GetCSVCache gets the file cache for getCSV.
func (f Caches) GetCSVCache() *Cache <span class="cov8" title="1">{
        return f[cacheKeyGetCSV]
}</span>

// ImageCache gets the file cache for processed images.
func (f Caches) ImageCache() *Cache <span class="cov8" title="1">{
        return f[cacheKeyImages]
}</span>

// ModulesCache gets the file cache for Hugo Modules.
func (f Caches) ModulesCache() *Cache <span class="cov0" title="0">{
        return f[cacheKeyModules]
}</span>

// AssetsCache gets the file cache for assets (processed resources, SCSS etc.).
func (f Caches) AssetsCache() *Cache <span class="cov8" title="1">{
        return f[cacheKeyAssets]
}</span>

func DecodeConfig(fs afero.Fs, cfg config.Provider) (Configs, error) <span class="cov8" title="1">{
        c := make(Configs)
        valid := make(map[string]bool)
        // Add defaults
        for k, v := range defaultCacheConfigs </span><span class="cov8" title="1">{
                c[k] = v
                valid[k] = true
        }</span>

        <span class="cov8" title="1">m := cfg.GetStringMap(cachesConfigKey)

        _, isOsFs := fs.(*afero.OsFs)

        for k, v := range m </span><span class="cov0" title="0">{
                cc := defaultCacheConfig

                dc := &amp;mapstructure.DecoderConfig{
                        Result:           &amp;cc,
                        DecodeHook:       mapstructure.StringToTimeDurationHookFunc(),
                        WeaklyTypedInput: true,
                }

                decoder, err := mapstructure.NewDecoder(dc)
                if err != nil </span><span class="cov0" title="0">{
                        return c, err
                }</span>

                <span class="cov0" title="0">if err := decoder.Decode(v); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if cc.Dir == "" </span><span class="cov0" title="0">{
                        return c, errors.New("must provide cache Dir")
                }</span>

                <span class="cov0" title="0">name := strings.ToLower(k)
                if !valid[name] </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%q is not a valid cache name", name)
                }</span>

                <span class="cov0" title="0">c[name] = cc</span>
        }

        // This is a very old flag in Hugo, but we need to respect it.
        <span class="cov8" title="1">disabled := cfg.GetBool("ignoreCache")

        for k, v := range c </span><span class="cov8" title="1">{
                dir := filepath.ToSlash(filepath.Clean(v.Dir))
                hadSlash := strings.HasPrefix(dir, "/")
                parts := strings.Split(dir, "/")

                for i, part := range parts </span><span class="cov8" title="1">{
                        if strings.HasPrefix(part, ":") </span><span class="cov8" title="1">{
                                resolved, isResource, err := resolveDirPlaceholder(fs, cfg, part)
                                if err != nil </span><span class="cov0" title="0">{
                                        return c, err
                                }</span>
                                <span class="cov8" title="1">if isResource </span><span class="cov8" title="1">{
                                        v.isResourceDir = true
                                }</span>
                                <span class="cov8" title="1">parts[i] = resolved</span>
                        }
                }

                <span class="cov8" title="1">dir = path.Join(parts...)
                if hadSlash </span><span class="cov0" title="0">{
                        dir = "/" + dir
                }</span>
                <span class="cov8" title="1">v.Dir = filepath.Clean(filepath.FromSlash(dir))

                if !v.isResourceDir </span><span class="cov8" title="1">{
                        if isOsFs &amp;&amp; !filepath.IsAbs(v.Dir) </span><span class="cov0" title="0">{
                                return c, errors.Errorf("%q must resolve to an absolute directory", v.Dir)
                        }</span>

                        // Avoid cache in root, e.g. / (Unix) or c:\ (Windows)
                        <span class="cov8" title="1">if len(strings.TrimPrefix(v.Dir, filepath.VolumeName(v.Dir))) == 1 </span><span class="cov0" title="0">{
                                return c, errors.Errorf("%q is a root folder and not allowed as cache dir", v.Dir)
                        }</span>
                }

                <span class="cov8" title="1">if !strings.HasPrefix(v.Dir, "_gen") </span><span class="cov8" title="1">{
                        // We do cache eviction (file removes) and since the user can set
                        // his/hers own cache directory, we really want to make sure
                        // we do not delete any files that do not belong to this cache.
                        // We do add the cache name as the root, but this is an extra safe
                        // guard. We skip the files inside /resources/_gen/ because
                        // that would be breaking.
                        v.Dir = filepath.Join(v.Dir, filecacheRootDirname, k)
                }</span> else<span class="cov8" title="1"> {
                        v.Dir = filepath.Join(v.Dir, k)
                }</span>

                <span class="cov8" title="1">if disabled </span><span class="cov0" title="0">{
                        v.MaxAge = 0
                }</span>

                <span class="cov8" title="1">c[k] = v</span>
        }

        <span class="cov8" title="1">return c, nil</span>
}

// Resolves :resourceDir =&gt; /myproject/resources etc., :cacheDir =&gt; ...
func resolveDirPlaceholder(fs afero.Fs, cfg config.Provider, placeholder string) (cacheDir string, isResource bool, err error) <span class="cov8" title="1">{
        workingDir := cfg.GetString("workingDir")

        switch strings.ToLower(placeholder) </span>{
        case ":resourcedir":<span class="cov8" title="1">
                return "", true, nil</span>
        case ":cachedir":<span class="cov8" title="1">
                d, err := helpers.GetCacheDir(fs, cfg)
                return d, false, err</span>
        case ":project":<span class="cov8" title="1">
                return filepath.Base(workingDir), false, nil</span>
        }

        <span class="cov0" title="0">return "", false, errors.Errorf("%q is not a valid placeholder (valid values are :cacheDir or :resourceDir)", placeholder)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package filecache

import (
        "io"
        "os"

        "github.com/pkg/errors"
        "github.com/spf13/afero"
)

// Prune removes expired and unused items from this cache.
// The last one requires a full build so the cache usage can be tracked.
// Note that we operate directly on the filesystem here, so this is not
// thread safe.
func (c Caches) Prune() (int, error) <span class="cov0" title="0">{
        counter := 0
        for k, cache := range c </span><span class="cov0" title="0">{

                count, err := cache.Prune(false)

                if err != nil </span><span class="cov0" title="0">{
                        return counter, errors.Wrapf(err, "failed to prune cache %q", k)
                }</span>

                <span class="cov0" title="0">counter += count</span>

        }

        <span class="cov0" title="0">return counter, nil</span>
}

// Prune removes expired and unused items from this cache.
// If force is set, everything will be removed not considering expiry time.
func (c *Cache) Prune(force bool) (int, error) <span class="cov0" title="0">{
        if c.pruneAllRootDir != "" </span><span class="cov0" title="0">{
                return c.pruneRootDir(force)
        }</span>

        <span class="cov0" title="0">counter := 0

        err := afero.Walk(c.Fs, "", func(name string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if info == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">name = cleanID(name)

                if info.IsDir() </span><span class="cov0" title="0">{
                        f, err := c.Fs.Open(name)
                        if err != nil </span><span class="cov0" title="0">{
                                // This cache dir may not exist.
                                return nil
                        }</span>
                        <span class="cov0" title="0">defer f.Close()
                        _, err = f.Readdirnames(1)
                        if err == io.EOF </span><span class="cov0" title="0">{
                                // Empty dir.
                                return c.Fs.Remove(name)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">shouldRemove := force || c.isExpired(info.ModTime())

                if !shouldRemove &amp;&amp; len(c.nlocker.seen) &gt; 0 </span><span class="cov0" title="0">{
                        // Remove it if it's not been touched/used in the last build.
                        _, seen := c.nlocker.seen[name]
                        shouldRemove = !seen
                }</span>

                <span class="cov0" title="0">if shouldRemove </span><span class="cov0" title="0">{
                        err := c.Fs.Remove(name)
                        if err == nil </span><span class="cov0" title="0">{
                                counter++
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return counter, err</span>
}

func (c *Cache) pruneRootDir(force bool) (int, error) <span class="cov0" title="0">{

        info, err := c.Fs.Stat(c.pruneAllRootDir)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }

        <span class="cov0" title="0">if !force &amp;&amp; !c.isExpired(info.ModTime()) </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">counter := 0
        // Module cache has 0555 directories; make them writable in order to remove content.
        afero.Walk(c.Fs, c.pruneAllRootDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        counter++
                        c.Fs.Chmod(path, 0777)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return 1, c.Fs.RemoveAll(c.pruneAllRootDir)</span>

}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package namedmemcache provides a memory cache with a named lock. This is suitable
// for situations where creating the cached resource can be time consuming or otherwise
// resource hungry, or in situations where a "once only per key" is a requirement.
package namedmemcache

import (
        "sync"

        "github.com/BurntSushi/locker"
)

// Cache holds the cached values.
type Cache struct {
        nlocker *locker.Locker
        cache   map[string]cacheEntry
        mu      sync.RWMutex
}

type cacheEntry struct {
        value interface{}
        err   error
}

// New creates a new cache.
func New() *Cache <span class="cov8" title="1">{
        return &amp;Cache{
                nlocker: locker.NewLocker(),
                cache:   make(map[string]cacheEntry),
        }
}</span>

// Clear clears the cache state.
func (c *Cache) Clear() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache = make(map[string]cacheEntry)
        c.nlocker = locker.NewLocker()

}</span>

// GetOrCreate tries to get the value with the given cache key, if not found
// create will be called and cached.
// This method is thread safe. It also guarantees that the create func for a given
// key is invoced only once for this cache.
func (c *Cache) GetOrCreate(key string, create func() (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        c.mu.RLock()
        entry, found := c.cache[key]
        c.mu.RUnlock()

        if found </span><span class="cov0" title="0">{
                return entry.value, entry.err
        }</span>

        <span class="cov0" title="0">c.nlocker.Lock(key)
        defer c.nlocker.Unlock(key)

        // Create it.
        value, err := create()

        c.mu.Lock()
        c.cache[key] = cacheEntry{value: value, err: err}
        c.mu.Unlock()

        return value, err</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cache

import (
        "sync"
)

// Partition represents a cache partition where Load is the callback
// for when the partition is needed.
type Partition struct {
        Key  string
        Load func() (map[string]interface{}, error)
}

// Lazy represents a lazily loaded cache.
type Lazy struct {
        initSync sync.Once
        initErr  error
        cache    map[string]interface{}
        load     func() (map[string]interface{}, error)
}

// NewLazy creates a lazy cache with the given load func.
func NewLazy(load func() (map[string]interface{}, error)) *Lazy <span class="cov8" title="1">{
        return &amp;Lazy{load: load}
}</span>

func (l *Lazy) init() error <span class="cov8" title="1">{
        l.initSync.Do(func() </span><span class="cov8" title="1">{
                c, err := l.load()
                l.cache = c
                l.initErr = err

        }</span>)

        <span class="cov8" title="1">return l.initErr</span>
}

// Get initializes the cache if not already initialized, then looks up the
// given key.
func (l *Lazy) Get(key string) (interface{}, bool, error) <span class="cov8" title="1">{
        l.init()
        if l.initErr != nil </span><span class="cov0" title="0">{
                return nil, false, l.initErr
        }</span>
        <span class="cov8" title="1">v, found := l.cache[key]
        return v, found, nil</span>
}

// PartitionedLazyCache is a lazily loaded cache paritioned by a supplied string key.
type PartitionedLazyCache struct {
        partitions map[string]*Lazy
}

// NewPartitionedLazyCache creates a new NewPartitionedLazyCache with the supplied
// partitions.
func NewPartitionedLazyCache(partitions ...Partition) *PartitionedLazyCache <span class="cov0" title="0">{
        lazyPartitions := make(map[string]*Lazy, len(partitions))
        for _, partition := range partitions </span><span class="cov0" title="0">{
                lazyPartitions[partition.Key] = NewLazy(partition.Load)
        }</span>
        <span class="cov0" title="0">cache := &amp;PartitionedLazyCache{partitions: lazyPartitions}

        return cache</span>
}

// Get initializes the partition if not already done so, then looks up the given
// key in the given partition, returns nil if no value found.
func (c *PartitionedLazyCache) Get(partition, key string) (interface{}, error) <span class="cov0" title="0">{
        p, found := c.partitions[partition]

        if !found </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">v, found, err := p.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                return v, nil
        }</span>

        <span class="cov0" title="0">return nil, nil</span>

}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "github.com/spf13/cobra"
)

var _ cmder = (*checkCmd)(nil)

type checkCmd struct {
        *baseCmd
}

func newCheckCmd() *checkCmd <span class="cov8" title="1">{
        cc := &amp;checkCmd{baseCmd: &amp;baseCmd{cmd: &amp;cobra.Command{
                Use:   "check",
                Short: "Contains some verification checks",
        },
        }}

        cc.cmd.AddCommand(newLimitCmd().getCommand())

        return cc
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "errors"
        "sync"

        "golang.org/x/sync/semaphore"

        "github.com/gohugoio/hugo/modules"

        "io/ioutil"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/hugo"

        jww "github.com/spf13/jwalterweatherman"

        "os"
        "path/filepath"
        "regexp"
        "time"

        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/config"

        "github.com/spf13/cobra"

        "github.com/gohugoio/hugo/hugolib"
        "github.com/spf13/afero"

        "github.com/bep/debounce"
        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/langs"
)

type commandeerHugoState struct {
        *deps.DepsCfg
        hugoSites *hugolib.HugoSites
        fsCreate  sync.Once
        created   chan struct{}
}

type commandeer struct {
        *commandeerHugoState

        logger *loggers.Logger

        // Currently only set when in "fast render mode". But it seems to
        // be fast enough that we could maybe just add it for all server modes.
        changeDetector *fileChangeDetector

        // We need to reuse this on server rebuilds.
        destinationFs afero.Fs

        h    *hugoBuilderCommon
        ftch flagsToConfigHandler

        visitedURLs *types.EvictingStringQueue

        doWithCommandeer func(c *commandeer) error

        // We watch these for changes.
        configFiles []string

        // Used in cases where we get flooded with events in server mode.
        debounce func(f func())

        serverPorts         []int
        languagesConfigured bool
        languages           langs.Languages
        doLiveReload        bool
        fastRenderMode      bool
        showErrorInBrowser  bool

        configured bool
        paused     bool

        fullRebuildSem *semaphore.Weighted

        // Any error from the last build.
        buildErr error
}

func newCommandeerHugoState() *commandeerHugoState <span class="cov8" title="1">{
        return &amp;commandeerHugoState{
                created: make(chan struct{}),
        }
}</span>

func (c *commandeerHugoState) hugo() *hugolib.HugoSites <span class="cov8" title="1">{
        &lt;-c.created
        return c.hugoSites
}</span>

func (c *commandeer) errCount() int <span class="cov0" title="0">{
        return int(c.logger.ErrorCounter.Count())
}</span>

func (c *commandeer) getErrorWithContext() interface{} <span class="cov0" title="0">{
        errCount := c.errCount()

        if errCount == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">m := make(map[string]interface{})

        m["Error"] = errors.New(removeErrorPrefixFromLog(c.logger.Errors()))
        m["Version"] = hugo.BuildVersionString()

        fe := herrors.UnwrapErrorWithFileContext(c.buildErr)
        if fe != nil </span><span class="cov0" title="0">{
                m["File"] = fe
        }</span>

        <span class="cov0" title="0">if c.h.verbose </span><span class="cov0" title="0">{
                var b bytes.Buffer
                herrors.FprintStackTrace(&amp;b, c.buildErr)
                m["StackTrace"] = b.String()
        }</span>

        <span class="cov0" title="0">return m</span>
}

func (c *commandeer) Set(key string, value interface{}) <span class="cov0" title="0">{
        if c.configured </span><span class="cov0" title="0">{
                panic("commandeer cannot be changed")</span>
        }
        <span class="cov0" title="0">c.Cfg.Set(key, value)</span>
}

func (c *commandeer) initFs(fs *hugofs.Fs) error <span class="cov8" title="1">{
        c.destinationFs = fs.Destination
        c.DepsCfg.Fs = fs

        return nil
}</span>

func newCommandeer(mustHaveConfigFile, running bool, h *hugoBuilderCommon, f flagsToConfigHandler, doWithCommandeer func(c *commandeer) error, subCmdVs ...*cobra.Command) (*commandeer, error) <span class="cov8" title="1">{

        var rebuildDebouncer func(f func())
        if running </span><span class="cov0" title="0">{
                // The time value used is tested with mass content replacements in a fairly big Hugo site.
                // It is better to wait for some seconds in those cases rather than get flooded
                // with rebuilds.
                rebuildDebouncer = debounce.New(4 * time.Second)
        }</span>

        <span class="cov8" title="1">c := &amp;commandeer{
                h:                   h,
                ftch:                f,
                commandeerHugoState: newCommandeerHugoState(),
                doWithCommandeer:    doWithCommandeer,
                visitedURLs:         types.NewEvictingStringQueue(10),
                debounce:            rebuildDebouncer,
                fullRebuildSem:      semaphore.NewWeighted(1),
                // This will be replaced later, but we need something to log to before the configuration is read.
                logger: loggers.NewLogger(jww.LevelError, jww.LevelError, os.Stdout, ioutil.Discard, running),
        }

        return c, c.loadConfig(mustHaveConfigFile, running)</span>
}

type fileChangeDetector struct {
        sync.Mutex
        current map[string]string
        prev    map[string]string

        irrelevantRe *regexp.Regexp
}

func (f *fileChangeDetector) OnFileClose(name, md5sum string) <span class="cov0" title="0">{
        f.Lock()
        defer f.Unlock()
        f.current[name] = md5sum
}</span>

func (f *fileChangeDetector) changed() []string <span class="cov0" title="0">{
        if f == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">f.Lock()
        defer f.Unlock()
        var c []string
        for k, v := range f.current </span><span class="cov0" title="0">{
                vv, found := f.prev[k]
                if !found || v != vv </span><span class="cov0" title="0">{
                        c = append(c, k)
                }</span>
        }

        <span class="cov0" title="0">return f.filterIrrelevant(c)</span>
}

func (f *fileChangeDetector) filterIrrelevant(in []string) []string <span class="cov0" title="0">{
        var filtered []string
        for _, v := range in </span><span class="cov0" title="0">{
                if !f.irrelevantRe.MatchString(v) </span><span class="cov0" title="0">{
                        filtered = append(filtered, v)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

func (f *fileChangeDetector) PrepareNew() <span class="cov0" title="0">{
        if f == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">f.Lock()
        defer f.Unlock()

        if f.current == nil </span><span class="cov0" title="0">{
                f.current = make(map[string]string)
                f.prev = make(map[string]string)
                return
        }</span>

        <span class="cov0" title="0">f.prev = make(map[string]string)
        for k, v := range f.current </span><span class="cov0" title="0">{
                f.prev[k] = v
        }</span>
        <span class="cov0" title="0">f.current = make(map[string]string)</span>
}

func (c *commandeer) loadConfig(mustHaveConfigFile, running bool) error <span class="cov8" title="1">{

        if c.DepsCfg == nil </span><span class="cov8" title="1">{
                c.DepsCfg = &amp;deps.DepsCfg{}
        }</span>

        <span class="cov8" title="1">if c.logger != nil </span><span class="cov8" title="1">{
                // Truncate the error log if this is a reload.
                c.logger.Reset()
        }</span>

        <span class="cov8" title="1">cfg := c.DepsCfg
        c.configured = false
        cfg.Running = running

        var dir string
        if c.h.source != "" </span><span class="cov0" title="0">{
                dir, _ = filepath.Abs(c.h.source)
        }</span> else<span class="cov8" title="1"> {
                dir, _ = os.Getwd()
        }</span>

        <span class="cov8" title="1">var sourceFs afero.Fs = hugofs.Os
        if c.DepsCfg.Fs != nil </span><span class="cov0" title="0">{
                sourceFs = c.DepsCfg.Fs.Source
        }</span>

        <span class="cov8" title="1">environment := c.h.getEnvironment(running)

        doWithConfig := func(cfg config.Provider) error </span><span class="cov8" title="1">{

                if c.ftch != nil </span><span class="cov8" title="1">{
                        c.ftch.flagsToConfig(cfg)
                }</span>

                <span class="cov8" title="1">cfg.Set("workingDir", dir)
                cfg.Set("environment", environment)
                return nil</span>
        }

        <span class="cov8" title="1">doWithCommandeer := func(cfg config.Provider) error </span><span class="cov8" title="1">{
                c.Cfg = cfg
                if c.doWithCommandeer == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">err := c.doWithCommandeer(c)
                return err</span>
        }

        <span class="cov8" title="1">configPath := c.h.source
        if configPath == "" </span><span class="cov8" title="1">{
                configPath = dir
        }</span>
        <span class="cov8" title="1">config, configFiles, err := hugolib.LoadConfig(
                hugolib.ConfigSourceDescriptor{
                        Fs:           sourceFs,
                        Path:         configPath,
                        WorkingDir:   dir,
                        Filename:     c.h.cfgFile,
                        AbsConfigDir: c.h.getConfigDir(dir),
                        Environ:      os.Environ(),
                        Environment:  environment},
                doWithCommandeer,
                doWithConfig)

        if err != nil </span><span class="cov0" title="0">{
                if mustHaveConfigFile </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err != hugolib.ErrNoConfigFile &amp;&amp; !modules.IsNotExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>

        }

        <span class="cov8" title="1">c.configFiles = configFiles

        if l, ok := c.Cfg.Get("languagesSorted").(langs.Languages); ok </span><span class="cov8" title="1">{
                c.languagesConfigured = true
                c.languages = l
        }</span>

        // Set some commonly used flags
        <span class="cov8" title="1">c.doLiveReload = running &amp;&amp; !c.Cfg.GetBool("disableLiveReload")
        c.fastRenderMode = c.doLiveReload &amp;&amp; !c.Cfg.GetBool("disableFastRender")
        c.showErrorInBrowser = c.doLiveReload &amp;&amp; !c.Cfg.GetBool("disableBrowserError")

        // This is potentially double work, but we need to do this one more time now
        // that all the languages have been configured.
        if c.doWithCommandeer != nil </span><span class="cov8" title="1">{
                if err := c.doWithCommandeer(c); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">logger, err := c.createLogger(config, running)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">cfg.Logger = logger
        c.logger = logger

        createMemFs := config.GetBool("renderToMemory")

        if createMemFs </span><span class="cov0" title="0">{
                // Rendering to memoryFS, publish to Root regardless of publishDir.
                config.Set("publishDir", "/")
        }</span>

        <span class="cov8" title="1">c.fsCreate.Do(func() </span><span class="cov8" title="1">{
                fs := hugofs.NewFrom(sourceFs, config)

                if c.destinationFs != nil </span><span class="cov0" title="0">{
                        // Need to reuse the destination on server rebuilds.
                        fs.Destination = c.destinationFs
                }</span> else<span class="cov8" title="1"> if createMemFs </span><span class="cov0" title="0">{
                        // Hugo writes the output to memory instead of the disk.
                        fs.Destination = new(afero.MemMapFs)
                }</span>

                <span class="cov8" title="1">if c.fastRenderMode </span><span class="cov0" title="0">{
                        // For now, fast render mode only. It should, however, be fast enough
                        // for the full variant, too.
                        changeDetector := &amp;fileChangeDetector{
                                // We use this detector to decide to do a Hot reload of a single path or not.
                                // We need to filter out source maps and possibly some other to be able
                                // to make that decision.
                                irrelevantRe: regexp.MustCompile(`\.map$`),
                        }

                        changeDetector.PrepareNew()
                        fs.Destination = hugofs.NewHashingFs(fs.Destination, changeDetector)
                        c.changeDetector = changeDetector
                }</span>

                <span class="cov8" title="1">if c.Cfg.GetBool("logPathWarnings") </span><span class="cov0" title="0">{
                        fs.Destination = hugofs.NewCreateCountingFs(fs.Destination)
                }</span>

                // To debug hard-to-find path issues.
                //fs.Destination = hugofs.NewStacktracerFs(fs.Destination, `fr/fr`)

                <span class="cov8" title="1">err = c.initFs(fs)
                if err != nil </span><span class="cov0" title="0">{
                        close(c.created)
                        return
                }</span>

                <span class="cov8" title="1">var h *hugolib.HugoSites

                h, err = hugolib.NewHugoSites(*c.DepsCfg)
                c.hugoSites = h
                close(c.created)</span>

        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">cacheDir, err := helpers.GetCacheDir(sourceFs, config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">config.Set("cacheDir", cacheDir)

        cfg.Logger.INFO.Println("Using config file:", config.ConfigFileUsed())

        return nil</span>

}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "os"

        "github.com/gohugoio/hugo/hugolib/paths"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/cobra"
)

type commandsBuilder struct {
        hugoBuilderCommon

        commands []cmder
}

func newCommandsBuilder() *commandsBuilder <span class="cov8" title="1">{
        return &amp;commandsBuilder{}
}</span>

func (b *commandsBuilder) addCommands(commands ...cmder) *commandsBuilder <span class="cov8" title="1">{
        b.commands = append(b.commands, commands...)
        return b
}</span>

func (b *commandsBuilder) addAll() *commandsBuilder <span class="cov8" title="1">{
        b.addCommands(
                b.newServerCmd(),
                newVersionCmd(),
                newEnvCmd(),
                newConfigCmd(),
                newCheckCmd(),
                newDeployCmd(),
                newConvertCmd(),
                b.newNewCmd(),
                newListCmd(),
                newImportCmd(),
                newGenCmd(),
                createReleaser(),
                b.newModCmd(),
        )

        return b
}</span>

func (b *commandsBuilder) build() *hugoCmd <span class="cov8" title="1">{
        h := b.newHugoCmd()
        addCommands(h.getCommand(), b.commands...)
        return h
}</span>

func addCommands(root *cobra.Command, commands ...cmder) <span class="cov8" title="1">{
        for _, command := range commands </span><span class="cov8" title="1">{
                cmd := command.getCommand()
                if cmd == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">root.AddCommand(cmd)</span>
        }
}

type baseCmd struct {
        cmd *cobra.Command
}

var _ commandsBuilderGetter = (*baseBuilderCmd)(nil)

// Used in tests.
type commandsBuilderGetter interface {
        getCommandsBuilder() *commandsBuilder
}
type baseBuilderCmd struct {
        *baseCmd
        *commandsBuilder
}

func (b *baseBuilderCmd) getCommandsBuilder() *commandsBuilder <span class="cov0" title="0">{
        return b.commandsBuilder
}</span>

func (c *baseCmd) getCommand() *cobra.Command <span class="cov8" title="1">{
        return c.cmd
}</span>

func newBaseCmd(cmd *cobra.Command) *baseCmd <span class="cov8" title="1">{
        return &amp;baseCmd{cmd: cmd}
}</span>

func (b *commandsBuilder) newBuilderCmd(cmd *cobra.Command) *baseBuilderCmd <span class="cov8" title="1">{
        bcmd := &amp;baseBuilderCmd{commandsBuilder: b, baseCmd: &amp;baseCmd{cmd: cmd}}
        bcmd.hugoBuilderCommon.handleFlags(cmd)
        return bcmd
}</span>

func (c *baseCmd) flagsToConfig(cfg config.Provider) <span class="cov8" title="1">{
        initializeFlags(c.cmd, cfg)
}</span>

type hugoCmd struct {
        *baseBuilderCmd

        // Need to get the sites once built.
        c *commandeer
}

var _ cmder = (*nilCommand)(nil)

type nilCommand struct {
}

func (c *nilCommand) getCommand() *cobra.Command <span class="cov8" title="1">{
        return nil
}</span>

func (c *nilCommand) flagsToConfig(cfg config.Provider) {<span class="cov0" title="0">

}</span>

func (b *commandsBuilder) newHugoCmd() *hugoCmd <span class="cov8" title="1">{
        cc := &amp;hugoCmd{}

        cc.baseBuilderCmd = b.newBuilderCmd(&amp;cobra.Command{
                Use:   "hugo",
                Short: "hugo builds your site",
                Long: `hugo is the main command, used to build your Hugo site.

Hugo is a Fast and Flexible Static Site Generator
built with love by spf13 and friends in Go.

Complete documentation is available at http://gohugo.io/.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        cfgInit := func(c *commandeer) error </span><span class="cov8" title="1">{
                                if cc.buildWatch </span><span class="cov0" title="0">{
                                        c.Set("disableLiveReload", true)
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        }

                        <span class="cov8" title="1">c, err := initializeConfig(true, cc.buildWatch, &amp;cc.hugoBuilderCommon, cc, cfgInit)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">cc.c = c

                        return c.build()</span>
                },
        })

        <span class="cov8" title="1">cc.cmd.PersistentFlags().StringVar(&amp;cc.cfgFile, "config", "", "config file (default is path/config.yaml|json|toml)")
        cc.cmd.PersistentFlags().StringVar(&amp;cc.cfgDir, "configDir", "config", "config dir")
        cc.cmd.PersistentFlags().BoolVar(&amp;cc.quiet, "quiet", false, "build in quiet mode")

        // Set bash-completion
        _ = cc.cmd.PersistentFlags().SetAnnotation("config", cobra.BashCompFilenameExt, config.ValidConfigFileExtensions)

        cc.cmd.PersistentFlags().BoolVarP(&amp;cc.verbose, "verbose", "v", false, "verbose output")
        cc.cmd.PersistentFlags().BoolVarP(&amp;cc.debug, "debug", "", false, "debug output")
        cc.cmd.PersistentFlags().BoolVar(&amp;cc.logging, "log", false, "enable Logging")
        cc.cmd.PersistentFlags().StringVar(&amp;cc.logFile, "logFile", "", "log File path (if set, logging enabled automatically)")
        cc.cmd.PersistentFlags().BoolVar(&amp;cc.verboseLog, "verboseLog", false, "verbose logging")

        cc.cmd.Flags().BoolVarP(&amp;cc.buildWatch, "watch", "w", false, "watch filesystem for changes and recreate as needed")

        cc.cmd.Flags().Bool("renderToMemory", false, "render to memory (only useful for benchmark testing)")

        // Set bash-completion
        _ = cc.cmd.PersistentFlags().SetAnnotation("logFile", cobra.BashCompFilenameExt, []string{})

        cc.cmd.SetGlobalNormalizationFunc(helpers.NormalizeHugoFlags)
        cc.cmd.SilenceUsage = true

        return cc</span>
}

type hugoBuilderCommon struct {
        source      string
        baseURL     string
        environment string

        buildWatch bool

        gc bool

        // Profile flags (for debugging of performance problems)
        cpuprofile   string
        memprofile   string
        mutexprofile string
        traceprofile string

        // TODO(bep) var vs string
        logging    bool
        verbose    bool
        verboseLog bool
        debug      bool
        quiet      bool

        cfgFile string
        cfgDir  string
        logFile string
}

func (cc *hugoBuilderCommon) getConfigDir(baseDir string) string <span class="cov8" title="1">{
        if cc.cfgDir != "" </span><span class="cov8" title="1">{
                return paths.AbsPathify(baseDir, cc.cfgDir)
        }</span>

        <span class="cov0" title="0">if v, found := os.LookupEnv("HUGO_CONFIGDIR"); found </span><span class="cov0" title="0">{
                return paths.AbsPathify(baseDir, v)
        }</span>

        <span class="cov0" title="0">return paths.AbsPathify(baseDir, "config")</span>
}

func (cc *hugoBuilderCommon) getEnvironment(isServer bool) string <span class="cov8" title="1">{
        if cc.environment != "" </span><span class="cov0" title="0">{
                return cc.environment
        }</span>

        <span class="cov8" title="1">if v, found := os.LookupEnv("HUGO_ENVIRONMENT"); found </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov8" title="1">if isServer </span><span class="cov0" title="0">{
                return hugo.EnvironmentDevelopment
        }</span>

        <span class="cov8" title="1">return hugo.EnvironmentProduction</span>
}

func (cc *hugoBuilderCommon) handleCommonBuilderFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.PersistentFlags().StringVarP(&amp;cc.source, "source", "s", "", "filesystem path to read files relative from")
        cmd.PersistentFlags().SetAnnotation("source", cobra.BashCompSubdirsInDir, []string{})
        cmd.PersistentFlags().StringVarP(&amp;cc.environment, "environment", "e", "", "build environment")
        cmd.PersistentFlags().StringP("themesDir", "", "", "filesystem path to themes directory")
        cmd.PersistentFlags().BoolP("ignoreVendor", "", false, "ignores any _vendor directory")
}</span>

func (cc *hugoBuilderCommon) handleFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cc.handleCommonBuilderFlags(cmd)
        cmd.Flags().Bool("cleanDestinationDir", false, "remove files from destination not found in static directories")
        cmd.Flags().BoolP("buildDrafts", "D", false, "include content marked as draft")
        cmd.Flags().BoolP("buildFuture", "F", false, "include content with publishdate in the future")
        cmd.Flags().BoolP("buildExpired", "E", false, "include expired content")
        cmd.Flags().StringP("contentDir", "c", "", "filesystem path to content directory")
        cmd.Flags().StringP("layoutDir", "l", "", "filesystem path to layout directory")
        cmd.Flags().StringP("cacheDir", "", "", "filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/")
        cmd.Flags().BoolP("ignoreCache", "", false, "ignores the cache directory")
        cmd.Flags().StringP("destination", "d", "", "filesystem path to write files to")
        cmd.Flags().StringSliceP("theme", "t", []string{}, "themes to use (located in /themes/THEMENAME/)")
        cmd.Flags().StringVarP(&amp;cc.baseURL, "baseURL", "b", "", "hostname (and path) to the root, e.g. http://spf13.com/")
        cmd.Flags().Bool("enableGitInfo", false, "add Git revision, date and author info to the pages")
        cmd.Flags().BoolVar(&amp;cc.gc, "gc", false, "enable to run some cleanup tasks (remove unused cache files) after the build")

        cmd.Flags().Bool("templateMetrics", false, "display metrics about template executions")
        cmd.Flags().Bool("templateMetricsHints", false, "calculate some improvement hints when combined with --templateMetrics")
        cmd.Flags().BoolP("forceSyncStatic", "", false, "copy all files when static is changed.")
        cmd.Flags().BoolP("noTimes", "", false, "don't sync modification time of files")
        cmd.Flags().BoolP("noChmod", "", false, "don't sync permission mode of files")
        cmd.Flags().BoolP("i18n-warnings", "", false, "print missing translations")
        cmd.Flags().BoolP("path-warnings", "", false, "print warnings on duplicate target paths etc.")
        cmd.Flags().StringVarP(&amp;cc.cpuprofile, "profile-cpu", "", "", "write cpu profile to `file`")
        cmd.Flags().StringVarP(&amp;cc.memprofile, "profile-mem", "", "", "write memory profile to `file`")
        cmd.Flags().StringVarP(&amp;cc.mutexprofile, "profile-mutex", "", "", "write Mutex profile to `file`")
        cmd.Flags().StringVarP(&amp;cc.traceprofile, "trace", "", "", "write trace to `file` (not useful in general)")

        // Hide these for now.
        cmd.Flags().MarkHidden("profile-cpu")
        cmd.Flags().MarkHidden("profile-mem")
        cmd.Flags().MarkHidden("profile-mutex")

        cmd.Flags().StringSlice("disableKinds", []string{}, "disable different kind of pages (home, RSS etc.)")

        cmd.Flags().Bool("minify", false, "minify any supported output format (HTML, XML etc.)")

        // Set bash-completion.
        // Each flag must first be defined before using the SetAnnotation() call.
        _ = cmd.Flags().SetAnnotation("source", cobra.BashCompSubdirsInDir, []string{})
        _ = cmd.Flags().SetAnnotation("cacheDir", cobra.BashCompSubdirsInDir, []string{})
        _ = cmd.Flags().SetAnnotation("destination", cobra.BashCompSubdirsInDir, []string{})
        _ = cmd.Flags().SetAnnotation("theme", cobra.BashCompSubdirsInDir, []string{"themes"})
}</span>

func checkErr(logger *loggers.Logger, err error, s ...string) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(s) == 0 </span><span class="cov0" title="0">{
                logger.CRITICAL.Println(err)
                return
        }</span>
        <span class="cov0" title="0">for _, message := range s </span><span class="cov0" title="0">{
                logger.ERROR.Println(message)
        }</span>
        <span class="cov0" title="0">logger.ERROR.Println(err)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.Print the version number of Hug

package commands

import (
        "encoding/json"
        "os"
        "reflect"
        "regexp"
        "sort"
        "strings"

        "github.com/gohugoio/hugo/parser"
        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/gohugoio/hugo/modules"

        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
        "github.com/spf13/viper"
)

var _ cmder = (*configCmd)(nil)

type configCmd struct {
        hugoBuilderCommon
        *baseCmd
}

func newConfigCmd() *configCmd <span class="cov8" title="1">{
        cc := &amp;configCmd{}
        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "config",
                Short: "Print the site configuration",
                Long:  `Print the site configuration, both default and custom settings.`,
                RunE:  cc.printConfig,
        })

        cc.cmd.PersistentFlags().StringVarP(&amp;cc.source, "source", "s", "", "filesystem path to read files relative from")

        printMountsCmd := &amp;cobra.Command{
                Use:   "mounts",
                Short: "Print the configured file mounts",
                RunE:  cc.printMounts,
        }

        cc.cmd.AddCommand(printMountsCmd)

        return cc
}</span>

func (c *configCmd) printMounts(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        cfg, err := initializeConfig(true, false, &amp;c.hugoBuilderCommon, c, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">allModules := cfg.Cfg.Get("allmodules").(modules.Modules)

        for _, m := range allModules </span><span class="cov0" title="0">{
                if err := parser.InterfaceToConfig(&amp;modMounts{m: m}, metadecoders.JSON, os.Stdout); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (c *configCmd) printConfig(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        cfg, err := initializeConfig(true, false, &amp;c.hugoBuilderCommon, c, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">allSettings := cfg.Cfg.(*viper.Viper).AllSettings()

        // We need to clean up this, but we store objects in the config that
        // isn't really interesting to the end user, so filter these.
        ignoreKeysRe := regexp.MustCompile("client|sorted|filecacheconfigs|allmodules|multilingual")

        separator := ": "

        if len(cfg.configFiles) &gt; 0 &amp;&amp; strings.HasSuffix(cfg.configFiles[0], ".toml") </span><span class="cov0" title="0">{
                separator = " = "
        }</span>

        <span class="cov0" title="0">var keys []string
        for k := range allSettings </span><span class="cov0" title="0">{
                if ignoreKeysRe.MatchString(k) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">keys = append(keys, k)</span>
        }
        <span class="cov0" title="0">sort.Strings(keys)
        for _, k := range keys </span><span class="cov0" title="0">{
                kv := reflect.ValueOf(allSettings[k])
                if kv.Kind() == reflect.String </span><span class="cov0" title="0">{
                        jww.FEEDBACK.Printf("%s%s\"%+v\"\n", k, separator, allSettings[k])
                }</span> else<span class="cov0" title="0"> {
                        jww.FEEDBACK.Printf("%s%s%+v\n", k, separator, allSettings[k])
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type modMounts struct {
        m modules.Module
}

type modMount struct {
        Source string `json:"source"`
        Target string `json:"target"`
        Lang   string `json:"lang,omitempty"`
}

func (m *modMounts) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        var mounts []modMount

        for _, mount := range m.m.Mounts() </span><span class="cov0" title="0">{
                mounts = append(mounts, modMount{
                        Source: mount.Source,
                        Target: mount.Target,
                        Lang:   mount.Lang,
                })
        }</span>

        <span class="cov0" title="0">return json.Marshal(&amp;struct {
                Path   string     `json:"path"`
                Dir    string     `json:"dir"`
                Mounts []modMount `json:"mounts"`
        }{
                Path:   m.m.Path(),
                Dir:    m.m.Dir(),
                Mounts: mounts,
        })</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/gohugoio/hugo/resources/page"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/parser"
        "github.com/gohugoio/hugo/parser/metadecoders"
        "github.com/gohugoio/hugo/parser/pageparser"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/hugolib"

        "path/filepath"

        "github.com/spf13/cobra"
)

var (
        _ cmder = (*convertCmd)(nil)
)

type convertCmd struct {
        hugoBuilderCommon

        outputDir string
        unsafe    bool

        *baseCmd
}

func newConvertCmd() *convertCmd <span class="cov8" title="1">{
        cc := &amp;convertCmd{}

        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "convert",
                Short: "Convert your content to different formats",
                Long: `Convert your content (e.g. front matter) to different formats.

See convert's subcommands toJSON, toTOML and toYAML for more information.`,
                RunE: nil,
        })

        cc.cmd.AddCommand(
                &amp;cobra.Command{
                        Use:   "toJSON",
                        Short: "Convert front matter to JSON",
                        Long: `toJSON converts all front matter in the content directory
to use JSON for the front matter.`,
                        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                                return cc.convertContents(metadecoders.JSON)
                        }</span>,
                },
                &amp;cobra.Command{
                        Use:   "toTOML",
                        Short: "Convert front matter to TOML",
                        Long: `toTOML converts all front matter in the content directory
to use TOML for the front matter.`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                return cc.convertContents(metadecoders.TOML)
                        }</span>,
                },
                &amp;cobra.Command{
                        Use:   "toYAML",
                        Short: "Convert front matter to YAML",
                        Long: `toYAML converts all front matter in the content directory
to use YAML for the front matter.`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                return cc.convertContents(metadecoders.YAML)
                        }</span>,
                },
        )

        <span class="cov8" title="1">cc.cmd.PersistentFlags().StringVarP(&amp;cc.outputDir, "output", "o", "", "filesystem path to write files to")
        cc.cmd.PersistentFlags().StringVarP(&amp;cc.source, "source", "s", "", "filesystem path to read files relative from")
        cc.cmd.PersistentFlags().BoolVar(&amp;cc.unsafe, "unsafe", false, "enable less safe operations, please backup first")
        cc.cmd.PersistentFlags().SetAnnotation("source", cobra.BashCompSubdirsInDir, []string{})

        return cc</span>
}

func (cc *convertCmd) convertContents(format metadecoders.Format) error <span class="cov0" title="0">{
        if cc.outputDir == "" &amp;&amp; !cc.unsafe </span><span class="cov0" title="0">{
                return newUserError("Unsafe operation not allowed, use --unsafe or set a different output path")
        }</span>

        <span class="cov0" title="0">c, err := initializeConfig(true, false, &amp;cc.hugoBuilderCommon, cc, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.Cfg.Set("buildDrafts", true)

        h, err := hugolib.NewHugoSites(*c.DepsCfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := h.Build(hugolib.BuildCfg{SkipRender: true}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">site := h.Sites[0]

        site.Log.FEEDBACK.Println("processing", len(site.AllPages()), "content files")
        for _, p := range site.AllPages() </span><span class="cov0" title="0">{
                if err := cc.convertAndSavePage(p, site, format); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (cc *convertCmd) convertAndSavePage(p page.Page, site *hugolib.Site, targetFormat metadecoders.Format) error <span class="cov0" title="0">{
        // The resources are not in .Site.AllPages.
        for _, r := range p.Resources().ByType("page") </span><span class="cov0" title="0">{
                if err := cc.convertAndSavePage(r.(page.Page), site, targetFormat); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if p.File().IsZero() </span><span class="cov0" title="0">{
                // No content file.
                return nil
        }</span>

        <span class="cov0" title="0">errMsg := fmt.Errorf("Error processing file %q", p.Path())

        site.Log.INFO.Println("Attempting to convert", p.File().Filename())

        f := p.File()
        file, err := f.FileInfo().Meta().Open()
        if err != nil </span><span class="cov0" title="0">{
                site.Log.ERROR.Println(errMsg)
                file.Close()
                return nil
        }</span>

        <span class="cov0" title="0">pf, err := parseContentFile(file)
        if err != nil </span><span class="cov0" title="0">{
                site.Log.ERROR.Println(errMsg)
                file.Close()
                return err
        }</span>

        <span class="cov0" title="0">file.Close()

        // better handling of dates in formats that don't have support for them
        if pf.frontMatterFormat == metadecoders.JSON || pf.frontMatterFormat == metadecoders.YAML || pf.frontMatterFormat == metadecoders.TOML </span><span class="cov0" title="0">{
                for k, v := range pf.frontMatter </span><span class="cov0" title="0">{
                        switch vv := v.(type) </span>{
                        case time.Time:<span class="cov0" title="0">
                                pf.frontMatter[k] = vv.Format(time.RFC3339)</span>
                        }
                }
        }

        <span class="cov0" title="0">var newContent bytes.Buffer
        err = parser.InterfaceToFrontMatter(pf.frontMatter, targetFormat, &amp;newContent)
        if err != nil </span><span class="cov0" title="0">{
                site.Log.ERROR.Println(errMsg)
                return err
        }</span>

        <span class="cov0" title="0">newContent.Write(pf.content)

        newFilename := p.File().Filename()

        if cc.outputDir != "" </span><span class="cov0" title="0">{
                contentDir := strings.TrimSuffix(newFilename, p.Path())
                contentDir = filepath.Base(contentDir)

                newFilename = filepath.Join(cc.outputDir, contentDir, p.Path())
        }</span>

        <span class="cov0" title="0">fs := hugofs.Os
        if err := helpers.WriteToDisk(newFilename, &amp;newContent, fs); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "Failed to save file %q:", newFilename)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type parsedFile struct {
        frontMatterFormat metadecoders.Format
        frontMatterSource []byte
        frontMatter       map[string]interface{}

        // Everything after Front Matter
        content []byte
}

func parseContentFile(r io.Reader) (parsedFile, error) <span class="cov0" title="0">{
        var pf parsedFile

        psr, err := pageparser.Parse(r, pageparser.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return pf, err
        }</span>

        <span class="cov0" title="0">iter := psr.Iterator()

        walkFn := func(item pageparser.Item) bool </span><span class="cov0" title="0">{
                if pf.frontMatterSource != nil </span><span class="cov0" title="0">{
                        // The rest is content.
                        pf.content = psr.Input()[item.Pos:]
                        // Done
                        return false
                }</span> else<span class="cov0" title="0"> if item.IsFrontMatter() </span><span class="cov0" title="0">{
                        pf.frontMatterFormat = metadecoders.FormatFromFrontMatterType(item.Type)
                        pf.frontMatterSource = item.Val
                }</span>
                <span class="cov0" title="0">return true</span>

        }

        <span class="cov0" title="0">iter.PeekWalk(walkFn)

        metadata, err := metadecoders.Default.UnmarshalToMap(pf.frontMatterSource, pf.frontMatterFormat)
        if err != nil </span><span class="cov0" title="0">{
                return pf, err
        }</span>
        <span class="cov0" title="0">pf.frontMatter = metadata

        return pf, nil</span>

}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "context"

        "github.com/gohugoio/hugo/deploy"
        "github.com/spf13/cobra"
)

var _ cmder = (*deployCmd)(nil)

// deployCmd supports deploying sites to Cloud providers.
type deployCmd struct {
        hugoBuilderCommon
        *baseCmd
}

// TODO: In addition to the "deploy" command, consider adding a "--deploy"
// flag for the default command; this would build the site and then deploy it.
// It's not obvious how to do this; would all of the deploy-specific flags
// have to exist at the top level as well?

// TODO:  The output files change every time "hugo" is executed, it looks
// like because of map order randomization. This means that you can
// run "hugo &amp;&amp; hugo deploy" again and again and upload new stuff every time. Is
// this intended?

func newDeployCmd() *deployCmd <span class="cov8" title="1">{
        cc := &amp;deployCmd{}

        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "deploy",
                Short: "Deploy your site to a Cloud provider.",
                Long: `Deploy your site to a Cloud provider.

See https://gohugo.io/hosting-and-deployment/hugo-deploy/ for detailed
documentation.
`,

                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        cfgInit := func(c *commandeer) error </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">comm, err := initializeConfig(true, false, &amp;cc.hugoBuilderCommon, cc, cfgInit)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">deployer, err := deploy.New(comm.Cfg, comm.hugo().PathSpec.PublishFs)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return deployer.Deploy(context.Background())</span>
                },
        })

        <span class="cov8" title="1">cc.cmd.Flags().String("target", "", "target deployment from deployments section in config file; defaults to the first one")
        cc.cmd.Flags().Bool("confirm", false, "ask for confirmation before making changes to the target")
        cc.cmd.Flags().Bool("dryRun", false, "dry run")
        cc.cmd.Flags().Bool("force", false, "force upload of all files")
        cc.cmd.Flags().Bool("invalidateCDN", true, "invalidate the CDN cache via the cloudFrontDistributionID listed in the deployment target")
        cc.cmd.Flags().Int("maxDeletes", 256, "maximum # of files to delete, or -1 to disable")

        return cc</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "runtime"

        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*envCmd)(nil)

type envCmd struct {
        *baseCmd
}

func newEnvCmd() *envCmd <span class="cov8" title="1">{
        return &amp;envCmd{baseCmd: newBaseCmd(&amp;cobra.Command{
                Use:   "env",
                Short: "Print Hugo version and environment info",
                Long:  `Print Hugo version and environment info. This is useful in Hugo bug reports.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        printHugoVersion()
                        jww.FEEDBACK.Printf("GOOS=%q\n", runtime.GOOS)
                        jww.FEEDBACK.Printf("GOARCH=%q\n", runtime.GOARCH)
                        jww.FEEDBACK.Printf("GOVERSION=%q\n", runtime.Version())

                        return nil
                }</span>,
        }),
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "github.com/spf13/cobra"
)

var _ cmder = (*genCmd)(nil)

type genCmd struct {
        *baseCmd
}

func newGenCmd() *genCmd <span class="cov8" title="1">{
        cc := &amp;genCmd{}
        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "gen",
                Short: "A collection of several useful generators.",
        })

        cc.cmd.AddCommand(
                newGenautocompleteCmd().getCommand(),
                newGenDocCmd().getCommand(),
                newGenManCmd().getCommand(),
                createGenDocsHelper().getCommand(),
                createGenChromaStyles().getCommand())

        return cc
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*genautocompleteCmd)(nil)

type genautocompleteCmd struct {
        autocompleteTarget string

        // bash for now (zsh and others will come)
        autocompleteType string

        *baseCmd
}

func newGenautocompleteCmd() *genautocompleteCmd <span class="cov8" title="1">{
        cc := &amp;genautocompleteCmd{}

        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "autocomplete",
                Short: "Generate shell autocompletion script for Hugo",
                Long: `Generates a shell autocompletion script for Hugo.

NOTE: The current version supports Bash only.
      This should work for *nix systems with Bash installed.

By default, the file is written directly to /etc/bash_completion.d
for convenience, and the command may need superuser rights, e.g.:

        $ sudo hugo gen autocomplete

Add ` + "`--completionfile=/path/to/file`" + ` flag to set alternative
file-path and name.

Logout and in again to reload the completion scripts,
or just source them in directly:

        $ . /etc/bash_completion`,

                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if cc.autocompleteType != "bash" </span><span class="cov0" title="0">{
                                return newUserError("Only Bash is supported for now")
                        }</span>

                        <span class="cov0" title="0">err := cmd.Root().GenBashCompletionFile(cc.autocompleteTarget)

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">jww.FEEDBACK.Println("Bash completion file for Hugo saved to", cc.autocompleteTarget)

                        return nil</span>
                },
        })

        <span class="cov8" title="1">cc.cmd.PersistentFlags().StringVarP(&amp;cc.autocompleteTarget, "completionfile", "", "/etc/bash_completion.d/hugo.sh", "autocompletion file")
        cc.cmd.PersistentFlags().StringVarP(&amp;cc.autocompleteType, "type", "", "bash", "autocompletion type (currently only bash supported)")

        // For bash-completion
        cc.cmd.PersistentFlags().SetAnnotation("completionfile", cobra.BashCompFilenameExt, []string{})

        return cc</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "os"

        "github.com/alecthomas/chroma"
        "github.com/alecthomas/chroma/formatters/html"
        "github.com/alecthomas/chroma/styles"
        "github.com/spf13/cobra"
)

var (
        _ cmder = (*genChromaStyles)(nil)
)

type genChromaStyles struct {
        style          string
        highlightStyle string
        linesStyle     string
        *baseCmd
}

// TODO(bep) highlight
func createGenChromaStyles() *genChromaStyles <span class="cov8" title="1">{
        g := &amp;genChromaStyles{
                baseCmd: newBaseCmd(&amp;cobra.Command{
                        Use:   "chromastyles",
                        Short: "Generate CSS stylesheet for the Chroma code highlighter",
                        Long: `Generate CSS stylesheet for the Chroma code highlighter for a given style. This stylesheet is needed if pygmentsUseClasses is enabled in config.

See https://help.farbox.com/pygments.html for preview of available styles`,
                }),
        }

        g.cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                return g.generate()
        }</span>

        <span class="cov8" title="1">g.cmd.PersistentFlags().StringVar(&amp;g.style, "style", "friendly", "highlighter style (see https://help.farbox.com/pygments.html)")
        g.cmd.PersistentFlags().StringVar(&amp;g.highlightStyle, "highlightStyle", "bg:#ffffcc", "style used for highlighting lines (see https://github.com/alecthomas/chroma)")
        g.cmd.PersistentFlags().StringVar(&amp;g.linesStyle, "linesStyle", "", "style used for line numbers (see https://github.com/alecthomas/chroma)")

        return g</span>
}

func (g *genChromaStyles) generate() error <span class="cov0" title="0">{
        builder := styles.Get(g.style).Builder()
        if g.highlightStyle != "" </span><span class="cov0" title="0">{
                builder.Add(chroma.LineHighlight, g.highlightStyle)
        }</span>
        <span class="cov0" title="0">if g.linesStyle != "" </span><span class="cov0" title="0">{
                builder.Add(chroma.LineNumbers, g.linesStyle)
        }</span>
        <span class="cov0" title="0">style, err := builder.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">formatter := html.New(html.WithClasses())
        formatter.WriteCSS(os.Stdout, style)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "fmt"
        "path"
        "path/filepath"
        "strings"
        "time"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/spf13/cobra"
        "github.com/spf13/cobra/doc"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*genDocCmd)(nil)

type genDocCmd struct {
        gendocdir string
        *baseCmd
}

func newGenDocCmd() *genDocCmd <span class="cov8" title="1">{
        const gendocFrontmatterTemplate = `---
date: %s
title: "%s"
slug: %s
url: %s
---
`

        cc := &amp;genDocCmd{}

        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "doc",
                Short: "Generate Markdown documentation for the Hugo CLI.",
                Long: `Generate Markdown documentation for the Hugo CLI.

This command is, mostly, used to create up-to-date documentation
of Hugo's command-line interface for http://gohugo.io/.

It creates one Markdown file per command with front matter suitable
for rendering in Hugo.`,

                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if !strings.HasSuffix(cc.gendocdir, helpers.FilePathSeparator) </span><span class="cov0" title="0">{
                                cc.gendocdir += helpers.FilePathSeparator
                        }</span>
                        <span class="cov0" title="0">if found, _ := helpers.Exists(cc.gendocdir, hugofs.Os); !found </span><span class="cov0" title="0">{
                                jww.FEEDBACK.Println("Directory", cc.gendocdir, "does not exist, creating...")
                                if err := hugofs.Os.MkdirAll(cc.gendocdir, 0777); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">now := time.Now().Format("2006-01-02")
                        prepender := func(filename string) string </span><span class="cov0" title="0">{
                                name := filepath.Base(filename)
                                base := strings.TrimSuffix(name, path.Ext(name))
                                url := "/commands/" + strings.ToLower(base) + "/"
                                return fmt.Sprintf(gendocFrontmatterTemplate, now, strings.Replace(base, "_", " ", -1), base, url)
                        }</span>

                        <span class="cov0" title="0">linkHandler := func(name string) string </span><span class="cov0" title="0">{
                                base := strings.TrimSuffix(name, path.Ext(name))
                                return "/commands/" + strings.ToLower(base) + "/"
                        }</span>

                        <span class="cov0" title="0">jww.FEEDBACK.Println("Generating Hugo command-line documentation in", cc.gendocdir, "...")
                        doc.GenMarkdownTreeCustom(cmd.Root(), cc.gendocdir, prepender, linkHandler)
                        jww.FEEDBACK.Println("Done.")

                        return nil</span>
                },
        })

        <span class="cov8" title="1">cc.cmd.PersistentFlags().StringVar(&amp;cc.gendocdir, "dir", "/tmp/hugodoc/", "the directory to write the doc.")

        // For bash-completion
        cc.cmd.PersistentFlags().SetAnnotation("dir", cobra.BashCompSubdirsInDir, []string{})

        return cc</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/gohugoio/hugo/docshelper"
        "github.com/spf13/cobra"
)

var (
        _ cmder = (*genDocsHelper)(nil)
)

type genDocsHelper struct {
        target string
        *baseCmd
}

func createGenDocsHelper() *genDocsHelper <span class="cov8" title="1">{
        g := &amp;genDocsHelper{
                baseCmd: newBaseCmd(&amp;cobra.Command{
                        Use:    "docshelper",
                        Short:  "Generate some data files for the Hugo docs.",
                        Hidden: true,
                }),
        }

        g.cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                return g.generate()
        }</span>

        <span class="cov8" title="1">g.cmd.PersistentFlags().StringVarP(&amp;g.target, "dir", "", "docs/data", "data dir")

        return g</span>
}

func (g *genDocsHelper) generate() error <span class="cov0" title="0">{
        fmt.Println("Generate docs data to", g.target)

        targetFile := filepath.Join(g.target, "docs.json")

        f, err := os.Create(targetFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        enc := json.NewEncoder(f)
        enc.SetIndent("", "  ")

        if err := enc.Encode(docshelper.DocProviders); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Done!")
        return nil</span>

}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "fmt"
        "strings"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/spf13/cobra"
        "github.com/spf13/cobra/doc"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*genManCmd)(nil)

type genManCmd struct {
        genmandir string
        *baseCmd
}

func newGenManCmd() *genManCmd <span class="cov8" title="1">{
        cc := &amp;genManCmd{}

        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "man",
                Short: "Generate man pages for the Hugo CLI",
                Long: `This command automatically generates up-to-date man pages of Hugo's
command-line interface.  By default, it creates the man page files
in the "man" directory under the current directory.`,

                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        header := &amp;doc.GenManHeader{
                                Section: "1",
                                Manual:  "Hugo Manual",
                                Source:  fmt.Sprintf("Hugo %s", hugo.CurrentVersion),
                        }
                        if !strings.HasSuffix(cc.genmandir, helpers.FilePathSeparator) </span><span class="cov0" title="0">{
                                cc.genmandir += helpers.FilePathSeparator
                        }</span>
                        <span class="cov0" title="0">if found, _ := helpers.Exists(cc.genmandir, hugofs.Os); !found </span><span class="cov0" title="0">{
                                jww.FEEDBACK.Println("Directory", cc.genmandir, "does not exist, creating...")
                                if err := hugofs.Os.MkdirAll(cc.genmandir, 0777); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">cmd.Root().DisableAutoGenTag = true

                        jww.FEEDBACK.Println("Generating Hugo man pages in", cc.genmandir, "...")
                        doc.GenManTree(cmd.Root(), header, cc.genmandir)

                        jww.FEEDBACK.Println("Done.")

                        return nil</span>
                },
        })

        <span class="cov8" title="1">cc.cmd.PersistentFlags().StringVar(&amp;cc.genmandir, "dir", "man/", "the directory to write the man pages.")

        // For bash-completion
        cc.cmd.PersistentFlags().SetAnnotation("dir", cobra.BashCompSubdirsInDir, []string{})

        return cc</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package commands defines and implements command-line commands and flags
// used by Hugo. Commands and flags are implemented using Cobra.
package commands

import (
        "fmt"
        "regexp"

        "github.com/gohugoio/hugo/config"
        "github.com/spf13/cobra"
)

const (
        ansiEsc    = "\u001B"
        clearLine  = "\r\033[K"
        hideCursor = ansiEsc + "[?25l"
        showCursor = ansiEsc + "[?25h"
)

type flagsToConfigHandler interface {
        flagsToConfig(cfg config.Provider)
}

type cmder interface {
        flagsToConfigHandler
        getCommand() *cobra.Command
}

// commandError is an error used to signal different error situations in command handling.
type commandError struct {
        s         string
        userError bool
}

func (c commandError) Error() string <span class="cov0" title="0">{
        return c.s
}</span>

func (c commandError) isUserError() bool <span class="cov0" title="0">{
        return c.userError
}</span>

func newUserError(a ...interface{}) commandError <span class="cov0" title="0">{
        return commandError{s: fmt.Sprintln(a...), userError: true}
}</span>

func newSystemError(a ...interface{}) commandError <span class="cov0" title="0">{
        return commandError{s: fmt.Sprintln(a...), userError: false}
}</span>

func newSystemErrorF(format string, a ...interface{}) commandError <span class="cov0" title="0">{
        return commandError{s: fmt.Sprintf(format, a...), userError: false}
}</span>

// Catch some of the obvious user errors from Cobra.
// We don't want to show the usage message for every error.
// The below may be to generic. Time will show.
var userErrorRegexp = regexp.MustCompile("argument|flag|shorthand")

func isUserError(err error) bool <span class="cov0" title="0">{
        if cErr, ok := err.(commandError); ok &amp;&amp; cErr.isUserError() </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return userErrorRegexp.MatchString(err.Error())</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package commands defines and implements command-line commands and flags
// used by Hugo. Commands and flags are implemented using Cobra.
package commands

import (
        "context"
        "fmt"
        "io/ioutil"
        "os/signal"
        "runtime/pprof"
        "runtime/trace"
        "sync/atomic"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/resources/page"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/common/terminal"

        "syscall"

        "github.com/gohugoio/hugo/hugolib/filesystems"

        "golang.org/x/sync/errgroup"

        "os"
        "path/filepath"
        "runtime"
        "strings"
        "time"

        "github.com/gohugoio/hugo/config"

        flag "github.com/spf13/pflag"

        "github.com/fsnotify/fsnotify"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugolib"
        "github.com/gohugoio/hugo/livereload"
        "github.com/gohugoio/hugo/watcher"
        "github.com/spf13/afero"
        "github.com/spf13/cobra"
        "github.com/spf13/fsync"
        jww "github.com/spf13/jwalterweatherman"
)

// The Response value from Execute.
type Response struct {
        // The build Result will only be set in the hugo build command.
        Result *hugolib.HugoSites

        // Err is set when the command failed to execute.
        Err error

        // The command that was executed.
        Cmd *cobra.Command
}

// IsUserError returns true is the Response error is a user error rather than a
// system error.
func (r Response) IsUserError() bool <span class="cov0" title="0">{
        return r.Err != nil &amp;&amp; isUserError(r.Err)
}</span>

// Execute adds all child commands to the root command HugoCmd and sets flags appropriately.
// The args are usually filled with os.Args[1:].
func Execute(args []string) Response <span class="cov8" title="1">{
        hugoCmd := newCommandsBuilder().addAll().build()
        cmd := hugoCmd.getCommand()
        cmd.SetArgs(args)

        c, err := cmd.ExecuteC()

        var resp Response

        if c == cmd &amp;&amp; hugoCmd.c != nil </span><span class="cov8" title="1">{
                // Root command executed
                resp.Result = hugoCmd.c.hugo()
        }</span>

        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                errCount := int(loggers.GlobalErrorCounter.Count())
                if errCount &gt; 0 </span><span class="cov0" title="0">{
                        err = fmt.Errorf("logged %d errors", errCount)
                }</span> else<span class="cov8" title="1"> if resp.Result != nil </span><span class="cov8" title="1">{
                        errCount = resp.Result.NumLogErrors()
                        if errCount &gt; 0 </span><span class="cov0" title="0">{
                                err = fmt.Errorf("logged %d errors", errCount)
                        }</span>
                }

        }

        <span class="cov8" title="1">resp.Err = err
        resp.Cmd = c

        return resp</span>
}

// InitializeConfig initializes a config file with sensible default configuration flags.
func initializeConfig(mustHaveConfigFile, running bool,
        h *hugoBuilderCommon,
        f flagsToConfigHandler,
        doWithCommandeer func(c *commandeer) error) (*commandeer, error) <span class="cov8" title="1">{

        c, err := newCommandeer(mustHaveConfigFile, running, h, f, doWithCommandeer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c, nil</span>

}

func (c *commandeer) createLogger(cfg config.Provider, running bool) (*loggers.Logger, error) <span class="cov8" title="1">{
        var (
                logHandle       = ioutil.Discard
                logThreshold    = jww.LevelWarn
                logFile         = cfg.GetString("logFile")
                outHandle       = os.Stdout
                stdoutThreshold = jww.LevelWarn
        )

        if c.h.verboseLog || c.h.logging || (c.h.logFile != "") </span><span class="cov0" title="0">{
                var err error
                if logFile != "" </span><span class="cov0" title="0">{
                        logHandle, err = os.OpenFile(logFile, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0666)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, newSystemError("Failed to open log file:", logFile, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        logHandle, err = ioutil.TempFile("", "hugo")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, newSystemError(err)
                        }</span>
                }
        } else<span class="cov8" title="1"> if !c.h.quiet &amp;&amp; cfg.GetBool("verbose") </span><span class="cov0" title="0">{
                stdoutThreshold = jww.LevelInfo
        }</span>

        <span class="cov8" title="1">if cfg.GetBool("debug") </span><span class="cov0" title="0">{
                stdoutThreshold = jww.LevelDebug
        }</span>

        <span class="cov8" title="1">if c.h.verboseLog </span><span class="cov0" title="0">{
                logThreshold = jww.LevelInfo
                if cfg.GetBool("debug") </span><span class="cov0" title="0">{
                        logThreshold = jww.LevelDebug
                }</span>
        }

        <span class="cov8" title="1">loggers.InitGlobalLogger(stdoutThreshold, logThreshold, outHandle, logHandle)
        helpers.InitLoggers()

        return loggers.NewLogger(stdoutThreshold, logThreshold, outHandle, logHandle, running), nil</span>
}

func initializeFlags(cmd *cobra.Command, cfg config.Provider) <span class="cov8" title="1">{
        persFlagKeys := []string{
                "debug",
                "verbose",
                "logFile",
                // Moved from vars
        }
        flagKeys := []string{
                "cleanDestinationDir",
                "buildDrafts",
                "buildFuture",
                "buildExpired",
                "uglyURLs",
                "canonifyURLs",
                "enableRobotsTXT",
                "enableGitInfo",
                "pluralizeListTitles",
                "preserveTaxonomyNames",
                "ignoreCache",
                "forceSyncStatic",
                "noTimes",
                "noChmod",
                "ignoreVendor",
                "templateMetrics",
                "templateMetricsHints",

                // Moved from vars.
                "baseURL",
                "buildWatch",
                "cacheDir",
                "cfgFile",
                "confirm",
                "contentDir",
                "debug",
                "destination",
                "disableKinds",
                "dryRun",
                "force",
                "gc",
                "i18n-warnings",
                "invalidateCDN",
                "layoutDir",
                "logFile",
                "maxDeletes",
                "quiet",
                "renderToMemory",
                "source",
                "target",
                "theme",
                "themesDir",
                "verbose",
                "verboseLog",
                "duplicateTargetPaths",
        }

        // Will set a value even if it is the default.
        flagKeysForced := []string{
                "minify",
        }

        for _, key := range persFlagKeys </span><span class="cov8" title="1">{
                setValueFromFlag(cmd.PersistentFlags(), key, cfg, "", false)
        }</span>
        <span class="cov8" title="1">for _, key := range flagKeys </span><span class="cov8" title="1">{
                setValueFromFlag(cmd.Flags(), key, cfg, "", false)
        }</span>

        <span class="cov8" title="1">for _, key := range flagKeysForced </span><span class="cov8" title="1">{
                setValueFromFlag(cmd.Flags(), key, cfg, "", true)
        }</span>

        // Set some "config aliases"
        <span class="cov8" title="1">setValueFromFlag(cmd.Flags(), "destination", cfg, "publishDir", false)
        setValueFromFlag(cmd.Flags(), "i18n-warnings", cfg, "logI18nWarnings", false)
        setValueFromFlag(cmd.Flags(), "path-warnings", cfg, "logPathWarnings", false)</span>

}

func setValueFromFlag(flags *flag.FlagSet, key string, cfg config.Provider, targetKey string, force bool) <span class="cov8" title="1">{
        key = strings.TrimSpace(key)
        if (force &amp;&amp; flags.Lookup(key) != nil) || flags.Changed(key) </span><span class="cov8" title="1">{
                f := flags.Lookup(key)
                configKey := key
                if targetKey != "" </span><span class="cov0" title="0">{
                        configKey = targetKey
                }</span>
                // Gotta love this API.
                <span class="cov8" title="1">switch f.Value.Type() </span>{
                case "bool":<span class="cov8" title="1">
                        bv, _ := flags.GetBool(key)
                        cfg.Set(configKey, bv)</span>
                case "string":<span class="cov8" title="1">
                        cfg.Set(configKey, f.Value.String())</span>
                case "stringSlice":<span class="cov0" title="0">
                        bv, _ := flags.GetStringSlice(key)
                        cfg.Set(configKey, bv)</span>
                case "int":<span class="cov0" title="0">
                        iv, _ := flags.GetInt(key)
                        cfg.Set(configKey, iv)</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("update switch with %s", f.Value.Type()))</span>
                }

        }
}

func isTerminal() bool <span class="cov8" title="1">{
        return terminal.IsTerminal(os.Stdout)

}</span>
func ifTerminal(s string) string <span class="cov8" title="1">{
        if !isTerminal() </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return s</span>
}

func (c *commandeer) fullBuild() error <span class="cov8" title="1">{

        var (
                g         errgroup.Group
                langCount map[string]uint64
        )

        if !c.h.quiet </span><span class="cov8" title="1">{
                fmt.Print(ifTerminal(hideCursor) + "Building sites  ")
                if isTerminal() </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                fmt.Print(showCursor + clearLine)
                        }</span>()
                }
        }

        <span class="cov8" title="1">copyStaticFunc := func() error </span><span class="cov8" title="1">{

                cnt, err := c.copyStatic()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Error copying static files")
                }</span>
                <span class="cov8" title="1">langCount = cnt
                return nil</span>
        }
        <span class="cov8" title="1">buildSitesFunc := func() error </span><span class="cov8" title="1">{
                if err := c.buildSites(); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Error building site")
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        // Do not copy static files and build sites in parallel if cleanDestinationDir is enabled.
        // This flag deletes all static resources in /public folder that are missing in /static,
        // and it does so at the end of copyStatic() call.
        <span class="cov8" title="1">if c.Cfg.GetBool("cleanDestinationDir") </span><span class="cov8" title="1">{
                if err := copyStaticFunc(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := buildSitesFunc(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                g.Go(copyStaticFunc)
                g.Go(buildSitesFunc)
                if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">for _, s := range c.hugo().Sites </span><span class="cov8" title="1">{
                s.ProcessingStats.Static = langCount[s.Language().Lang]
        }</span>

        <span class="cov8" title="1">if c.h.gc </span><span class="cov0" title="0">{
                count, err := c.hugo().GC()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, s := range c.hugo().Sites </span><span class="cov0" title="0">{
                        // We have no way of knowing what site the garbage belonged to.
                        s.ProcessingStats.Cleaned = uint64(count)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>

}

func (c *commandeer) initCPUProfile() (func(), error) <span class="cov8" title="1">{
        if c.h.cpuprofile == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">f, err := os.Create(c.h.cpuprofile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to create CPU profile")
        }</span>
        <span class="cov0" title="0">if err := pprof.StartCPUProfile(f); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to start CPU profile")
        }</span>
        <span class="cov0" title="0">return func() </span><span class="cov0" title="0">{
                pprof.StopCPUProfile()
                f.Close()
        }</span>, nil
}

func (c *commandeer) initMemProfile() <span class="cov8" title="1">{
        if c.h.memprofile == "" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">f, err := os.Create(c.h.memprofile)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.ERROR.Println("could not create memory profile: ", err)
        }</span>
        <span class="cov0" title="0">defer f.Close()
        runtime.GC() // get up-to-date statistics
        if err := pprof.WriteHeapProfile(f); err != nil </span><span class="cov0" title="0">{
                c.logger.ERROR.Println("could not write memory profile: ", err)
        }</span>
}

func (c *commandeer) initTraceProfile() (func(), error) <span class="cov8" title="1">{
        if c.h.traceprofile == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">f, err := os.Create(c.h.traceprofile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to create trace file")
        }</span>

        <span class="cov0" title="0">if err := trace.Start(f); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to start trace")
        }</span>

        <span class="cov0" title="0">return func() </span><span class="cov0" title="0">{
                trace.Stop()
                f.Close()
        }</span>, nil
}

func (c *commandeer) initMutexProfile() (func(), error) <span class="cov8" title="1">{
        if c.h.mutexprofile == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">f, err := os.Create(c.h.mutexprofile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">runtime.SetMutexProfileFraction(1)

        return func() </span><span class="cov0" title="0">{
                pprof.Lookup("mutex").WriteTo(f, 0)
                f.Close()
        }</span>, nil

}

func (c *commandeer) initProfiling() (func(), error) <span class="cov8" title="1">{
        stopCPUProf, err := c.initCPUProfile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">stopMutexProf, err := c.initMutexProfile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">stopTraceProf, err := c.initTraceProfile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return func() </span><span class="cov8" title="1">{
                c.initMemProfile()

                if stopCPUProf != nil </span><span class="cov0" title="0">{
                        stopCPUProf()
                }</span>
                <span class="cov8" title="1">if stopMutexProf != nil </span><span class="cov0" title="0">{
                        stopMutexProf()
                }</span>

                <span class="cov8" title="1">if stopTraceProf != nil </span><span class="cov0" title="0">{
                        stopTraceProf()
                }</span>
        }, nil
}

func (c *commandeer) build() error <span class="cov8" title="1">{
        defer c.timeTrack(time.Now(), "Total")

        stopProfiling, err := c.initProfiling()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if stopProfiling != nil </span><span class="cov8" title="1">{
                        stopProfiling()
                }</span>
        }()

        <span class="cov8" title="1">if err := c.fullBuild(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO(bep) Feedback?
        <span class="cov8" title="1">if !c.h.quiet </span><span class="cov8" title="1">{
                fmt.Println()
                c.hugo().PrintProcessingStats(os.Stdout)
                fmt.Println()

                if createCounter, ok := c.destinationFs.(hugofs.DuplicatesReporter); ok </span><span class="cov0" title="0">{
                        dupes := createCounter.ReportDuplicates()
                        if dupes != "" </span><span class="cov0" title="0">{
                                c.logger.WARN.Println("Duplicate target paths:", dupes)
                        }</span>
                }
        }

        <span class="cov8" title="1">if c.h.buildWatch </span><span class="cov0" title="0">{
                watchDirs, err := c.getDirList()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">baseWatchDir := c.Cfg.GetString("workingDir")
                rootWatchDirs := getRootWatchDirsStr(baseWatchDir, watchDirs)

                c.logger.FEEDBACK.Printf("Watching for changes in %s%s{%s}\n", baseWatchDir, helpers.FilePathSeparator, rootWatchDirs)
                c.logger.FEEDBACK.Println("Press Ctrl+C to stop")
                watcher, err := c.newWatcher(watchDirs...)
                checkErr(c.Logger, err)
                defer watcher.Close()

                var sigs = make(chan os.Signal, 1)
                signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

                &lt;-sigs</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *commandeer) serverBuild() error <span class="cov0" title="0">{
        defer c.timeTrack(time.Now(), "Total")

        stopProfiling, err := c.initProfiling()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if stopProfiling != nil </span><span class="cov0" title="0">{
                        stopProfiling()
                }</span>
        }()

        <span class="cov0" title="0">if err := c.fullBuild(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO(bep) Feedback?
        <span class="cov0" title="0">if !c.h.quiet </span><span class="cov0" title="0">{
                fmt.Println()
                c.hugo().PrintProcessingStats(os.Stdout)
                fmt.Println()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *commandeer) copyStatic() (map[string]uint64, error) <span class="cov8" title="1">{
        m, err := c.doWithPublishDirs(c.copyStaticTo)
        if err == nil || os.IsNotExist(err) </span><span class="cov8" title="1">{
                return m, nil
        }</span>
        <span class="cov0" title="0">return m, err</span>
}

func (c *commandeer) doWithPublishDirs(f func(sourceFs *filesystems.SourceFilesystem) (uint64, error)) (map[string]uint64, error) <span class="cov8" title="1">{

        langCount := make(map[string]uint64)

        staticFilesystems := c.hugo().BaseFs.SourceFilesystems.Static

        if len(staticFilesystems) == 0 </span><span class="cov0" title="0">{
                c.logger.INFO.Println("No static directories found to sync")
                return langCount, nil
        }</span>

        <span class="cov8" title="1">for lang, fs := range staticFilesystems </span><span class="cov8" title="1">{
                cnt, err := f(fs)
                if err != nil </span><span class="cov0" title="0">{
                        return langCount, err
                }</span>

                <span class="cov8" title="1">if lang == "" </span><span class="cov8" title="1">{
                        // Not multihost
                        for _, l := range c.languages </span><span class="cov8" title="1">{
                                langCount[l.Lang] = cnt
                        }</span>
                } else<span class="cov0" title="0"> {
                        langCount[lang] = cnt
                }</span>
        }

        <span class="cov8" title="1">return langCount, nil</span>
}

type countingStatFs struct {
        afero.Fs
        statCounter uint64
}

func (fs *countingStatFs) Stat(name string) (os.FileInfo, error) <span class="cov8" title="1">{
        f, err := fs.Fs.Stat(name)
        if err == nil </span><span class="cov8" title="1">{
                if !f.IsDir() </span><span class="cov8" title="1">{
                        atomic.AddUint64(&amp;fs.statCounter, 1)
                }</span>
        }
        <span class="cov8" title="1">return f, err</span>
}

func chmodFilter(dst, src os.FileInfo) bool <span class="cov8" title="1">{
        // Hugo publishes data from multiple sources, potentially
        // with overlapping directory structures. We cannot sync permissions
        // for directories as that would mean that we might end up with write-protected
        // directories inside /public.
        // One example of this would be syncing from the Go Module cache,
        // which have 0555 directories.
        return src.IsDir()
}</span>

func (c *commandeer) copyStaticTo(sourceFs *filesystems.SourceFilesystem) (uint64, error) <span class="cov8" title="1">{
        publishDir := c.hugo().PathSpec.PublishDir
        // If root, remove the second '/'
        if publishDir == "//" </span><span class="cov0" title="0">{
                publishDir = helpers.FilePathSeparator
        }</span>

        <span class="cov8" title="1">if sourceFs.PublishFolder != "" </span><span class="cov0" title="0">{
                publishDir = filepath.Join(publishDir, sourceFs.PublishFolder)
        }</span>

        <span class="cov8" title="1">fs := &amp;countingStatFs{Fs: sourceFs.Fs}

        syncer := fsync.NewSyncer()
        syncer.NoTimes = c.Cfg.GetBool("noTimes")
        syncer.NoChmod = c.Cfg.GetBool("noChmod")
        syncer.ChmodFilter = chmodFilter
        syncer.SrcFs = fs
        syncer.DestFs = c.Fs.Destination
        // Now that we are using a unionFs for the static directories
        // We can effectively clean the publishDir on initial sync
        syncer.Delete = c.Cfg.GetBool("cleanDestinationDir")

        if syncer.Delete </span><span class="cov8" title="1">{
                c.logger.INFO.Println("removing all files from destination that don't exist in static dirs")

                syncer.DeleteFilter = func(f os.FileInfo) bool </span><span class="cov8" title="1">{
                        return f.IsDir() &amp;&amp; strings.HasPrefix(f.Name(), ".")
                }</span>
        }
        <span class="cov8" title="1">c.logger.INFO.Println("syncing static files to", publishDir)

        // because we are using a baseFs (to get the union right).
        // set sync src to root
        err := syncer.Sync(publishDir, helpers.FilePathSeparator)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Sync runs Stat 3 times for every source file (which sounds much)
        <span class="cov8" title="1">numFiles := fs.statCounter / 3

        return numFiles, err</span>
}

func (c *commandeer) firstPathSpec() *helpers.PathSpec <span class="cov0" title="0">{
        return c.hugo().Sites[0].PathSpec
}</span>

func (c *commandeer) timeTrack(start time.Time, name string) <span class="cov8" title="1">{
        if c.h.quiet </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">elapsed := time.Since(start)
        c.logger.FEEDBACK.Printf("%s in %v ms", name, int(1000*elapsed.Seconds()))</span>
}

// getDirList provides NewWatcher() with a list of directories to watch for changes.
func (c *commandeer) getDirList() ([]string, error) <span class="cov0" title="0">{
        var dirnames []string

        walkFn := func(path string, fi hugofs.FileMetaInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.ERROR.Println("walker: ", err)
                        return nil
                }</span>

                <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                        if fi.Name() == ".git" ||
                                fi.Name() == "node_modules" || fi.Name() == "bower_components" </span><span class="cov0" title="0">{
                                return filepath.SkipDir
                        }</span>

                        <span class="cov0" title="0">dirnames = append(dirnames, fi.Meta().Filename())</span>
                }

                <span class="cov0" title="0">return nil</span>

        }

        <span class="cov0" title="0">watchDirs := c.hugo().PathSpec.BaseFs.WatchDirs()
        for _, watchDir := range watchDirs </span><span class="cov0" title="0">{

                w := hugofs.NewWalkway(hugofs.WalkwayConfig{Logger: c.logger, Info: watchDir, WalkFn: walkFn})
                if err := w.Walk(); err != nil </span><span class="cov0" title="0">{
                        c.logger.ERROR.Println("walker: ", err)
                }</span>
        }

        <span class="cov0" title="0">dirnames = helpers.UniqueStringsSorted(dirnames)

        return dirnames, nil</span>
}

func (c *commandeer) buildSites() (err error) <span class="cov8" title="1">{
        return c.hugo().Build(hugolib.BuildCfg{})
}</span>

func (c *commandeer) handleBuildErr(err error, msg string) <span class="cov0" title="0">{
        c.buildErr = err

        c.logger.ERROR.Print(msg + ":\n\n")
        c.logger.ERROR.Println(helpers.FirstUpper(err.Error()))
        if !c.h.quiet &amp;&amp; c.h.verbose </span><span class="cov0" title="0">{
                herrors.PrintStackTrace(err)
        }</span>
}

func (c *commandeer) rebuildSites(events []fsnotify.Event) error <span class="cov0" title="0">{
        defer c.timeTrack(time.Now(), "Total")

        c.buildErr = nil
        visited := c.visitedURLs.PeekAllSet()
        if c.fastRenderMode </span><span class="cov0" title="0">{

                // Make sure we always render the home pages
                for _, l := range c.languages </span><span class="cov0" title="0">{
                        langPath := c.hugo().PathSpec.GetLangSubDir(l.Lang)
                        if langPath != "" </span><span class="cov0" title="0">{
                                langPath = langPath + "/"
                        }</span>
                        <span class="cov0" title="0">home := c.hugo().PathSpec.PrependBasePath("/"+langPath, false)
                        visited[home] = true</span>
                }

        }
        <span class="cov0" title="0">return c.hugo().Build(hugolib.BuildCfg{RecentlyVisited: visited}, events...)</span>
}

func (c *commandeer) partialReRender(urls ...string) error <span class="cov0" title="0">{
        c.buildErr = nil
        visited := make(map[string]bool)
        for _, url := range urls </span><span class="cov0" title="0">{
                visited[url] = true
        }</span>
        <span class="cov0" title="0">return c.hugo().Build(hugolib.BuildCfg{RecentlyVisited: visited, PartialReRender: true})</span>
}

func (c *commandeer) fullRebuild(changeType string) <span class="cov0" title="0">{
        if changeType == configChangeGoMod </span><span class="cov0" title="0">{
                // go.mod may be changed during the build itself, and
                // we really want to prevent superfluous builds.
                if !c.fullRebuildSem.TryAcquire(1) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">c.fullRebuildSem.Release(1)</span>
        }

        <span class="cov0" title="0">c.fullRebuildSem.Acquire(context.Background(), 1)

        go func() </span><span class="cov0" title="0">{

                defer c.fullRebuildSem.Release(1)

                c.printChangeDetected(changeType)

                defer func() </span><span class="cov0" title="0">{

                        // Allow any file system events to arrive back.
                        // This will block any rebuild on config changes for the
                        // duration of the sleep.
                        time.Sleep(2 * time.Second)
                }</span>()

                <span class="cov0" title="0">defer c.timeTrack(time.Now(), "Total")

                c.commandeerHugoState = newCommandeerHugoState()
                err := c.loadConfig(true, true)
                if err != nil </span><span class="cov0" title="0">{
                        // Set the processing on pause until the state is recovered.
                        c.paused = true
                        c.handleBuildErr(err, "Failed to reload config")

                }</span> else<span class="cov0" title="0"> {
                        c.paused = false
                }</span>

                <span class="cov0" title="0">if !c.paused </span><span class="cov0" title="0">{
                        _, err := c.copyStatic()
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.ERROR.Println(err)
                                return
                        }</span>

                        <span class="cov0" title="0">err = c.buildSites()
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.ERROR.Println(err)
                        }</span> else<span class="cov0" title="0"> if !c.h.buildWatch &amp;&amp; !c.Cfg.GetBool("disableLiveReload") </span><span class="cov0" title="0">{
                                livereload.ForceRefresh()
                        }</span>
                }
        }()
}

// newWatcher creates a new watcher to watch filesystem events.
func (c *commandeer) newWatcher(dirList ...string) (*watcher.Batcher, error) <span class="cov0" title="0">{
        if runtime.GOOS == "darwin" </span><span class="cov0" title="0">{
                tweakLimit()
        }</span>

        <span class="cov0" title="0">staticSyncer, err := newStaticSyncer(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">watcher, err := watcher.New(1 * time.Second)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, d := range dirList </span><span class="cov0" title="0">{
                if d != "" </span><span class="cov0" title="0">{
                        _ = watcher.Add(d)
                }</span>
        }

        // Identifies changes to config (config.toml) files.
        <span class="cov0" title="0">configSet := make(map[string]bool)

        c.logger.FEEDBACK.Println("Watching for config changes in", strings.Join(c.configFiles, ", "))
        for _, configFile := range c.configFiles </span><span class="cov0" title="0">{
                watcher.Add(configFile)
                configSet[configFile] = true
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case evs := &lt;-watcher.Events:<span class="cov0" title="0">
                                c.handleEvents(watcher, staticSyncer, evs, configSet)
                                if c.showErrorInBrowser &amp;&amp; c.errCount() &gt; 0 </span><span class="cov0" title="0">{
                                        // Need to reload browser to show the error
                                        livereload.ForceRefresh()
                                }</span>
                        case err := &lt;-watcher.Errors:<span class="cov0" title="0">
                                if err != nil </span><span class="cov0" title="0">{
                                        c.logger.ERROR.Println("Error while watching:", err)
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">return watcher, nil</span>
}

func (c *commandeer) printChangeDetected(typ string) <span class="cov0" title="0">{
        msg := "\nChange"
        if typ != "" </span><span class="cov0" title="0">{
                msg += " of " + typ
        }</span>
        <span class="cov0" title="0">msg += " detected, rebuilding site."

        c.logger.FEEDBACK.Println(msg)
        const layout = "2006-01-02 15:04:05.000 -0700"
        c.logger.FEEDBACK.Println(time.Now().Format(layout))</span>
}

const (
        configChangeConfig = "config file"
        configChangeGoMod  = "go.mod file"
)

func (c *commandeer) handleEvents(watcher *watcher.Batcher,
        staticSyncer *staticSyncer,
        evs []fsnotify.Event,
        configSet map[string]bool) <span class="cov0" title="0">{

        var isHandled bool

        for _, ev := range evs </span><span class="cov0" title="0">{
                isConfig := configSet[ev.Name]
                configChangeType := configChangeConfig
                if isConfig </span><span class="cov0" title="0">{
                        if strings.Contains(ev.Name, "go.mod") </span><span class="cov0" title="0">{
                                configChangeType = configChangeGoMod
                        }</span>
                }
                <span class="cov0" title="0">if !isConfig </span><span class="cov0" title="0">{
                        // It may be one of the /config folders
                        dirname := filepath.Dir(ev.Name)
                        if dirname != "." &amp;&amp; configSet[dirname] </span><span class="cov0" title="0">{
                                isConfig = true
                        }</span>
                }

                <span class="cov0" title="0">if isConfig </span><span class="cov0" title="0">{
                        isHandled = true

                        if ev.Op&amp;fsnotify.Chmod == fsnotify.Chmod </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if ev.Op&amp;fsnotify.Remove == fsnotify.Remove || ev.Op&amp;fsnotify.Rename == fsnotify.Rename </span><span class="cov0" title="0">{
                                for _, configFile := range c.configFiles </span><span class="cov0" title="0">{
                                        counter := 0
                                        for watcher.Add(configFile) != nil </span><span class="cov0" title="0">{
                                                counter++
                                                if counter &gt;= 100 </span><span class="cov0" title="0">{
                                                        break</span>
                                                }
                                                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
                                        }
                                }

                        }

                        // Config file(s) changed. Need full rebuild.
                        <span class="cov0" title="0">c.fullRebuild(configChangeType)

                        return</span>
                }
        }

        <span class="cov0" title="0">if isHandled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if c.paused </span><span class="cov0" title="0">{
                // Wait for the server to get into a consistent state before
                // we continue with processing.
                return
        }</span>

        <span class="cov0" title="0">if len(evs) &gt; 50 </span><span class="cov0" title="0">{
                // This is probably a mass edit of the content dir.
                // Schedule a full rebuild for when it slows down.
                c.debounce(func() </span><span class="cov0" title="0">{
                        c.fullRebuild("")
                }</span>)
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.logger.INFO.Println("Received System Events:", evs)

        staticEvents := []fsnotify.Event{}
        dynamicEvents := []fsnotify.Event{}

        // Special handling for symbolic links inside /content.
        filtered := []fsnotify.Event{}
        for _, ev := range evs </span><span class="cov0" title="0">{
                // Check the most specific first, i.e. files.
                contentMapped := c.hugo().ContentChanges.GetSymbolicLinkMappings(ev.Name)
                if len(contentMapped) &gt; 0 </span><span class="cov0" title="0">{
                        for _, mapped := range contentMapped </span><span class="cov0" title="0">{
                                filtered = append(filtered, fsnotify.Event{Name: mapped, Op: ev.Op})
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Check for any symbolic directory mapping.

                <span class="cov0" title="0">dir, name := filepath.Split(ev.Name)

                contentMapped = c.hugo().ContentChanges.GetSymbolicLinkMappings(dir)

                if len(contentMapped) == 0 </span><span class="cov0" title="0">{
                        filtered = append(filtered, ev)
                        continue</span>
                }

                <span class="cov0" title="0">for _, mapped := range contentMapped </span><span class="cov0" title="0">{
                        mappedFilename := filepath.Join(mapped, name)
                        filtered = append(filtered, fsnotify.Event{Name: mappedFilename, Op: ev.Op})
                }</span>
        }

        <span class="cov0" title="0">evs = filtered

        for _, ev := range evs </span><span class="cov0" title="0">{
                ext := filepath.Ext(ev.Name)
                baseName := filepath.Base(ev.Name)
                istemp := strings.HasSuffix(ext, "~") ||
                        (ext == ".swp") || // vim
                        (ext == ".swx") || // vim
                        (ext == ".tmp") || // generic temp file
                        (ext == ".DS_Store") || // OSX Thumbnail
                        baseName == "4913" || // vim
                        strings.HasPrefix(ext, ".goutputstream") || // gnome
                        strings.HasSuffix(ext, "jb_old___") || // intelliJ
                        strings.HasSuffix(ext, "jb_tmp___") || // intelliJ
                        strings.HasSuffix(ext, "jb_bak___") || // intelliJ
                        strings.HasPrefix(ext, ".sb-") || // byword
                        strings.HasPrefix(baseName, ".#") || // emacs
                        strings.HasPrefix(baseName, "#") // emacs
                if istemp </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if c.hugo().Deps.SourceSpec.IgnoreFile(ev.Name) </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Sometimes during rm -rf operations a '"": REMOVE' is triggered. Just ignore these
                <span class="cov0" title="0">if ev.Name == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Write and rename operations are often followed by CHMOD.
                // There may be valid use cases for rebuilding the site on CHMOD,
                // but that will require more complex logic than this simple conditional.
                // On OS X this seems to be related to Spotlight, see:
                // https://github.com/go-fsnotify/fsnotify/issues/15
                // A workaround is to put your site(s) on the Spotlight exception list,
                // but that may be a little mysterious for most end users.
                // So, for now, we skip reload on CHMOD.
                // We do have to check for WRITE though. On slower laptops a Chmod
                // could be aggregated with other important events, and we still want
                // to rebuild on those
                <span class="cov0" title="0">if ev.Op&amp;(fsnotify.Chmod|fsnotify.Write|fsnotify.Create) == fsnotify.Chmod </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">walkAdder := func(path string, f hugofs.FileMetaInfo, err error) error </span><span class="cov0" title="0">{
                        if f.IsDir() </span><span class="cov0" title="0">{
                                c.logger.FEEDBACK.Println("adding created directory to watchlist", path)
                                if err := watcher.Add(path); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> if !staticSyncer.isStatic(path) </span><span class="cov0" title="0">{
                                // Hugo's rebuilding logic is entirely file based. When you drop a new folder into
                                // /content on OSX, the above logic will handle future watching of those files,
                                // but the initial CREATE is lost.
                                dynamicEvents = append(dynamicEvents, fsnotify.Event{Name: path, Op: fsnotify.Create})
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                // recursively add new directories to watch list
                // When mkdir -p is used, only the top directory triggers an event (at least on OSX)
                <span class="cov0" title="0">if ev.Op&amp;fsnotify.Create == fsnotify.Create </span><span class="cov0" title="0">{
                        if s, err := c.Fs.Source.Stat(ev.Name); err == nil &amp;&amp; s.Mode().IsDir() </span><span class="cov0" title="0">{
                                _ = helpers.SymbolicWalk(c.Fs.Source, ev.Name, walkAdder)
                        }</span>
                }

                <span class="cov0" title="0">if staticSyncer.isStatic(ev.Name) </span><span class="cov0" title="0">{
                        staticEvents = append(staticEvents, ev)
                }</span> else<span class="cov0" title="0"> {
                        dynamicEvents = append(dynamicEvents, ev)
                }</span>
        }

        <span class="cov0" title="0">if len(staticEvents) &gt; 0 </span><span class="cov0" title="0">{
                c.printChangeDetected("Static files")

                if c.Cfg.GetBool("forceSyncStatic") </span><span class="cov0" title="0">{
                        c.logger.FEEDBACK.Printf("Syncing all static files\n")
                        _, err := c.copyStatic()
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.ERROR.Println("Error copying static files to publish dir:", err)
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := staticSyncer.syncsStaticEvents(staticEvents); err != nil </span><span class="cov0" title="0">{
                                c.logger.ERROR.Println("Error syncing static files to publish dir:", err)
                                return
                        }</span>
                }

                <span class="cov0" title="0">if !c.h.buildWatch &amp;&amp; !c.Cfg.GetBool("disableLiveReload") </span><span class="cov0" title="0">{
                        // Will block forever trying to write to a channel that nobody is reading if livereload isn't initialized

                        // force refresh when more than one file
                        if len(staticEvents) == 1 </span><span class="cov0" title="0">{
                                ev := staticEvents[0]
                                path := c.hugo().BaseFs.SourceFilesystems.MakeStaticPathRelative(ev.Name)
                                path = c.firstPathSpec().RelURL(helpers.ToSlashTrimLeading(path), false)
                                livereload.RefreshPath(path)
                        }</span> else<span class="cov0" title="0"> {
                                livereload.ForceRefresh()
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(dynamicEvents) &gt; 0 </span><span class="cov0" title="0">{
                partitionedEvents := partitionDynamicEvents(
                        c.firstPathSpec().BaseFs.SourceFilesystems,
                        dynamicEvents)

                doLiveReload := !c.h.buildWatch &amp;&amp; !c.Cfg.GetBool("disableLiveReload")
                onePageName := pickOneWriteOrCreatePath(partitionedEvents.ContentEvents)

                c.printChangeDetected("")
                c.changeDetector.PrepareNew()
                if err := c.rebuildSites(dynamicEvents); err != nil </span><span class="cov0" title="0">{
                        c.handleBuildErr(err, "Rebuild failed")
                }</span>

                <span class="cov0" title="0">if doLiveReload </span><span class="cov0" title="0">{
                        if len(partitionedEvents.ContentEvents) == 0 &amp;&amp; len(partitionedEvents.AssetEvents) &gt; 0 </span><span class="cov0" title="0">{
                                changed := c.changeDetector.changed()
                                if c.changeDetector != nil &amp;&amp; len(changed) == 0 </span><span class="cov0" title="0">{
                                        // Nothing has changed.
                                        return
                                }</span> else<span class="cov0" title="0"> if len(changed) == 1 </span><span class="cov0" title="0">{
                                        pathToRefresh := c.firstPathSpec().RelURL(helpers.ToSlashTrimLeading(changed[0]), false)
                                        livereload.RefreshPath(pathToRefresh)
                                }</span> else<span class="cov0" title="0"> {
                                        livereload.ForceRefresh()
                                }</span>
                        }

                        <span class="cov0" title="0">if len(partitionedEvents.ContentEvents) &gt; 0 </span><span class="cov0" title="0">{

                                navigate := c.Cfg.GetBool("navigateToChanged")
                                // We have fetched the same page above, but it may have
                                // changed.
                                var p page.Page

                                if navigate </span><span class="cov0" title="0">{
                                        if onePageName != "" </span><span class="cov0" title="0">{
                                                p = c.hugo().GetContentPage(onePageName)
                                        }</span>
                                }

                                <span class="cov0" title="0">if p != nil </span><span class="cov0" title="0">{
                                        livereload.NavigateToPathForPort(p.RelPermalink(), p.Site().ServerPort())
                                }</span> else<span class="cov0" title="0"> {
                                        livereload.ForceRefresh()
                                }</span>
                        }
                }
        }
}

// dynamicEvents contains events that is considered dynamic, as in "not static".
// Both of these categories will trigger a new build, but the asset events
// does not fit into the "navigate to changed" logic.
type dynamicEvents struct {
        ContentEvents []fsnotify.Event
        AssetEvents   []fsnotify.Event
}

func partitionDynamicEvents(sourceFs *filesystems.SourceFilesystems, events []fsnotify.Event) (de dynamicEvents) <span class="cov0" title="0">{
        for _, e := range events </span><span class="cov0" title="0">{
                if sourceFs.IsAsset(e.Name) </span><span class="cov0" title="0">{
                        de.AssetEvents = append(de.AssetEvents, e)
                }</span> else<span class="cov0" title="0"> {
                        de.ContentEvents = append(de.ContentEvents, e)
                }</span>
        }
        <span class="cov0" title="0">return</span>

}

func pickOneWriteOrCreatePath(events []fsnotify.Event) string <span class="cov0" title="0">{
        name := ""

        // Some editors (for example notepad.exe on Windows) triggers a change
        // both for directory and file. So we pick the longest path, which should
        // be the file itself.
        for _, ev := range events </span><span class="cov0" title="0">{
                if (ev.Op&amp;fsnotify.Write == fsnotify.Write || ev.Op&amp;fsnotify.Create == fsnotify.Create) &amp;&amp; len(ev.Name) &gt; len(name) </span><span class="cov0" title="0">{
                        name = ev.Name
                }</span>
        }

        <span class="cov0" title="0">return name</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "time"
        "unicode"

        "github.com/gohugoio/hugo/common/hugio"

        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/hugolib"
        "github.com/gohugoio/hugo/parser"
        "github.com/spf13/afero"
        "github.com/spf13/cast"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*importCmd)(nil)

type importCmd struct {
        *baseCmd
}

func newImportCmd() *importCmd <span class="cov8" title="1">{
        cc := &amp;importCmd{}

        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "import",
                Short: "Import your site from others.",
                Long: `Import your site from other web site generators like Jekyll.

Import requires a subcommand, e.g. ` + "`hugo import jekyll jekyll_root_path target_path`.",
                RunE: nil,
        })

        importJekyllCmd := &amp;cobra.Command{
                Use:   "jekyll",
                Short: "hugo import from Jekyll",
                Long: `hugo import from Jekyll.

Import from Jekyll requires two paths, e.g. ` + "`hugo import jekyll jekyll_root_path target_path`.",
                RunE: cc.importFromJekyll,
        }

        importJekyllCmd.Flags().Bool("force", false, "allow import into non-empty target directory")

        cc.cmd.AddCommand(importJekyllCmd)

        return cc

}</span>

func (i *importCmd) importFromJekyll(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{

        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return newUserError(`import from jekyll requires two paths, e.g. ` + "`hugo import jekyll jekyll_root_path target_path`.")
        }</span>

        <span class="cov0" title="0">jekyllRoot, err := filepath.Abs(filepath.Clean(args[0]))
        if err != nil </span><span class="cov0" title="0">{
                return newUserError("path error:", args[0])
        }</span>

        <span class="cov0" title="0">targetDir, err := filepath.Abs(filepath.Clean(args[1]))
        if err != nil </span><span class="cov0" title="0">{
                return newUserError("path error:", args[1])
        }</span>

        <span class="cov0" title="0">jww.INFO.Println("Import Jekyll from:", jekyllRoot, "to:", targetDir)

        if strings.HasPrefix(filepath.Dir(targetDir), jekyllRoot) </span><span class="cov0" title="0">{
                return newUserError("abort: target path should not be inside the Jekyll root")
        }</span>

        <span class="cov0" title="0">forceImport, _ := cmd.Flags().GetBool("force")

        fs := afero.NewOsFs()
        jekyllPostDirs, hasAnyPost := i.getJekyllDirInfo(fs, jekyllRoot)
        if !hasAnyPost </span><span class="cov0" title="0">{
                return errors.New("abort: jekyll root contains neither posts nor drafts")
        }</span>

        <span class="cov0" title="0">site, err := i.createSiteFromJekyll(jekyllRoot, targetDir, jekyllPostDirs, forceImport)

        if err != nil </span><span class="cov0" title="0">{
                return newUserError(err)
        }</span>

        <span class="cov0" title="0">jww.FEEDBACK.Println("Importing...")

        fileCount := 0
        callback := func(path string, fi hugofs.FileMetaInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">relPath, err := filepath.Rel(jekyllRoot, path)
                if err != nil </span><span class="cov0" title="0">{
                        return newUserError("get rel path error:", path)
                }</span>

                <span class="cov0" title="0">relPath = filepath.ToSlash(relPath)
                draft := false

                switch </span>{
                case strings.Contains(relPath, "_posts/"):<span class="cov0" title="0">
                        relPath = filepath.Join("content/post", strings.Replace(relPath, "_posts/", "", -1))</span>
                case strings.Contains(relPath, "_drafts/"):<span class="cov0" title="0">
                        relPath = filepath.Join("content/draft", strings.Replace(relPath, "_drafts/", "", -1))
                        draft = true</span>
                default:<span class="cov0" title="0">
                        return nil</span>
                }

                <span class="cov0" title="0">fileCount++
                return convertJekyllPost(site, path, relPath, targetDir, draft)</span>
        }

        <span class="cov0" title="0">for jekyllPostDir, hasAnyPostInDir := range jekyllPostDirs </span><span class="cov0" title="0">{
                if hasAnyPostInDir </span><span class="cov0" title="0">{
                        if err = helpers.SymbolicWalk(hugofs.Os, filepath.Join(jekyllRoot, jekyllPostDir), callback); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">jww.FEEDBACK.Println("Congratulations!", fileCount, "post(s) imported!")
        jww.FEEDBACK.Println("Now, start Hugo by yourself:\n" +
                "$ git clone https://github.com/spf13/herring-cove.git " + args[1] + "/themes/herring-cove")
        jww.FEEDBACK.Println("$ cd " + args[1] + "\n$ hugo server --theme=herring-cove")

        return nil</span>
}

func (i *importCmd) getJekyllDirInfo(fs afero.Fs, jekyllRoot string) (map[string]bool, bool) <span class="cov0" title="0">{
        postDirs := make(map[string]bool)
        hasAnyPost := false
        if entries, err := ioutil.ReadDir(jekyllRoot); err == nil </span><span class="cov0" title="0">{
                for _, entry := range entries </span><span class="cov0" title="0">{
                        if entry.IsDir() </span><span class="cov0" title="0">{
                                subDir := filepath.Join(jekyllRoot, entry.Name())
                                if isPostDir, hasAnyPostInDir := i.retrieveJekyllPostDir(fs, subDir); isPostDir </span><span class="cov0" title="0">{
                                        postDirs[entry.Name()] = hasAnyPostInDir
                                        if hasAnyPostInDir </span><span class="cov0" title="0">{
                                                hasAnyPost = true
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return postDirs, hasAnyPost</span>
}

func (i *importCmd) retrieveJekyllPostDir(fs afero.Fs, dir string) (bool, bool) <span class="cov0" title="0">{
        if strings.HasSuffix(dir, "_posts") || strings.HasSuffix(dir, "_drafts") </span><span class="cov0" title="0">{
                isEmpty, _ := helpers.IsEmpty(dir, fs)
                return true, !isEmpty
        }</span>

        <span class="cov0" title="0">if entries, err := ioutil.ReadDir(dir); err == nil </span><span class="cov0" title="0">{
                for _, entry := range entries </span><span class="cov0" title="0">{
                        if entry.IsDir() </span><span class="cov0" title="0">{
                                subDir := filepath.Join(dir, entry.Name())
                                if isPostDir, hasAnyPost := i.retrieveJekyllPostDir(fs, subDir); isPostDir </span><span class="cov0" title="0">{
                                        return isPostDir, hasAnyPost
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false, true</span>
}

func (i *importCmd) createSiteFromJekyll(jekyllRoot, targetDir string, jekyllPostDirs map[string]bool, force bool) (*hugolib.Site, error) <span class="cov0" title="0">{
        s, err := hugolib.NewSiteDefaultLang()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">fs := s.Fs.Source
        if exists, _ := helpers.Exists(targetDir, fs); exists </span><span class="cov0" title="0">{
                if isDir, _ := helpers.IsDir(targetDir, fs); !isDir </span><span class="cov0" title="0">{
                        return nil, errors.New("target path \"" + targetDir + "\" exists but is not a directory")
                }</span>

                <span class="cov0" title="0">isEmpty, _ := helpers.IsEmpty(targetDir, fs)

                if !isEmpty &amp;&amp; !force </span><span class="cov0" title="0">{
                        return nil, errors.New("target path \"" + targetDir + "\" exists and is not empty")
                }</span>
        }

        <span class="cov0" title="0">jekyllConfig := i.loadJekyllConfig(fs, jekyllRoot)

        mkdir(targetDir, "layouts")
        mkdir(targetDir, "content")
        mkdir(targetDir, "archetypes")
        mkdir(targetDir, "static")
        mkdir(targetDir, "data")
        mkdir(targetDir, "themes")

        i.createConfigFromJekyll(fs, targetDir, "yaml", jekyllConfig)

        i.copyJekyllFilesAndFolders(jekyllRoot, filepath.Join(targetDir, "static"), jekyllPostDirs)

        return s, nil</span>
}

func (i *importCmd) loadJekyllConfig(fs afero.Fs, jekyllRoot string) map[string]interface{} <span class="cov0" title="0">{
        path := filepath.Join(jekyllRoot, "_config.yml")

        exists, err := helpers.Exists(path, fs)

        if err != nil || !exists </span><span class="cov0" title="0">{
                jww.WARN.Println("_config.yaml not found: Is the specified Jekyll root correct?")
                return nil
        }</span>

        <span class="cov0" title="0">f, err := fs.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">defer f.Close()

        b, err := ioutil.ReadAll(f)

        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">c, err := metadecoders.Default.UnmarshalToMap(b, metadecoders.YAML)

        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return c</span>
}

func (i *importCmd) createConfigFromJekyll(fs afero.Fs, inpath string, kind metadecoders.Format, jekyllConfig map[string]interface{}) (err error) <span class="cov0" title="0">{
        title := "My New Hugo Site"
        baseURL := "http://example.org/"

        for key, value := range jekyllConfig </span><span class="cov0" title="0">{
                lowerKey := strings.ToLower(key)

                switch lowerKey </span>{
                case "title":<span class="cov0" title="0">
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                title = str
                        }</span>

                case "url":<span class="cov0" title="0">
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                baseURL = str
                        }</span>
                }
        }

        <span class="cov0" title="0">in := map[string]interface{}{
                "baseURL":            baseURL,
                "title":              title,
                "languageCode":       "en-us",
                "disablePathToLower": true,
        }

        var buf bytes.Buffer
        err = parser.InterfaceToConfig(in, kind, &amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return helpers.WriteToDisk(filepath.Join(inpath, "config."+string(kind)), &amp;buf, fs)</span>
}

func (i *importCmd) copyJekyllFilesAndFolders(jekyllRoot, dest string, jekyllPostDirs map[string]bool) (err error) <span class="cov0" title="0">{
        fs := hugofs.Os

        fi, err := fs.Stat(jekyllRoot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !fi.IsDir() </span><span class="cov0" title="0">{
                return errors.New(jekyllRoot + " is not a directory")
        }</span>
        <span class="cov0" title="0">err = os.MkdirAll(dest, fi.Mode())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">entries, err := ioutil.ReadDir(jekyllRoot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                sfp := filepath.Join(jekyllRoot, entry.Name())
                dfp := filepath.Join(dest, entry.Name())
                if entry.IsDir() </span><span class="cov0" title="0">{
                        if entry.Name()[0] != '_' &amp;&amp; entry.Name()[0] != '.' </span><span class="cov0" title="0">{
                                if _, ok := jekyllPostDirs[entry.Name()]; !ok </span><span class="cov0" title="0">{
                                        err = hugio.CopyDir(fs, sfp, dfp, nil)
                                        if err != nil </span><span class="cov0" title="0">{
                                                jww.ERROR.Println(err)
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        lowerEntryName := strings.ToLower(entry.Name())
                        exceptSuffix := []string{".md", ".markdown", ".html", ".htm",
                                ".xml", ".textile", "rakefile", "gemfile", ".lock"}
                        isExcept := false
                        for _, suffix := range exceptSuffix </span><span class="cov0" title="0">{
                                if strings.HasSuffix(lowerEntryName, suffix) </span><span class="cov0" title="0">{
                                        isExcept = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !isExcept &amp;&amp; entry.Name()[0] != '.' &amp;&amp; entry.Name()[0] != '_' </span><span class="cov0" title="0">{
                                err = hugio.CopyFile(fs, sfp, dfp)
                                if err != nil </span><span class="cov0" title="0">{
                                        jww.ERROR.Println(err)
                                }</span>
                        }
                }

        }
        <span class="cov0" title="0">return nil</span>
}

func parseJekyllFilename(filename string) (time.Time, string, error) <span class="cov0" title="0">{
        re := regexp.MustCompile(`(\d+-\d+-\d+)-(.+)\..*`)
        r := re.FindAllStringSubmatch(filename, -1)
        if len(r) == 0 </span><span class="cov0" title="0">{
                return time.Now(), "", errors.New("filename not match")
        }</span>

        <span class="cov0" title="0">postDate, err := time.Parse("2006-1-2", r[0][1])
        if err != nil </span><span class="cov0" title="0">{
                return time.Now(), "", err
        }</span>

        <span class="cov0" title="0">postName := r[0][2]

        return postDate, postName, nil</span>
}

func convertJekyllPost(s *hugolib.Site, path, relPath, targetDir string, draft bool) error <span class="cov0" title="0">{
        jww.TRACE.Println("Converting", path)

        filename := filepath.Base(path)
        postDate, postName, err := parseJekyllFilename(filename)
        if err != nil </span><span class="cov0" title="0">{
                jww.WARN.Printf("Failed to parse filename '%s': %s. Skipping.", filename, err)
                return nil
        }</span>

        <span class="cov0" title="0">jww.TRACE.Println(filename, postDate, postName)

        targetFile := filepath.Join(targetDir, relPath)
        targetParentDir := filepath.Dir(targetFile)
        os.MkdirAll(targetParentDir, 0777)

        contentBytes, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Println("Read file error:", path)
                return err
        }</span>

        <span class="cov0" title="0">pf, err := parseContentFile(bytes.NewReader(contentBytes))
        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Println("Parse file error:", path)
                return err
        }</span>

        <span class="cov0" title="0">newmetadata, err := convertJekyllMetaData(pf.frontMatter, postName, postDate, draft)
        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Println("Convert metadata error:", path)
                return err
        }</span>

        <span class="cov0" title="0">content := convertJekyllContent(newmetadata, string(pf.content))

        fs := hugofs.Os
        if err := helpers.WriteToDisk(targetFile, strings.NewReader(content), fs); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save file %q: %s", filename, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func convertJekyllMetaData(m interface{}, postName string, postDate time.Time, draft bool) (interface{}, error) <span class="cov0" title="0">{
        metadata, err := cast.ToStringMapE(m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if draft </span><span class="cov0" title="0">{
                metadata["draft"] = true
        }</span>

        <span class="cov0" title="0">for key, value := range metadata </span><span class="cov0" title="0">{
                lowerKey := strings.ToLower(key)

                switch lowerKey </span>{
                case "layout":<span class="cov0" title="0">
                        delete(metadata, key)</span>
                case "permalink":<span class="cov0" title="0">
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                metadata["url"] = str
                        }</span>
                        <span class="cov0" title="0">delete(metadata, key)</span>
                case "category":<span class="cov0" title="0">
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                metadata["categories"] = []string{str}
                        }</span>
                        <span class="cov0" title="0">delete(metadata, key)</span>
                case "excerpt_separator":<span class="cov0" title="0">
                        if key != lowerKey </span><span class="cov0" title="0">{
                                delete(metadata, key)
                                metadata[lowerKey] = value
                        }</span>
                case "date":<span class="cov0" title="0">
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                re := regexp.MustCompile(`(\d+):(\d+):(\d+)`)
                                r := re.FindAllStringSubmatch(str, -1)
                                if len(r) &gt; 0 </span><span class="cov0" title="0">{
                                        hour, _ := strconv.Atoi(r[0][1])
                                        minute, _ := strconv.Atoi(r[0][2])
                                        second, _ := strconv.Atoi(r[0][3])
                                        postDate = time.Date(postDate.Year(), postDate.Month(), postDate.Day(), hour, minute, second, 0, time.UTC)
                                }</span>
                        }
                        <span class="cov0" title="0">delete(metadata, key)</span>
                }

        }

        <span class="cov0" title="0">metadata["date"] = postDate.Format(time.RFC3339)

        return metadata, nil</span>
}

func convertJekyllContent(m interface{}, content string) string <span class="cov0" title="0">{
        metadata, _ := cast.ToStringMapE(m)

        lines := strings.Split(content, "\n")
        var resultLines []string
        for _, line := range lines </span><span class="cov0" title="0">{
                resultLines = append(resultLines, strings.Trim(line, "\r\n"))
        }</span>

        <span class="cov0" title="0">content = strings.Join(resultLines, "\n")

        excerptSep := "&lt;!--more--&gt;"
        if value, ok := metadata["excerpt_separator"]; ok </span><span class="cov0" title="0">{
                if str, strOk := value.(string); strOk </span><span class="cov0" title="0">{
                        content = strings.Replace(content, strings.TrimSpace(str), excerptSep, -1)
                }</span>
        }

        <span class="cov0" title="0">replaceList := []struct {
                re      *regexp.Regexp
                replace string
        }{
                {regexp.MustCompile("(?i)&lt;!-- more --&gt;"), "&lt;!--more--&gt;"},
                {regexp.MustCompile(`\{%\s*raw\s*%\}\s*(.*?)\s*\{%\s*endraw\s*%\}`), "$1"},
                {regexp.MustCompile(`{%\s*endhighlight\s*%}`), "{{&lt; / highlight &gt;}}"},
        }

        for _, replace := range replaceList </span><span class="cov0" title="0">{
                content = replace.re.ReplaceAllString(content, replace.replace)
        }</span>

        <span class="cov0" title="0">replaceListFunc := []struct {
                re      *regexp.Regexp
                replace func(string) string
        }{
                // Octopress image tag: http://octopress.org/docs/plugins/image-tag/
                {regexp.MustCompile(`{%\s+img\s*(.*?)\s*%}`), replaceImageTag},
                {regexp.MustCompile(`{%\s*highlight\s*(.*?)\s*%}`), replaceHighlightTag},
        }

        for _, replace := range replaceListFunc </span><span class="cov0" title="0">{
                content = replace.re.ReplaceAllStringFunc(content, replace.replace)
        }</span>

        <span class="cov0" title="0">return content</span>
}

func replaceHighlightTag(match string) string <span class="cov0" title="0">{
        r := regexp.MustCompile(`{%\s*highlight\s*(.*?)\s*%}`)
        parts := r.FindStringSubmatch(match)
        lastQuote := rune(0)
        f := func(c rune) bool </span><span class="cov0" title="0">{
                switch </span>{
                case c == lastQuote:<span class="cov0" title="0">
                        lastQuote = rune(0)
                        return false</span>
                case lastQuote != rune(0):<span class="cov0" title="0">
                        return false</span>
                case unicode.In(c, unicode.Quotation_Mark):<span class="cov0" title="0">
                        lastQuote = c
                        return false</span>
                default:<span class="cov0" title="0">
                        return unicode.IsSpace(c)</span>
                }
        }
        // splitting string by space but considering quoted section
        <span class="cov0" title="0">items := strings.FieldsFunc(parts[1], f)

        result := bytes.NewBufferString("{{&lt; highlight ")
        result.WriteString(items[0]) // language
        options := items[1:]
        for i, opt := range options </span><span class="cov0" title="0">{
                opt = strings.Replace(opt, "\"", "", -1)
                if opt == "linenos" </span><span class="cov0" title="0">{
                        opt = "linenos=table"
                }</span>
                <span class="cov0" title="0">if i == 0 </span><span class="cov0" title="0">{
                        opt = " \"" + opt
                }</span>
                <span class="cov0" title="0">if i &lt; len(options)-1 </span><span class="cov0" title="0">{
                        opt += ","
                }</span> else<span class="cov0" title="0"> if i == len(options)-1 </span><span class="cov0" title="0">{
                        opt += "\""
                }</span>
                <span class="cov0" title="0">result.WriteString(opt)</span>
        }

        <span class="cov0" title="0">result.WriteString(" &gt;}}")
        return result.String()</span>
}

func replaceImageTag(match string) string <span class="cov0" title="0">{
        r := regexp.MustCompile(`{%\s+img\s*(\p{L}*)\s+([\S]*/[\S]+)\s+(\d*)\s*(\d*)\s*(.*?)\s*%}`)
        result := bytes.NewBufferString("{{&lt; figure ")
        parts := r.FindStringSubmatch(match)
        // Index 0 is the entire string, ignore
        replaceOptionalPart(result, "class", parts[1])
        replaceOptionalPart(result, "src", parts[2])
        replaceOptionalPart(result, "width", parts[3])
        replaceOptionalPart(result, "height", parts[4])
        // title + alt
        part := parts[5]
        if len(part) &gt; 0 </span><span class="cov0" title="0">{
                splits := strings.Split(part, "'")
                lenSplits := len(splits)
                if lenSplits == 1 </span><span class="cov0" title="0">{
                        replaceOptionalPart(result, "title", splits[0])
                }</span> else<span class="cov0" title="0"> if lenSplits == 3 </span><span class="cov0" title="0">{
                        replaceOptionalPart(result, "title", splits[1])
                }</span> else<span class="cov0" title="0"> if lenSplits == 5 </span><span class="cov0" title="0">{
                        replaceOptionalPart(result, "title", splits[1])
                        replaceOptionalPart(result, "alt", splits[3])
                }</span>
        }
        <span class="cov0" title="0">result.WriteString("&gt;}}")
        return result.String()</span>

}
func replaceOptionalPart(buffer *bytes.Buffer, partName string, part string) <span class="cov0" title="0">{
        if len(part) &gt; 0 </span><span class="cov0" title="0">{
                buffer.WriteString(partName + "=\"" + part + "\" ")
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "syscall"

        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*limitCmd)(nil)

type limitCmd struct {
        *baseCmd
}

func newLimitCmd() *limitCmd <span class="cov8" title="1">{
        ccmd := &amp;cobra.Command{
                Use:   "ulimit",
                Short: "Check system ulimit settings",
                Long: `Hugo will inspect the current ulimit settings on the system.
This is primarily to ensure that Hugo can watch enough files on some OSs`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        var rLimit syscall.Rlimit
                        err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &amp;rLimit)
                        if err != nil </span><span class="cov0" title="0">{
                                return newSystemError("Error Getting rlimit ", err)
                        }</span>

                        <span class="cov0" title="0">jww.FEEDBACK.Println("Current rLimit:", rLimit)

                        if rLimit.Cur &gt;= newRlimit </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">jww.FEEDBACK.Println("Attempting to increase limit")
                        rLimit.Cur = newRlimit
                        err = syscall.Setrlimit(syscall.RLIMIT_NOFILE, &amp;rLimit)
                        if err != nil </span><span class="cov0" title="0">{
                                return newSystemError("Error Setting rLimit ", err)
                        }</span>
                        <span class="cov0" title="0">err = syscall.Getrlimit(syscall.RLIMIT_NOFILE, &amp;rLimit)
                        if err != nil </span><span class="cov0" title="0">{
                                return newSystemError("Error Getting rLimit ", err)
                        }</span>
                        <span class="cov0" title="0">jww.FEEDBACK.Println("rLimit after change:", rLimit)

                        return nil</span>
                },
        }

        <span class="cov8" title="1">return &amp;limitCmd{baseCmd: newBaseCmd(ccmd)}</span>
}

const newRlimit = 10240

func tweakLimit() <span class="cov0" title="0">{
        var rLimit syscall.Rlimit
        err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &amp;rLimit)
        if err != nil </span><span class="cov0" title="0">{
                jww.WARN.Println("Unable to get rlimit:", err)
                return
        }</span>
        <span class="cov0" title="0">if rLimit.Cur &lt; newRlimit </span><span class="cov0" title="0">{
                rLimit.Cur = newRlimit
                err = syscall.Setrlimit(syscall.RLIMIT_NOFILE, &amp;rLimit)
                if err != nil </span><span class="cov0" title="0">{
                        // This may not succeed, see https://github.com/golang/go/issues/30401
                        jww.INFO.Println("Unable to increase number of open files limit:", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "encoding/csv"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/gohugoio/hugo/hugolib"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*listCmd)(nil)

type listCmd struct {
        hugoBuilderCommon
        *baseCmd
}

func (lc *listCmd) buildSites(config map[string]interface{}) (*hugolib.HugoSites, error) <span class="cov0" title="0">{
        cfgInit := func(c *commandeer) error </span><span class="cov0" title="0">{
                for key, value := range config </span><span class="cov0" title="0">{
                        c.Set(key, value)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">c, err := initializeConfig(true, false, &amp;lc.hugoBuilderCommon, lc, cfgInit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sites, err := hugolib.NewHugoSites(*c.DepsCfg)

        if err != nil </span><span class="cov0" title="0">{
                return nil, newSystemError("Error creating sites", err)
        }</span>

        <span class="cov0" title="0">if err := sites.Build(hugolib.BuildCfg{SkipRender: true}); err != nil </span><span class="cov0" title="0">{
                return nil, newSystemError("Error Processing Source Content", err)
        }</span>

        <span class="cov0" title="0">return sites, nil</span>
}

func newListCmd() *listCmd <span class="cov8" title="1">{
        cc := &amp;listCmd{}

        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "list",
                Short: "Listing out various types of content",
                Long: `Listing out various types of content.

List requires a subcommand, e.g. ` + "`hugo list drafts`.",
                RunE: nil,
        })

        cc.cmd.AddCommand(
                &amp;cobra.Command{
                        Use:   "drafts",
                        Short: "List all drafts",
                        Long:  `List all of the drafts in your content directory.`,
                        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                                sites, err := cc.buildSites(map[string]interface{}{"buildDrafts": true})

                                if err != nil </span><span class="cov0" title="0">{
                                        return newSystemError("Error building sites", err)
                                }</span>

                                <span class="cov0" title="0">for _, p := range sites.Pages() </span><span class="cov0" title="0">{
                                        if p.Draft() </span><span class="cov0" title="0">{
                                                jww.FEEDBACK.Println(strings.TrimPrefix(p.File().Filename(), sites.WorkingDir+string(os.PathSeparator)))
                                        }</span>
                                }

                                <span class="cov0" title="0">return nil</span>
                        },
                },
                &amp;cobra.Command{
                        Use:   "future",
                        Short: "List all posts dated in the future",
                        Long:  `List all of the posts in your content directory which will be posted in the future.`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                sites, err := cc.buildSites(map[string]interface{}{"buildFuture": true})

                                if err != nil </span><span class="cov0" title="0">{
                                        return newSystemError("Error building sites", err)
                                }</span>

                                <span class="cov0" title="0">writer := csv.NewWriter(os.Stdout)
                                defer writer.Flush()

                                for _, p := range sites.Pages() </span><span class="cov0" title="0">{
                                        if resource.IsFuture(p) </span><span class="cov0" title="0">{
                                                err := writer.Write([]string{
                                                        strings.TrimPrefix(p.File().Filename(), sites.WorkingDir+string(os.PathSeparator)),
                                                        p.PublishDate().Format(time.RFC3339),
                                                })
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return newSystemError("Error writing future posts to stdout", err)
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">return nil</span>
                        },
                },
                &amp;cobra.Command{
                        Use:   "expired",
                        Short: "List all posts already expired",
                        Long:  `List all of the posts in your content directory which has already expired.`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                sites, err := cc.buildSites(map[string]interface{}{"buildExpired": true})

                                if err != nil </span><span class="cov0" title="0">{
                                        return newSystemError("Error building sites", err)
                                }</span>

                                <span class="cov0" title="0">writer := csv.NewWriter(os.Stdout)
                                defer writer.Flush()

                                for _, p := range sites.Pages() </span><span class="cov0" title="0">{
                                        if resource.IsExpired(p) </span><span class="cov0" title="0">{
                                                err := writer.Write([]string{
                                                        strings.TrimPrefix(p.File().Filename(), sites.WorkingDir+string(os.PathSeparator)),
                                                        p.ExpiryDate().Format(time.RFC3339),
                                                })
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return newSystemError("Error writing expired posts to stdout", err)
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">return nil</span>
                        },
                },
                &amp;cobra.Command{
                        Use:   "all",
                        Short: "List all posts",
                        Long:  `List all of the posts in your content directory, include drafts, future and expired pages.`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                sites, err := cc.buildSites(map[string]interface{}{
                                        "buildExpired": true,
                                        "buildDrafts":  true,
                                        "buildFuture":  true,
                                })

                                if err != nil </span><span class="cov0" title="0">{
                                        return newSystemError("Error building sites", err)
                                }</span>

                                <span class="cov0" title="0">writer := csv.NewWriter(os.Stdout)
                                defer writer.Flush()

                                writer.Write([]string{
                                        "path",
                                        "slug",
                                        "title",
                                        "date",
                                        "expiryDate",
                                        "publishDate",
                                        "draft",
                                        "permalink",
                                })
                                for _, p := range sites.Pages() </span><span class="cov0" title="0">{
                                        if !p.IsPage() </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">err := writer.Write([]string{
                                                strings.TrimPrefix(p.File().Filename(), sites.WorkingDir+string(os.PathSeparator)),
                                                p.Slug(),
                                                p.Title(),
                                                p.Date().Format(time.RFC3339),
                                                p.ExpiryDate().Format(time.RFC3339),
                                                p.PublishDate().Format(time.RFC3339),
                                                strconv.FormatBool(p.Draft()),
                                                p.Permalink(),
                                        })
                                        if err != nil </span><span class="cov0" title="0">{
                                                return newSystemError("Error writing posts to stdout", err)
                                        }</span>
                                }

                                <span class="cov0" title="0">return nil</span>
                        },
                },
        )

        <span class="cov8" title="1">cc.cmd.PersistentFlags().StringVarP(&amp;cc.source, "source", "s", "", "filesystem path to read files relative from")
        cc.cmd.PersistentFlags().SetAnnotation("source", cobra.BashCompSubdirsInDir, []string{})

        return cc</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "os"

        "github.com/gohugoio/hugo/modules"
        "github.com/spf13/cobra"
)

var _ cmder = (*modCmd)(nil)

type modCmd struct {
        *baseBuilderCmd
}

func (b *commandsBuilder) newModCmd() *modCmd <span class="cov8" title="1">{
        c := &amp;modCmd{}

        const commonUsage = `
Note that Hugo will always start out by resolving the components defined in the site
configuration, provided by a _vendor directory (if no --ignoreVendor flag provided),
Go Modules, or a folder inside the themes directory, in that order.

See https://gohugo.io/hugo-modules/ for more information.

`

        cmd := &amp;cobra.Command{
                Use:   "mod",
                Short: "Various Hugo Modules helpers.",
                Long: `Various helpers to help manage the modules in your project's dependency graph.

Most operations here requires a Go version installed on your system (&gt;= Go 1.12) and the relevant VCS client (typically Git).
This is not needed if you only operate on modules inside /themes or if you have vendored them via "hugo mod vendor".

` + commonUsage,

                RunE: nil,
        }

        cmd.AddCommand(
                &amp;cobra.Command{
                        Use:                "get",
                        DisableFlagParsing: true,
                        Short:              "Resolves dependencies in your current Hugo Project.",
                        Long: `
Resolves dependencies in your current Hugo Project.

Some examples:

Install the latest version possible for a given module:

    hugo mod get github.com/gohugoio/testshortcodes
    
Install a specific version:

    hugo mod get github.com/gohugoio/testshortcodes@v0.3.0

Install the latest versions of all module dependencies:

    hugo mod get -u

Run "go help get" for more information. All flags available for "go get" is also relevant here.
` + commonUsage,
                        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                                return c.withModsClient(false, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                        // We currently just pass on the flags we get to Go and
                                        // need to do the flag handling manually.
                                        if len(args) == 1 &amp;&amp; args[0] == "-h" </span><span class="cov0" title="0">{
                                                return cmd.Help()
                                        }</span>
                                        <span class="cov0" title="0">return c.Get(args...)</span>
                                })
                        },
                },
                &amp;cobra.Command{
                        Use:   "graph",
                        Short: "Print a module dependency graph.",
                        Long: `Print a module dependency graph with information about module status (disabled, vendored).
Note that for vendored modules, that is the version listed and not the one from go.mod.
`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                return c.withModsClient(true, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                        return c.Graph(os.Stdout)
                                }</span>)
                        },
                },
                &amp;cobra.Command{
                        Use:   "init",
                        Short: "Initialize this project as a Hugo Module.",
                        Long: `Initialize this project as a Hugo Module.
It will try to guess the module path, but you may help by passing it as an argument, e.g:

    hugo mod init github.com/gohugoio/testshortcodes

Note that Hugo Modules supports multi-module projects, so you can initialize a Hugo Module
inside a subfolder on GitHub, as one example.
`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                var path string
                                if len(args) &gt;= 1 </span><span class="cov0" title="0">{
                                        path = args[0]
                                }</span>
                                <span class="cov0" title="0">return c.withModsClient(false, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                        return c.Init(path)
                                }</span>)
                        },
                },
                &amp;cobra.Command{
                        Use:   "vendor",
                        Short: "Vendor all module dependencies into the _vendor directory.",
                        Long: `Vendor all module dependencies into the _vendor directory.

If a module is vendored, that is where Hugo will look for it's dependencies.
`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                return c.withModsClient(true, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                        return c.Vendor()
                                }</span>)
                        },
                },
                &amp;cobra.Command{
                        Use:   "tidy",
                        Short: "Remove unused entries in go.mod and go.sum.",
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                return c.withModsClient(true, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                        return c.Tidy()
                                }</span>)
                        },
                },
                &amp;cobra.Command{
                        Use:   "clean",
                        Short: "Delete the entire Hugo Module cache.",
                        Long: `Delete the entire Hugo Module cache.

Note that after you run this command, all of your dependencies will be re-downloaded next time you run "hugo".

Also note that if you configure a positive maxAge for the "modules" file cache, it will also be cleaned as part of "hugo --gc".
 
`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                com, err := c.initConfig(true)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">_, err = com.hugo().FileCaches.ModulesCache().Prune(true)
                                return err</span>

                        },
                },
        )

        <span class="cov8" title="1">c.baseBuilderCmd = b.newBuilderCmd(cmd)

        return c</span>

}

func (c *modCmd) withModsClient(failOnMissingConfig bool, f func(*modules.Client) error) error <span class="cov0" title="0">{
        com, err := c.initConfig(failOnMissingConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return f(com.hugo().ModulesClient)</span>
}

func (c *modCmd) initConfig(failOnNoConfig bool) (*commandeer, error) <span class="cov0" title="0">{
        com, err := initializeConfig(failOnNoConfig, false, &amp;c.hugoBuilderCommon, c, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return com, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "os"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/create"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugolib"
        "github.com/spf13/afero"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*newCmd)(nil)

type newCmd struct {
        contentEditor string
        contentType   string

        *baseBuilderCmd
}

func (b *commandsBuilder) newNewCmd() *newCmd <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "new [path]",
                Short: "Create new content for your site",
                Long: `Create a new content file and automatically set the date and title.
It will guess which kind of file to create based on the path provided.

You can also specify the kind with ` + "`-k KIND`" + `.

If archetypes are provided in your theme or site, they will be used.

Ensure you run this within the root directory of your site.`,
        }

        cc := &amp;newCmd{baseBuilderCmd: b.newBuilderCmd(cmd)}

        cmd.Flags().StringVarP(&amp;cc.contentType, "kind", "k", "", "content type to create")
        cmd.Flags().StringVar(&amp;cc.contentEditor, "editor", "", "edit new content with this editor, if provided")

        cmd.AddCommand(newNewSiteCmd().getCommand())
        cmd.AddCommand(newNewThemeCmd().getCommand())

        cmd.RunE = cc.newContent

        return cc
}</span>

func (n *newCmd) newContent(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        cfgInit := func(c *commandeer) error </span><span class="cov0" title="0">{
                if cmd.Flags().Changed("editor") </span><span class="cov0" title="0">{
                        c.Set("newContentEditor", n.contentEditor)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">c, err := initializeConfig(true, false, &amp;n.hugoBuilderCommon, n, cfgInit)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return newUserError("path needs to be provided")
        }</span>

        <span class="cov0" title="0">createPath := args[0]

        var kind string

        createPath, kind = newContentPathSection(c.hugo(), createPath)

        if n.contentType != "" </span><span class="cov0" title="0">{
                kind = n.contentType
        }</span>

        <span class="cov0" title="0">return create.NewContent(c.hugo(), kind, createPath)</span>
}

func mkdir(x ...string) <span class="cov0" title="0">{
        p := filepath.Join(x...)

        err := os.MkdirAll(p, 0777) // before umask
        if err != nil </span><span class="cov0" title="0">{
                jww.FATAL.Fatalln(err)
        }</span>
}

func touchFile(fs afero.Fs, x ...string) <span class="cov0" title="0">{
        inpath := filepath.Join(x...)
        mkdir(filepath.Dir(inpath))
        err := helpers.WriteToDisk(inpath, bytes.NewReader([]byte{}), fs)
        if err != nil </span><span class="cov0" title="0">{
                jww.FATAL.Fatalln(err)
        }</span>
}

func newContentPathSection(h *hugolib.HugoSites, path string) (string, string) <span class="cov0" title="0">{
        // Forward slashes is used in all examples. Convert if needed.
        // Issue #1133
        createpath := filepath.FromSlash(path)

        if h != nil </span><span class="cov0" title="0">{
                for _, dir := range h.BaseFs.Content.Dirs </span><span class="cov0" title="0">{
                        createpath = strings.TrimPrefix(createpath, dir.Meta().Filename())
                }</span>
        }

        <span class="cov0" title="0">var section string
        // assume the first directory is the section (kind)
        if strings.Contains(createpath[1:], helpers.FilePathSeparator) </span><span class="cov0" title="0">{
                parts := strings.Split(strings.TrimPrefix(createpath, helpers.FilePathSeparator), helpers.FilePathSeparator)
                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                        section = parts[0]
                }</span>

        }

        <span class="cov0" title="0">return createpath, section</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "errors"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/parser/metadecoders"

        _errors "github.com/pkg/errors"

        "github.com/gohugoio/hugo/create"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/parser"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
        "github.com/spf13/viper"
)

var _ cmder = (*newSiteCmd)(nil)

type newSiteCmd struct {
        configFormat string

        *baseCmd
}

func newNewSiteCmd() *newSiteCmd <span class="cov8" title="1">{
        ccmd := &amp;newSiteCmd{}

        cmd := &amp;cobra.Command{
                Use:   "site [path]",
                Short: "Create a new site (skeleton)",
                Long: `Create a new site in the provided directory.
The new site will have the correct structure, but no content or theme yet.
Use ` + "`hugo new [contentPath]`" + ` to create new content.`,
                RunE: ccmd.newSite,
        }

        cmd.Flags().StringVarP(&amp;ccmd.configFormat, "format", "f", "toml", "config &amp; frontmatter format")
        cmd.Flags().Bool("force", false, "init inside non-empty directory")

        ccmd.baseCmd = newBaseCmd(cmd)

        return ccmd

}</span>

func (n *newSiteCmd) doNewSite(fs *hugofs.Fs, basepath string, force bool) error <span class="cov0" title="0">{
        archeTypePath := filepath.Join(basepath, "archetypes")
        dirs := []string{
                filepath.Join(basepath, "layouts"),
                filepath.Join(basepath, "content"),
                archeTypePath,
                filepath.Join(basepath, "static"),
                filepath.Join(basepath, "data"),
                filepath.Join(basepath, "themes"),
        }

        if exists, _ := helpers.Exists(basepath, fs.Source); exists </span><span class="cov0" title="0">{
                if isDir, _ := helpers.IsDir(basepath, fs.Source); !isDir </span><span class="cov0" title="0">{
                        return errors.New(basepath + " already exists but not a directory")
                }</span>

                <span class="cov0" title="0">isEmpty, _ := helpers.IsEmpty(basepath, fs.Source)

                switch </span>{
                case !isEmpty &amp;&amp; !force:<span class="cov0" title="0">
                        return errors.New(basepath + " already exists and is not empty")</span>

                case !isEmpty &amp;&amp; force:<span class="cov0" title="0">
                        all := append(dirs, filepath.Join(basepath, "config."+n.configFormat))
                        for _, path := range all </span><span class="cov0" title="0">{
                                if exists, _ := helpers.Exists(path, fs.Source); exists </span><span class="cov0" title="0">{
                                        return errors.New(path + " already exists")
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">for _, dir := range dirs </span><span class="cov0" title="0">{
                if err := fs.Source.MkdirAll(dir, 0777); err != nil </span><span class="cov0" title="0">{
                        return _errors.Wrap(err, "Failed to create dir")
                }</span>
        }

        <span class="cov0" title="0">createConfig(fs, basepath, n.configFormat)

        // Create a default archetype file.
        helpers.SafeWriteToDisk(filepath.Join(archeTypePath, "default.md"),
                strings.NewReader(create.ArchetypeTemplateTemplate), fs.Source)

        jww.FEEDBACK.Printf("Congratulations! Your new Hugo site is created in %s.\n\n", basepath)
        jww.FEEDBACK.Println(nextStepsText())

        return nil</span>
}

// newSite creates a new Hugo site and initializes a structured Hugo directory.
func (n *newSiteCmd) newSite(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return newUserError("path needs to be provided")
        }</span>

        <span class="cov0" title="0">createpath, err := filepath.Abs(filepath.Clean(args[0]))
        if err != nil </span><span class="cov0" title="0">{
                return newUserError(err)
        }</span>

        <span class="cov0" title="0">forceNew, _ := cmd.Flags().GetBool("force")

        return n.doNewSite(hugofs.NewDefault(viper.New()), createpath, forceNew)</span>
}

func createConfig(fs *hugofs.Fs, inpath string, kind string) (err error) <span class="cov0" title="0">{
        in := map[string]string{
                "baseURL":      "http://example.org/",
                "title":        "My New Hugo Site",
                "languageCode": "en-us",
        }

        var buf bytes.Buffer
        err = parser.InterfaceToConfig(in, metadecoders.FormatFromString(kind), &amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return helpers.WriteToDisk(filepath.Join(inpath, "config."+kind), &amp;buf, fs.Source)</span>
}

func nextStepsText() string <span class="cov0" title="0">{
        var nextStepsText bytes.Buffer

        nextStepsText.WriteString(`Just a few more steps and you're ready to go:

1. Download a theme into the same-named folder.
   Choose a theme from https://themes.gohugo.io/ or
   create your own with the "hugo new theme &lt;THEMENAME&gt;" command.
2. Perhaps you want to add some content. You can add single files
   with "hugo new `)

        nextStepsText.WriteString(filepath.Join("&lt;SECTIONNAME&gt;", "&lt;FILENAME&gt;.&lt;FORMAT&gt;"))

        nextStepsText.WriteString(`".
3. Start the built-in live server via "hugo server".

Visit https://gohugo.io/ for quickstart guide and full documentation.`)

        return nextStepsText.String()
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "errors"
        "path/filepath"
        "strings"
        "time"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*newThemeCmd)(nil)

type newThemeCmd struct {
        *baseCmd
        hugoBuilderCommon
}

func newNewThemeCmd() *newThemeCmd <span class="cov8" title="1">{
        ccmd := &amp;newThemeCmd{baseCmd: newBaseCmd(nil)}

        cmd := &amp;cobra.Command{
                Use:   "theme [name]",
                Short: "Create a new theme",
                Long: `Create a new theme (skeleton) called [name] in the current directory.
New theme is a skeleton. Please add content to the touched files. Add your
name to the copyright line in the license and adjust the theme.toml file
as you see fit.`,
                RunE: ccmd.newTheme,
        }

        ccmd.cmd = cmd

        return ccmd
}</span>

// newTheme creates a new Hugo theme template
func (n *newThemeCmd) newTheme(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        c, err := initializeConfig(false, false, &amp;n.hugoBuilderCommon, n, nil)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return newUserError("theme name needs to be provided")
        }</span>

        <span class="cov0" title="0">createpath := c.hugo().PathSpec.AbsPathify(filepath.Join(c.Cfg.GetString("themesDir"), args[0]))
        jww.FEEDBACK.Println("Creating theme at", createpath)

        cfg := c.DepsCfg

        if x, _ := helpers.Exists(createpath, cfg.Fs.Source); x </span><span class="cov0" title="0">{
                return errors.New(createpath + " already exists")
        }</span>

        <span class="cov0" title="0">mkdir(createpath, "layouts", "_default")
        mkdir(createpath, "layouts", "partials")

        touchFile(cfg.Fs.Source, createpath, "layouts", "index.html")
        touchFile(cfg.Fs.Source, createpath, "layouts", "404.html")
        touchFile(cfg.Fs.Source, createpath, "layouts", "_default", "list.html")
        touchFile(cfg.Fs.Source, createpath, "layouts", "_default", "single.html")

        baseofDefault := []byte(`&lt;!DOCTYPE html&gt;
&lt;html&gt;
    {{- partial "head.html" . -}}
    &lt;body&gt;
        {{- partial "header.html" . -}}
        &lt;div id="content"&gt;
        {{- block "main" . }}{{- end }}
        &lt;/div&gt;
        {{- partial "footer.html" . -}}
    &lt;/body&gt;
&lt;/html&gt;
`)
        err = helpers.WriteToDisk(filepath.Join(createpath, "layouts", "_default", "baseof.html"), bytes.NewReader(baseofDefault), cfg.Fs.Source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">touchFile(cfg.Fs.Source, createpath, "layouts", "partials", "head.html")
        touchFile(cfg.Fs.Source, createpath, "layouts", "partials", "header.html")
        touchFile(cfg.Fs.Source, createpath, "layouts", "partials", "footer.html")

        mkdir(createpath, "archetypes")

        archDefault := []byte("+++\n+++\n")

        err = helpers.WriteToDisk(filepath.Join(createpath, "archetypes", "default.md"), bytes.NewReader(archDefault), cfg.Fs.Source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">mkdir(createpath, "static", "js")
        mkdir(createpath, "static", "css")

        by := []byte(`The MIT License (MIT)

Copyright (c) ` + time.Now().Format("2006") + ` YOUR_NAME_HERE

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
`)

        err = helpers.WriteToDisk(filepath.Join(createpath, "LICENSE"), bytes.NewReader(by), cfg.Fs.Source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">n.createThemeMD(cfg.Fs, createpath)

        return nil</span>
}

func (n *newThemeCmd) createThemeMD(fs *hugofs.Fs, inpath string) (err error) <span class="cov0" title="0">{

        by := []byte(`# theme.toml template for a Hugo theme
# See https://github.com/gohugoio/hugoThemes#themetoml for an example

name = "` + strings.Title(helpers.MakeTitle(filepath.Base(inpath))) + `"
license = "MIT"
licenselink = "https://github.com/yourname/yourtheme/blob/master/LICENSE"
description = ""
homepage = "http://example.com/"
tags = []
features = []
min_version = "0.41"

[author]
  name = ""
  homepage = ""

# If porting an existing theme
[original]
  name = ""
  homepage = ""
  repo = ""
`)

        err = helpers.WriteToDisk(filepath.Join(inpath, "theme.toml"), bytes.NewReader(by), fs.Source)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// +build !release

// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

func createReleaser() cmder <span class="cov8" title="1">{
        return &amp;nilCommand{}
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "fmt"
        "net"
        "net/http"
        "net/url"
        "os"
        "os/signal"
        "path/filepath"
        "regexp"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/livereload"
        "github.com/gohugoio/hugo/tpl"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/afero"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

type serverCmd struct {
        // Can be used to stop the server. Useful in tests
        stop &lt;-chan bool

        disableLiveReload bool
        navigateToChanged bool
        renderToDisk      bool
        serverAppend      bool
        serverInterface   string
        serverPort        int
        liveReloadPort    int
        serverWatch       bool
        noHTTPCache       bool

        disableFastRender   bool
        disableBrowserError bool

        *baseBuilderCmd
}

func (b *commandsBuilder) newServerCmd() *serverCmd <span class="cov8" title="1">{
        return b.newServerCmdSignaled(nil)
}</span>

func (b *commandsBuilder) newServerCmdSignaled(stop &lt;-chan bool) *serverCmd <span class="cov8" title="1">{
        cc := &amp;serverCmd{stop: stop}

        cc.baseBuilderCmd = b.newBuilderCmd(&amp;cobra.Command{
                Use:     "server",
                Aliases: []string{"serve"},
                Short:   "A high performance webserver",
                Long: `Hugo provides its own webserver which builds and serves the site.
While hugo server is high performance, it is a webserver with limited options.
Many run it in production, but the standard behavior is for people to use it
in development and use a more full featured server such as Nginx or Caddy.

'hugo server' will avoid writing the rendered and served content to disk,
preferring to store it in memory.

By default hugo will also watch your files for any changes you make and
automatically rebuild the site. It will then live reload any open browser pages
and push the latest content to them. As most Hugo sites are built in a fraction
of a second, you will be able to save and see your changes nearly instantly.`,
                RunE: cc.server,
        })

        cc.cmd.Flags().IntVarP(&amp;cc.serverPort, "port", "p", 1313, "port on which the server will listen")
        cc.cmd.Flags().IntVar(&amp;cc.liveReloadPort, "liveReloadPort", -1, "port for live reloading (i.e. 443 in HTTPS proxy situations)")
        cc.cmd.Flags().StringVarP(&amp;cc.serverInterface, "bind", "", "127.0.0.1", "interface to which the server will bind")
        cc.cmd.Flags().BoolVarP(&amp;cc.serverWatch, "watch", "w", true, "watch filesystem for changes and recreate as needed")
        cc.cmd.Flags().BoolVar(&amp;cc.noHTTPCache, "noHTTPCache", false, "prevent HTTP caching")
        cc.cmd.Flags().BoolVarP(&amp;cc.serverAppend, "appendPort", "", true, "append port to baseURL")
        cc.cmd.Flags().BoolVar(&amp;cc.disableLiveReload, "disableLiveReload", false, "watch without enabling live browser reload on rebuild")
        cc.cmd.Flags().BoolVar(&amp;cc.navigateToChanged, "navigateToChanged", false, "navigate to changed content file on live browser reload")
        cc.cmd.Flags().BoolVar(&amp;cc.renderToDisk, "renderToDisk", false, "render to Destination path (default is render to memory &amp; serve from there)")
        cc.cmd.Flags().BoolVar(&amp;cc.disableFastRender, "disableFastRender", false, "enables full re-renders on changes")
        cc.cmd.Flags().BoolVar(&amp;cc.disableBrowserError, "disableBrowserError", false, "do not show build errors in the browser")

        cc.cmd.Flags().String("memstats", "", "log memory usage to this file")
        cc.cmd.Flags().String("meminterval", "100ms", "interval to poll memory usage (requires --memstats), valid time units are \"ns\", \"us\" (or \"s\"), \"ms\", \"s\", \"m\", \"h\".")

        return cc
}</span>

type filesOnlyFs struct {
        fs http.FileSystem
}

type noDirFile struct {
        http.File
}

func (fs filesOnlyFs) Open(name string) (http.File, error) <span class="cov0" title="0">{
        f, err := fs.fs.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return noDirFile{f}, nil</span>
}

func (f noDirFile) Readdir(count int) ([]os.FileInfo, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

var serverPorts []int

func (sc *serverCmd) server(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // If a Destination is provided via flag write to disk
        destination, _ := cmd.Flags().GetString("destination")
        if destination != "" </span><span class="cov0" title="0">{
                sc.renderToDisk = true
        }</span>

        <span class="cov0" title="0">var serverCfgInit sync.Once

        cfgInit := func(c *commandeer) error </span><span class="cov0" title="0">{
                c.Set("renderToMemory", !sc.renderToDisk)
                if cmd.Flags().Changed("navigateToChanged") </span><span class="cov0" title="0">{
                        c.Set("navigateToChanged", sc.navigateToChanged)
                }</span>
                <span class="cov0" title="0">if cmd.Flags().Changed("disableLiveReload") </span><span class="cov0" title="0">{
                        c.Set("disableLiveReload", sc.disableLiveReload)
                }</span>
                <span class="cov0" title="0">if cmd.Flags().Changed("disableFastRender") </span><span class="cov0" title="0">{
                        c.Set("disableFastRender", sc.disableFastRender)
                }</span>
                <span class="cov0" title="0">if cmd.Flags().Changed("disableBrowserError") </span><span class="cov0" title="0">{
                        c.Set("disableBrowserError", sc.disableBrowserError)
                }</span>
                <span class="cov0" title="0">if sc.serverWatch </span><span class="cov0" title="0">{
                        c.Set("watch", true)
                }</span>

                // TODO(bep) yes, we should fix.
                <span class="cov0" title="0">if !c.languagesConfigured </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">var err error

                // We can only do this once.
                serverCfgInit.Do(func() </span><span class="cov0" title="0">{
                        serverPorts = make([]int, 1)

                        if c.languages.IsMultihost() </span><span class="cov0" title="0">{
                                if !sc.serverAppend </span><span class="cov0" title="0">{
                                        err = newSystemError("--appendPort=false not supported when in multihost mode")
                                }</span>
                                <span class="cov0" title="0">serverPorts = make([]int, len(c.languages))</span>
                        }

                        <span class="cov0" title="0">currentServerPort := sc.serverPort

                        for i := 0; i &lt; len(serverPorts); i++ </span><span class="cov0" title="0">{
                                l, err := net.Listen("tcp", net.JoinHostPort(sc.serverInterface, strconv.Itoa(currentServerPort)))
                                if err == nil </span><span class="cov0" title="0">{
                                        l.Close()
                                        serverPorts[i] = currentServerPort
                                }</span> else<span class="cov0" title="0"> {
                                        if i == 0 &amp;&amp; sc.cmd.Flags().Changed("port") </span><span class="cov0" title="0">{
                                                // port set explicitly by user -- he/she probably meant it!
                                                err = newSystemErrorF("Server startup failed: %s", err)
                                        }</span>
                                        <span class="cov0" title="0">c.logger.FEEDBACK.Println("port", sc.serverPort, "already in use, attempting to use an available port")
                                        sp, err := helpers.FindAvailablePort()
                                        if err != nil </span><span class="cov0" title="0">{
                                                err = newSystemError("Unable to find alternative port to use:", err)
                                        }</span>
                                        <span class="cov0" title="0">serverPorts[i] = sp.Port</span>
                                }

                                <span class="cov0" title="0">currentServerPort = serverPorts[i] + 1</span>
                        }
                })

                <span class="cov0" title="0">c.serverPorts = serverPorts

                c.Set("port", sc.serverPort)
                if sc.liveReloadPort != -1 </span><span class="cov0" title="0">{
                        c.Set("liveReloadPort", sc.liveReloadPort)
                }</span> else<span class="cov0" title="0"> {
                        c.Set("liveReloadPort", serverPorts[0])
                }</span>

                <span class="cov0" title="0">isMultiHost := c.languages.IsMultihost()
                for i, language := range c.languages </span><span class="cov0" title="0">{
                        var serverPort int
                        if isMultiHost </span><span class="cov0" title="0">{
                                serverPort = serverPorts[i]
                        }</span> else<span class="cov0" title="0"> {
                                serverPort = serverPorts[0]
                        }</span>

                        <span class="cov0" title="0">baseURL, err := sc.fixURL(language, sc.baseURL, serverPort)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">if isMultiHost </span><span class="cov0" title="0">{
                                language.Set("baseURL", baseURL)
                        }</span>
                        <span class="cov0" title="0">if i == 0 </span><span class="cov0" title="0">{
                                c.Set("baseURL", baseURL)
                        }</span>
                }

                <span class="cov0" title="0">return err</span>

        }

        <span class="cov0" title="0">if err := memStats(); err != nil </span><span class="cov0" title="0">{
                jww.WARN.Println("memstats error:", err)
        }</span>

        <span class="cov0" title="0">c, err := initializeConfig(true, true, &amp;sc.hugoBuilderCommon, sc, cfgInit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.serverBuild(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, s := range c.hugo().Sites </span><span class="cov0" title="0">{
                s.RegisterMediaTypes()
        }</span>

        // Watch runs its own server as part of the routine
        <span class="cov0" title="0">if sc.serverWatch </span><span class="cov0" title="0">{

                watchDirs, err := c.getDirList()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">watchGroups := helpers.ExtractAndGroupRootPaths(watchDirs)

                for _, group := range watchGroups </span><span class="cov0" title="0">{
                        jww.FEEDBACK.Printf("Watching for changes in %s\n", group)
                }</span>
                <span class="cov0" title="0">watcher, err := c.newWatcher(watchDirs...)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">defer watcher.Close()</span>

        }

        <span class="cov0" title="0">return c.serve(sc)</span>

}

func getRootWatchDirsStr(baseDir string, watchDirs []string) string <span class="cov0" title="0">{
        relWatchDirs := make([]string, len(watchDirs))
        for i, dir := range watchDirs </span><span class="cov0" title="0">{
                relWatchDirs[i], _ = helpers.GetRelativePath(dir, baseDir)
        }</span>

        <span class="cov0" title="0">return strings.Join(helpers.UniqueStringsSorted(helpers.ExtractRootPaths(relWatchDirs)), ",")</span>
}

type fileServer struct {
        baseURLs      []string
        roots         []string
        errorTemplate tpl.Template
        c             *commandeer
        s             *serverCmd
}

func (f *fileServer) createEndpoint(i int) (*http.ServeMux, string, string, error) <span class="cov0" title="0">{
        baseURL := f.baseURLs[i]
        root := f.roots[i]
        port := f.c.serverPorts[i]

        publishDir := f.c.Cfg.GetString("publishDir")

        if root != "" </span><span class="cov0" title="0">{
                publishDir = filepath.Join(publishDir, root)
        }</span>

        <span class="cov0" title="0">absPublishDir := f.c.hugo().PathSpec.AbsPathify(publishDir)

        jww.FEEDBACK.Printf("Environment: %q", f.c.hugo().Deps.Site.Hugo().Environment)

        if i == 0 </span><span class="cov0" title="0">{
                if f.s.renderToDisk </span><span class="cov0" title="0">{
                        jww.FEEDBACK.Println("Serving pages from " + absPublishDir)
                }</span> else<span class="cov0" title="0"> {
                        jww.FEEDBACK.Println("Serving pages from memory")
                }</span>
        }

        <span class="cov0" title="0">httpFs := afero.NewHttpFs(f.c.destinationFs)
        fs := filesOnlyFs{httpFs.Dir(absPublishDir)}

        if i == 0 &amp;&amp; f.c.fastRenderMode </span><span class="cov0" title="0">{
                jww.FEEDBACK.Println("Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender")
        }</span>

        // We're only interested in the path
        <span class="cov0" title="0">u, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", "", errors.Wrap(err, "Invalid baseURL")
        }</span>

        <span class="cov0" title="0">decorate := func(h http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        if f.c.showErrorInBrowser </span><span class="cov0" title="0">{
                                // First check the error state
                                err := f.c.getErrorWithContext()
                                if err != nil </span><span class="cov0" title="0">{
                                        w.WriteHeader(500)
                                        var b bytes.Buffer
                                        err := f.errorTemplate.Execute(&amp;b, err)
                                        if err != nil </span><span class="cov0" title="0">{
                                                f.c.logger.ERROR.Println(err)
                                        }</span>
                                        <span class="cov0" title="0">port = 1313
                                        if !f.c.paused </span><span class="cov0" title="0">{
                                                port = f.c.Cfg.GetInt("liveReloadPort")
                                        }</span>
                                        <span class="cov0" title="0">fmt.Fprint(w, injectLiveReloadScript(&amp;b, port))

                                        return</span>
                                }
                        }

                        <span class="cov0" title="0">if f.s.noHTTPCache </span><span class="cov0" title="0">{
                                w.Header().Set("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0")
                                w.Header().Set("Pragma", "no-cache")
                        }</span>

                        <span class="cov0" title="0">if f.c.fastRenderMode &amp;&amp; f.c.buildErr == nil </span><span class="cov0" title="0">{
                                p := r.RequestURI
                                if strings.HasSuffix(p, "/") || strings.HasSuffix(p, "html") || strings.HasSuffix(p, "htm") </span><span class="cov0" title="0">{
                                        if !f.c.visitedURLs.Contains(p) </span><span class="cov0" title="0">{
                                                // If not already on stack, re-render that single page.
                                                if err := f.c.partialReRender(p); err != nil </span><span class="cov0" title="0">{
                                                        f.c.handleBuildErr(err, fmt.Sprintf("Failed to render %q", p))
                                                        if f.c.showErrorInBrowser </span><span class="cov0" title="0">{
                                                                http.Redirect(w, r, p, http.StatusMovedPermanently)
                                                                return
                                                        }</span>
                                                }
                                        }

                                        <span class="cov0" title="0">f.c.visitedURLs.Add(p)</span>

                                }
                        }
                        <span class="cov0" title="0">h.ServeHTTP(w, r)</span>
                })
        }

        <span class="cov0" title="0">fileserver := decorate(http.FileServer(fs))
        mu := http.NewServeMux()

        if u.Path == "" || u.Path == "/" </span><span class="cov0" title="0">{
                mu.Handle("/", fileserver)
        }</span> else<span class="cov0" title="0"> {
                mu.Handle(u.Path, http.StripPrefix(u.Path, fileserver))
        }</span>

        <span class="cov0" title="0">endpoint := net.JoinHostPort(f.s.serverInterface, strconv.Itoa(port))

        return mu, u.String(), endpoint, nil</span>
}

var logErrorRe = regexp.MustCompile(`(?s)ERROR \d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2} `)

func removeErrorPrefixFromLog(content string) string <span class="cov0" title="0">{
        return logErrorRe.ReplaceAllLiteralString(content, "")
}</span>
func (c *commandeer) serve(s *serverCmd) error <span class="cov0" title="0">{

        isMultiHost := c.hugo().IsMultihost()

        var (
                baseURLs []string
                roots    []string
        )

        if isMultiHost </span><span class="cov0" title="0">{
                for _, s := range c.hugo().Sites </span><span class="cov0" title="0">{
                        baseURLs = append(baseURLs, s.BaseURL.String())
                        roots = append(roots, s.Language().Lang)
                }</span>
        } else<span class="cov0" title="0"> {
                s := c.hugo().Sites[0]
                baseURLs = []string{s.BaseURL.String()}
                roots = []string{""}
        }</span>

        <span class="cov0" title="0">templ, err := c.hugo().TextTmpl.Parse("__default_server_error", buildErrorTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">srv := &amp;fileServer{
                baseURLs:      baseURLs,
                roots:         roots,
                c:             c,
                s:             s,
                errorTemplate: templ,
        }

        doLiveReload := !c.Cfg.GetBool("disableLiveReload")

        if doLiveReload </span><span class="cov0" title="0">{
                livereload.Initialize()
        }</span>

        <span class="cov0" title="0">var sigs = make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

        for i := range baseURLs </span><span class="cov0" title="0">{
                mu, serverURL, endpoint, err := srv.createEndpoint(i)

                if doLiveReload </span><span class="cov0" title="0">{
                        mu.HandleFunc("/livereload.js", livereload.ServeJS)
                        mu.HandleFunc("/livereload", livereload.Handler)
                }</span>
                <span class="cov0" title="0">jww.FEEDBACK.Printf("Web Server is available at %s (bind address %s)\n", serverURL, s.serverInterface)
                go func() </span><span class="cov0" title="0">{
                        err = http.ListenAndServe(endpoint, mu)
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.ERROR.Printf("Error: %s\n", err.Error())
                                os.Exit(1)
                        }</span>
                }()
        }

        <span class="cov0" title="0">jww.FEEDBACK.Println("Press Ctrl+C to stop")

        if s.stop != nil </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-sigs:<span class="cov0" title="0"></span>
                case &lt;-s.stop:<span class="cov0" title="0"></span>
                }
        } else<span class="cov0" title="0"> {
                &lt;-sigs
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// fixURL massages the baseURL into a form needed for serving
// all pages correctly.
func (sc *serverCmd) fixURL(cfg config.Provider, s string, port int) (string, error) <span class="cov0" title="0">{
        useLocalhost := false
        if s == "" </span><span class="cov0" title="0">{
                s = cfg.GetString("baseURL")
                useLocalhost = true
        }</span>

        <span class="cov0" title="0">if !strings.HasSuffix(s, "/") </span><span class="cov0" title="0">{
                s = s + "/"
        }</span>

        // do an initial parse of the input string
        <span class="cov0" title="0">u, err := url.Parse(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // if no Host is defined, then assume that no schema or double-slash were
        // present in the url.  Add a double-slash and make a best effort attempt.
        <span class="cov0" title="0">if u.Host == "" &amp;&amp; s != "/" </span><span class="cov0" title="0">{
                s = "//" + s

                u, err = url.Parse(s)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov0" title="0">if useLocalhost </span><span class="cov0" title="0">{
                if u.Scheme == "https" </span><span class="cov0" title="0">{
                        u.Scheme = "http"
                }</span>
                <span class="cov0" title="0">u.Host = "localhost"</span>
        }

        <span class="cov0" title="0">if sc.serverAppend </span><span class="cov0" title="0">{
                if strings.Contains(u.Host, ":") </span><span class="cov0" title="0">{
                        u.Host, _, err = net.SplitHostPort(u.Host)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", errors.Wrap(err, "Failed to split baseURL hostpost")
                        }</span>
                }
                <span class="cov0" title="0">u.Host += fmt.Sprintf(":%d", port)</span>
        }

        <span class="cov0" title="0">return u.String(), nil</span>
}

func memStats() error <span class="cov0" title="0">{
        b := newCommandsBuilder()
        sc := b.newServerCmd().getCommand()
        memstats := sc.Flags().Lookup("memstats").Value.String()
        if memstats != "" </span><span class="cov0" title="0">{
                interval, err := time.ParseDuration(sc.Flags().Lookup("meminterval").Value.String())
                if err != nil </span><span class="cov0" title="0">{
                        interval, _ = time.ParseDuration("100ms")
                }</span>

                <span class="cov0" title="0">fileMemStats, err := os.Create(memstats)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">fileMemStats.WriteString("# Time\tHeapSys\tHeapAlloc\tHeapIdle\tHeapReleased\n")

                go func() </span><span class="cov0" title="0">{
                        var stats runtime.MemStats

                        start := time.Now().UnixNano()

                        for </span><span class="cov0" title="0">{
                                runtime.ReadMemStats(&amp;stats)
                                if fileMemStats != nil </span><span class="cov0" title="0">{
                                        fileMemStats.WriteString(fmt.Sprintf("%d\t%d\t%d\t%d\t%d\n",
                                                (time.Now().UnixNano()-start)/1000000, stats.HeapSys, stats.HeapAlloc, stats.HeapIdle, stats.HeapReleased))
                                        time.Sleep(interval)
                                }</span> else<span class="cov0" title="0"> {
                                        break</span>
                                }
                        }
                }()
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "io"

        "github.com/gohugoio/hugo/transform"
        "github.com/gohugoio/hugo/transform/livereloadinject"
)

var buildErrorTemplate = `&lt;!doctype html&gt;
&lt;html class="no-js" lang=""&gt;
        &lt;head&gt;
                &lt;meta charset="utf-8"&gt;
                &lt;title&gt;Hugo Server: Error&lt;/title&gt;
                &lt;style type="text/css"&gt;
                body {
                        font-family: "Muli",avenir, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
                        font-size: 16px;
                        background-color: black;
                        color: rgba(255, 255, 255, 0.9);
                }
                main {
                        margin: auto;
                        width: 95%;
                        padding: 1rem;
                }                
                .version {
                        color: #ccc;
                        padding: 1rem 0;
                }
                .stack {
                        margin-top: 6rem;
                }
                pre {
                        white-space: pre-wrap;      
                        white-space: -moz-pre-wrap;  
                        white-space: -pre-wrap;     
                        white-space: -o-pre-wrap;    
                        word-wrap: break-word;     
                }
                .highlight {
                        overflow-x: auto;
                        padding: 0.75rem;
                        margin-bottom: 1rem;
                        background-color: #272822;
                        border: 1px solid black;
                }
                a {
                        color: #0594cb;
                        text-decoration: none;
                }
                a:hover {
                        color: #ccc;
                }
                &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
                &lt;main&gt;
                        {{ highlight .Error "apl" "noclasses=true,style=monokai" }}
                        {{ with .File }}
                        {{ $params := printf "noclasses=true,style=monokai,linenos=table,hl_lines=%d,linenostart=%d" (add .LinesPos 1) (sub .Position.LineNumber .LinesPos) }}
                        {{ $lexer := .ChromaLexer | default "go-html-template" }}
                        {{  highlight (delimit .Lines "\n") $lexer $params }}
                        {{ end }}
                        {{ with .StackTrace }}
                        {{ highlight . "apl" "noclasses=true,style=monokai" }}
                        {{ end }}
                        &lt;p class="version"&gt;{{ .Version }}&lt;/p&gt;
                        &lt;a href=""&gt;Reload Page&lt;/a&gt;
                &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;
`

func injectLiveReloadScript(src io.Reader, port int) string <span class="cov0" title="0">{
        var b bytes.Buffer
        chain := transform.Chain{livereloadinject.New(port)}
        chain.Apply(&amp;b, src)

        return b.String()
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "os"
        "path/filepath"

        "github.com/gohugoio/hugo/hugolib/filesystems"

        "github.com/fsnotify/fsnotify"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/fsync"
)

type staticSyncer struct {
        c *commandeer
}

func newStaticSyncer(c *commandeer) (*staticSyncer, error) <span class="cov0" title="0">{
        return &amp;staticSyncer{c: c}, nil
}</span>

func (s *staticSyncer) isStatic(filename string) bool <span class="cov0" title="0">{
        return s.c.hugo().BaseFs.SourceFilesystems.IsStatic(filename)
}</span>

func (s *staticSyncer) syncsStaticEvents(staticEvents []fsnotify.Event) error <span class="cov0" title="0">{
        c := s.c

        syncFn := func(sourceFs *filesystems.SourceFilesystem) (uint64, error) </span><span class="cov0" title="0">{
                publishDir := c.hugo().PathSpec.PublishDir
                // If root, remove the second '/'
                if publishDir == "//" </span><span class="cov0" title="0">{
                        publishDir = helpers.FilePathSeparator
                }</span>

                <span class="cov0" title="0">if sourceFs.PublishFolder != "" </span><span class="cov0" title="0">{
                        publishDir = filepath.Join(publishDir, sourceFs.PublishFolder)
                }</span>

                <span class="cov0" title="0">syncer := fsync.NewSyncer()
                syncer.NoTimes = c.Cfg.GetBool("noTimes")
                syncer.NoChmod = c.Cfg.GetBool("noChmod")
                syncer.ChmodFilter = chmodFilter
                syncer.SrcFs = sourceFs.Fs
                syncer.DestFs = c.Fs.Destination

                // prevent spamming the log on changes
                logger := helpers.NewDistinctFeedbackLogger()

                for _, ev := range staticEvents </span><span class="cov0" title="0">{
                        // Due to our approach of layering both directories and the content's rendered output
                        // into one we can't accurately remove a file not in one of the source directories.
                        // If a file is in the local static dir and also in the theme static dir and we remove
                        // it from one of those locations we expect it to still exist in the destination
                        //
                        // If Hugo generates a file (from the content dir) over a static file
                        // the content generated file should take precedence.
                        //
                        // Because we are now watching and handling individual events it is possible that a static
                        // event that occupies the same path as a content generated file will take precedence
                        // until a regeneration of the content takes places.
                        //
                        // Hugo assumes that these cases are very rare and will permit this bad behavior
                        // The alternative is to track every single file and which pipeline rendered it
                        // and then to handle conflict resolution on every event.

                        fromPath := ev.Name

                        relPath := sourceFs.MakePathRelative(fromPath)

                        if relPath == "" </span><span class="cov0" title="0">{
                                // Not member of this virtual host.
                                continue</span>
                        }

                        // Remove || rename is harder and will require an assumption.
                        // Hugo takes the following approach:
                        // If the static file exists in any of the static source directories after this event
                        // Hugo will re-sync it.
                        // If it does not exist in all of the static directories Hugo will remove it.
                        //
                        // This assumes that Hugo has not generated content on top of a static file and then removed
                        // the source of that static file. In this case Hugo will incorrectly remove that file
                        // from the published directory.
                        <span class="cov0" title="0">if ev.Op&amp;fsnotify.Rename == fsnotify.Rename || ev.Op&amp;fsnotify.Remove == fsnotify.Remove </span><span class="cov0" title="0">{
                                if _, err := sourceFs.Fs.Stat(relPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        // If file doesn't exist in any static dir, remove it
                                        toRemove := filepath.Join(publishDir, relPath)

                                        logger.Println("File no longer exists in static dir, removing", toRemove)
                                        _ = c.Fs.Destination.RemoveAll(toRemove)
                                }</span> else<span class="cov0" title="0"> if err == nil </span><span class="cov0" title="0">{
                                        // If file still exists, sync it
                                        logger.Println("Syncing", relPath, "to", publishDir)

                                        if err := syncer.Sync(filepath.Join(publishDir, relPath), relPath); err != nil </span><span class="cov0" title="0">{
                                                c.logger.ERROR.Println(err)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        c.logger.ERROR.Println(err)
                                }</span>

                                <span class="cov0" title="0">continue</span>
                        }

                        // For all other event operations Hugo will sync static.
                        <span class="cov0" title="0">logger.Println("Syncing", relPath, "to", publishDir)
                        if err := syncer.Sync(filepath.Join(publishDir, relPath), relPath); err != nil </span><span class="cov0" title="0">{
                                c.logger.ERROR.Println(err)
                        }</span>
                }

                <span class="cov0" title="0">return 0, nil</span>
        }

        <span class="cov0" title="0">_, err := c.doWithPublishDirs(syncFn)
        return err</span>

}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "github.com/gohugoio/hugo/common/hugo"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*versionCmd)(nil)

type versionCmd struct {
        *baseCmd
}

func newVersionCmd() *versionCmd <span class="cov8" title="1">{
        return &amp;versionCmd{
                newBaseCmd(&amp;cobra.Command{
                        Use:   "version",
                        Short: "Print the version number of Hugo",
                        Long:  `All software has versions. This is Hugo's.`,
                        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                                printHugoVersion()
                                return nil
                        }</span>,
                }),
        }
}

func printHugoVersion() <span class="cov0" title="0">{
        jww.FEEDBACK.Println(hugo.BuildVersionString())
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "fmt"
        "reflect"
)

// Append appends from to a slice to and returns the resulting slice.
// If length of from is one and the only element is a slice of same type as to,
// it will be appended.
func Append(to interface{}, from ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        tov, toIsNil := indirect(reflect.ValueOf(to))

        toIsNil = toIsNil || to == nil
        var tot reflect.Type

        if !toIsNil </span><span class="cov0" title="0">{
                if tov.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected a slice, got %T", to)
                }</span>

                <span class="cov0" title="0">tot = tov.Type().Elem()
                toIsNil = tov.Len() == 0

                if len(from) == 1 </span><span class="cov0" title="0">{
                        fromv := reflect.ValueOf(from[0])
                        if fromv.Kind() == reflect.Slice </span><span class="cov0" title="0">{
                                if toIsNil </span><span class="cov0" title="0">{
                                        // If we get nil []string, we just return the []string
                                        return from[0], nil
                                }</span>

                                <span class="cov0" title="0">fromt := reflect.TypeOf(from[0]).Elem()

                                // If we get []string []string, we append the from slice to to
                                if tot == fromt </span><span class="cov0" title="0">{
                                        return reflect.AppendSlice(tov, fromv).Interface(), nil
                                }</span> else<span class="cov0" title="0"> if !fromt.AssignableTo(tot) </span><span class="cov0" title="0">{
                                        // Fall back to a []interface{} slice.
                                        return appendToInterfaceSliceFromValues(tov, fromv)

                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if toIsNil </span><span class="cov0" title="0">{
                return Slice(from...), nil
        }</span>

        <span class="cov0" title="0">for _, f := range from </span><span class="cov0" title="0">{
                fv := reflect.ValueOf(f)
                if !fv.Type().AssignableTo(tot) </span><span class="cov0" title="0">{
                        // Fall back to a []interface{} slice.
                        return appendToInterfaceSlice(tov, from...)
                }</span>
                <span class="cov0" title="0">tov = reflect.Append(tov, fv)</span>
        }

        <span class="cov0" title="0">return tov.Interface(), nil</span>
}

func appendToInterfaceSliceFromValues(slice1, slice2 reflect.Value) ([]interface{}, error) <span class="cov0" title="0">{
        var tos []interface{}

        for _, slice := range []reflect.Value{slice1, slice2} </span><span class="cov0" title="0">{
                for i := 0; i &lt; slice.Len(); i++ </span><span class="cov0" title="0">{
                        tos = append(tos, slice.Index(i).Interface())
                }</span>
        }

        <span class="cov0" title="0">return tos, nil</span>
}

func appendToInterfaceSlice(tov reflect.Value, from ...interface{}) ([]interface{}, error) <span class="cov0" title="0">{
        var tos []interface{}

        for i := 0; i &lt; tov.Len(); i++ </span><span class="cov0" title="0">{
                tos = append(tos, tov.Index(i).Interface())
        }</span>

        <span class="cov0" title="0">tos = append(tos, from...)

        return tos, nil</span>
}

// indirect is borrowed from the Go stdlib: 'text/template/exec.go'
// TODO(bep) consolidate
func indirect(v reflect.Value) (rv reflect.Value, isNil bool) <span class="cov0" title="0">{
        for ; v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface; v = v.Elem() </span><span class="cov0" title="0">{
                if v.IsNil() </span><span class="cov0" title="0">{
                        return v, true
                }</span>
                <span class="cov0" title="0">if v.Kind() == reflect.Interface &amp;&amp; v.NumMethod() &gt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return v, false</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "reflect"
)

// Slicer defines a very generic way to create a typed slice. This is used
// in collections.Slice template func to get types such as Pages, PageGroups etc.
// instead of the less useful []interface{}.
type Slicer interface {
        Slice(items interface{}) (interface{}, error)
}

// Slice returns a slice of all passed arguments.
func Slice(args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return args
        }</span>

        <span class="cov8" title="1">first := args[0]
        firstType := reflect.TypeOf(first)

        if firstType == nil </span><span class="cov0" title="0">{
                return args
        }</span>

        <span class="cov8" title="1">if g, ok := first.(Slicer); ok </span><span class="cov0" title="0">{
                v, err := g.Slice(args)
                if err == nil </span><span class="cov0" title="0">{
                        return v
                }</span>

                // If Slice fails, the items are not of the same type and
                // []interface{} is the best we can do.
                <span class="cov0" title="0">return args</span>
        }

        <span class="cov8" title="1">if len(args) &gt; 1 </span><span class="cov0" title="0">{
                // This can be a mix of types.
                for i := 1; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                        if firstType != reflect.TypeOf(args[i]) </span><span class="cov0" title="0">{
                                // []interface{} is the best we can do
                                return args
                        }</span>
                }
        }

        <span class="cov8" title="1">slice := reflect.MakeSlice(reflect.SliceOf(firstType), len(args), len(args))
        for i, arg := range args </span><span class="cov8" title="1">{
                slice.Index(i).Set(reflect.ValueOf(arg))
        }</span>
        <span class="cov8" title="1">return slice.Interface()</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package errors contains common Hugo errors and error related utilities.
package herrors

import (
        "io"
        "io/ioutil"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/text"

        "github.com/spf13/afero"
)

// LineMatcher contains the elements used to match an error to a line
type LineMatcher struct {
        Position text.Position
        Error    error

        LineNumber int
        Offset     int
        Line       string
}

// LineMatcherFn is used to match a line with an error.
type LineMatcherFn func(m LineMatcher) bool

// SimpleLineMatcher simply matches by line number.
var SimpleLineMatcher = func(m LineMatcher) bool <span class="cov0" title="0">{
        return m.Position.LineNumber == m.LineNumber
}</span>

var _ text.Positioner = ErrorContext{}

// ErrorContext contains contextual information about an error. This will
// typically be the lines surrounding some problem in a file.
type ErrorContext struct {

        // If a match will contain the matched line and up to 2 lines before and after.
        // Will be empty if no match.
        Lines []string

        // The position of the error in the Lines above. 0 based.
        LinesPos int

        position text.Position

        // The lexer to use for syntax highlighting.
        // https://gohugo.io/content-management/syntax-highlighting/#list-of-chroma-highlighting-languages
        ChromaLexer string
}

// Position returns the text position of this error.
func (e ErrorContext) Position() text.Position <span class="cov0" title="0">{
        return e.position
}</span>

var _ causer = (*ErrorWithFileContext)(nil)

// ErrorWithFileContext is an error with some additional file context related
// to that error.
type ErrorWithFileContext struct {
        cause error
        ErrorContext
}

func (e *ErrorWithFileContext) Error() string <span class="cov0" title="0">{
        pos := e.Position()
        if pos.IsValid() </span><span class="cov0" title="0">{
                return pos.String() + ": " + e.cause.Error()
        }</span>
        <span class="cov0" title="0">return e.cause.Error()</span>
}

func (e *ErrorWithFileContext) Cause() error <span class="cov0" title="0">{
        return e.cause
}</span>

// WithFileContextForFile will try to add a file context with lines matching the given matcher.
// If no match could be found, the original error is returned with false as the second return value.
func WithFileContextForFile(e error, realFilename, filename string, fs afero.Fs, matcher LineMatcherFn) (error, bool) <span class="cov0" title="0">{
        f, err := fs.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return e, false
        }</span>
        <span class="cov0" title="0">defer f.Close()
        return WithFileContext(e, realFilename, f, matcher)</span>
}

// WithFileContextForFile will try to add a file context with lines matching the given matcher.
// If no match could be found, the original error is returned with false as the second return value.
func WithFileContext(e error, realFilename string, r io.Reader, matcher LineMatcherFn) (error, bool) <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                panic("error missing")</span>
        }
        <span class="cov0" title="0">le := UnwrapFileError(e)

        if le == nil </span><span class="cov0" title="0">{
                var ok bool
                if le, ok = ToFileError("", e).(FileError); !ok </span><span class="cov0" title="0">{
                        return e, false
                }</span>
        }

        <span class="cov0" title="0">var errCtx ErrorContext

        posle := le.Position()

        if posle.Offset != -1 </span><span class="cov0" title="0">{
                errCtx = locateError(r, le, func(m LineMatcher) bool </span><span class="cov0" title="0">{
                        if posle.Offset &gt;= m.Offset &amp;&amp; posle.Offset &lt; m.Offset+len(m.Line) </span><span class="cov0" title="0">{
                                lno := posle.LineNumber - m.Position.LineNumber + m.LineNumber
                                m.Position = text.Position{LineNumber: lno}
                        }</span>
                        <span class="cov0" title="0">return matcher(m)</span>
                })
        } else<span class="cov0" title="0"> {
                errCtx = locateError(r, le, matcher)
        }</span>

        <span class="cov0" title="0">pos := &amp;errCtx.position

        if pos.LineNumber == -1 </span><span class="cov0" title="0">{
                return e, false
        }</span>

        <span class="cov0" title="0">pos.Filename = realFilename

        if le.Type() != "" </span><span class="cov0" title="0">{
                errCtx.ChromaLexer = chromaLexerFromType(le.Type())
        }</span> else<span class="cov0" title="0"> {
                errCtx.ChromaLexer = chromaLexerFromFilename(realFilename)
        }</span>

        <span class="cov0" title="0">return &amp;ErrorWithFileContext{cause: e, ErrorContext: errCtx}, true</span>
}

// UnwrapErrorWithFileContext tries to unwrap an ErrorWithFileContext from err.
// It returns nil if this is not possible.
func UnwrapErrorWithFileContext(err error) *ErrorWithFileContext <span class="cov8" title="1">{
        for err != nil </span><span class="cov0" title="0">{
                switch v := err.(type) </span>{
                case *ErrorWithFileContext:<span class="cov0" title="0">
                        return v</span>
                case causer:<span class="cov0" title="0">
                        err = v.Cause()</span>
                default:<span class="cov0" title="0">
                        return nil</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func chromaLexerFromType(fileType string) string <span class="cov0" title="0">{
        switch fileType </span>{
        case "html", "htm":<span class="cov0" title="0">
                return "go-html-template"</span>
        }
        <span class="cov0" title="0">return fileType</span>
}

func extNoDelimiter(filename string) string <span class="cov0" title="0">{
        return strings.TrimPrefix(filepath.Ext(filename), ".")
}</span>

func chromaLexerFromFilename(filename string) string <span class="cov0" title="0">{
        if strings.Contains(filename, "layouts") </span><span class="cov0" title="0">{
                return "go-html-template"
        }</span>

        <span class="cov0" title="0">ext := extNoDelimiter(filename)
        return chromaLexerFromType(ext)</span>
}

func locateErrorInString(src string, matcher LineMatcherFn) ErrorContext <span class="cov0" title="0">{
        return locateError(strings.NewReader(src), &amp;fileError{}, matcher)
}</span>

func locateError(r io.Reader, le FileError, matches LineMatcherFn) ErrorContext <span class="cov0" title="0">{
        if le == nil </span><span class="cov0" title="0">{
                panic("must provide an error")</span>
        }

        <span class="cov0" title="0">errCtx := ErrorContext{position: text.Position{LineNumber: -1, ColumnNumber: 1, Offset: -1}, LinesPos: -1}

        b, err := ioutil.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return errCtx
        }</span>

        <span class="cov0" title="0">pos := &amp;errCtx.position
        lepos := le.Position()

        lines := strings.Split(string(b), "\n")

        if lepos.ColumnNumber &gt;= 0 </span><span class="cov0" title="0">{
                pos.ColumnNumber = lepos.ColumnNumber
        }</span>

        <span class="cov0" title="0">lineNo := 0
        posBytes := 0

        for li, line := range lines </span><span class="cov0" title="0">{
                lineNo = li + 1
                m := LineMatcher{
                        Position:   le.Position(),
                        Error:      le,
                        LineNumber: lineNo,
                        Offset:     posBytes,
                        Line:       line,
                }
                if errCtx.LinesPos == -1 &amp;&amp; matches(m) </span><span class="cov0" title="0">{
                        pos.LineNumber = lineNo
                        break</span>
                }

                <span class="cov0" title="0">posBytes += len(line)</span>
        }

        <span class="cov0" title="0">if pos.LineNumber != -1 </span><span class="cov0" title="0">{
                low := pos.LineNumber - 3
                if low &lt; 0 </span><span class="cov0" title="0">{
                        low = 0
                }</span>

                <span class="cov0" title="0">if pos.LineNumber &gt; 2 </span><span class="cov0" title="0">{
                        errCtx.LinesPos = 2
                }</span> else<span class="cov0" title="0"> {
                        errCtx.LinesPos = pos.LineNumber - 1
                }</span>

                <span class="cov0" title="0">high := pos.LineNumber + 2
                if high &gt; len(lines) </span><span class="cov0" title="0">{
                        high = len(lines)
                }</span>

                <span class="cov0" title="0">errCtx.Lines = lines[low:high]</span>

        }

        <span class="cov0" title="0">return errCtx</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package herrors contains common Hugo errors and error related utilities.
package herrors

import (
        "errors"
        "fmt"
        "io"
        "os"
        "runtime/debug"

        _errors "github.com/pkg/errors"
)

// As defined in https://godoc.org/github.com/pkg/errors
type causer interface {
        Cause() error
}

type stackTracer interface {
        StackTrace() _errors.StackTrace
}

// PrintStackTrace prints the error's stack trace to stdoud.
func PrintStackTrace(err error) <span class="cov0" title="0">{
        FprintStackTrace(os.Stdout, err)
}</span>

// FprintStackTrace prints the error's stack trace to w.
func FprintStackTrace(w io.Writer, err error) <span class="cov0" title="0">{
        if err, ok := err.(stackTracer); ok </span><span class="cov0" title="0">{
                for _, f := range err.StackTrace() </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "%+s:%d\n", f, f)
                }</span>
        }
}

// Recover is a helper function that can be used to capture panics.
// Put this at the top of a method/function that crashes in a template:
//     defer herrors.Recover()
func Recover(args ...interface{}) <span class="cov0" title="0">{
        if r := recover(); r != nil </span><span class="cov0" title="0">{
                fmt.Println("ERR:", r)
                args = append(args, "stacktrace from panic: \n"+string(debug.Stack()), "\n")
                fmt.Println(args...)
        }</span>

}

// ErrFeatureNotAvailable denotes that a feature is unavailable.
//
// We will, at least to begin with, make some Hugo features (SCSS with libsass) optional,
// and this error is used to signal those situations.
var ErrFeatureNotAvailable = errors.New("this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information")
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitatio        ns under the License.

package herrors

import (
        "encoding/json"

        "github.com/gohugoio/hugo/common/text"

        "github.com/pkg/errors"
)

var (
        _ causer = (*fileError)(nil)
)

// FileError represents an error when handling a file: Parsing a config file,
// execute a template etc.
type FileError interface {
        error

        text.Positioner

        // A string identifying the type of file, e.g. JSON, TOML, markdown etc.
        Type() string
}

var _ FileError = (*fileError)(nil)

type fileError struct {
        position text.Position

        fileType string

        cause error
}

// Position returns the text position of this error.
func (e fileError) Position() text.Position <span class="cov0" title="0">{
        return e.position
}</span>

func (e *fileError) Type() string <span class="cov0" title="0">{
        return e.fileType
}</span>

func (e *fileError) Error() string <span class="cov0" title="0">{
        if e.cause == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return e.cause.Error()</span>
}

func (f *fileError) Cause() error <span class="cov0" title="0">{
        return f.cause
}</span>

// NewFileError creates a new FileError.
func NewFileError(fileType string, offset, lineNumber, columnNumber int, err error) FileError <span class="cov0" title="0">{
        pos := text.Position{Offset: offset, LineNumber: lineNumber, ColumnNumber: columnNumber}
        return &amp;fileError{cause: err, fileType: fileType, position: pos}
}</span>

// UnwrapFileError tries to unwrap a FileError from err.
// It returns nil if this is not possible.
func UnwrapFileError(err error) FileError <span class="cov0" title="0">{
        for err != nil </span><span class="cov0" title="0">{
                switch v := err.(type) </span>{
                case FileError:<span class="cov0" title="0">
                        return v</span>
                case causer:<span class="cov0" title="0">
                        err = v.Cause()</span>
                default:<span class="cov0" title="0">
                        return nil</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// ToFileErrorWithOffset will return a new FileError with a line number
// with the given offset from the original.
func ToFileErrorWithOffset(fe FileError, offset int) FileError <span class="cov0" title="0">{
        pos := fe.Position()
        return ToFileErrorWithLineNumber(fe, pos.LineNumber+offset)
}</span>

// ToFileErrorWithOffset will return a new FileError with the given line number.
func ToFileErrorWithLineNumber(fe FileError, lineNumber int) FileError <span class="cov0" title="0">{
        pos := fe.Position()
        pos.LineNumber = lineNumber
        return &amp;fileError{cause: fe, fileType: fe.Type(), position: pos}
}</span>

// ToFileError will convert the given error to an error supporting
// the FileError interface.
func ToFileError(fileType string, err error) FileError <span class="cov0" title="0">{
        for _, handle := range lineNumberExtractors </span><span class="cov0" title="0">{
                lno, col := handle(err)
                offset, typ := extractOffsetAndType(err)
                if fileType == "" </span><span class="cov0" title="0">{
                        fileType = typ
                }</span>

                <span class="cov0" title="0">if lno &gt; 0 || offset != -1 </span><span class="cov0" title="0">{
                        return NewFileError(fileType, offset, lno, col, err)
                }</span>
        }
        // Fall back to the pointing to line number 1.
        <span class="cov0" title="0">return NewFileError(fileType, -1, 1, 1, err)</span>
}

func extractOffsetAndType(e error) (int, string) <span class="cov0" title="0">{
        e = errors.Cause(e)
        switch v := e.(type) </span>{
        case *json.UnmarshalTypeError:<span class="cov0" title="0">
                return int(v.Offset), "json"</span>
        case *json.SyntaxError:<span class="cov0" title="0">
                return int(v.Offset), "json"</span>
        default:<span class="cov0" title="0">
                return -1, ""</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitatio        ns under the License.

package herrors

import (
        "regexp"
        "strconv"
)

var lineNumberExtractors = []lineNumberExtractor{
        // Template/shortcode parse errors
        newLineNumberErrHandlerFromRegexp(".*:(\\d+):(\\d*):"),
        newLineNumberErrHandlerFromRegexp(".*:(\\d+):"),

        // TOML parse errors
        newLineNumberErrHandlerFromRegexp(".*Near line (\\d+)(\\s.*)"),

        // YAML parse errors
        newLineNumberErrHandlerFromRegexp("line (\\d+):"),

        // i18n bundle errors
        newLineNumberErrHandlerFromRegexp("\\((\\d+),\\s(\\d*)"),
}

type lineNumberExtractor func(e error) (int, int)

func newLineNumberErrHandlerFromRegexp(expression string) lineNumberExtractor <span class="cov8" title="1">{
        re := regexp.MustCompile(expression)
        return extractLineNo(re)
}</span>

func extractLineNo(re *regexp.Regexp) lineNumberExtractor <span class="cov8" title="1">{
        return func(e error) (int, int) </span><span class="cov0" title="0">{
                if e == nil </span><span class="cov0" title="0">{
                        panic("no error")</span>
                }
                <span class="cov0" title="0">col := 1
                s := e.Error()
                m := re.FindStringSubmatch(s)
                if len(m) &gt;= 2 </span><span class="cov0" title="0">{
                        lno, _ := strconv.Atoi(m[1])
                        if len(m) &gt; 2 </span><span class="cov0" title="0">{
                                col, _ = strconv.Atoi(m[2])
                        }</span>

                        <span class="cov0" title="0">if col &lt;= 0 </span><span class="cov0" title="0">{
                                col = 1
                        }</span>

                        <span class="cov0" title="0">return lno, col</span>
                }

                <span class="cov0" title="0">return -1, col</span>
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
// Some functions in this file (see comments) is based on the Go source code,
// copyright The Go Authors and  governed by a BSD-style license.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package hreflect contains reflect helpers.
package hreflect

import (
        "reflect"

        "github.com/gohugoio/hugo/common/types"
)

// IsTruthful returns whether in represents a truthful value.
// See IsTruthfulValue
func IsTruthful(in interface{}) bool <span class="cov8" title="1">{
        switch v := in.(type) </span>{
        case reflect.Value:<span class="cov0" title="0">
                return IsTruthfulValue(v)</span>
        default:<span class="cov8" title="1">
                return IsTruthfulValue(reflect.ValueOf(in))</span>
        }

}

var zeroType = reflect.TypeOf((*types.Zeroer)(nil)).Elem()

// IsTruthfulValue returns whether the given value has a meaningful truth value.
// This is based on template.IsTrue in Go's stdlib, but also considers
// IsZero and any interface value will be unwrapped before it's considered
// for truthfulness.
//
// Based on:
// https://github.com/golang/go/blob/178a2c42254166cffed1b25fb1d3c7a5727cada6/src/text/template/exec.go#L306
func IsTruthfulValue(val reflect.Value) (truth bool) <span class="cov8" title="1">{
        val = indirectInterface(val)

        if !val.IsValid() </span><span class="cov8" title="1">{
                // Something like var x interface{}, never set. It's a form of nil.
                return
        }</span>

        <span class="cov8" title="1">if val.Type().Implements(zeroType) </span><span class="cov0" title="0">{
                return !val.Interface().(types.Zeroer).IsZero()
        }</span>

        <span class="cov8" title="1">switch val.Kind() </span>{
        case reflect.Array, reflect.Map, reflect.Slice, reflect.String:<span class="cov8" title="1">
                truth = val.Len() &gt; 0</span>
        case reflect.Bool:<span class="cov8" title="1">
                truth = val.Bool()</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov0" title="0">
                truth = val.Complex() != 0</span>
        case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Interface:<span class="cov8" title="1">
                truth = !val.IsNil()</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                truth = val.Int() != 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                truth = val.Float() != 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                truth = val.Uint() != 0</span>
        case reflect.Struct:<span class="cov0" title="0">
                truth = true</span> // Struct values are always true.
        default:<span class="cov0" title="0">
                return</span>
        }

        <span class="cov8" title="1">return</span>
}

// Based on: https://github.com/golang/go/blob/178a2c42254166cffed1b25fb1d3c7a5727cada6/src/text/template/exec.go#L931
func indirectInterface(v reflect.Value) reflect.Value <span class="cov8" title="1">{
        if v.Kind() != reflect.Interface </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">if v.IsNil() </span><span class="cov0" title="0">{
                return reflect.Value{}
        }</span>
        <span class="cov8" title="1">return v.Elem()</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugio

import (
        "io"
        "io/ioutil"
        "os"
        "path/filepath"

        "github.com/pkg/errors"

        "github.com/spf13/afero"
)

// CopyFile copies a file.
func CopyFile(fs afero.Fs, from, to string) error <span class="cov0" title="0">{
        sf, err := os.Open(from)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sf.Close()
        df, err := os.Create(to)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer df.Close()
        _, err = io.Copy(df, sf)
        if err == nil </span><span class="cov0" title="0">{
                si, err := os.Stat(from)
                if err != nil </span><span class="cov0" title="0">{
                        err = os.Chmod(to, si.Mode())

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        }
        <span class="cov0" title="0">return nil</span>
}

// CopyDir copies a directory.
func CopyDir(fs afero.Fs, from, to string, shouldCopy func(filename string) bool) error <span class="cov0" title="0">{
        fi, err := os.Stat(from)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !fi.IsDir() </span><span class="cov0" title="0">{
                return errors.Errorf("%q is not a directory", from)
        }</span>

        <span class="cov0" title="0">err = fs.MkdirAll(to, 0777) // before umask
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">entries, _ := ioutil.ReadDir(from)
        for _, entry := range entries </span><span class="cov0" title="0">{
                fromFilename := filepath.Join(from, entry.Name())
                toFilename := filepath.Join(to, entry.Name())
                if entry.IsDir() </span><span class="cov0" title="0">{
                        if shouldCopy != nil &amp;&amp; !shouldCopy(fromFilename) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if err := CopyDir(fs, fromFilename, toFilename, shouldCopy); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := CopyFile(fs, fromFilename, toFilename); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugio

import (
        "io"
        "strings"
)

// ReadSeeker wraps io.Reader and io.Seeker.
type ReadSeeker interface {
        io.Reader
        io.Seeker
}

// ReadSeekCloser is implemented by afero.File. We use this as the common type for
// content in Resource objects, even for strings.
type ReadSeekCloser interface {
        ReadSeeker
        io.Closer
}

// ReadSeekerNoOpCloser implements ReadSeekCloser by doing nothing in Close.
// TODO(bep) rename this and simila to ReadSeekerNopCloser, naming used in stdlib, which kind of makes sense.
type ReadSeekerNoOpCloser struct {
        ReadSeeker
}

// Close does nothing.
func (r ReadSeekerNoOpCloser) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// NewReadSeekerNoOpCloser creates a new ReadSeekerNoOpCloser with the given ReadSeeker.
func NewReadSeekerNoOpCloser(r ReadSeeker) ReadSeekerNoOpCloser <span class="cov0" title="0">{
        return ReadSeekerNoOpCloser{r}
}</span>

// NewReadSeekerNoOpCloserFromString uses strings.NewReader to create a new ReadSeekerNoOpCloser
// from the given string.
func NewReadSeekerNoOpCloserFromString(content string) ReadSeekerNoOpCloser <span class="cov0" title="0">{
        return ReadSeekerNoOpCloser{strings.NewReader(content)}
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugio

import (
        "io"
        "io/ioutil"
)

type multiWriteCloser struct {
        io.Writer
        closers []io.WriteCloser
}

func (m multiWriteCloser) Close() error <span class="cov0" title="0">{
        var err error
        for _, c := range m.closers </span><span class="cov0" title="0">{
                if closeErr := c.Close(); err != nil </span><span class="cov0" title="0">{
                        err = closeErr
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

// NewMultiWriteCloser creates a new io.WriteCloser that duplicates its writes to all the
// provided writers.
func NewMultiWriteCloser(writeClosers ...io.WriteCloser) io.WriteCloser <span class="cov0" title="0">{
        writers := make([]io.Writer, len(writeClosers))
        for i, w := range writeClosers </span><span class="cov0" title="0">{
                writers[i] = w
        }</span>
        <span class="cov0" title="0">return multiWriteCloser{Writer: io.MultiWriter(writers...), closers: writeClosers}</span>
}

// ToWriteCloser creates an io.WriteCloser from the given io.Writer.
// If it's not already, one will be created with a Close method that does nothing.
func ToWriteCloser(w io.Writer) io.WriteCloser <span class="cov0" title="0">{
        if rw, ok := w.(io.WriteCloser); ok </span><span class="cov0" title="0">{
                return rw
        }</span>

        <span class="cov0" title="0">return struct {
                io.Writer
                io.Closer
        }{
                w,
                ioutil.NopCloser(nil),
        }</span>
}

// ToReadCloser creates an io.ReadCloser from the given io.Reader.
// If it's not already, one will be created with a Close method that does nothing.
func ToReadCloser(r io.Reader) io.ReadCloser <span class="cov0" title="0">{
        if rc, ok := r.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                return rc
        }</span>

        <span class="cov0" title="0">return struct {
                io.Reader
                io.Closer
        }{
                r,
                ioutil.NopCloser(nil),
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugo

import (
        "fmt"
        "html/template"
)

const (
        EnvironmentDevelopment = "development"
        EnvironmentProduction  = "production"
)

var (
        // commitHash contains the current Git revision. Use make to build to make
        // sure this gets set.
        commitHash string

        // buildDate contains the date of the current build.
        buildDate string
)

// Info contains information about the current Hugo environment
type Info struct {
        CommitHash string
        BuildDate  string

        // The build environment.
        // Defaults are "production" (hugo) and "development" (hugo server).
        // This can also be set by the user.
        // It can be any string, but it will be all lower case.
        Environment string
}

// Version returns the current version as a comparable version string.
func (i Info) Version() VersionString <span class="cov0" title="0">{
        return CurrentVersion.Version()
}</span>

// Generator a Hugo meta generator HTML tag.
func (i Info) Generator() template.HTML <span class="cov8" title="1">{
        return template.HTML(fmt.Sprintf(`&lt;meta name="generator" content="Hugo %s" /&gt;`, CurrentVersion.String()))
}</span>

// NewInfo creates a new Hugo Info object.
func NewInfo(environment string) Info <span class="cov8" title="1">{
        if environment == "" </span><span class="cov0" title="0">{
                environment = EnvironmentProduction
        }</span>
        <span class="cov8" title="1">return Info{
                CommitHash:  commitHash,
                BuildDate:   buildDate,
                Environment: environment,
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugo

import (
        "fmt"
        "strconv"

        "runtime"
        "strings"

        "github.com/gohugoio/hugo/compare"
        "github.com/spf13/cast"
)

// Version represents the Hugo build version.
type Version struct {
        // Major and minor version.
        Number float32

        // Increment this for bug releases
        PatchLevel int

        // HugoVersionSuffix is the suffix used in the Hugo version string.
        // It will be blank for release versions.
        Suffix string
}

var (
        _ compare.Eqer     = (*VersionString)(nil)
        _ compare.Comparer = (*VersionString)(nil)
)

func (v Version) String() string <span class="cov8" title="1">{
        return version(v.Number, v.PatchLevel, v.Suffix)
}</span>

// Version returns the Hugo version.
func (v Version) Version() VersionString <span class="cov8" title="1">{
        return VersionString(v.String())
}</span>

// VersionString represents a Hugo version string.
type VersionString string

func (h VersionString) String() string <span class="cov8" title="1">{
        return string(h)
}</span>

// Compare implements the compare.Comparer interface.
func (h VersionString) Compare(other interface{}) int <span class="cov8" title="1">{
        v := MustParseVersion(h.String())
        return compareVersionsWithSuffix(v.Number, v.PatchLevel, v.Suffix, other)
}</span>

// Eq implements the compare.Eqer interface.
func (h VersionString) Eq(other interface{}) bool <span class="cov0" title="0">{
        s, err := cast.ToStringE(other)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return s == h.String()</span>
}

var versionSuffixes = []string{"-test", "-DEV"}

// ParseVersion parses a version string.
func ParseVersion(s string) (Version, error) <span class="cov8" title="1">{
        var vv Version
        for _, suffix := range versionSuffixes </span><span class="cov8" title="1">{
                if strings.HasSuffix(s, suffix) </span><span class="cov8" title="1">{
                        vv.Suffix = suffix
                        s = strings.TrimSuffix(s, suffix)
                }</span>
        }

        <span class="cov8" title="1">v, p := parseVersion(s)

        vv.Number = v
        vv.PatchLevel = p

        return vv, nil</span>
}

// MustParseVersion parses a version string
// and panics if any error occurs.
func MustParseVersion(s string) Version <span class="cov8" title="1">{
        vv, err := ParseVersion(s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return vv</span>
}

// ReleaseVersion represents the release version.
func (v Version) ReleaseVersion() Version <span class="cov0" title="0">{
        v.Suffix = ""
        return v
}</span>

// Next returns the next Hugo release version.
func (v Version) Next() Version <span class="cov0" title="0">{
        return Version{Number: v.Number + 0.01}
}</span>

// Prev returns the previous Hugo release version.
func (v Version) Prev() Version <span class="cov0" title="0">{
        return Version{Number: v.Number - 0.01}
}</span>

// NextPatchLevel returns the next patch/bugfix Hugo version.
// This will be a patch increment on the previous Hugo version.
func (v Version) NextPatchLevel(level int) Version <span class="cov0" title="0">{
        return Version{Number: v.Number - 0.01, PatchLevel: level}
}</span>

// BuildVersionString creates a version string. This is what you see when
// running "hugo version".
func BuildVersionString() string <span class="cov0" title="0">{
        program := "Hugo Static Site Generator"

        version := "v" + CurrentVersion.String()
        if commitHash != "" </span><span class="cov0" title="0">{
                version += "-" + strings.ToUpper(commitHash)
        }</span>
        <span class="cov0" title="0">if IsExtended </span><span class="cov0" title="0">{
                version += "/extended"
        }</span>

        <span class="cov0" title="0">osArch := runtime.GOOS + "/" + runtime.GOARCH

        date := buildDate
        if date == "" </span><span class="cov0" title="0">{
                date = "unknown"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s %s %s BuildDate: %s", program, version, osArch, date)</span>

}

func version(version float32, patchVersion int, suffix string) string <span class="cov8" title="1">{
        if patchVersion &gt; 0 || version &gt; 0.53 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%.2f.%d%s", version, patchVersion, suffix)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.2f%s", version, suffix)</span>
}

// CompareVersion compares the given version string or number against the
// running Hugo version.
// It returns -1 if the given version is less than, 0 if equal and 1 if greater than
// the running version.
func CompareVersion(version interface{}) int <span class="cov0" title="0">{
        return compareVersionsWithSuffix(CurrentVersion.Number, CurrentVersion.PatchLevel, CurrentVersion.Suffix, version)
}</span>

func compareVersions(inVersion float32, inPatchVersion int, in interface{}) int <span class="cov0" title="0">{
        return compareVersionsWithSuffix(inVersion, inPatchVersion, "", in)
}</span>

func compareVersionsWithSuffix(inVersion float32, inPatchVersion int, suffix string, in interface{}) int <span class="cov8" title="1">{
        var c int
        switch d := in.(type) </span>{
        case float64:<span class="cov0" title="0">
                c = compareFloatVersions(inVersion, float32(d))</span>
        case float32:<span class="cov0" title="0">
                c = compareFloatVersions(inVersion, d)</span>
        case int:<span class="cov0" title="0">
                c = compareFloatVersions(inVersion, float32(d))</span>
        case int32:<span class="cov0" title="0">
                c = compareFloatVersions(inVersion, float32(d))</span>
        case int64:<span class="cov0" title="0">
                c = compareFloatVersions(inVersion, float32(d))</span>
        default:<span class="cov8" title="1">
                s, err := cast.ToStringE(in)
                if err != nil </span><span class="cov0" title="0">{
                        return -1
                }</span>

                <span class="cov8" title="1">v, err := ParseVersion(s)
                if err != nil </span><span class="cov0" title="0">{
                        return -1
                }</span>

                <span class="cov8" title="1">if v.Number == inVersion &amp;&amp; v.PatchLevel == inPatchVersion </span><span class="cov0" title="0">{
                        return strings.Compare(suffix, v.Suffix)
                }</span>

                <span class="cov8" title="1">if v.Number &lt; inVersion || (v.Number == inVersion &amp;&amp; v.PatchLevel &lt; inPatchVersion) </span><span class="cov8" title="1">{
                        return -1
                }</span>

                <span class="cov0" title="0">return 1</span>
        }

        <span class="cov0" title="0">if c == 0 &amp;&amp; suffix != "" </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">return c</span>
}

func parseVersion(s string) (float32, int) <span class="cov8" title="1">{
        var (
                v float32
                p int
        )

        if strings.Count(s, ".") == 2 </span><span class="cov8" title="1">{
                li := strings.LastIndex(s, ".")
                p = cast.ToInt(s[li+1:])
                s = s[:li]
        }</span>

        <span class="cov8" title="1">v = float32(cast.ToFloat64(s))

        return v, p</span>
}

func compareFloatVersions(version float32, v float32) int <span class="cov0" title="0">{
        if v == version </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if v &lt; version </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">return 1</span>
}

func GoMinorVersion() int <span class="cov0" title="0">{
        return goMinorVersion(runtime.Version())
}</span>

func goMinorVersion(version string) int <span class="cov0" title="0">{
        if strings.HasPrefix(version, "devel") </span><span class="cov0" title="0">{
                return 9999 // magic
        }</span>
        <span class="cov0" title="0">i, _ := strconv.Atoi(strings.Split(version, ".")[1])
        return i</span>

}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package loggers

import (
        "bytes"
        "io"
        "io/ioutil"
        "log"
        "os"
        "regexp"

        "github.com/gohugoio/hugo/common/terminal"

        jww "github.com/spf13/jwalterweatherman"
)

var (
        // Counts ERROR logs to the global jww logger.
        GlobalErrorCounter *jww.Counter
)

func init() <span class="cov8" title="1">{
        GlobalErrorCounter = &amp;jww.Counter{}
        jww.SetLogListeners(jww.LogCounter(GlobalErrorCounter, jww.LevelError))
}</span>

// Logger wraps a *loggers.Logger and some other related logging state.
type Logger struct {
        *jww.Notepad
        ErrorCounter *jww.Counter
        WarnCounter  *jww.Counter

        // This is only set in server mode.
        errors *bytes.Buffer
}

func (l *Logger) Errors() string <span class="cov0" title="0">{
        if l.errors == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return ansiColorRe.ReplaceAllString(l.errors.String(), "")</span>
}

// Reset resets the logger's internal state.
func (l *Logger) Reset() <span class="cov8" title="1">{
        l.ErrorCounter.Reset()
        if l.errors != nil </span><span class="cov0" title="0">{
                l.errors.Reset()
        }</span>
}

//  NewLogger creates a new Logger for the given thresholds
func NewLogger(stdoutThreshold, logThreshold jww.Threshold, outHandle, logHandle io.Writer, saveErrors bool) *Logger <span class="cov8" title="1">{
        return newLogger(stdoutThreshold, logThreshold, outHandle, logHandle, saveErrors)
}</span>

// NewDebugLogger is a convenience function to create a debug logger.
func NewDebugLogger() *Logger <span class="cov0" title="0">{
        return newBasicLogger(jww.LevelDebug)
}</span>

// NewWarningLogger is a convenience function to create a warning logger.
func NewWarningLogger() *Logger <span class="cov8" title="1">{
        return newBasicLogger(jww.LevelWarn)
}</span>

// NewErrorLogger is a convenience function to create an error logger.
func NewErrorLogger() *Logger <span class="cov0" title="0">{
        return newBasicLogger(jww.LevelError)
}</span>

var (
        ansiColorRe = regexp.MustCompile("(?s)\\033\\[\\d*(;\\d*)*m")
        errorRe     = regexp.MustCompile("^(ERROR|FATAL|WARN)")
)

type ansiCleaner struct {
        w io.Writer
}

func (a ansiCleaner) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        return a.w.Write(ansiColorRe.ReplaceAll(p, []byte("")))
}</span>

type labelColorizer struct {
        w io.Writer
}

func (a labelColorizer) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        replaced := errorRe.ReplaceAllStringFunc(string(p), func(m string) string </span><span class="cov8" title="1">{
                switch m </span>{
                case "ERROR", "FATAL":<span class="cov0" title="0">
                        return terminal.Error(m)</span>
                case "WARN":<span class="cov8" title="1">
                        return terminal.Warning(m)</span>
                default:<span class="cov0" title="0">
                        return m</span>
                }
        })
        // io.MultiWriter will abort if we return a bigger write count than input
        // bytes, so we lie a little.
        <span class="cov8" title="1">_, err = a.w.Write([]byte(replaced))
        return len(p), err</span>

}

// InitGlobalLogger initializes the global logger, used in some rare cases.
func InitGlobalLogger(stdoutThreshold, logThreshold jww.Threshold, outHandle, logHandle io.Writer) <span class="cov8" title="1">{
        outHandle, logHandle = getLogWriters(outHandle, logHandle)

        jww.SetStdoutOutput(outHandle)
        jww.SetLogOutput(logHandle)
        jww.SetLogThreshold(logThreshold)
        jww.SetStdoutThreshold(stdoutThreshold)

}</span>

func getLogWriters(outHandle, logHandle io.Writer) (io.Writer, io.Writer) <span class="cov8" title="1">{
        isTerm := terminal.IsTerminal(os.Stdout)
        if logHandle != ioutil.Discard &amp;&amp; isTerm </span><span class="cov0" title="0">{
                // Remove any Ansi coloring from log output
                logHandle = ansiCleaner{w: logHandle}
        }</span>

        <span class="cov8" title="1">if isTerm </span><span class="cov8" title="1">{
                outHandle = labelColorizer{w: outHandle}
        }</span>

        <span class="cov8" title="1">return outHandle, logHandle</span>

}

func newLogger(stdoutThreshold, logThreshold jww.Threshold, outHandle, logHandle io.Writer, saveErrors bool) *Logger <span class="cov8" title="1">{
        errorCounter := &amp;jww.Counter{}
        warnCounter := &amp;jww.Counter{}
        outHandle, logHandle = getLogWriters(outHandle, logHandle)

        listeners := []jww.LogListener{jww.LogCounter(errorCounter, jww.LevelError), jww.LogCounter(warnCounter, jww.LevelWarn)}
        var errorBuff *bytes.Buffer
        if saveErrors </span><span class="cov0" title="0">{
                errorBuff = new(bytes.Buffer)
                errorCapture := func(t jww.Threshold) io.Writer </span><span class="cov0" title="0">{
                        if t != jww.LevelError </span><span class="cov0" title="0">{
                                // Only interested in ERROR
                                return nil
                        }</span>

                        <span class="cov0" title="0">return errorBuff</span>
                }

                <span class="cov0" title="0">listeners = append(listeners, errorCapture)</span>
        }

        <span class="cov8" title="1">return &amp;Logger{
                Notepad:      jww.NewNotepad(stdoutThreshold, logThreshold, outHandle, logHandle, "", log.Ldate|log.Ltime, listeners...),
                ErrorCounter: errorCounter,
                WarnCounter:  warnCounter,
                errors:       errorBuff,
        }</span>
}

func newBasicLogger(t jww.Threshold) *Logger <span class="cov8" title="1">{
        return newLogger(t, jww.LevelError, os.Stdout, ioutil.Discard, false)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package maps

import (
        "strings"

        "github.com/gobwas/glob"

        "github.com/spf13/cast"
)

// ToLower makes all the keys in the given map lower cased and will do so
// recursively.
// Notes:
// * This will modify the map given.
// * Any nested map[interface{}]interface{} will be converted to map[string]interface{}.
func ToLower(m map[string]interface{}) <span class="cov8" title="1">{
        for k, v := range m </span><span class="cov8" title="1">{
                switch v.(type) </span>{
                case map[interface{}]interface{}:<span class="cov0" title="0">
                        v = cast.ToStringMap(v)
                        ToLower(v.(map[string]interface{}))</span>
                case map[string]interface{}:<span class="cov8" title="1">
                        ToLower(v.(map[string]interface{}))</span>
                }

                <span class="cov8" title="1">lKey := strings.ToLower(k)
                if k != lKey </span><span class="cov8" title="1">{
                        delete(m, k)
                        m[lKey] = v
                }</span>

        }
}

type keyRename struct {
        pattern glob.Glob
        newKey  string
}

// KeyRenamer supports renaming of keys in a map.
type KeyRenamer struct {
        renames []keyRename
}

// NewKeyRenamer creates a new KeyRenamer given a list of pattern and new key
// value pairs.
func NewKeyRenamer(patternKeys ...string) (KeyRenamer, error) <span class="cov8" title="1">{
        var renames []keyRename
        for i := 0; i &lt; len(patternKeys); i += 2 </span><span class="cov8" title="1">{
                g, err := glob.Compile(strings.ToLower(patternKeys[i]), '/')
                if err != nil </span><span class="cov0" title="0">{
                        return KeyRenamer{}, err
                }</span>
                <span class="cov8" title="1">renames = append(renames, keyRename{pattern: g, newKey: patternKeys[i+1]})</span>
        }

        <span class="cov8" title="1">return KeyRenamer{renames: renames}, nil</span>
}

func (r KeyRenamer) getNewKey(keyPath string) string <span class="cov8" title="1">{
        for _, matcher := range r.renames </span><span class="cov8" title="1">{
                if matcher.pattern.Match(keyPath) </span><span class="cov0" title="0">{
                        return matcher.newKey
                }</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// Rename renames the keys in the given map according
// to the patterns in the current KeyRenamer.
func (r KeyRenamer) Rename(m map[string]interface{}) <span class="cov8" title="1">{
        r.renamePath("", m)
}</span>

func (KeyRenamer) keyPath(k1, k2 string) string <span class="cov8" title="1">{
        k1, k2 = strings.ToLower(k1), strings.ToLower(k2)
        if k1 == "" </span><span class="cov8" title="1">{
                return k2
        }</span> else<span class="cov0" title="0"> {
                return k1 + "/" + k2
        }</span>
}

func (r KeyRenamer) renamePath(parentKeyPath string, m map[string]interface{}) <span class="cov8" title="1">{
        for key, val := range m </span><span class="cov8" title="1">{
                keyPath := r.keyPath(parentKeyPath, key)
                switch val.(type) </span>{
                case map[interface{}]interface{}:<span class="cov0" title="0">
                        val = cast.ToStringMap(val)
                        r.renamePath(keyPath, val.(map[string]interface{}))</span>
                case map[string]interface{}:<span class="cov0" title="0">
                        r.renamePath(keyPath, val.(map[string]interface{}))</span>
                }

                <span class="cov8" title="1">newKey := r.getNewKey(keyPath)

                if newKey != "" </span><span class="cov0" title="0">{
                        delete(m, key)
                        m[newKey] = val
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package maps

import (
        "github.com/spf13/cast"
)

// GetString tries to get a value with key from map m and convert it to a string.
// It will return an empty string if not found or if it cannot be convertd to a string.
func GetString(m map[string]interface{}, key string) string <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">v, found := m[key]
        if !found </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return cast.ToString(v)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package maps

import (
        "strings"

        "github.com/spf13/cast"
)

// GetNestedParam gets the first match of the keyStr in the candidates given.
// It will first try the exact match and then try to find it as a nested map value,
// using the given separator, e.g. "mymap.name".
// It assumes that all the maps given have lower cased keys.
func GetNestedParam(keyStr, separator string, candidates ...map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        keyStr = strings.ToLower(keyStr)

        lookupFn := func(key string) interface{} </span><span class="cov8" title="1">{
                for _, m := range candidates </span><span class="cov8" title="1">{
                        if v, ok := m[key]; ok </span><span class="cov8" title="1">{
                                return v
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">v, _, _, err := GetNestedParamFn(keyStr, separator, lookupFn)
        return v, err</span>
}

func GetNestedParamFn(keyStr, separator string, lookupFn func(key string) interface{}) (interface{}, string, map[string]interface{}, error) <span class="cov8" title="1">{
        result, _ := traverseDirectParams(keyStr, lookupFn)
        if result != nil </span><span class="cov8" title="1">{
                return result, keyStr, nil, nil
        }</span>

        <span class="cov8" title="1">keySegments := strings.Split(keyStr, separator)
        if len(keySegments) == 1 </span><span class="cov8" title="1">{
                return nil, keyStr, nil, nil
        }</span>

        <span class="cov0" title="0">return traverseNestedParams(keySegments, lookupFn)</span>
}

func traverseDirectParams(keyStr string, lookupFn func(key string) interface{}) (interface{}, error) <span class="cov8" title="1">{
        return lookupFn(keyStr), nil
}</span>

func traverseNestedParams(keySegments []string, lookupFn func(key string) interface{}) (interface{}, string, map[string]interface{}, error) <span class="cov0" title="0">{
        firstKey, rest := keySegments[0], keySegments[1:]
        result := lookupFn(firstKey)
        if result == nil || len(rest) == 0 </span><span class="cov0" title="0">{
                return result, firstKey, nil, nil
        }</span>

        <span class="cov0" title="0">switch m := result.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                v, key, owner := traverseParams(rest, m)
                return v, key, owner, nil</span>
        default:<span class="cov0" title="0">
                return nil, "", nil, nil</span>
        }
}

func traverseParams(keys []string, m map[string]interface{}) (interface{}, string, map[string]interface{}) <span class="cov0" title="0">{
        // Shift first element off.
        firstKey, rest := keys[0], keys[1:]
        result := m[firstKey]

        // No point in continuing here.
        if result == nil </span><span class="cov0" title="0">{
                return result, "", nil
        }</span>

        <span class="cov0" title="0">if len(rest) == 0 </span><span class="cov0" title="0">{
                // That was the last key.
                return result, firstKey, m
        }</span>

        // That was not the last key.
        <span class="cov0" title="0">return traverseParams(rest, cast.ToStringMap(result))</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package maps

import (
        "reflect"
        "sort"
        "sync"

        "github.com/gohugoio/hugo/common/collections"
        "github.com/gohugoio/hugo/common/math"
)

// Scratch is a writable context used for stateful operations in Page/Node rendering.
type Scratch struct {
        values map[string]interface{}
        mu     sync.RWMutex
}

// Scratcher provides a scratching service.
type Scratcher interface {
        Scratch() *Scratch
}

type scratcher struct {
        s *Scratch
}

func (s scratcher) Scratch() *Scratch <span class="cov0" title="0">{
        return s.s
}</span>

// NewScratcher creates a new Scratcher.
func NewScratcher() Scratcher <span class="cov8" title="1">{
        return scratcher{s: NewScratch()}
}</span>

// Add will, for single values, add (using the + operator) the addend to the existing addend (if found).
// Supports numeric values and strings.
//
// If the first add for a key is an array or slice, then the next value(s) will be appended.
func (c *Scratch) Add(key string, newAddend interface{}) (string, error) <span class="cov0" title="0">{

        var newVal interface{}
        c.mu.RLock()
        existingAddend, found := c.values[key]
        c.mu.RUnlock()
        if found </span><span class="cov0" title="0">{
                var err error

                addendV := reflect.TypeOf(existingAddend)

                if addendV.Kind() == reflect.Slice || addendV.Kind() == reflect.Array </span><span class="cov0" title="0">{
                        newVal, err = collections.Append(existingAddend, newAddend)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                } else<span class="cov0" title="0"> {
                        newVal, err = math.DoArithmetic(existingAddend, newAddend, '+')
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                newVal = newAddend
        }</span>
        <span class="cov0" title="0">c.mu.Lock()
        c.values[key] = newVal
        c.mu.Unlock()
        return "", nil</span> // have to return something to make it work with the Go templates
}

// Set stores a value with the given key in the Node context.
// This value can later be retrieved with Get.
func (c *Scratch) Set(key string, value interface{}) string <span class="cov0" title="0">{
        c.mu.Lock()
        c.values[key] = value
        c.mu.Unlock()
        return ""
}</span>

// Delete deletes the given key.
func (c *Scratch) Delete(key string) string <span class="cov0" title="0">{
        c.mu.Lock()
        delete(c.values, key)
        c.mu.Unlock()
        return ""
}</span>

// Get returns a value previously set by Add or Set.
func (c *Scratch) Get(key string) interface{} <span class="cov0" title="0">{
        c.mu.RLock()
        val := c.values[key]
        c.mu.RUnlock()

        return val
}</span>

// SetInMap stores a value to a map with the given key in the Node context.
// This map can later be retrieved with GetSortedMapValues.
func (c *Scratch) SetInMap(key string, mapKey string, value interface{}) string <span class="cov0" title="0">{
        c.mu.Lock()
        _, found := c.values[key]
        if !found </span><span class="cov0" title="0">{
                c.values[key] = make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">c.values[key].(map[string]interface{})[mapKey] = value
        c.mu.Unlock()
        return ""</span>
}

// GetSortedMapValues returns a sorted map previously filled with SetInMap.
func (c *Scratch) GetSortedMapValues(key string) interface{} <span class="cov0" title="0">{
        c.mu.RLock()

        if c.values[key] == nil </span><span class="cov0" title="0">{
                c.mu.RUnlock()
                return nil
        }</span>

        <span class="cov0" title="0">unsortedMap := c.values[key].(map[string]interface{})
        c.mu.RUnlock()
        var keys []string
        for mapKey := range unsortedMap </span><span class="cov0" title="0">{
                keys = append(keys, mapKey)
        }</span>

        <span class="cov0" title="0">sort.Strings(keys)

        sortedArray := make([]interface{}, len(unsortedMap))
        for i, mapKey := range keys </span><span class="cov0" title="0">{
                sortedArray[i] = unsortedMap[mapKey]
        }</span>

        <span class="cov0" title="0">return sortedArray</span>
}

// NewScratch returns a new instance Scratch.
func NewScratch() *Scratch <span class="cov8" title="1">{
        return &amp;Scratch{values: make(map[string]interface{})}
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package math

import (
        "errors"
        "reflect"
)

// DoArithmetic performs arithmetic operations (+,-,*,/) using reflection to
// determine the type of the two terms.
func DoArithmetic(a, b interface{}, op rune) (interface{}, error) <span class="cov8" title="1">{
        av := reflect.ValueOf(a)
        bv := reflect.ValueOf(b)
        var ai, bi int64
        var af, bf float64
        var au, bu uint64
        switch av.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                ai = av.Int()
                switch bv.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                        bi = bv.Int()</span>
                case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                        af = float64(ai) // may overflow
                        ai = 0
                        bf = bv.Float()</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                        bu = bv.Uint()
                        if ai &gt;= 0 </span><span class="cov0" title="0">{
                                au = uint64(ai)
                                ai = 0
                        }</span> else<span class="cov0" title="0"> {
                                bi = int64(bu) // may overflow
                                bu = 0
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, errors.New("can't apply the operator to the values")</span>
                }
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                af = av.Float()
                switch bv.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                        bf = float64(bv.Int())</span> // may overflow
                case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                        bf = bv.Float()</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                        bf = float64(bv.Uint())</span> // may overflow
                default:<span class="cov0" title="0">
                        return nil, errors.New("can't apply the operator to the values")</span>
                }
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                au = av.Uint()
                switch bv.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                        bi = bv.Int()
                        if bi &gt;= 0 </span><span class="cov0" title="0">{
                                bu = uint64(bi)
                                bi = 0
                        }</span> else<span class="cov0" title="0"> {
                                ai = int64(au) // may overflow
                                au = 0
                        }</span>
                case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                        af = float64(au) // may overflow
                        au = 0
                        bf = bv.Float()</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                        bu = bv.Uint()</span>
                default:<span class="cov0" title="0">
                        return nil, errors.New("can't apply the operator to the values")</span>
                }
        case reflect.String:<span class="cov0" title="0">
                as := av.String()
                if bv.Kind() == reflect.String &amp;&amp; op == '+' </span><span class="cov0" title="0">{
                        bs := bv.String()
                        return as + bs, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.New("can't apply the operator to the values")</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("can't apply the operator to the values")</span>
        }

        <span class="cov8" title="1">switch op </span>{
        case '+':<span class="cov8" title="1">
                if ai != 0 || bi != 0 </span><span class="cov8" title="1">{
                        return ai + bi, nil
                }</span> else<span class="cov0" title="0"> if af != 0 || bf != 0 </span><span class="cov0" title="0">{
                        return af + bf, nil
                }</span> else<span class="cov0" title="0"> if au != 0 || bu != 0 </span><span class="cov0" title="0">{
                        return au + bu, nil
                }</span>
                <span class="cov0" title="0">return 0, nil</span>
        case '-':<span class="cov0" title="0">
                if ai != 0 || bi != 0 </span><span class="cov0" title="0">{
                        return ai - bi, nil
                }</span> else<span class="cov0" title="0"> if af != 0 || bf != 0 </span><span class="cov0" title="0">{
                        return af - bf, nil
                }</span> else<span class="cov0" title="0"> if au != 0 || bu != 0 </span><span class="cov0" title="0">{
                        return au - bu, nil
                }</span>
                <span class="cov0" title="0">return 0, nil</span>
        case '*':<span class="cov0" title="0">
                if ai != 0 || bi != 0 </span><span class="cov0" title="0">{
                        return ai * bi, nil
                }</span> else<span class="cov0" title="0"> if af != 0 || bf != 0 </span><span class="cov0" title="0">{
                        return af * bf, nil
                }</span> else<span class="cov0" title="0"> if au != 0 || bu != 0 </span><span class="cov0" title="0">{
                        return au * bu, nil
                }</span>
                <span class="cov0" title="0">return 0, nil</span>
        case '/':<span class="cov0" title="0">
                if bi != 0 </span><span class="cov0" title="0">{
                        return ai / bi, nil
                }</span> else<span class="cov0" title="0"> if bf != 0 </span><span class="cov0" title="0">{
                        return af / bf, nil
                }</span> else<span class="cov0" title="0"> if bu != 0 </span><span class="cov0" title="0">{
                        return au / bu, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.New("can't divide the value by 0")</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("there is no such an operation")</span>
        }
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package terminal contains helper for the terminal, such as coloring output.
package terminal

import (
        "fmt"
        "os"
        "runtime"
        "strings"

        isatty "github.com/mattn/go-isatty"
)

const (
        errorColor   = "\033[1;31m%s\033[0m"
        warningColor = "\033[0;33m%s\033[0m"
        noticeColor  = "\033[1;36m%s\033[0m"
)

// IsTerminal return true if the file descriptor is terminal and the TERM
// environment variable isn't a dumb one.
func IsTerminal(f *os.File) bool <span class="cov8" title="1">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">fd := f.Fd()
        return os.Getenv("TERM") != "dumb" &amp;&amp; (isatty.IsTerminal(fd) || isatty.IsCygwinTerminal(fd))</span>
}

// Notice colorizes the string in a noticeable color.
func Notice(s string) string <span class="cov0" title="0">{
        return colorize(s, noticeColor)
}</span>

// Error colorizes the string in a colour that grabs attention.
func Error(s string) string <span class="cov0" title="0">{
        return colorize(s, errorColor)
}</span>

// Warning colorizes the string in a colour that warns.
func Warning(s string) string <span class="cov8" title="1">{
        return colorize(s, warningColor)
}</span>

// colorize s in color.
func colorize(s, color string) string <span class="cov8" title="1">{
        s = fmt.Sprintf(color, doublePercent(s))
        return singlePercent(s)
}</span>

func doublePercent(str string) string <span class="cov8" title="1">{
        return strings.Replace(str, "%", "%%", -1)
}</span>

func singlePercent(str string) string <span class="cov8" title="1">{
        return strings.Replace(str, "%%", "%", -1)
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package text

import (
        "fmt"
        "os"
        "strings"

        "github.com/gohugoio/hugo/common/terminal"
)

// Positioner represents a thing that knows its position in a text file or stream,
// typically an error.
type Positioner interface {
        Position() Position
}

// Position holds a source position in a text file or stream.
type Position struct {
        Filename     string // filename, if any
        Offset       int    // byte offset, starting at 0. It's set to -1 if not provided.
        LineNumber   int    // line number, starting at 1
        ColumnNumber int    // column number, starting at 1 (character count per line)
}

func (pos Position) String() string <span class="cov0" title="0">{
        if pos.Filename == "" </span><span class="cov0" title="0">{
                pos.Filename = "&lt;stream&gt;"
        }</span>
        <span class="cov0" title="0">return positionStringFormatfunc(pos)</span>
}

// IsValid returns true if line number is &gt; 0.
func (pos Position) IsValid() bool <span class="cov0" title="0">{
        return pos.LineNumber &gt; 0
}</span>

var positionStringFormatfunc func(p Position) string

func createPositionStringFormatter(formatStr string) func(p Position) string <span class="cov8" title="1">{

        if formatStr == "" </span><span class="cov8" title="1">{
                formatStr = "\":file::line::col\""
        }</span>

        <span class="cov8" title="1">var identifiers = []string{":file", ":line", ":col"}
        var identifiersFound []string

        for i := range formatStr </span><span class="cov8" title="1">{
                for _, id := range identifiers </span><span class="cov8" title="1">{
                        if strings.HasPrefix(formatStr[i:], id) </span><span class="cov8" title="1">{
                                identifiersFound = append(identifiersFound, id)
                        }</span>
                }
        }

        <span class="cov8" title="1">replacer := strings.NewReplacer(":file", "%s", ":line", "%d", ":col", "%d")
        format := replacer.Replace(formatStr)

        f := func(pos Position) string </span><span class="cov0" title="0">{
                args := make([]interface{}, len(identifiersFound))
                for i, id := range identifiersFound </span><span class="cov0" title="0">{
                        switch id </span>{
                        case ":file":<span class="cov0" title="0">
                                args[i] = pos.Filename</span>
                        case ":line":<span class="cov0" title="0">
                                args[i] = pos.LineNumber</span>
                        case ":col":<span class="cov0" title="0">
                                args[i] = pos.ColumnNumber</span>
                        }
                }

                <span class="cov0" title="0">msg := fmt.Sprintf(format, args...)

                if terminal.IsTerminal(os.Stdout) </span><span class="cov0" title="0">{
                        return terminal.Notice(msg)
                }</span>

                <span class="cov0" title="0">return msg</span>
        }

        <span class="cov8" title="1">return f</span>
}

func init() <span class="cov8" title="1">{
        positionStringFormatfunc = createPositionStringFormatter(os.Getenv("HUGO_FILE_LOG_FORMAT"))
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package types contains types shared between packages in Hugo.
package types

import (
        "sync"
)

// EvictingStringQueue is a queue which automatically evicts elements from the head of
// the queue when attempting to add new elements onto the queue and it is full.
// This queue orders elements LIFO (last-in-first-out). It throws away duplicates.
// Note: This queue currently does not contain any remove (poll etc.) methods.
type EvictingStringQueue struct {
        size int
        vals []string
        set  map[string]bool
        mu   sync.Mutex
}

// NewEvictingStringQueue creates a new queue with the given size.
func NewEvictingStringQueue(size int) *EvictingStringQueue <span class="cov8" title="1">{
        return &amp;EvictingStringQueue{size: size, set: make(map[string]bool)}
}</span>

// Add adds a new string to the tail of the queue if it's not already there.
func (q *EvictingStringQueue) Add(v string) <span class="cov0" title="0">{
        q.mu.Lock()
        if q.set[v] </span><span class="cov0" title="0">{
                q.mu.Unlock()
                return
        }</span>

        <span class="cov0" title="0">if len(q.set) == q.size </span><span class="cov0" title="0">{
                // Full
                delete(q.set, q.vals[0])
                q.vals = append(q.vals[:0], q.vals[1:]...)
        }</span>
        <span class="cov0" title="0">q.set[v] = true
        q.vals = append(q.vals, v)
        q.mu.Unlock()</span>
}

// Contains returns whether the queue contains v.
func (q *EvictingStringQueue) Contains(v string) bool <span class="cov0" title="0">{
        q.mu.Lock()
        defer q.mu.Unlock()
        return q.set[v]
}</span>

// Peek looks at the last element added to the queue.
func (q *EvictingStringQueue) Peek() string <span class="cov0" title="0">{
        q.mu.Lock()
        l := len(q.vals)
        if l == 0 </span><span class="cov0" title="0">{
                q.mu.Unlock()
                return ""
        }</span>
        <span class="cov0" title="0">elem := q.vals[l-1]
        q.mu.Unlock()
        return elem</span>
}

// PeekAll looks at all the elements in the queue, with the newest first.
func (q *EvictingStringQueue) PeekAll() []string <span class="cov0" title="0">{
        q.mu.Lock()
        vals := make([]string, len(q.vals))
        copy(vals, q.vals)
        q.mu.Unlock()
        for i, j := 0, len(vals)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                vals[i], vals[j] = vals[j], vals[i]
        }</span>
        <span class="cov0" title="0">return vals</span>
}

// PeekAllSet returns PeekAll as a set.
func (q *EvictingStringQueue) PeekAllSet() map[string]bool <span class="cov0" title="0">{
        all := q.PeekAll()
        set := make(map[string]bool)
        for _, v := range all </span><span class="cov0" title="0">{
                set[v] = true
        }</span>

        <span class="cov0" title="0">return set</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package types contains types shared between packages in Hugo.
package types

import (
        "fmt"
        "reflect"

        "github.com/spf13/cast"
)

// KeyValueStr is a string tuple.
type KeyValueStr struct {
        Key   string
        Value string
}

// KeyValues holds an key and a slice of values.
type KeyValues struct {
        Key    interface{}
        Values []interface{}
}

// KeyString returns the key as a string, an empty string if conversion fails.
func (k KeyValues) KeyString() string <span class="cov0" title="0">{
        return cast.ToString(k.Key)
}</span>

func (k KeyValues) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v: %v", k.Key, k.Values)
}</span>

// NewKeyValuesStrings takes a given key and slice of values and returns a new
// KeyValues struct.
func NewKeyValuesStrings(key string, values ...string) KeyValues <span class="cov0" title="0">{
        iv := make([]interface{}, len(values))
        for i := 0; i &lt; len(values); i++ </span><span class="cov0" title="0">{
                iv[i] = values[i]
        }</span>
        <span class="cov0" title="0">return KeyValues{Key: key, Values: iv}</span>
}

// Zeroer, as implemented by time.Time, will be used by the truth template
// funcs in Hugo (if, with, not, and, or).
type Zeroer interface {
        IsZero() bool
}

// IsNil reports whether v is nil.
func IsNil(v interface{}) bool <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">value := reflect.ValueOf(v)
        switch value.Kind() </span>{
        case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:<span class="cov0" title="0">
                return value.IsNil()</span>
        }

        <span class="cov8" title="1">return false</span>
}

// DevMarker is a marker interface for types that should only be used during
// development.
type DevMarker interface {
        DevOnly()
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package compare

import (
        "strings"
        "unicode"
        "unicode/utf8"
)

// Strings returns an integer comparing two strings lexicographically.
func Strings(s, t string) int <span class="cov8" title="1">{
        c := compareFold(s, t)

        if c == 0 </span><span class="cov0" title="0">{
                // "B" and "b" would be the same so we need a tiebreaker.
                return strings.Compare(s, t)
        }</span>

        <span class="cov8" title="1">return c</span>
}

// This function is derived from strings.EqualFold in Go's stdlib.
// https://github.com/golang/go/blob/ad4a58e31501bce5de2aad90a620eaecdc1eecb8/src/strings/strings.go#L893
func compareFold(s, t string) int <span class="cov8" title="1">{
        for s != "" &amp;&amp; t != "" </span><span class="cov8" title="1">{
                var sr, tr rune
                if s[0] &lt; utf8.RuneSelf </span><span class="cov8" title="1">{
                        sr, s = rune(s[0]), s[1:]
                }</span> else<span class="cov0" title="0"> {
                        r, size := utf8.DecodeRuneInString(s)
                        sr, s = r, s[size:]
                }</span>
                <span class="cov8" title="1">if t[0] &lt; utf8.RuneSelf </span><span class="cov8" title="1">{
                        tr, t = rune(t[0]), t[1:]
                }</span> else<span class="cov0" title="0"> {
                        r, size := utf8.DecodeRuneInString(t)
                        tr, t = r, t[size:]
                }</span>

                <span class="cov8" title="1">if tr == sr </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">c := 1
                if tr &lt; sr </span><span class="cov8" title="1">{
                        tr, sr = sr, tr
                        c = -c
                }</span>

                //  ASCII only.
                <span class="cov8" title="1">if tr &lt; utf8.RuneSelf </span><span class="cov8" title="1">{
                        if sr &gt;= 'A' &amp;&amp; sr &lt;= 'Z' </span><span class="cov8" title="1">{
                                if tr &lt;= 'Z' </span><span class="cov8" title="1">{
                                        // Same case.
                                        return -c
                                }</span>

                                <span class="cov0" title="0">diff := tr - (sr + 'a' - 'A')

                                if diff == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">if diff &lt; 0 </span><span class="cov0" title="0">{
                                        return c
                                }</span>

                                <span class="cov0" title="0">if diff &gt; 0 </span><span class="cov0" title="0">{
                                        return -c
                                }</span>
                        }
                }

                // Unicode.
                <span class="cov0" title="0">r := unicode.SimpleFold(sr)
                for r != sr &amp;&amp; r &lt; tr </span><span class="cov0" title="0">{
                        r = unicode.SimpleFold(r)
                }</span>

                <span class="cov0" title="0">if r == tr </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">return -c</span>
        }

        <span class="cov0" title="0">if s == "" &amp;&amp; t == "" </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">if s == "" </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">return 1</span>
}

// LessStrings returns whether s is less than t lexicographically.
func LessStrings(s, t string) bool <span class="cov0" title="0">{
        return Strings(s, t) &lt; 0
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/parser/metadecoders"
        "github.com/spf13/afero"
        "github.com/spf13/viper"
)

var (
        ValidConfigFileExtensions                    = []string{"toml", "yaml", "yml", "json"}
        validConfigFileExtensionsMap map[string]bool = make(map[string]bool)
)

func init() <span class="cov8" title="1">{
        for _, ext := range ValidConfigFileExtensions </span><span class="cov8" title="1">{
                validConfigFileExtensionsMap[ext] = true
        }</span>
}

// IsValidConfigFilename returns whether filename is one of the supported
// config formats in Hugo.
func IsValidConfigFilename(filename string) bool <span class="cov0" title="0">{
        ext := strings.ToLower(strings.TrimPrefix(filepath.Ext(filename), "."))
        return validConfigFileExtensionsMap[ext]
}</span>

// FromConfigString creates a config from the given YAML, JSON or TOML config. This is useful in tests.
func FromConfigString(config, configType string) (Provider, error) <span class="cov0" title="0">{
        v := newViper()
        m, err := readConfig(metadecoders.FormatFromString(configType), []byte(config))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">v.MergeConfigMap(m)

        return v, nil</span>
}

// FromFile loads the configuration from the given filename.
func FromFile(fs afero.Fs, filename string) (Provider, error) <span class="cov0" title="0">{
        m, err := loadConfigFromFile(fs, filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">v := newViper()

        err = v.MergeConfigMap(m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return v, nil</span>
}

// FromFileToMap is the same as FromFile, but it returns the config values
// as a simple map.
func FromFileToMap(fs afero.Fs, filename string) (map[string]interface{}, error) <span class="cov8" title="1">{
        return loadConfigFromFile(fs, filename)
}</span>

func readConfig(format metadecoders.Format, data []byte) (map[string]interface{}, error) <span class="cov0" title="0">{
        m, err := metadecoders.Default.UnmarshalToMap(data, format)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">RenameKeys(m)

        return m, nil</span>

}

func loadConfigFromFile(fs afero.Fs, filename string) (map[string]interface{}, error) <span class="cov8" title="1">{
        m, err := metadecoders.Default.UnmarshalFileToMap(fs, filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">RenameKeys(m)
        return m, nil</span>
}

var keyAliases maps.KeyRenamer

func init() <span class="cov8" title="1">{
        var err error
        keyAliases, err = maps.NewKeyRenamer(
                // Before 0.53 we used singular for "menu".
                "{menu,languages/*/menu}", "menus",
        )

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// RenameKeys renames config keys in m recursively according to a global Hugo
// alias definition.
func RenameKeys(m map[string]interface{}) <span class="cov8" title="1">{
        keyAliases.Rename(m)
}</span>

func newViper() *viper.Viper <span class="cov0" title="0">{
        v := viper.New()

        return v
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
        "github.com/spf13/cast"
)

// Provider provides the configuration settings for Hugo.
type Provider interface {
        GetString(key string) string
        GetInt(key string) int
        GetBool(key string) bool
        GetStringMap(key string) map[string]interface{}
        GetStringMapString(key string) map[string]string
        GetStringSlice(key string) []string
        Get(key string) interface{}
        Set(key string, value interface{})
        IsSet(key string) bool
}

// GetStringSlicePreserveString returns a string slice from the given config and key.
// It differs from the GetStringSlice method in that if the config value is a string,
// we do not attempt to split it into fields.
func GetStringSlicePreserveString(cfg Provider, key string) []string <span class="cov8" title="1">{
        sd := cfg.Get(key)
        return toStringSlicePreserveString(sd)
}</span>

func toStringSlicePreserveString(v interface{}) []string <span class="cov8" title="1">{
        if sds, ok := v.(string); ok </span><span class="cov8" title="1">{
                return []string{sds}
        }</span>
        <span class="cov8" title="1">return cast.ToStringSlice(v)</span>
}

// SetBaseTestDefaults provides some common config defaults used in tests.
func SetBaseTestDefaults(cfg Provider) <span class="cov0" title="0">{
        cfg.Set("resourceDir", "resources")
        cfg.Set("contentDir", "content")
        cfg.Set("dataDir", "data")
        cfg.Set("i18nDir", "i18n")
        cfg.Set("layoutDir", "layouts")
        cfg.Set("assetDir", "assets")
        cfg.Set("archetypeDir", "archetypes")
        cfg.Set("publishDir", "public")
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
        "os"
        "runtime"
        "strconv"
        "strings"
)

// GetNumWorkerMultiplier returns the base value used to calculate the number
// of workers to use for Hugo's parallel execution.
// It returns the value in HUGO_NUMWORKERMULTIPLIER OS env variable if set to a
// positive integer, else the number of logical CPUs.
func GetNumWorkerMultiplier() int <span class="cov8" title="1">{
        if gmp := os.Getenv("HUGO_NUMWORKERMULTIPLIER"); gmp != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(gmp); err == nil &amp;&amp; p &gt; 0 </span><span class="cov0" title="0">{
                        return p
                }</span>
        }
        <span class="cov8" title="1">return runtime.NumCPU()</span>
}

// SetEnvVars sets vars on the form key=value in the oldVars slice.
func SetEnvVars(oldVars *[]string, keyValues ...string) <span class="cov8" title="1">{
        for i := 0; i &lt; len(keyValues); i += 2 </span><span class="cov8" title="1">{
                setEnvVar(oldVars, keyValues[i], keyValues[i+1])
        }</span>
}

func SplitEnvVar(v string) (string, string) <span class="cov8" title="1">{
        parts := strings.Split(v, "=")
        return parts[0], parts[1]
}</span>

func setEnvVar(vars *[]string, key, value string) <span class="cov8" title="1">{
        for i := range *vars </span><span class="cov8" title="1">{
                if strings.HasPrefix((*vars)[i], key+"=") </span><span class="cov8" title="1">{
                        (*vars)[i] = key + "=" + value
                        return
                }</span>
        }
        // New var.
        <span class="cov8" title="1">*vars = append(*vars, key+"="+value)</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package privacy

import (
        "github.com/gohugoio/hugo/config"
        "github.com/mitchellh/mapstructure"
)

const privacyConfigKey = "privacy"

// Service is the common values for a service in a policy definition.
type Service struct {
        Disable bool
}

// Config is a privacy configuration for all the relevant services in Hugo.
type Config struct {
        Disqus          Disqus
        GoogleAnalytics GoogleAnalytics
        Instagram       Instagram
        Twitter         Twitter
        Vimeo           Vimeo
        YouTube         YouTube
}

// Disqus holds the privacy configuration settings related to the Disqus template.
type Disqus struct {
        Service `mapstructure:",squash"`
}

// GoogleAnalytics holds the privacy configuration settings related to the Google Analytics template.
type GoogleAnalytics struct {
        Service `mapstructure:",squash"`

        // Enabling this will disable the use of Cookies and use Session Storage to Store the GA Client ID.
        UseSessionStorage bool

        // Enabling this will make the GA templates respect the
        // "Do Not Track" HTTP header. See  https://www.paulfurley.com/google-analytics-dnt/.
        RespectDoNotTrack bool

        // Enabling this will make it so the users' IP addresses are anonymized within Google Analytics.
        AnonymizeIP bool
}

// Instagram holds the privacy configuration settings related to the Instagram shortcode.
type Instagram struct {
        Service `mapstructure:",squash"`

        // If simple mode is enabled, a static and no-JS version of the Instagram
        // image card will be built.
        Simple bool
}

// Twitter holds the privacy configuration settingsrelated to the Twitter shortcode.
type Twitter struct {
        Service `mapstructure:",squash"`

        // When set to true, the Tweet and its embedded page on your site are not used
        // for purposes that include personalized suggestions and personalized ads.
        EnableDNT bool

        // If simple mode is enabled, a static and no-JS version of the Tweet will be built.
        Simple bool
}

// Vimeo holds the privacy configuration settingsrelated to the Vimeo shortcode.
type Vimeo struct {
        Service `mapstructure:",squash"`

        // If simple mode is enabled, only a thumbnail is fetched from i.vimeocdn.com and
        // shown with a play button overlaid. If a user clicks the button, he/she will
        // be taken to the video page on vimeo.com in a new browser tab.
        Simple bool
}

// YouTube holds the privacy configuration settingsrelated to the YouTube shortcode.
type YouTube struct {
        Service `mapstructure:",squash"`

        // When you turn on privacy-enhanced mode,
        // YouTube wont store information about visitors on your website
        // unless the user plays the embedded video.
        PrivacyEnhanced bool
}

// DecodeConfig creates a privacy Config from a given Hugo configuration.
func DecodeConfig(cfg config.Provider) (pc Config, err error) <span class="cov8" title="1">{
        if !cfg.IsSet(privacyConfigKey) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">m := cfg.GetStringMap(privacyConfigKey)

        err = mapstructure.WeakDecode(m, &amp;pc)

        return</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package services

import (
        "github.com/gohugoio/hugo/config"
        "github.com/mitchellh/mapstructure"
)

const (
        servicesConfigKey = "services"

        disqusShortnameKey = "disqusshortname"
        googleAnalyticsKey = "googleanalytics"
        rssLimitKey        = "rssLimit"
)

// Config is a privacy configuration for all the relevant services in Hugo.
type Config struct {
        Disqus          Disqus
        GoogleAnalytics GoogleAnalytics
        Instagram       Instagram
        Twitter         Twitter
        RSS             RSS
}

// Disqus holds the functional configuration settings related to the Disqus template.
type Disqus struct {
        // A Shortname is the unique identifier assigned to a Disqus site.
        Shortname string
}

// GoogleAnalytics holds the functional configuration settings related to the Google Analytics template.
type GoogleAnalytics struct {
        // The GA tracking ID.
        ID string
}

// Instagram holds the functional configuration settings related to the Instagram shortcodes.
type Instagram struct {
        // The Simple variant of the Instagram is decorated with Bootstrap 4 card classes.
        // This means that if you use Bootstrap 4 or want to provide your own CSS, you want
        // to disable the inline CSS provided by Hugo.
        DisableInlineCSS bool
}

// Twitter holds the functional configuration settings related to the Twitter shortcodes.
type Twitter struct {
        // The Simple variant of Twitter is decorated with a basic set of inline styles.
        // This means that if you want to provide your own CSS, you want
        // to disable the inline CSS provided by Hugo.
        DisableInlineCSS bool
}

// RSS holds the functional configuration settings related to the RSS feeds.
type RSS struct {
        // Limit the number of pages.
        Limit int
}

// DecodeConfig creates a services Config from a given Hugo configuration.
func DecodeConfig(cfg config.Provider) (c Config, err error) <span class="cov8" title="1">{
        m := cfg.GetStringMap(servicesConfigKey)

        err = mapstructure.WeakDecode(m, &amp;c)

        // Keep backwards compatibility.
        if c.GoogleAnalytics.ID == "" </span><span class="cov8" title="1">{
                // Try the global config
                c.GoogleAnalytics.ID = cfg.GetString(googleAnalyticsKey)
        }</span>
        <span class="cov8" title="1">if c.Disqus.Shortname == "" </span><span class="cov8" title="1">{
                c.Disqus.Shortname = cfg.GetString(disqusShortnameKey)
        }</span>

        <span class="cov8" title="1">if c.RSS.Limit == 0 </span><span class="cov8" title="1">{
                c.RSS.Limit = cfg.GetInt(rssLimitKey)
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
        "github.com/spf13/cast"
        jww "github.com/spf13/jwalterweatherman"
)

// Sitemap configures the sitemap to be generated.
type Sitemap struct {
        ChangeFreq string
        Priority   float64
        Filename   string
}

func DecodeSitemap(prototype Sitemap, input map[string]interface{}) Sitemap <span class="cov8" title="1">{

        for key, value := range input </span><span class="cov0" title="0">{
                switch key </span>{
                case "changefreq":<span class="cov0" title="0">
                        prototype.ChangeFreq = cast.ToString(value)</span>
                case "priority":<span class="cov0" title="0">
                        prototype.Priority = cast.ToFloat64(value)</span>
                case "filename":<span class="cov0" title="0">
                        prototype.Filename = cast.ToString(value)</span>
                default:<span class="cov0" title="0">
                        jww.WARN.Printf("Unknown Sitemap field: %s\n", key)</span>
                }
        }

        <span class="cov8" title="1">return prototype</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package create provides functions to create new content.
package create

import (
        "bytes"

        "github.com/pkg/errors"

        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugolib"
        "github.com/spf13/afero"
        jww "github.com/spf13/jwalterweatherman"
)

// NewContent creates a new content file in the content directory based upon the
// given kind, which is used to lookup an archetype.
func NewContent(
        sites *hugolib.HugoSites, kind, targetPath string) error <span class="cov0" title="0">{
        targetPath = filepath.Clean(targetPath)
        ext := helpers.Ext(targetPath)
        ps := sites.PathSpec
        archetypeFs := ps.BaseFs.SourceFilesystems.Archetypes.Fs
        sourceFs := ps.Fs.Source

        jww.INFO.Printf("attempting to create %q of %q of ext %q", targetPath, kind, ext)

        archetypeFilename, isDir := findArchetype(ps, kind, ext)
        contentPath, s := resolveContentPath(sites, sourceFs, targetPath)

        if isDir </span><span class="cov0" title="0">{

                langFs, err := hugofs.NewLanguageFs(sites.LanguageSet(), archetypeFs)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">cm, err := mapArcheTypeDir(ps, langFs, archetypeFilename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if cm.siteUsed </span><span class="cov0" title="0">{
                        if err := sites.Build(hugolib.BuildCfg{SkipRender: true}); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">name := filepath.Base(targetPath)
                return newContentFromDir(archetypeFilename, sites, sourceFs, cm, name, contentPath)</span>
        }

        // Building the sites can be expensive, so only do it if really needed.
        <span class="cov0" title="0">siteUsed := false

        if archetypeFilename != "" </span><span class="cov0" title="0">{

                var err error
                siteUsed, err = usesSiteVar(archetypeFs, archetypeFilename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if siteUsed </span><span class="cov0" title="0">{
                if err := sites.Build(hugolib.BuildCfg{SkipRender: true}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">content, err := executeArcheTypeAsTemplate(s, "", kind, targetPath, archetypeFilename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := helpers.SafeWriteToDisk(contentPath, bytes.NewReader(content), s.Fs.Source); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">jww.FEEDBACK.Println(contentPath, "created")

        editor := s.Cfg.GetString("newContentEditor")
        if editor != "" </span><span class="cov0" title="0">{
                jww.FEEDBACK.Printf("Editing %s with %q ...\n", targetPath, editor)

                cmd := exec.Command(editor, contentPath)
                cmd.Stdin = os.Stdin
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr

                return cmd.Run()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func targetSite(sites *hugolib.HugoSites, fi hugofs.FileMetaInfo) *hugolib.Site <span class="cov0" title="0">{
        for _, s := range sites.Sites </span><span class="cov0" title="0">{
                if fi.Meta().Lang() == s.Language().Lang </span><span class="cov0" title="0">{
                        return s
                }</span>
        }
        <span class="cov0" title="0">return sites.Sites[0]</span>
}

func newContentFromDir(
        archetypeDir string,
        sites *hugolib.HugoSites,
        targetFs afero.Fs,
        cm archetypeMap, name, targetPath string) error <span class="cov0" title="0">{

        for _, f := range cm.otherFiles </span><span class="cov0" title="0">{
                meta := f.Meta()
                filename := meta.Path()
                // Just copy the file to destination.
                in, err := meta.Open()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to open non-content file")
                }</span>

                <span class="cov0" title="0">targetFilename := filepath.Join(targetPath, strings.TrimPrefix(filename, archetypeDir))

                targetDir := filepath.Dir(targetFilename)
                if err := targetFs.MkdirAll(targetDir, 0777); err != nil &amp;&amp; !os.IsExist(err) </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to create target directory for %s:", targetDir)
                }</span>

                <span class="cov0" title="0">out, err := targetFs.Create(targetFilename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = io.Copy(out, in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">in.Close()
                out.Close()</span>
        }

        <span class="cov0" title="0">for _, f := range cm.contentFiles </span><span class="cov0" title="0">{
                filename := f.Meta().Path()
                s := targetSite(sites, f)
                targetFilename := filepath.Join(targetPath, strings.TrimPrefix(filename, archetypeDir))

                content, err := executeArcheTypeAsTemplate(s, name, archetypeDir, targetFilename, filename)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to execute archetype template")
                }</span>

                <span class="cov0" title="0">if err := helpers.SafeWriteToDisk(targetFilename, bytes.NewReader(content), targetFs); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to save results")
                }</span>
        }

        <span class="cov0" title="0">jww.FEEDBACK.Println(targetPath, "created")

        return nil</span>
}

type archetypeMap struct {
        // These needs to be parsed and executed as Go templates.
        contentFiles []hugofs.FileMetaInfo
        // These are just copied to destination.
        otherFiles []hugofs.FileMetaInfo
        // If the templates needs a fully built site. This can potentially be
        // expensive, so only do when needed.
        siteUsed bool
}

func mapArcheTypeDir(
        ps *helpers.PathSpec,
        fs afero.Fs,
        archetypeDir string) (archetypeMap, error) <span class="cov0" title="0">{

        var m archetypeMap

        walkFn := func(path string, fi hugofs.FileMetaInfo, err error) error </span><span class="cov0" title="0">{

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">fil := fi.(hugofs.FileMetaInfo)

                if files.IsContentFile(path) </span><span class="cov0" title="0">{
                        m.contentFiles = append(m.contentFiles, fil)
                        if !m.siteUsed </span><span class="cov0" title="0">{
                                m.siteUsed, err = usesSiteVar(fs, path)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">m.otherFiles = append(m.otherFiles, fil)

                return nil</span>
        }

        <span class="cov0" title="0">walkCfg := hugofs.WalkwayConfig{
                WalkFn: walkFn,
                Fs:     fs,
                Root:   archetypeDir,
        }

        w := hugofs.NewWalkway(walkCfg)

        if err := w.Walk(); err != nil </span><span class="cov0" title="0">{
                return m, errors.Wrapf(err, "failed to walk archetype dir %q", archetypeDir)
        }</span>

        <span class="cov0" title="0">return m, nil</span>
}

func usesSiteVar(fs afero.Fs, filename string) (bool, error) <span class="cov0" title="0">{
        f, err := fs.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed to open archetype file")
        }</span>
        <span class="cov0" title="0">defer f.Close()
        return helpers.ReaderContains(f, []byte(".Site")), nil</span>
}

// Resolve the target content path.
func resolveContentPath(sites *hugolib.HugoSites, fs afero.Fs, targetPath string) (string, *hugolib.Site) <span class="cov0" title="0">{
        targetDir := filepath.Dir(targetPath)
        first := sites.Sites[0]

        var (
                s              *hugolib.Site
                siteContentDir string
        )

        // Try the filename: my-post.en.md
        for _, ss := range sites.Sites </span><span class="cov0" title="0">{
                if strings.Contains(targetPath, "."+ss.Language().Lang+".") </span><span class="cov0" title="0">{
                        s = ss
                        break</span>
                }
        }

        <span class="cov0" title="0">var dirLang string

        for _, dir := range sites.BaseFs.Content.Dirs </span><span class="cov0" title="0">{
                meta := dir.Meta()
                contentDir := meta.Filename()

                if !strings.HasSuffix(contentDir, helpers.FilePathSeparator) </span><span class="cov0" title="0">{
                        contentDir += helpers.FilePathSeparator
                }</span>

                <span class="cov0" title="0">if strings.HasPrefix(targetPath, contentDir) </span><span class="cov0" title="0">{
                        siteContentDir = contentDir
                        dirLang = meta.Lang()
                        break</span>
                }
        }

        <span class="cov0" title="0">if s == nil &amp;&amp; dirLang != "" </span><span class="cov0" title="0">{
                for _, ss := range sites.Sites </span><span class="cov0" title="0">{
                        if ss.Lang() == dirLang </span><span class="cov0" title="0">{
                                s = ss
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if s == nil </span><span class="cov0" title="0">{
                s = first
        }</span>

        <span class="cov0" title="0">if targetDir != "" &amp;&amp; targetDir != "." </span><span class="cov0" title="0">{
                exists, _ := helpers.Exists(targetDir, fs)

                if exists </span><span class="cov0" title="0">{
                        return targetPath, s
                }</span>
        }

        <span class="cov0" title="0">if siteContentDir == "" </span>{<span class="cov0" title="0">

        }</span>

        <span class="cov0" title="0">if siteContentDir != "" </span><span class="cov0" title="0">{
                pp := filepath.Join(siteContentDir, strings.TrimPrefix(targetPath, siteContentDir))
                return s.PathSpec.AbsPathify(pp), s
        }</span> else<span class="cov0" title="0"> {
                var contentDir string
                for _, dir := range sites.BaseFs.Content.Dirs </span><span class="cov0" title="0">{
                        contentDir = dir.Meta().Filename()
                        if dir.Meta().Lang() == s.Lang() </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">return s.PathSpec.AbsPathify(filepath.Join(contentDir, targetPath)), s</span>
        }

}

// FindArchetype takes a given kind/archetype of content and returns the path
// to the archetype in the archetype filesystem, blank if none found.
func findArchetype(ps *helpers.PathSpec, kind, ext string) (outpath string, isDir bool) <span class="cov0" title="0">{
        fs := ps.BaseFs.Archetypes.Fs

        var pathsToCheck []string

        if kind != "" </span><span class="cov0" title="0">{
                pathsToCheck = append(pathsToCheck, kind+ext)
        }</span>
        <span class="cov0" title="0">pathsToCheck = append(pathsToCheck, "default"+ext, "default")

        for _, p := range pathsToCheck </span><span class="cov0" title="0">{
                fi, err := fs.Stat(p)
                if err == nil </span><span class="cov0" title="0">{
                        return p, fi.IsDir()
                }</span>
        }

        <span class="cov0" title="0">return "", false</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package create

import (
        "bytes"
        "fmt"
        "path/filepath"
        "strings"
        "time"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/source"

        "github.com/gohugoio/hugo/hugolib"
        "github.com/gohugoio/hugo/tpl"
        "github.com/spf13/afero"
)

// ArchetypeFileData represents the data available to an archetype template.
type ArchetypeFileData struct {
        // The archetype content type, either given as --kind option or extracted
        // from the target path's section, i.e. "blog/mypost.md" will resolve to
        // "blog".
        Type string

        // The current date and time as a RFC3339 formatted string, suitable for use in front matter.
        Date string

        // The Site, fully equipped with all the pages etc. Note: This will only be set if it is actually
        // used in the archetype template. Also, if this is a multilingual setup,
        // this site is the site that best matches the target content file, based
        // on the presence of language code in the filename.
        Site *hugolib.SiteInfo

        // Name will in most cases be the same as TranslationBaseName, e.g. "my-post".
        // But if that value is "index" (bundles), the Name is instead the owning folder.
        // This is the value you in most cases would want to use to construct the title in your
        // archetype template.
        Name string

        // The target content file. Note that the .Content will be empty, as that
        // has not been created yet.
        source.File
}

const (
        // ArchetypeTemplateTemplate is used as initial template when adding an archetype template.
        ArchetypeTemplateTemplate = `---
title: "{{ replace .Name "-" " " | title }}"
date: {{ .Date }}
draft: true
---

`
)

var (
        archetypeShortcodeReplacementsPre = strings.NewReplacer(
                "{{&lt;", "{x{&lt;",
                "{{%", "{x{%",
                "&gt;}}", "&gt;}x}",
                "%}}", "%}x}")

        archetypeShortcodeReplacementsPost = strings.NewReplacer(
                "{x{&lt;", "{{&lt;",
                "{x{%", "{{%",
                "&gt;}x}", "&gt;}}",
                "%}x}", "%}}")
)

func executeArcheTypeAsTemplate(s *hugolib.Site, name, kind, targetPath, archetypeFilename string) ([]byte, error) <span class="cov0" title="0">{

        var (
                archetypeContent  []byte
                archetypeTemplate []byte
                err               error
        )

        f, err := s.SourceSpec.NewFileInfoFrom(targetPath, targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                name = f.TranslationBaseName()

                if name == "index" || name == "_index" </span><span class="cov0" title="0">{
                        // Page bundles; the directory name will hopefully have a better name.
                        dir := strings.TrimSuffix(f.Dir(), helpers.FilePathSeparator)
                        _, name = filepath.Split(dir)
                }</span>
        }

        <span class="cov0" title="0">data := ArchetypeFileData{
                Type: kind,
                Date: time.Now().Format(time.RFC3339),
                Name: name,
                File: f,
                Site: &amp;s.Info,
        }

        if archetypeFilename == "" </span><span class="cov0" title="0">{
                // TODO(bep) archetype revive the issue about wrong tpl funcs arg order
                archetypeTemplate = []byte(ArchetypeTemplateTemplate)
        }</span> else<span class="cov0" title="0"> {
                archetypeTemplate, err = afero.ReadFile(s.BaseFs.Archetypes.Fs, archetypeFilename)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read archetype file %s", err)
                }</span>

        }

        // The archetype template may contain shortcodes, and these does not play well
        // with the Go templates. Need to set some temporary delimiters.
        <span class="cov0" title="0">archetypeTemplate = []byte(archetypeShortcodeReplacementsPre.Replace(string(archetypeTemplate)))

        // Reuse the Hugo template setup to get the template funcs properly set up.
        templateHandler := s.Deps.Tmpl.(tpl.TemplateHandler)
        templateName := "_text/" + helpers.Filename(archetypeFilename)
        if err := templateHandler.AddTemplate(templateName, string(archetypeTemplate)); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "Failed to parse archetype file %q:", archetypeFilename)
        }</span>

        <span class="cov0" title="0">templ, _ := templateHandler.Lookup(templateName)

        var buff bytes.Buffer
        if err := templ.Execute(&amp;buff, data); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "Failed to process archetype file %q:", archetypeFilename)
        }</span>

        <span class="cov0" title="0">archetypeContent = []byte(archetypeShortcodeReplacementsPost.Replace(buff.String()))

        return archetypeContent, nil</span>

}
</pre>
		
		<pre class="file" id="file64" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package deploy

import (
        "context"
        "time"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/cloudfront"
)

// InvalidateCloudFront invalidates the CloudFront cache for distributionID.
// It uses the default AWS credentials from the environment.
func InvalidateCloudFront(ctx context.Context, distributionID string) error <span class="cov0" title="0">{
        // SharedConfigEnable enables loading "shared config (~/.aws/config) and
        // shared credentials (~/.aws/credentials) files".
        // See https://docs.aws.amazon.com/sdk-for-go/api/aws/session/ for more
        // details.
        // This is the same codepath used by Go CDK when creating an s3 URL.
        // TODO: Update this to a Go CDK helper once available
        // (https://github.com/google/go-cloud/issues/2003).
        sess, err := session.NewSessionWithOptions(session.Options{SharedConfigState: session.SharedConfigEnable})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">req := &amp;cloudfront.CreateInvalidationInput{
                DistributionId: aws.String(distributionID),
                InvalidationBatch: &amp;cloudfront.InvalidationBatch{
                        CallerReference: aws.String(time.Now().Format("20060102150405")),
                        Paths: &amp;cloudfront.Paths{
                                Items:    []*string{aws.String("/*")},
                                Quantity: aws.Int64(1),
                        },
                },
        }
        _, err = cloudfront.New(sess).CreateInvalidationWithContext(ctx, req)
        return err</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package deploy

import (
        "bytes"
        "compress/gzip"
        "context"
        "crypto/md5"
        "fmt"
        "io"
        "io/ioutil"
        "mime"
        "os"
        "path/filepath"
        "regexp"
        "runtime"
        "sort"
        "strings"
        "sync"

        "github.com/dustin/go-humanize"
        "github.com/gohugoio/hugo/config"
        "github.com/pkg/errors"
        "github.com/spf13/afero"
        jww "github.com/spf13/jwalterweatherman"
        "golang.org/x/text/unicode/norm"

        "gocloud.dev/blob"
        _ "gocloud.dev/blob/azureblob" // import
        _ "gocloud.dev/blob/fileblob"  // import
        _ "gocloud.dev/blob/gcsblob"   // import
        _ "gocloud.dev/blob/s3blob"    // import
)

// Deployer supports deploying the site to target cloud providers.
type Deployer struct {
        localFs afero.Fs
        bucket  *blob.Bucket

        target        *target          // the target to deploy to
        matchers      []*matcher       // matchers to apply to uploaded files
        ordering      []*regexp.Regexp // orders uploads
        quiet         bool             // true reduces STDOUT
        confirm       bool             // true enables confirmation before making changes
        dryRun        bool             // true skips conformations and prints changes instead of applying them
        force         bool             // true forces upload of all files
        invalidateCDN bool             // true enables invalidate CDN cache (if possible)
        maxDeletes    int              // caps the # of files to delete; -1 to disable

        // For tests...
        summary deploySummary // summary of latest Deploy results
}

type deploySummary struct {
        NumLocal, NumRemote, NumUploads, NumDeletes int
}

// New constructs a new *Deployer.
func New(cfg config.Provider, localFs afero.Fs) (*Deployer, error) <span class="cov0" title="0">{
        targetName := cfg.GetString("target")

        // Load the [deployment] section of the config.
        dcfg, err := decodeConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(dcfg.Targets) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("no deployment targets found")
        }</span>

        // Find the target to deploy to.
        <span class="cov0" title="0">var tgt *target
        if targetName == "" </span><span class="cov0" title="0">{
                // Default to the first target.
                tgt = dcfg.Targets[0]
        }</span> else<span class="cov0" title="0"> {
                for _, t := range dcfg.Targets </span><span class="cov0" title="0">{
                        if t.Name == targetName </span><span class="cov0" title="0">{
                                tgt = t
                        }</span>
                }
                <span class="cov0" title="0">if tgt == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("deployment target %q not found", targetName)
                }</span>
        }
        <span class="cov0" title="0">return &amp;Deployer{
                localFs:       localFs,
                target:        tgt,
                matchers:      dcfg.Matchers,
                ordering:      dcfg.ordering,
                quiet:         cfg.GetBool("quiet"),
                confirm:       cfg.GetBool("confirm"),
                dryRun:        cfg.GetBool("dryRun"),
                force:         cfg.GetBool("force"),
                invalidateCDN: cfg.GetBool("invalidateCDN"),
                maxDeletes:    cfg.GetInt("maxDeletes"),
        }, nil</span>
}

func (d *Deployer) openBucket(ctx context.Context) (*blob.Bucket, error) <span class="cov0" title="0">{
        if d.bucket != nil </span><span class="cov0" title="0">{
                return d.bucket, nil
        }</span>
        <span class="cov0" title="0">jww.FEEDBACK.Printf("Deploying to target %q (%s)\n", d.target.Name, d.target.URL)
        return blob.OpenBucket(ctx, d.target.URL)</span>
}

// Deploy deploys the site to a target.
func (d *Deployer) Deploy(ctx context.Context) error <span class="cov0" title="0">{
        bucket, err := d.openBucket(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Load local files from the source directory.
        <span class="cov0" title="0">local, err := walkLocal(d.localFs, d.matchers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">jww.INFO.Printf("Found %d local files.\n", len(local))
        d.summary.NumLocal = len(local)

        // Load remote files from the target.
        remote, err := walkRemote(ctx, bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">jww.INFO.Printf("Found %d remote files.\n", len(remote))
        d.summary.NumRemote = len(remote)

        // Diff local vs remote to see what changes need to be applied.
        uploads, deletes := findDiffs(local, remote, d.force)
        d.summary.NumUploads = len(uploads)
        d.summary.NumDeletes = len(deletes)
        if len(uploads)+len(deletes) == 0 </span><span class="cov0" title="0">{
                if !d.quiet </span><span class="cov0" title="0">{
                        jww.FEEDBACK.Println("No changes required.")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">if !d.quiet </span><span class="cov0" title="0">{
                jww.FEEDBACK.Println(summarizeChanges(uploads, deletes))
        }</span>

        // Ask for confirmation before proceeding.
        <span class="cov0" title="0">if d.confirm &amp;&amp; !d.dryRun </span><span class="cov0" title="0">{
                fmt.Printf("Continue? (Y/n) ")
                var confirm string
                if _, err := fmt.Scanln(&amp;confirm); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if confirm != "" &amp;&amp; confirm[0] != 'y' &amp;&amp; confirm[0] != 'Y' </span><span class="cov0" title="0">{
                        return errors.New("aborted")
                }</span>
        }

        // Order the uploads. They are organized in groups; all uploads in a group
        // must be complete before moving on to the next group.
        <span class="cov0" title="0">uploadGroups := applyOrdering(d.ordering, uploads)

        // Apply the changes in parallel, using an inverted worker
        // pool (https://www.youtube.com/watch?v=5zXAHh5tJqQ&amp;t=26m58s).
        // sem prevents more than nParallel concurrent goroutines.
        const nParallel = 10
        var errs []error
        var errMu sync.Mutex // protects errs

        for _, uploads := range uploadGroups </span><span class="cov0" title="0">{
                // Short-circuit for an empty group.
                if len(uploads) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Within the group, apply uploads in parallel.
                <span class="cov0" title="0">sem := make(chan struct{}, nParallel)
                for _, upload := range uploads </span><span class="cov0" title="0">{
                        if d.dryRun </span><span class="cov0" title="0">{
                                if !d.quiet </span><span class="cov0" title="0">{
                                        jww.FEEDBACK.Printf("[DRY RUN] Would upload: %v\n", upload)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov0" title="0">sem &lt;- struct{}{}
                        go func(upload *fileToUpload) </span><span class="cov0" title="0">{
                                if err := doSingleUpload(ctx, bucket, upload); err != nil </span><span class="cov0" title="0">{
                                        errMu.Lock()
                                        defer errMu.Unlock()
                                        errs = append(errs, err)
                                }</span>
                                <span class="cov0" title="0">&lt;-sem</span>
                        }(upload)
                }
                // Wait for all uploads in the group to finish.
                <span class="cov0" title="0">for n := nParallel; n &gt; 0; n-- </span><span class="cov0" title="0">{
                        sem &lt;- struct{}{}
                }</span>
        }

        <span class="cov0" title="0">if d.maxDeletes != -1 &amp;&amp; len(deletes) &gt; d.maxDeletes </span><span class="cov0" title="0">{
                jww.WARN.Printf("Skipping %d deletes because it is more than --maxDeletes (%d). If this is expected, set --maxDeletes to a larger number, or -1 to disable this check.\n", len(deletes), d.maxDeletes)
                d.summary.NumDeletes = 0
        }</span> else<span class="cov0" title="0"> {
                // Apply deletes in parallel.
                sort.Slice(deletes, func(i, j int) bool </span><span class="cov0" title="0">{ return deletes[i] &lt; deletes[j] }</span>)
                <span class="cov0" title="0">sem := make(chan struct{}, nParallel)
                for _, del := range deletes </span><span class="cov0" title="0">{
                        if d.dryRun </span><span class="cov0" title="0">{
                                if !d.quiet </span><span class="cov0" title="0">{
                                        jww.FEEDBACK.Printf("[DRY RUN] Would delete %s\n", del)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">sem &lt;- struct{}{}
                        go func(del string) </span><span class="cov0" title="0">{
                                jww.INFO.Printf("Deleting %s...\n", del)
                                if err := bucket.Delete(ctx, del); err != nil </span><span class="cov0" title="0">{
                                        errMu.Lock()
                                        defer errMu.Unlock()
                                        errs = append(errs, err)
                                }</span>
                                <span class="cov0" title="0">&lt;-sem</span>
                        }(del)
                }
                // Wait for all deletes to finish.
                <span class="cov0" title="0">for n := nParallel; n &gt; 0; n-- </span><span class="cov0" title="0">{
                        sem &lt;- struct{}{}
                }</span>
        }
        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                if !d.quiet </span><span class="cov0" title="0">{
                        jww.FEEDBACK.Printf("Encountered %d errors.\n", len(errs))
                }</span>
                <span class="cov0" title="0">return errs[0]</span>
        }
        <span class="cov0" title="0">if !d.quiet </span><span class="cov0" title="0">{
                jww.FEEDBACK.Println("Success!")
        }</span>

        <span class="cov0" title="0">if d.invalidateCDN &amp;&amp; d.target.CloudFrontDistributionID != "" </span><span class="cov0" title="0">{
                jww.FEEDBACK.Println("Invalidating CloudFront CDN...")
                if err := InvalidateCloudFront(ctx, d.target.CloudFrontDistributionID); err != nil </span><span class="cov0" title="0">{
                        jww.FEEDBACK.Printf("Failed to invalidate CloudFront CDN: %v\n", err)
                        return err
                }</span>
                <span class="cov0" title="0">jww.FEEDBACK.Println("Success!")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// summarizeChanges creates a text description of the proposed changes.
func summarizeChanges(uploads []*fileToUpload, deletes []string) string <span class="cov0" title="0">{
        uploadSize := int64(0)
        for _, u := range uploads </span><span class="cov0" title="0">{
                uploadSize += u.Local.UploadSize
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Identified %d file(s) to upload, totaling %s, and %d file(s) to delete.", len(uploads), humanize.Bytes(uint64(uploadSize)), len(deletes))</span>
}

// doSingleUpload executes a single file upload.
func doSingleUpload(ctx context.Context, bucket *blob.Bucket, upload *fileToUpload) error <span class="cov0" title="0">{
        jww.INFO.Printf("Uploading %v...\n", upload)
        opts := &amp;blob.WriterOptions{
                CacheControl:    upload.Local.CacheControl(),
                ContentEncoding: upload.Local.ContentEncoding(),
                ContentType:     upload.Local.ContentType(),
        }
        w, err := bucket.NewWriter(ctx, upload.Local.SlashPath, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r, err := upload.Local.Reader()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer r.Close()
        _, err = io.Copy(w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// localFile represents a local file from the source. Use newLocalFile to
// construct one.
type localFile struct {
        // NativePath is the native path to the file (using file.Separator).
        NativePath string
        // SlashPath is NativePath converted to use /.
        SlashPath string
        // UploadSize is the size of the content to be uploaded. It may not
        // be the same as the local file size if the content will be
        // gzipped before upload.
        UploadSize int64

        fs      afero.Fs
        matcher *matcher
        md5     []byte       // cache
        gzipped bytes.Buffer // cached of gzipped contents if gzipping
}

// newLocalFile initializes a *localFile.
func newLocalFile(fs afero.Fs, nativePath, slashpath string, m *matcher) (*localFile, error) <span class="cov0" title="0">{
        f, err := fs.Open(nativePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        lf := &amp;localFile{
                NativePath: nativePath,
                SlashPath:  slashpath,
                fs:         fs,
                matcher:    m,
        }
        if m != nil &amp;&amp; m.Gzip </span><span class="cov0" title="0">{
                // We're going to gzip the content. Do it once now, and cache the result
                // in gzipped. The UploadSize is the size of the gzipped content.
                gz := gzip.NewWriter(&amp;lf.gzipped)
                if _, err := io.Copy(gz, f); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := gz.Close(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">lf.UploadSize = int64(lf.gzipped.Len())</span>
        } else<span class="cov0" title="0"> {
                // Raw content. Just get the UploadSize.
                info, err := f.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">lf.UploadSize = info.Size()</span>
        }
        <span class="cov0" title="0">return lf, nil</span>
}

// Reader returns an io.ReadCloser for reading the content to be uploaded.
// The caller must call Close on the returned ReaderCloser.
// The reader content may not be the same as the local file content due to
// gzipping.
func (lf *localFile) Reader() (io.ReadCloser, error) <span class="cov0" title="0">{
        if lf.matcher != nil &amp;&amp; lf.matcher.Gzip </span><span class="cov0" title="0">{
                // We've got the gzipped contents cached in gzipped.
                // Note: we can't use lf.gzipped directly as a Reader, since we it discards
                // data after it is read, and we may read it more than once.
                return ioutil.NopCloser(bytes.NewReader(lf.gzipped.Bytes())), nil
        }</span>
        // Not expected to fail since we did it successfully earlier in newLocalFile,
        // but could happen due to changes in the underlying filesystem.
        <span class="cov0" title="0">return lf.fs.Open(lf.NativePath)</span>
}

// CacheControl returns the Cache-Control header to use for lf, based on the
// first matching matcher (if any).
func (lf *localFile) CacheControl() string <span class="cov0" title="0">{
        if lf.matcher == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return lf.matcher.CacheControl</span>
}

// ContentEncoding returns the Content-Encoding header to use for lf, based
// on the matcher's Content-Encoding and Gzip fields.
func (lf *localFile) ContentEncoding() string <span class="cov0" title="0">{
        if lf.matcher == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if lf.matcher.Gzip </span><span class="cov0" title="0">{
                return "gzip"
        }</span>
        <span class="cov0" title="0">return lf.matcher.ContentEncoding</span>
}

// ContentType returns the Content-Type header to use for lf.
// It first checks if there's a Content-Type header configured via a matching
// matcher; if not, it tries to generate one based on the filename extension.
// If this fails, the Content-Type will be the empty string. In this case, Go
// Cloud will automatically try to infer a Content-Type based on the file
// content.
func (lf *localFile) ContentType() string <span class="cov0" title="0">{
        if lf.matcher != nil &amp;&amp; lf.matcher.ContentType != "" </span><span class="cov0" title="0">{
                return lf.matcher.ContentType
        }</span>
        // TODO: Hugo has a MediaType and a MediaTypes list and also a concept
        // of custom MIME types.
        // Use 1) The matcher 2) Hugo's MIME types 3) TypeByExtension.
        <span class="cov0" title="0">return mime.TypeByExtension(filepath.Ext(lf.NativePath))</span>
}

// Force returns true if the file should be forced to re-upload based on the
// matching matcher.
func (lf *localFile) Force() bool <span class="cov0" title="0">{
        return lf.matcher != nil &amp;&amp; lf.matcher.Force
}</span>

// MD5 returns an MD5 hash of the content to be uploaded.
func (lf *localFile) MD5() []byte <span class="cov0" title="0">{
        if len(lf.md5) &gt; 0 </span><span class="cov0" title="0">{
                return lf.md5
        }</span>
        <span class="cov0" title="0">h := md5.New()
        r, err := lf.Reader()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">defer r.Close()
        if _, err := io.Copy(h, r); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">lf.md5 = h.Sum(nil)
        return lf.md5</span>
}

// walkLocal walks the source directory and returns a flat list of files,
// using localFile.SlashPath as the map keys.
func walkLocal(fs afero.Fs, matchers []*matcher) (map[string]*localFile, error) <span class="cov0" title="0">{
        retval := map[string]*localFile{}
        err := afero.Walk(fs, "", func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        // Skip hidden directories.
                        if path != "" &amp;&amp; strings.HasPrefix(info.Name(), ".") </span><span class="cov0" title="0">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                // .DS_Store is an internal MacOS attribute file; skip it.
                <span class="cov0" title="0">if info.Name() == ".DS_Store" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // When a file system is HFS+, its filepath is in NFD form.
                <span class="cov0" title="0">if runtime.GOOS == "darwin" </span><span class="cov0" title="0">{
                        path = norm.NFC.String(path)
                }</span>

                // Find the first matching matcher (if any).
                <span class="cov0" title="0">slashpath := filepath.ToSlash(path)
                var m *matcher
                for _, cur := range matchers </span><span class="cov0" title="0">{
                        if cur.Matches(slashpath) </span><span class="cov0" title="0">{
                                m = cur
                                break</span>
                        }
                }
                <span class="cov0" title="0">lf, err := newLocalFile(fs, path, slashpath, m)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">retval[lf.SlashPath] = lf
                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return retval, nil</span>
}

// walkRemote walks the target bucket and returns a flat list.
func walkRemote(ctx context.Context, bucket *blob.Bucket) (map[string]*blob.ListObject, error) <span class="cov0" title="0">{
        retval := map[string]*blob.ListObject{}
        iter := bucket.List(nil)
        for </span><span class="cov0" title="0">{
                obj, err := iter.Next(ctx)
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // If the remote didn't give us an MD5, compute one.
                // This can happen for some providers (e.g., fileblob, which uses the
                // local filesystem), but not for the most common Cloud providers
                // (S3, GCS, Azure). Although, it can happen for S3 if the blob was uploaded
                // via a multi-part upload.
                // Although it's unfortunate to have to read the file, it's likely better
                // than assuming a delta and re-uploading it.
                <span class="cov0" title="0">if len(obj.MD5) == 0 </span><span class="cov0" title="0">{
                        r, err := bucket.NewReader(ctx, obj.Key, nil)
                        if err == nil </span><span class="cov0" title="0">{
                                h := md5.New()
                                if _, err := io.Copy(h, r); err == nil </span><span class="cov0" title="0">{
                                        obj.MD5 = h.Sum(nil)
                                }</span>
                                <span class="cov0" title="0">r.Close()</span>
                        }
                }
                <span class="cov0" title="0">retval[obj.Key] = obj</span>
        }
        <span class="cov0" title="0">return retval, nil</span>
}

// uploadReason is an enum of reasons why a file must be uploaded.
type uploadReason string

const (
        reasonUnknown    uploadReason = "unknown"
        reasonNotFound   uploadReason = "not found at target"
        reasonForce      uploadReason = "--force"
        reasonSize       uploadReason = "size differs"
        reasonMD5Differs uploadReason = "md5 differs"
        reasonMD5Missing uploadReason = "remote md5 missing"
)

// fileToUpload represents a single local file that should be uploaded to
// the target.
type fileToUpload struct {
        Local  *localFile
        Reason uploadReason
}

func (u *fileToUpload) String() string <span class="cov0" title="0">{
        details := []string{humanize.Bytes(uint64(u.Local.UploadSize))}
        if s := u.Local.CacheControl(); s != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("Cache-Control: %q", s))
        }</span>
        <span class="cov0" title="0">if s := u.Local.ContentEncoding(); s != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("Content-Encoding: %q", s))
        }</span>
        <span class="cov0" title="0">if s := u.Local.ContentType(); s != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("Content-Type: %q", s))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s (%s): %v", u.Local.SlashPath, strings.Join(details, ", "), u.Reason)</span>
}

// findDiffs diffs localFiles vs remoteFiles to see what changes should be
// applied to the remote target. It returns a slice of *fileToUpload and a
// slice of paths for files to delete.
func findDiffs(localFiles map[string]*localFile, remoteFiles map[string]*blob.ListObject, force bool) ([]*fileToUpload, []string) <span class="cov0" title="0">{
        var uploads []*fileToUpload
        var deletes []string

        found := map[string]bool{}
        for path, lf := range localFiles </span><span class="cov0" title="0">{
                upload := false
                reason := reasonUnknown

                if remoteFile, ok := remoteFiles[path]; ok </span><span class="cov0" title="0">{
                        // The file exists in remote. Let's see if we need to upload it anyway.

                        // TODO: We don't register a diff if the metadata (e.g., Content-Type
                        // header) has changed. This would be difficult/expensive to detect; some
                        // providers return metadata along with their "List" result, but others
                        // (notably AWS S3) do not, so gocloud.dev's blob.Bucket doesn't expose
                        // it in the list result. It would require a separate request per blob
                        // to fetch. At least for now, we work around this by documenting it and
                        // providing a "force" flag (to re-upload everything) and a "force" bool
                        // per matcher (to re-upload all files in a matcher whose headers may have
                        // changed).
                        // Idea: extract a sample set of 1 file per extension + 1 file per matcher
                        // and check those files?
                        if force </span><span class="cov0" title="0">{
                                upload = true
                                reason = reasonForce
                        }</span> else<span class="cov0" title="0"> if lf.Force() </span><span class="cov0" title="0">{
                                upload = true
                                reason = reasonForce
                        }</span> else<span class="cov0" title="0"> if lf.UploadSize != remoteFile.Size </span><span class="cov0" title="0">{
                                upload = true
                                reason = reasonSize
                        }</span> else<span class="cov0" title="0"> if len(remoteFile.MD5) == 0 </span><span class="cov0" title="0">{
                                // This shouldn't happen unless the remote didn't give us an MD5 hash
                                // from List, AND we failed to compute one by reading the remote file.
                                // Default to considering the files different.
                                upload = true
                                reason = reasonMD5Missing
                        }</span> else<span class="cov0" title="0"> if !bytes.Equal(lf.MD5(), remoteFile.MD5) </span><span class="cov0" title="0">{
                                upload = true
                                reason = reasonMD5Differs
                        }</span> else <span class="cov0" title="0">{
                                // Nope! Leave uploaded = false.
                        }</span>
                        <span class="cov0" title="0">found[path] = true</span>
                } else<span class="cov0" title="0"> {
                        // The file doesn't exist in remote.
                        upload = true
                        reason = reasonNotFound
                }</span>
                <span class="cov0" title="0">if upload </span><span class="cov0" title="0">{
                        jww.DEBUG.Printf("%s needs to be uploaded: %v\n", path, reason)
                        uploads = append(uploads, &amp;fileToUpload{lf, reason})
                }</span> else<span class="cov0" title="0"> {
                        jww.DEBUG.Printf("%s exists at target and does not need to be uploaded", path)
                }</span>
        }

        // Remote files that weren't found locally should be deleted.
        <span class="cov0" title="0">for path := range remoteFiles </span><span class="cov0" title="0">{
                if !found[path] </span><span class="cov0" title="0">{
                        deletes = append(deletes, path)
                }</span>
        }
        <span class="cov0" title="0">return uploads, deletes</span>
}

// applyOrdering returns an ordered slice of slices of uploads.
//
// The returned slice will have length len(ordering)+1.
//
// The subslice at index i, for i = 0 ... len(ordering)-1, will have all of the
// uploads whose Local.SlashPath matched the regex at ordering[i] (but not any
// previous ordering regex).
// The subslice at index len(ordering) will have the remaining uploads that
// didn't match any ordering regex.
//
// The subslices are sorted by Local.SlashPath.
func applyOrdering(ordering []*regexp.Regexp, uploads []*fileToUpload) [][]*fileToUpload <span class="cov0" title="0">{

        // Sort the whole slice by Local.SlashPath first.
        sort.Slice(uploads, func(i, j int) bool </span><span class="cov0" title="0">{ return uploads[i].Local.SlashPath &lt; uploads[j].Local.SlashPath }</span>)

        <span class="cov0" title="0">retval := make([][]*fileToUpload, len(ordering)+1)
        for _, u := range uploads </span><span class="cov0" title="0">{
                matched := false
                for i, re := range ordering </span><span class="cov0" title="0">{
                        if re.MatchString(u.Local.SlashPath) </span><span class="cov0" title="0">{
                                retval[i] = append(retval[i], u)
                                matched = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                        retval[len(ordering)] = append(retval[len(ordering)], u)
                }</span>
        }
        <span class="cov0" title="0">return retval</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package deploy

import (
        "fmt"
        "regexp"

        "github.com/gohugoio/hugo/config"
        "github.com/mitchellh/mapstructure"
)

const deploymentConfigKey = "deployment"

// deployConfig is the complete configuration for deployment.
type deployConfig struct {
        Targets  []*target
        Matchers []*matcher
        Order    []string

        ordering []*regexp.Regexp // compiled Order
}

type target struct {
        Name string
        URL  string

        CloudFrontDistributionID string
}

// matcher represents configuration to be applied to files whose paths match
// a specified pattern.
type matcher struct {
        // Pattern is the string pattern to match against paths.
        // Matching is done against paths converted to use / as the path separator.
        Pattern string

        // CacheControl specifies caching attributes to use when serving the blob.
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control
        CacheControl string

        // ContentEncoding specifies the encoding used for the blob's content, if any.
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding
        ContentEncoding string

        // ContentType specifies the MIME type of the blob being written.
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type
        ContentType string

        // Gzip determines whether the file should be gzipped before upload.
        // If so, the ContentEncoding field will automatically be set to "gzip".
        Gzip bool

        // Force indicates that matching files should be re-uploaded. Useful when
        // other route-determined metadata (e.g., ContentType) has changed.
        Force bool

        // re is Pattern compiled.
        re *regexp.Regexp
}

func (m *matcher) Matches(path string) bool <span class="cov0" title="0">{
        return m.re.MatchString(path)
}</span>

// decode creates a config from a given Hugo configuration.
func decodeConfig(cfg config.Provider) (deployConfig, error) <span class="cov0" title="0">{
        var dcfg deployConfig
        if !cfg.IsSet(deploymentConfigKey) </span><span class="cov0" title="0">{
                return dcfg, nil
        }</span>
        <span class="cov0" title="0">if err := mapstructure.WeakDecode(cfg.GetStringMap(deploymentConfigKey), &amp;dcfg); err != nil </span><span class="cov0" title="0">{
                return dcfg, err
        }</span>
        <span class="cov0" title="0">var err error
        for _, m := range dcfg.Matchers </span><span class="cov0" title="0">{
                m.re, err = regexp.Compile(m.Pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return dcfg, fmt.Errorf("invalid deployment.matchers.pattern: %v", err)
                }</span>
        }
        <span class="cov0" title="0">for _, o := range dcfg.Order </span><span class="cov0" title="0">{
                re, err := regexp.Compile(o)
                if err != nil </span><span class="cov0" title="0">{
                        return dcfg, fmt.Errorf("invalid deployment.orderings.pattern: %v", err)
                }</span>
                <span class="cov0" title="0">dcfg.ordering = append(dcfg.ordering, re)</span>
        }
        <span class="cov0" title="0">return dcfg, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package deps

import (
        "sync"
        "time"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/cache/filecache"
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/resources/page"

        "github.com/gohugoio/hugo/metrics"
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/source"
        "github.com/gohugoio/hugo/tpl"
        jww "github.com/spf13/jwalterweatherman"
)

// Deps holds dependencies used by many.
// There will be normally only one instance of deps in play
// at a given time, i.e. one per Site built.
type Deps struct {

        // The logger to use.
        Log *loggers.Logger `json:"-"`

        // Used to log errors that may repeat itself many times.
        DistinctErrorLog *helpers.DistinctLogger

        // Used to log warnings that may repeat itself many times.
        DistinctWarningLog *helpers.DistinctLogger

        // The templates to use. This will usually implement the full tpl.TemplateHandler.
        Tmpl tpl.TemplateFinder `json:"-"`

        // We use this to parse and execute ad-hoc text templates.
        TextTmpl tpl.TemplateParseFinder `json:"-"`

        // The file systems to use.
        Fs *hugofs.Fs `json:"-"`

        // The PathSpec to use
        *helpers.PathSpec `json:"-"`

        // The ContentSpec to use
        *helpers.ContentSpec `json:"-"`

        // The SourceSpec to use
        SourceSpec *source.SourceSpec `json:"-"`

        // The Resource Spec to use
        ResourceSpec *resources.Spec

        // The configuration to use
        Cfg config.Provider `json:"-"`

        // The file cache to use.
        FileCaches filecache.Caches

        // The translation func to use
        Translate func(translationID string, args ...interface{}) string `json:"-"`

        // The language in use. TODO(bep) consolidate with site
        Language *langs.Language

        // The site building.
        Site page.Site

        // All the output formats available for the current site.
        OutputFormatsConfig output.Formats

        templateProvider ResourceProvider
        WithTemplate     func(templ tpl.TemplateHandler) error `json:"-"`

        translationProvider ResourceProvider

        Metrics metrics.Provider

        // Timeout is configurable in site config.
        Timeout time.Duration

        // BuildStartListeners will be notified before a build starts.
        BuildStartListeners *Listeners

        *globalErrHandler
}

type globalErrHandler struct {
        // Channel for some "hard to get to" build errors
        buildErrors chan error
}

// SendErr sends the error on a channel to be handled later.
// This can be used in situations where returning and aborting the current
// operation isn't practical.
func (e *globalErrHandler) SendError(err error) <span class="cov0" title="0">{
        if e.buildErrors != nil </span><span class="cov0" title="0">{
                select </span>{
                case e.buildErrors &lt;- err:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">jww.ERROR.Println(err)</span>
}

func (e *globalErrHandler) StartErrorCollector() chan error <span class="cov8" title="1">{
        e.buildErrors = make(chan error, 10)
        return e.buildErrors
}</span>

// Listeners represents an event listener.
type Listeners struct {
        sync.Mutex

        // A list of funcs to be notified about an event.
        listeners []func()
}

// Add adds a function to a Listeners instance.
func (b *Listeners) Add(f func()) <span class="cov8" title="1">{
        if b == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">b.Lock()
        defer b.Unlock()
        b.listeners = append(b.listeners, f)</span>
}

// Notify executes all listener functions.
func (b *Listeners) Notify() <span class="cov0" title="0">{
        b.Lock()
        defer b.Unlock()
        for _, notify := range b.listeners </span><span class="cov0" title="0">{
                notify()
        }</span>
}

// ResourceProvider is used to create and refresh, and clone resources needed.
type ResourceProvider interface {
        Update(deps *Deps) error
        Clone(deps *Deps) error
}

// TemplateHandler returns the used tpl.TemplateFinder as tpl.TemplateHandler.
func (d *Deps) TemplateHandler() tpl.TemplateHandler <span class="cov8" title="1">{
        return d.Tmpl.(tpl.TemplateHandler)
}</span>

// LoadResources loads translations and templates.
func (d *Deps) LoadResources() error <span class="cov8" title="1">{
        // Note that the translations need to be loaded before the templates.
        if err := d.translationProvider.Update(d); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "loading translations")
        }</span>

        <span class="cov8" title="1">if err := d.templateProvider.Update(d); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "loading templates")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// New initializes a Dep struct.
// Defaults are set for nil values,
// but TemplateProvider, TranslationProvider and Language are always required.
func New(cfg DepsCfg) (*Deps, error) <span class="cov8" title="1">{
        var (
                logger = cfg.Logger
                fs     = cfg.Fs
        )

        if cfg.TemplateProvider == nil </span><span class="cov0" title="0">{
                panic("Must have a TemplateProvider")</span>
        }

        <span class="cov8" title="1">if cfg.TranslationProvider == nil </span><span class="cov0" title="0">{
                panic("Must have a TranslationProvider")</span>
        }

        <span class="cov8" title="1">if cfg.Language == nil </span><span class="cov0" title="0">{
                panic("Must have a Language")</span>
        }

        <span class="cov8" title="1">if logger == nil </span><span class="cov0" title="0">{
                logger = loggers.NewErrorLogger()
        }</span>

        <span class="cov8" title="1">if fs == nil </span><span class="cov0" title="0">{
                // Default to the production file system.
                fs = hugofs.NewDefault(cfg.Language)
        }</span>

        <span class="cov8" title="1">if cfg.MediaTypes == nil </span><span class="cov0" title="0">{
                cfg.MediaTypes = media.DefaultTypes
        }</span>

        <span class="cov8" title="1">if cfg.OutputFormats == nil </span><span class="cov0" title="0">{
                cfg.OutputFormats = output.DefaultFormats
        }</span>

        <span class="cov8" title="1">ps, err := helpers.NewPathSpec(fs, cfg.Language, logger)

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "create PathSpec")
        }</span>

        <span class="cov8" title="1">fileCaches, err := filecache.NewCaches(ps)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.WithMessage(err, "failed to create file caches from configuration")
        }</span>

        <span class="cov8" title="1">resourceSpec, err := resources.NewSpec(ps, fileCaches, logger, cfg.OutputFormats, cfg.MediaTypes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">contentSpec, err := helpers.NewContentSpec(cfg.Language)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sp := source.NewSourceSpec(ps, fs.Source)

        timeoutms := cfg.Language.GetInt("timeout")
        if timeoutms &lt;= 0 </span><span class="cov0" title="0">{
                timeoutms = 3000
        }</span>

        <span class="cov8" title="1">distinctErrorLogger := helpers.NewDistinctLogger(logger.ERROR)
        distinctWarnLogger := helpers.NewDistinctLogger(logger.WARN)

        d := &amp;Deps{
                Fs:                  fs,
                Log:                 logger,
                DistinctErrorLog:    distinctErrorLogger,
                DistinctWarningLog:  distinctWarnLogger,
                templateProvider:    cfg.TemplateProvider,
                translationProvider: cfg.TranslationProvider,
                WithTemplate:        cfg.WithTemplate,
                PathSpec:            ps,
                ContentSpec:         contentSpec,
                SourceSpec:          sp,
                ResourceSpec:        resourceSpec,
                Cfg:                 cfg.Language,
                Language:            cfg.Language,
                Site:                cfg.Site,
                FileCaches:          fileCaches,
                BuildStartListeners: &amp;Listeners{},
                Timeout:             time.Duration(timeoutms) * time.Millisecond,
                globalErrHandler:    &amp;globalErrHandler{},
        }

        if cfg.Cfg.GetBool("templateMetrics") </span><span class="cov0" title="0">{
                d.Metrics = metrics.NewProvider(cfg.Cfg.GetBool("templateMetricsHints"))
        }</span>

        <span class="cov8" title="1">return d, nil</span>
}

// ForLanguage creates a copy of the Deps with the language dependent
// parts switched out.
func (d Deps) ForLanguage(cfg DepsCfg, onCreated func(d *Deps) error) (*Deps, error) <span class="cov0" title="0">{
        l := cfg.Language
        var err error

        d.PathSpec, err = helpers.NewPathSpecWithBaseBaseFsProvided(d.Fs, l, d.Log, d.BaseFs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">d.ContentSpec, err = helpers.NewContentSpec(l)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">d.Site = cfg.Site

        // The resource cache is global so reuse.
        // TODO(bep) clean up these inits.
        resourceCache := d.ResourceSpec.ResourceCache
        d.ResourceSpec, err = resources.NewSpec(d.PathSpec, d.ResourceSpec.FileCaches, d.Log, cfg.OutputFormats, cfg.MediaTypes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">d.ResourceSpec.ResourceCache = resourceCache

        d.Cfg = l
        d.Language = l

        if onCreated != nil </span><span class="cov0" title="0">{
                if err = onCreated(&amp;d); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if err := d.translationProvider.Clone(&amp;d); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := d.templateProvider.Clone(&amp;d); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">d.BuildStartListeners = &amp;Listeners{}

        return &amp;d, nil</span>

}

// DepsCfg contains configuration options that can be used to configure Hugo
// on a global level, i.e. logging etc.
// Nil values will be given default values.
type DepsCfg struct {

        // The Logger to use.
        Logger *loggers.Logger

        // The file systems to use
        Fs *hugofs.Fs

        // The language to use.
        Language *langs.Language

        // The Site in use
        Site page.Site

        // The configuration to use.
        Cfg config.Provider

        // The media types configured.
        MediaTypes media.Types

        // The output formats configured.
        OutputFormats output.Formats

        // Template handling.
        TemplateProvider ResourceProvider
        WithTemplate     func(templ tpl.TemplateHandler) error

        // i18n handling.
        TranslationProvider ResourceProvider

        // Whether we are in running (server) mode
        Running bool
}
</pre>
		
		<pre class="file" id="file68" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package docshelper provides some helpers for the Hugo documentation, and
// is of limited interest for the general Hugo user.
package docshelper

import (
        "encoding/json"
)

// DocProviders contains all DocProviders added to the system.
var DocProviders = make(map[string]DocProvider)

// AddDocProvider adds or updates the DocProvider for a given name.
func AddDocProvider(name string, provider DocProvider) <span class="cov8" title="1">{
        DocProviders[name] = provider
}</span>

// DocProvider is used to save arbitrary JSON data
// used for the generation of the documentation.
type DocProvider func() map[string]interface{}

// MarshalJSON returns a JSON representation of the DocProvider.
func (d DocProvider) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.MarshalIndent(d(), "", "  ")
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package helpers implements general utility functions that work with
// and on content.  The helper functions defined here lay down the
// foundation of how Hugo works with files and filepaths, and perform
// string operations on content.
package helpers

import (
        "bytes"
        "fmt"
        "html/template"
        "os/exec"
        "runtime"
        "unicode"
        "unicode/utf8"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/niklasfasching/go-org/org"

        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/config"
        "github.com/miekg/mmark"
        "github.com/mitchellh/mapstructure"
        "github.com/russross/blackfriday"
        jww "github.com/spf13/jwalterweatherman"

        "strings"
)

// SummaryDivider denotes where content summarization should end. The default is "&lt;!--more--&gt;".
var SummaryDivider = []byte("&lt;!--more--&gt;")

var (
        openingPTag        = []byte("&lt;p&gt;")
        closingPTag        = []byte("&lt;/p&gt;")
        paragraphIndicator = []byte("&lt;p")
)

// ContentSpec provides functionality to render markdown content.
type ContentSpec struct {
        BlackFriday                *BlackFriday
        footnoteAnchorPrefix       string
        footnoteReturnLinkContents string
        // SummaryLength is the length of the summary that Hugo extracts from a content.
        summaryLength int

        BuildFuture  bool
        BuildExpired bool
        BuildDrafts  bool

        Highlight            func(code, lang, optsStr string) (string, error)
        defatultPygmentsOpts map[string]string

        Cfg config.Provider
}

// NewContentSpec returns a ContentSpec initialized
// with the appropriate fields from the given config.Provider.
func NewContentSpec(cfg config.Provider) (*ContentSpec, error) <span class="cov8" title="1">{
        bf := newBlackfriday(cfg.GetStringMap("blackfriday"))
        spec := &amp;ContentSpec{
                BlackFriday:                bf,
                footnoteAnchorPrefix:       cfg.GetString("footnoteAnchorPrefix"),
                footnoteReturnLinkContents: cfg.GetString("footnoteReturnLinkContents"),
                summaryLength:              cfg.GetInt("summaryLength"),
                BuildFuture:                cfg.GetBool("buildFuture"),
                BuildExpired:               cfg.GetBool("buildExpired"),
                BuildDrafts:                cfg.GetBool("buildDrafts"),

                Cfg: cfg,
        }

        // Highlighting setup
        options, err := parseDefaultPygmentsOpts(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">spec.defatultPygmentsOpts = options

        // Use the Pygmentize on path if present
        useClassic := false
        h := newHiglighters(spec)

        if cfg.GetBool("pygmentsUseClassic") </span><span class="cov0" title="0">{
                if !hasPygments() </span><span class="cov0" title="0">{
                        jww.WARN.Println("Highlighting with pygmentsUseClassic set requires Pygments to be installed and in the path")
                }</span> else<span class="cov0" title="0"> {
                        useClassic = true
                }</span>
        }

        <span class="cov8" title="1">if useClassic </span><span class="cov0" title="0">{
                spec.Highlight = h.pygmentsHighlight
        }</span> else<span class="cov8" title="1"> {
                spec.Highlight = h.chromaHighlight
        }</span>

        <span class="cov8" title="1">return spec, nil</span>
}

// BlackFriday holds configuration values for BlackFriday rendering.
type BlackFriday struct {
        Smartypants           bool
        SmartypantsQuotesNBSP bool
        AngledQuotes          bool
        Fractions             bool
        HrefTargetBlank       bool
        NofollowLinks         bool
        NoreferrerLinks       bool
        SmartDashes           bool
        LatexDashes           bool
        TaskLists             bool
        PlainIDAnchors        bool
        Extensions            []string
        ExtensionsMask        []string
        SkipHTML              bool
}

// NewBlackfriday creates a new Blackfriday filled with site config or some sane defaults.
func newBlackfriday(config map[string]interface{}) *BlackFriday <span class="cov8" title="1">{
        defaultParam := map[string]interface{}{
                "smartypants":           true,
                "angledQuotes":          false,
                "smartypantsQuotesNBSP": false,
                "fractions":             true,
                "hrefTargetBlank":       false,
                "nofollowLinks":         false,
                "noreferrerLinks":       false,
                "smartDashes":           true,
                "latexDashes":           true,
                "plainIDAnchors":        true,
                "taskLists":             true,
                "skipHTML":              false,
        }

        maps.ToLower(defaultParam)

        siteConfig := make(map[string]interface{})

        for k, v := range defaultParam </span><span class="cov8" title="1">{
                siteConfig[k] = v
        }</span>

        <span class="cov8" title="1">for k, v := range config </span><span class="cov0" title="0">{
                siteConfig[k] = v
        }</span>

        <span class="cov8" title="1">combinedConfig := &amp;BlackFriday{}
        if err := mapstructure.Decode(siteConfig, combinedConfig); err != nil </span><span class="cov0" title="0">{
                jww.FATAL.Printf("Failed to get site rendering config\n%s", err.Error())
        }</span>

        <span class="cov8" title="1">return combinedConfig</span>
}

var blackfridayExtensionMap = map[string]int{
        "noIntraEmphasis":        blackfriday.EXTENSION_NO_INTRA_EMPHASIS,
        "tables":                 blackfriday.EXTENSION_TABLES,
        "fencedCode":             blackfriday.EXTENSION_FENCED_CODE,
        "autolink":               blackfriday.EXTENSION_AUTOLINK,
        "strikethrough":          blackfriday.EXTENSION_STRIKETHROUGH,
        "laxHtmlBlocks":          blackfriday.EXTENSION_LAX_HTML_BLOCKS,
        "spaceHeaders":           blackfriday.EXTENSION_SPACE_HEADERS,
        "hardLineBreak":          blackfriday.EXTENSION_HARD_LINE_BREAK,
        "tabSizeEight":           blackfriday.EXTENSION_TAB_SIZE_EIGHT,
        "footnotes":              blackfriday.EXTENSION_FOOTNOTES,
        "noEmptyLineBeforeBlock": blackfriday.EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK,
        "headerIds":              blackfriday.EXTENSION_HEADER_IDS,
        "titleblock":             blackfriday.EXTENSION_TITLEBLOCK,
        "autoHeaderIds":          blackfriday.EXTENSION_AUTO_HEADER_IDS,
        "backslashLineBreak":     blackfriday.EXTENSION_BACKSLASH_LINE_BREAK,
        "definitionLists":        blackfriday.EXTENSION_DEFINITION_LISTS,
        "joinLines":              blackfriday.EXTENSION_JOIN_LINES,
}

var stripHTMLReplacer = strings.NewReplacer("\n", " ", "&lt;/p&gt;", "\n", "&lt;br&gt;", "\n", "&lt;br /&gt;", "\n")

var mmarkExtensionMap = map[string]int{
        "tables":                 mmark.EXTENSION_TABLES,
        "fencedCode":             mmark.EXTENSION_FENCED_CODE,
        "autolink":               mmark.EXTENSION_AUTOLINK,
        "laxHtmlBlocks":          mmark.EXTENSION_LAX_HTML_BLOCKS,
        "spaceHeaders":           mmark.EXTENSION_SPACE_HEADERS,
        "hardLineBreak":          mmark.EXTENSION_HARD_LINE_BREAK,
        "footnotes":              mmark.EXTENSION_FOOTNOTES,
        "noEmptyLineBeforeBlock": mmark.EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK,
        "headerIds":              mmark.EXTENSION_HEADER_IDS,
        "autoHeaderIds":          mmark.EXTENSION_AUTO_HEADER_IDS,
}

// StripHTML accepts a string, strips out all HTML tags and returns it.
func StripHTML(s string) string <span class="cov8" title="1">{

        // Shortcut strings with no tags in them
        if !strings.ContainsAny(s, "&lt;&gt;") </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov8" title="1">s = stripHTMLReplacer.Replace(s)

        // Walk through the string removing all tags
        b := bp.GetBuffer()
        defer bp.PutBuffer(b)
        var inTag, isSpace, wasSpace bool
        for _, r := range s </span><span class="cov8" title="1">{
                if !inTag </span><span class="cov8" title="1">{
                        isSpace = false
                }</span>

                <span class="cov8" title="1">switch </span>{
                case r == '&lt;':<span class="cov8" title="1">
                        inTag = true</span>
                case r == '&gt;':<span class="cov8" title="1">
                        inTag = false</span>
                case unicode.IsSpace(r):<span class="cov8" title="1">
                        isSpace = true
                        fallthrough</span>
                default:<span class="cov8" title="1">
                        if !inTag &amp;&amp; (!isSpace || (isSpace &amp;&amp; !wasSpace)) </span><span class="cov8" title="1">{
                                b.WriteRune(r)
                        }</span>
                }

                <span class="cov8" title="1">wasSpace = isSpace</span>

        }
        <span class="cov8" title="1">return b.String()</span>
}

// stripEmptyNav strips out empty &lt;nav&gt; tags from content.
func stripEmptyNav(in []byte) []byte <span class="cov8" title="1">{
        return bytes.Replace(in, []byte("&lt;nav&gt;\n&lt;/nav&gt;\n\n"), []byte(``), -1)
}</span>

// BytesToHTML converts bytes to type template.HTML.
func BytesToHTML(b []byte) template.HTML <span class="cov8" title="1">{
        return template.HTML(string(b))
}</span>

// getHTMLRenderer creates a new Blackfriday HTML Renderer with the given configuration.
func (c *ContentSpec) getHTMLRenderer(defaultFlags int, ctx *RenderingContext) blackfriday.Renderer <span class="cov8" title="1">{
        renderParameters := blackfriday.HtmlRendererParameters{
                FootnoteAnchorPrefix:       c.footnoteAnchorPrefix,
                FootnoteReturnLinkContents: c.footnoteReturnLinkContents,
        }

        b := len(ctx.DocumentID) != 0

        if ctx.Config == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("RenderingContext of %q doesn't have a config", ctx.DocumentID))</span>
        }

        <span class="cov8" title="1">if b &amp;&amp; !ctx.Config.PlainIDAnchors </span><span class="cov0" title="0">{
                renderParameters.FootnoteAnchorPrefix = ctx.DocumentID + ":" + renderParameters.FootnoteAnchorPrefix
                renderParameters.HeaderIDSuffix = ":" + ctx.DocumentID
        }</span>

        <span class="cov8" title="1">htmlFlags := defaultFlags
        htmlFlags |= blackfriday.HTML_USE_XHTML
        htmlFlags |= blackfriday.HTML_FOOTNOTE_RETURN_LINKS

        if ctx.Config.Smartypants </span><span class="cov8" title="1">{
                htmlFlags |= blackfriday.HTML_USE_SMARTYPANTS
        }</span>

        <span class="cov8" title="1">if ctx.Config.SmartypantsQuotesNBSP </span><span class="cov0" title="0">{
                htmlFlags |= blackfriday.HTML_SMARTYPANTS_QUOTES_NBSP
        }</span>

        <span class="cov8" title="1">if ctx.Config.AngledQuotes </span><span class="cov0" title="0">{
                htmlFlags |= blackfriday.HTML_SMARTYPANTS_ANGLED_QUOTES
        }</span>

        <span class="cov8" title="1">if ctx.Config.Fractions </span><span class="cov8" title="1">{
                htmlFlags |= blackfriday.HTML_SMARTYPANTS_FRACTIONS
        }</span>

        <span class="cov8" title="1">if ctx.Config.HrefTargetBlank </span><span class="cov0" title="0">{
                htmlFlags |= blackfriday.HTML_HREF_TARGET_BLANK
        }</span>

        <span class="cov8" title="1">if ctx.Config.NofollowLinks </span><span class="cov0" title="0">{
                htmlFlags |= blackfriday.HTML_NOFOLLOW_LINKS
        }</span>

        <span class="cov8" title="1">if ctx.Config.NoreferrerLinks </span><span class="cov0" title="0">{
                htmlFlags |= blackfriday.HTML_NOREFERRER_LINKS
        }</span>

        <span class="cov8" title="1">if ctx.Config.SmartDashes </span><span class="cov8" title="1">{
                htmlFlags |= blackfriday.HTML_SMARTYPANTS_DASHES
        }</span>

        <span class="cov8" title="1">if ctx.Config.LatexDashes </span><span class="cov8" title="1">{
                htmlFlags |= blackfriday.HTML_SMARTYPANTS_LATEX_DASHES
        }</span>

        <span class="cov8" title="1">if ctx.Config.SkipHTML </span><span class="cov0" title="0">{
                htmlFlags |= blackfriday.HTML_SKIP_HTML
        }</span>

        <span class="cov8" title="1">return &amp;HugoHTMLRenderer{
                cs:               c,
                RenderingContext: ctx,
                Renderer:         blackfriday.HtmlRendererWithParameters(htmlFlags, "", "", renderParameters),
        }</span>
}

func getMarkdownExtensions(ctx *RenderingContext) int <span class="cov8" title="1">{
        // Default Blackfriday common extensions
        commonExtensions := 0 |
                blackfriday.EXTENSION_NO_INTRA_EMPHASIS |
                blackfriday.EXTENSION_TABLES |
                blackfriday.EXTENSION_FENCED_CODE |
                blackfriday.EXTENSION_AUTOLINK |
                blackfriday.EXTENSION_STRIKETHROUGH |
                blackfriday.EXTENSION_SPACE_HEADERS |
                blackfriday.EXTENSION_HEADER_IDS |
                blackfriday.EXTENSION_BACKSLASH_LINE_BREAK |
                blackfriday.EXTENSION_DEFINITION_LISTS

        // Extra Blackfriday extensions that Hugo enables by default
        flags := commonExtensions |
                blackfriday.EXTENSION_AUTO_HEADER_IDS |
                blackfriday.EXTENSION_FOOTNOTES

        if ctx.Config == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("RenderingContext of %q doesn't have a config", ctx.DocumentID))</span>
        }

        <span class="cov8" title="1">for _, extension := range ctx.Config.Extensions </span><span class="cov0" title="0">{
                if flag, ok := blackfridayExtensionMap[extension]; ok </span><span class="cov0" title="0">{
                        flags |= flag
                }</span>
        }
        <span class="cov8" title="1">for _, extension := range ctx.Config.ExtensionsMask </span><span class="cov0" title="0">{
                if flag, ok := blackfridayExtensionMap[extension]; ok </span><span class="cov0" title="0">{
                        flags &amp;= ^flag
                }</span>
        }
        <span class="cov8" title="1">return flags</span>
}

func (c ContentSpec) markdownRender(ctx *RenderingContext) []byte <span class="cov8" title="1">{
        if ctx.RenderTOC </span><span class="cov8" title="1">{
                return blackfriday.Markdown(ctx.Content,
                        c.getHTMLRenderer(blackfriday.HTML_TOC, ctx),
                        getMarkdownExtensions(ctx))
        }</span>
        <span class="cov0" title="0">return blackfriday.Markdown(ctx.Content, c.getHTMLRenderer(0, ctx),
                getMarkdownExtensions(ctx))</span>
}

// getMmarkHTMLRenderer creates a new mmark HTML Renderer with the given configuration.
func (c *ContentSpec) getMmarkHTMLRenderer(defaultFlags int, ctx *RenderingContext) mmark.Renderer <span class="cov0" title="0">{
        renderParameters := mmark.HtmlRendererParameters{
                FootnoteAnchorPrefix:       c.footnoteAnchorPrefix,
                FootnoteReturnLinkContents: c.footnoteReturnLinkContents,
        }

        b := len(ctx.DocumentID) != 0

        if ctx.Config == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("RenderingContext of %q doesn't have a config", ctx.DocumentID))</span>
        }

        <span class="cov0" title="0">if b &amp;&amp; !ctx.Config.PlainIDAnchors </span><span class="cov0" title="0">{
                renderParameters.FootnoteAnchorPrefix = ctx.DocumentID + ":" + renderParameters.FootnoteAnchorPrefix
                // renderParameters.HeaderIDSuffix = ":" + ctx.DocumentId
        }</span>

        <span class="cov0" title="0">htmlFlags := defaultFlags
        htmlFlags |= mmark.HTML_FOOTNOTE_RETURN_LINKS

        return &amp;HugoMmarkHTMLRenderer{
                cs:       c,
                Renderer: mmark.HtmlRendererWithParameters(htmlFlags, "", "", renderParameters),
                Cfg:      c.Cfg,
        }</span>
}

func getMmarkExtensions(ctx *RenderingContext) int <span class="cov0" title="0">{
        flags := 0
        flags |= mmark.EXTENSION_TABLES
        flags |= mmark.EXTENSION_FENCED_CODE
        flags |= mmark.EXTENSION_AUTOLINK
        flags |= mmark.EXTENSION_SPACE_HEADERS
        flags |= mmark.EXTENSION_CITATION
        flags |= mmark.EXTENSION_TITLEBLOCK_TOML
        flags |= mmark.EXTENSION_HEADER_IDS
        flags |= mmark.EXTENSION_AUTO_HEADER_IDS
        flags |= mmark.EXTENSION_UNIQUE_HEADER_IDS
        flags |= mmark.EXTENSION_FOOTNOTES
        flags |= mmark.EXTENSION_SHORT_REF
        flags |= mmark.EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK
        flags |= mmark.EXTENSION_INCLUDE

        if ctx.Config == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("RenderingContext of %q doesn't have a config", ctx.DocumentID))</span>
        }

        <span class="cov0" title="0">for _, extension := range ctx.Config.Extensions </span><span class="cov0" title="0">{
                if flag, ok := mmarkExtensionMap[extension]; ok </span><span class="cov0" title="0">{
                        flags |= flag
                }</span>
        }
        <span class="cov0" title="0">return flags</span>
}

func (c ContentSpec) mmarkRender(ctx *RenderingContext) []byte <span class="cov0" title="0">{
        return mmark.Parse(ctx.Content, c.getMmarkHTMLRenderer(0, ctx),
                getMmarkExtensions(ctx)).Bytes()
}</span>

// ExtractTOC extracts Table of Contents from content.
func ExtractTOC(content []byte) (newcontent []byte, toc []byte) <span class="cov8" title="1">{
        if !bytes.Contains(content, []byte("&lt;nav&gt;")) </span><span class="cov0" title="0">{
                return content, nil
        }</span>
        <span class="cov8" title="1">origContent := make([]byte, len(content))
        copy(origContent, content)
        first := []byte(`&lt;nav&gt;
&lt;ul&gt;`)

        last := []byte(`&lt;/ul&gt;
&lt;/nav&gt;`)

        replacement := []byte(`&lt;nav id="TableOfContents"&gt;
&lt;ul&gt;`)

        startOfTOC := bytes.Index(content, first)

        peekEnd := len(content)
        if peekEnd &gt; 70+startOfTOC </span><span class="cov8" title="1">{
                peekEnd = 70 + startOfTOC
        }</span>

        <span class="cov8" title="1">if startOfTOC &lt; 0 </span><span class="cov8" title="1">{
                return stripEmptyNav(content), toc
        }</span>
        // Need to peek ahead to see if this nav element is actually the right one.
        <span class="cov8" title="1">correctNav := bytes.Index(content[startOfTOC:peekEnd], []byte(`&lt;li&gt;&lt;a href="#`))
        if correctNav &lt; 0 </span><span class="cov0" title="0">{ // no match found
                return content, toc
        }</span>
        <span class="cov8" title="1">lengthOfTOC := bytes.Index(content[startOfTOC:], last) + len(last)
        endOfTOC := startOfTOC + lengthOfTOC

        newcontent = append(content[:startOfTOC], content[endOfTOC:]...)
        toc = append(replacement, origContent[startOfTOC+len(first):endOfTOC]...)
        return</span>
}

// RenderingContext holds contextual information, like content and configuration,
// for a given content rendering.
// By creating you must set the Config, otherwise it will panic.
type RenderingContext struct {
        Content      []byte
        PageFmt      string
        DocumentID   string
        DocumentName string
        Config       *BlackFriday
        RenderTOC    bool
        Cfg          config.Provider
}

// RenderBytes renders a []byte.
func (c ContentSpec) RenderBytes(ctx *RenderingContext) []byte <span class="cov8" title="1">{
        switch ctx.PageFmt </span>{
        default:<span class="cov0" title="0">
                return c.markdownRender(ctx)</span>
        case "markdown":<span class="cov8" title="1">
                return c.markdownRender(ctx)</span>
        case "asciidoc":<span class="cov0" title="0">
                return getAsciidocContent(ctx)</span>
        case "mmark":<span class="cov0" title="0">
                return c.mmarkRender(ctx)</span>
        case "rst":<span class="cov0" title="0">
                return getRstContent(ctx)</span>
        case "org":<span class="cov0" title="0">
                return orgRender(ctx, c)</span>
        case "pandoc":<span class="cov0" title="0">
                return getPandocContent(ctx)</span>
        }
}

// TotalWords counts instance of one or more consecutive white space
// characters, as defined by unicode.IsSpace, in s.
// This is a cheaper way of word counting than the obvious len(strings.Fields(s)).
func TotalWords(s string) int <span class="cov8" title="1">{
        n := 0
        inWord := false
        for _, r := range s </span><span class="cov8" title="1">{
                wasInWord := inWord
                inWord = !unicode.IsSpace(r)
                if inWord &amp;&amp; !wasInWord </span><span class="cov8" title="1">{
                        n++
                }</span>
        }
        <span class="cov8" title="1">return n</span>
}

// TruncateWordsByRune truncates words by runes.
func (c *ContentSpec) TruncateWordsByRune(in []string) (string, bool) <span class="cov0" title="0">{
        words := make([]string, len(in))
        copy(words, in)

        count := 0
        for index, word := range words </span><span class="cov0" title="0">{
                if count &gt;= c.summaryLength </span><span class="cov0" title="0">{
                        return strings.Join(words[:index], " "), true
                }</span>
                <span class="cov0" title="0">runeCount := utf8.RuneCountInString(word)
                if len(word) == runeCount </span><span class="cov0" title="0">{
                        count++
                }</span> else<span class="cov0" title="0"> if count+runeCount &lt; c.summaryLength </span><span class="cov0" title="0">{
                        count += runeCount
                }</span> else<span class="cov0" title="0"> {
                        for ri := range word </span><span class="cov0" title="0">{
                                if count &gt;= c.summaryLength </span><span class="cov0" title="0">{
                                        truncatedWords := append(words[:index], word[:ri])
                                        return strings.Join(truncatedWords, " "), true
                                }</span>
                                <span class="cov0" title="0">count++</span>
                        }
                }
        }

        <span class="cov0" title="0">return strings.Join(words, " "), false</span>
}

// TruncateWordsToWholeSentence takes content and truncates to whole sentence
// limited by max number of words. It also returns whether it is truncated.
func (c *ContentSpec) TruncateWordsToWholeSentence(s string) (string, bool) <span class="cov8" title="1">{
        var (
                wordCount     = 0
                lastWordIndex = -1
        )

        for i, r := range s </span><span class="cov8" title="1">{
                if unicode.IsSpace(r) </span><span class="cov8" title="1">{
                        wordCount++
                        lastWordIndex = i

                        if wordCount &gt;= c.summaryLength </span><span class="cov0" title="0">{
                                break</span>
                        }

                }
        }

        <span class="cov8" title="1">if lastWordIndex == -1 </span><span class="cov0" title="0">{
                return s, false
        }</span>

        <span class="cov8" title="1">endIndex := -1

        for j, r := range s[lastWordIndex:] </span><span class="cov8" title="1">{
                if isEndOfSentence(r) </span><span class="cov8" title="1">{
                        endIndex = j + lastWordIndex + utf8.RuneLen(r)
                        break</span>
                }
        }

        <span class="cov8" title="1">if endIndex == -1 </span><span class="cov8" title="1">{
                return s, false
        }</span>

        <span class="cov8" title="1">return strings.TrimSpace(s[:endIndex]), endIndex &lt; len(s)</span>
}

// TrimShortHTML removes the &lt;p&gt;/&lt;/p&gt; tags from HTML input in the situation
// where said tags are the only &lt;p&gt; tags in the input and enclose the content
// of the input (whitespace excluded).
func (c *ContentSpec) TrimShortHTML(input []byte) []byte <span class="cov0" title="0">{
        first := bytes.Index(input, paragraphIndicator)
        last := bytes.LastIndex(input, paragraphIndicator)
        if first == last </span><span class="cov0" title="0">{
                input = bytes.TrimSpace(input)
                input = bytes.TrimPrefix(input, openingPTag)
                input = bytes.TrimSuffix(input, closingPTag)
                input = bytes.TrimSpace(input)
        }</span>
        <span class="cov0" title="0">return input</span>
}

func isEndOfSentence(r rune) bool <span class="cov8" title="1">{
        return r == '.' || r == '?' || r == '!' || r == '"' || r == '\n'
}</span>

// Kept only for benchmark.
func (c *ContentSpec) truncateWordsToWholeSentenceOld(content string) (string, bool) <span class="cov0" title="0">{
        words := strings.Fields(content)

        if c.summaryLength &gt;= len(words) </span><span class="cov0" title="0">{
                return strings.Join(words, " "), false
        }</span>

        <span class="cov0" title="0">for counter, word := range words[c.summaryLength:] </span><span class="cov0" title="0">{
                if strings.HasSuffix(word, ".") ||
                        strings.HasSuffix(word, "?") ||
                        strings.HasSuffix(word, ".\"") ||
                        strings.HasSuffix(word, "!") </span><span class="cov0" title="0">{
                        upper := c.summaryLength + counter + 1
                        return strings.Join(words[:upper], " "), (upper &lt; len(words))
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(words[:c.summaryLength], " "), true</span>
}

func getAsciidocExecPath() string <span class="cov0" title="0">{
        path, err := exec.LookPath("asciidoc")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return path</span>
}

func getAsciidoctorExecPath() string <span class="cov0" title="0">{
        path, err := exec.LookPath("asciidoctor")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return path</span>
}

// HasAsciidoc returns whether Asciidoc or Asciidoctor is installed on this computer.
func HasAsciidoc() bool <span class="cov0" title="0">{
        return (getAsciidoctorExecPath() != "" ||
                getAsciidocExecPath() != "")
}</span>

// getAsciidocContent calls asciidoctor or asciidoc as an external helper
// to convert AsciiDoc content to HTML.
func getAsciidocContent(ctx *RenderingContext) []byte <span class="cov0" title="0">{
        var isAsciidoctor bool
        path := getAsciidoctorExecPath()
        if path == "" </span><span class="cov0" title="0">{
                path = getAsciidocExecPath()
                if path == "" </span><span class="cov0" title="0">{
                        jww.ERROR.Println("asciidoctor / asciidoc not found in $PATH: Please install.\n",
                                "                 Leaving AsciiDoc content unrendered.")
                        return ctx.Content
                }</span>
        } else<span class="cov0" title="0"> {
                isAsciidoctor = true
        }</span>

        <span class="cov0" title="0">jww.INFO.Println("Rendering", ctx.DocumentName, "with", path, "...")
        args := []string{"--no-header-footer", "--safe"}
        if isAsciidoctor </span><span class="cov0" title="0">{
                // asciidoctor-specific arg to show stack traces on errors
                args = append(args, "--trace")
        }</span>
        <span class="cov0" title="0">args = append(args, "-")
        return externallyRenderContent(ctx, path, args)</span>
}

// HasRst returns whether rst2html is installed on this computer.
func HasRst() bool <span class="cov0" title="0">{
        return getRstExecPath() != ""
}</span>

func getRstExecPath() string <span class="cov0" title="0">{
        path, err := exec.LookPath("rst2html")
        if err != nil </span><span class="cov0" title="0">{
                path, err = exec.LookPath("rst2html.py")
                if err != nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
        }
        <span class="cov0" title="0">return path</span>
}

func getPythonExecPath() string <span class="cov0" title="0">{
        path, err := exec.LookPath("python")
        if err != nil </span><span class="cov0" title="0">{
                path, err = exec.LookPath("python.exe")
                if err != nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
        }
        <span class="cov0" title="0">return path</span>
}

// getRstContent calls the Python script rst2html as an external helper
// to convert reStructuredText content to HTML.
func getRstContent(ctx *RenderingContext) []byte <span class="cov0" title="0">{
        path := getRstExecPath()

        if path == "" </span><span class="cov0" title="0">{
                jww.ERROR.Println("rst2html / rst2html.py not found in $PATH: Please install.\n",
                        "                 Leaving reStructuredText content unrendered.")
                return ctx.Content

        }</span>
        <span class="cov0" title="0">jww.INFO.Println("Rendering", ctx.DocumentName, "with", path, "...")
        var result []byte
        // certain *nix based OSs wrap executables in scripted launchers
        // invoking binaries on these OSs via python interpreter causes SyntaxError
        // invoke directly so that shebangs work as expected
        // handle Windows manually because it doesn't do shebangs
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                python := getPythonExecPath()
                args := []string{path, "--leave-comments", "--initial-header-level=2"}
                result = externallyRenderContent(ctx, python, args)
        }</span> else<span class="cov0" title="0"> {
                args := []string{"--leave-comments", "--initial-header-level=2"}
                result = externallyRenderContent(ctx, path, args)
        }</span>
        // TODO(bep) check if rst2html has a body only option.
        <span class="cov0" title="0">bodyStart := bytes.Index(result, []byte("&lt;body&gt;\n"))
        if bodyStart &lt; 0 </span><span class="cov0" title="0">{
                bodyStart = -7 //compensate for length
        }</span>

        <span class="cov0" title="0">bodyEnd := bytes.Index(result, []byte("\n&lt;/body&gt;"))
        if bodyEnd &lt; 0 || bodyEnd &gt;= len(result) </span><span class="cov0" title="0">{
                bodyEnd = len(result) - 1
                if bodyEnd &lt; 0 </span><span class="cov0" title="0">{
                        bodyEnd = 0
                }</span>
        }

        <span class="cov0" title="0">return result[bodyStart+7 : bodyEnd]</span>
}

// getPandocContent calls pandoc as an external helper to convert pandoc markdown to HTML.
func getPandocContent(ctx *RenderingContext) []byte <span class="cov0" title="0">{
        path, err := exec.LookPath("pandoc")
        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Println("pandoc not found in $PATH: Please install.\n",
                        "                 Leaving pandoc content unrendered.")
                return ctx.Content
        }</span>
        <span class="cov0" title="0">args := []string{"--mathjax"}
        return externallyRenderContent(ctx, path, args)</span>
}

func orgRender(ctx *RenderingContext, c ContentSpec) []byte <span class="cov0" title="0">{
        config := org.New()
        config.Log = jww.WARN
        writer := org.NewHTMLWriter()
        writer.HighlightCodeBlock = func(source, lang string) string </span><span class="cov0" title="0">{
                highlightedSource, err := c.Highlight(source, lang, "")
                if err != nil </span><span class="cov0" title="0">{
                        jww.ERROR.Printf("Could not highlight source as lang %s. Using raw source.", lang)
                        return source
                }</span>
                <span class="cov0" title="0">return highlightedSource</span>
        }

        <span class="cov0" title="0">html, err := config.Parse(bytes.NewReader(ctx.Content), ctx.DocumentName).Write(writer)
        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Printf("Could not render org: %s. Using unrendered content.", err)
                return ctx.Content
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}

func externallyRenderContent(ctx *RenderingContext, path string, args []string) []byte <span class="cov0" title="0">{
        content := ctx.Content
        cleanContent := bytes.Replace(content, SummaryDivider, []byte(""), 1)

        cmd := exec.Command(path, args...)
        cmd.Stdin = bytes.NewReader(cleanContent)
        var out, cmderr bytes.Buffer
        cmd.Stdout = &amp;out
        cmd.Stderr = &amp;cmderr
        err := cmd.Run()
        // Most external helpers exit w/ non-zero exit code only if severe, i.e.
        // halting errors occurred. -&gt; log stderr output regardless of state of err
        for _, item := range strings.Split(cmderr.String(), "\n") </span><span class="cov0" title="0">{
                item := strings.TrimSpace(item)
                if item != "" </span><span class="cov0" title="0">{
                        jww.ERROR.Printf("%s: %s", ctx.DocumentName, item)
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Printf("%s rendering %s: %v", path, ctx.DocumentName, err)
        }</span>

        <span class="cov0" title="0">return normalizeExternalHelperLineFeeds(out.Bytes())</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "bytes"
        "strings"

        "github.com/gohugoio/hugo/config"
        "github.com/miekg/mmark"
        "github.com/russross/blackfriday"
)

// HugoHTMLRenderer wraps a blackfriday.Renderer, typically a blackfriday.Html
// Enabling Hugo to customise the rendering experience
type HugoHTMLRenderer struct {
        cs *ContentSpec
        *RenderingContext
        blackfriday.Renderer
}

// BlockCode renders a given text as a block of code.
// Pygments is used if it is setup to handle code fences.
func (r *HugoHTMLRenderer) BlockCode(out *bytes.Buffer, text []byte, lang string) <span class="cov0" title="0">{
        if r.Cfg.GetBool("pygmentsCodeFences") &amp;&amp; (lang != "" || r.Cfg.GetBool("pygmentsCodeFencesGuessSyntax")) </span><span class="cov0" title="0">{
                opts := r.Cfg.GetString("pygmentsOptions")
                str := strings.Trim(string(text), "\n\r")
                highlighted, _ := r.cs.Highlight(str, lang, opts)
                out.WriteString(highlighted)
        }</span> else<span class="cov0" title="0"> {
                r.Renderer.BlockCode(out, text, lang)
        }</span>
}

// ListItem adds task list support to the Blackfriday renderer.
func (r *HugoHTMLRenderer) ListItem(out *bytes.Buffer, text []byte, flags int) <span class="cov8" title="1">{
        if !r.Config.TaskLists </span><span class="cov0" title="0">{
                r.Renderer.ListItem(out, text, flags)
                return
        }</span>

        <span class="cov8" title="1">switch </span>{
        case bytes.HasPrefix(text, []byte("[ ] ")):<span class="cov0" title="0">
                text = append([]byte(`&lt;label&gt;&lt;input type="checkbox" disabled class="task-list-item"&gt;`), text[3:]...)
                text = append(text, []byte(`&lt;/label&gt;`)...)</span>

        case bytes.HasPrefix(text, []byte("[x] ")) || bytes.HasPrefix(text, []byte("[X] ")):<span class="cov0" title="0">
                text = append([]byte(`&lt;label&gt;&lt;input type="checkbox" checked disabled class="task-list-item"&gt;`), text[3:]...)
                text = append(text, []byte(`&lt;/label&gt;`)...)</span>
        }

        <span class="cov8" title="1">r.Renderer.ListItem(out, text, flags)</span>
}

// List adds task list support to the Blackfriday renderer.
func (r *HugoHTMLRenderer) List(out *bytes.Buffer, text func() bool, flags int) <span class="cov8" title="1">{
        if !r.Config.TaskLists </span><span class="cov0" title="0">{
                r.Renderer.List(out, text, flags)
                return
        }</span>
        <span class="cov8" title="1">marker := out.Len()
        r.Renderer.List(out, text, flags)
        if out.Len() &gt; marker </span><span class="cov8" title="1">{
                list := out.Bytes()[marker:]
                if bytes.Contains(list, []byte("task-list-item")) </span><span class="cov0" title="0">{
                        // Find the index of the first &gt;, it might be 3 or 4 depending on whether
                        // there is a new line at the start, but this is safer than just hardcoding it.
                        closingBracketIndex := bytes.Index(list, []byte("&gt;"))
                        // Rewrite the buffer from the marker
                        out.Truncate(marker)
                        // Safely assuming closingBracketIndex won't be -1 since there is a list
                        // May be either dl, ul or ol
                        list := append(list[:closingBracketIndex], append([]byte(` class="task-list"`), list[closingBracketIndex:]...)...)
                        out.Write(list)
                }</span>
        }
}

// HugoMmarkHTMLRenderer wraps a mmark.Renderer, typically a mmark.html,
// enabling Hugo to customise the rendering experience.
type HugoMmarkHTMLRenderer struct {
        cs *ContentSpec
        mmark.Renderer
        Cfg config.Provider
}

// BlockCode renders a given text as a block of code.
// Pygments is used if it is setup to handle code fences.
func (r *HugoMmarkHTMLRenderer) BlockCode(out *bytes.Buffer, text []byte, lang string, caption []byte, subfigure bool, callouts bool) <span class="cov0" title="0">{
        if r.Cfg.GetBool("pygmentsCodeFences") &amp;&amp; (lang != "" || r.Cfg.GetBool("pygmentsCodeFencesGuessSyntax")) </span><span class="cov0" title="0">{
                str := strings.Trim(string(text), "\n\r")
                highlighted, _ := r.cs.Highlight(str, lang, "")
                out.WriteString(highlighted)
        }</span> else<span class="cov0" title="0"> {
                r.Renderer.BlockCode(out, text, lang, caption, subfigure, callouts)
        }</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package helpers

import (
        "path/filepath"
        "sort"
        "strings"

        "github.com/alecthomas/chroma/lexers"
        "github.com/gohugoio/hugo/docshelper"
)

// This is is just some helpers used to create some JSON used in the Hugo docs.
func init() <span class="cov8" title="1">{

        docsProvider := func() map[string]interface{} </span><span class="cov0" title="0">{
                docs := make(map[string]interface{})

                var chromaLexers []interface{}

                sort.Sort(lexers.Registry.Lexers)

                for _, l := range lexers.Registry.Lexers </span><span class="cov0" title="0">{

                        config := l.Config()

                        var filenames []string
                        filenames = append(filenames, config.Filenames...)
                        filenames = append(filenames, config.AliasFilenames...)

                        aliases := config.Aliases

                        for _, filename := range filenames </span><span class="cov0" title="0">{
                                alias := strings.TrimSpace(strings.TrimPrefix(filepath.Ext(filename), "."))
                                if alias != "" </span><span class="cov0" title="0">{
                                        aliases = append(aliases, alias)
                                }</span>
                        }

                        <span class="cov0" title="0">aliases = UniqueStringsSorted(aliases)

                        lexerEntry := struct {
                                Name    string
                                Aliases []string
                        }{
                                config.Name,
                                aliases,
                        }

                        chromaLexers = append(chromaLexers, lexerEntry)

                        docs["lexers"] = chromaLexers</span>
                }
                <span class="cov0" title="0">return docs</span>

        }

        <span class="cov8" title="1">docshelper.AddDocProvider("chroma", docsProvider)</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "bytes"
        "sync"

        "github.com/kyokomi/emoji"
)

var (
        emojiInit sync.Once

        emojis = make(map[string][]byte)

        emojiDelim     = []byte(":")
        emojiWordDelim = []byte(" ")
        emojiMaxSize   int
)

// Emoji returns the emojy given a key, e.g. ":smile:", nil if not found.
func Emoji(key string) []byte <span class="cov0" title="0">{
        emojiInit.Do(initEmoji)
        return emojis[key]
}</span>

// Emojify "emojifies" the input source.
// Note that the input byte slice will be modified if needed.
// See http://www.emoji-cheat-sheet.com/
func Emojify(source []byte) []byte <span class="cov0" title="0">{
        emojiInit.Do(initEmoji)

        start := 0
        k := bytes.Index(source[start:], emojiDelim)

        for k != -1 </span><span class="cov0" title="0">{

                j := start + k

                upper := j + emojiMaxSize

                if upper &gt; len(source) </span><span class="cov0" title="0">{
                        upper = len(source)
                }</span>

                <span class="cov0" title="0">endEmoji := bytes.Index(source[j+1:upper], emojiDelim)
                nextWordDelim := bytes.Index(source[j:upper], emojiWordDelim)

                if endEmoji &lt; 0 </span><span class="cov0" title="0">{
                        start++
                }</span> else<span class="cov0" title="0"> if endEmoji == 0 || (nextWordDelim != -1 &amp;&amp; nextWordDelim &lt; endEmoji) </span><span class="cov0" title="0">{
                        start += endEmoji + 1
                }</span> else<span class="cov0" title="0"> {
                        endKey := endEmoji + j + 2
                        emojiKey := source[j:endKey]

                        if emoji, ok := emojis[string(emojiKey)]; ok </span><span class="cov0" title="0">{
                                source = append(source[:j], append(emoji, source[endKey:]...)...)
                        }</span>

                        <span class="cov0" title="0">start += endEmoji</span>
                }

                <span class="cov0" title="0">if start &gt;= len(source) </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">k = bytes.Index(source[start:], emojiDelim)</span>
        }

        <span class="cov0" title="0">return source</span>
}

func initEmoji() <span class="cov0" title="0">{
        emojiMap := emoji.CodeMap()

        for k, v := range emojiMap </span><span class="cov0" title="0">{
                emojis[k] = []byte(v)

                if len(k) &gt; emojiMaxSize </span><span class="cov0" title="0">{
                        emojiMaxSize = len(k)
                }</span>
        }

}
</pre>
		
		<pre class="file" id="file73" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "bytes"
        "crypto/md5"
        "encoding/hex"
        "fmt"
        "io"
        "net"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "unicode"
        "unicode/utf8"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/common/hugo"

        "github.com/spf13/afero"

        "github.com/jdkato/prose/transform"

        bp "github.com/gohugoio/hugo/bufferpool"
        jww "github.com/spf13/jwalterweatherman"
        "github.com/spf13/pflag"
)

// FilePathSeparator as defined by os.Separator.
const FilePathSeparator = string(filepath.Separator)

// Strips carriage returns from third-party / external processes (useful for Windows)
func normalizeExternalHelperLineFeeds(content []byte) []byte <span class="cov0" title="0">{
        return bytes.Replace(content, []byte("\r"), []byte(""), -1)
}</span>

// FindAvailablePort returns an available and valid TCP port.
func FindAvailablePort() (*net.TCPAddr, error) <span class="cov0" title="0">{
        l, err := net.Listen("tcp", ":0")
        if err == nil </span><span class="cov0" title="0">{
                defer l.Close()
                addr := l.Addr()
                if a, ok := addr.(*net.TCPAddr); ok </span><span class="cov0" title="0">{
                        return a, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unable to obtain a valid tcp port: %v", addr)</span>
        }
        <span class="cov0" title="0">return nil, err</span>
}

// InStringArray checks if a string is an element of a slice of strings
// and returns a boolean value.
func InStringArray(arr []string, el string) bool <span class="cov0" title="0">{
        for _, v := range arr </span><span class="cov0" title="0">{
                if v == el </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GuessType attempts to guess the type of file from a given string.
func GuessType(in string) string <span class="cov8" title="1">{
        switch strings.ToLower(in) </span>{
        case "md", "markdown", "mdown":<span class="cov8" title="1">
                return "markdown"</span>
        case "asciidoc", "adoc", "ad":<span class="cov0" title="0">
                return "asciidoc"</span>
        case "mmark":<span class="cov0" title="0">
                return "mmark"</span>
        case "rst":<span class="cov0" title="0">
                return "rst"</span>
        case "pandoc", "pdc":<span class="cov0" title="0">
                return "pandoc"</span>
        case "html", "htm":<span class="cov0" title="0">
                return "html"</span>
        case "org":<span class="cov0" title="0">
                return "org"</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// FirstUpper returns a string with the first character as upper case.
func FirstUpper(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">r, n := utf8.DecodeRuneInString(s)
        return string(unicode.ToUpper(r)) + s[n:]</span>
}

// UniqueStrings returns a new slice with any duplicates removed.
func UniqueStrings(s []string) []string <span class="cov0" title="0">{
        unique := make([]string, 0, len(s))
        set := map[string]interface{}{}
        for _, val := range s </span><span class="cov0" title="0">{
                if _, ok := set[val]; !ok </span><span class="cov0" title="0">{
                        unique = append(unique, val)
                        set[val] = val
                }</span>
        }
        <span class="cov0" title="0">return unique</span>
}

// UniqueStringsReuse returns a slice with any duplicates removed.
// It will modify the input slice.
func UniqueStringsReuse(s []string) []string <span class="cov8" title="1">{
        set := map[string]interface{}{}
        result := s[:0]
        for _, val := range s </span><span class="cov8" title="1">{
                if _, ok := set[val]; !ok </span><span class="cov8" title="1">{
                        result = append(result, val)
                        set[val] = val
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// UniqueStringsReuse returns a sorted slice with any duplicates removed.
// It will modify the input slice.
func UniqueStringsSorted(s []string) []string <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">ss := sort.StringSlice(s)
        ss.Sort()
        i := 0
        for j := 1; j &lt; len(s); j++ </span><span class="cov0" title="0">{
                if !ss.Less(i, j) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">i++
                s[i] = s[j]</span>
        }

        <span class="cov0" title="0">return s[:i+1]</span>
}

// ReaderToBytes takes an io.Reader argument, reads from it
// and returns bytes.
func ReaderToBytes(lines io.Reader) []byte <span class="cov8" title="1">{
        if lines == nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov8" title="1">b := bp.GetBuffer()
        defer bp.PutBuffer(b)

        b.ReadFrom(lines)

        bc := make([]byte, b.Len())
        copy(bc, b.Bytes())
        return bc</span>
}

// ReaderToString is the same as ReaderToBytes, but returns a string.
func ReaderToString(lines io.Reader) string <span class="cov0" title="0">{
        if lines == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">b := bp.GetBuffer()
        defer bp.PutBuffer(b)
        b.ReadFrom(lines)
        return b.String()</span>
}

// ReaderContains reports whether subslice is within r.
func ReaderContains(r io.Reader, subslice []byte) bool <span class="cov0" title="0">{

        if r == nil || len(subslice) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">bufflen := len(subslice) * 4
        halflen := bufflen / 2
        buff := make([]byte, bufflen)
        var err error
        var n, i int

        for </span><span class="cov0" title="0">{
                i++
                if i == 1 </span><span class="cov0" title="0">{
                        n, err = io.ReadAtLeast(r, buff[:halflen], halflen)
                }</span> else<span class="cov0" title="0"> {
                        if i != 2 </span><span class="cov0" title="0">{
                                // shift left to catch overlapping matches
                                copy(buff[:], buff[halflen:])
                        }</span>
                        <span class="cov0" title="0">n, err = io.ReadAtLeast(r, buff[halflen:], halflen)</span>
                }

                <span class="cov0" title="0">if n &gt; 0 &amp;&amp; bytes.Contains(buff, subslice) </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// GetTitleFunc returns a func that can be used to transform a string to
// title case.
//
// The supported styles are
//
// - "Go" (strings.Title)
// - "AP" (see https://www.apstylebook.com/)
// - "Chicago" (see http://www.chicagomanualofstyle.org/home.html)
//
// If an unknown or empty style is provided, AP style is what you get.
func GetTitleFunc(style string) func(s string) string <span class="cov8" title="1">{
        switch strings.ToLower(style) </span>{
        case "go":<span class="cov0" title="0">
                return strings.Title</span>
        case "chicago":<span class="cov0" title="0">
                tc := transform.NewTitleConverter(transform.ChicagoStyle)
                return tc.Title</span>
        default:<span class="cov8" title="1">
                tc := transform.NewTitleConverter(transform.APStyle)
                return tc.Title</span>
        }
}

// HasStringsPrefix tests whether the string slice s begins with prefix slice s.
func HasStringsPrefix(s, prefix []string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(prefix) &amp;&amp; compareStringSlices(s[0:len(prefix)], prefix)
}</span>

// HasStringsSuffix tests whether the string slice s ends with suffix slice s.
func HasStringsSuffix(s, suffix []string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(suffix) &amp;&amp; compareStringSlices(s[len(s)-len(suffix):], suffix)
}</span>

func compareStringSlices(a, b []string) bool <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if a == nil || b == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for i := range a </span><span class="cov0" title="0">{
                if a[i] != b[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// LogPrinter is the common interface of the JWWs loggers.
type LogPrinter interface {
        // Println is the only common method that works in all of JWWs loggers.
        Println(a ...interface{})
}

// DistinctLogger ignores duplicate log statements.
type DistinctLogger struct {
        sync.RWMutex
        logger LogPrinter
        m      map[string]bool
}

// Println will log the string returned from fmt.Sprintln given the arguments,
// but not if it has been logged before.
func (l *DistinctLogger) Println(v ...interface{}) <span class="cov0" title="0">{
        // fmt.Sprint doesn't add space between string arguments
        logStatement := strings.TrimSpace(fmt.Sprintln(v...))
        l.print(logStatement)
}</span>

// Printf will log the string returned from fmt.Sprintf given the arguments,
// but not if it has been logged before.
// Note: A newline is appended.
func (l *DistinctLogger) Printf(format string, v ...interface{}) <span class="cov8" title="1">{
        logStatement := fmt.Sprintf(format, v...)
        l.print(logStatement)
}</span>

func (l *DistinctLogger) print(logStatement string) <span class="cov8" title="1">{
        l.RLock()
        if l.m[logStatement] </span><span class="cov8" title="1">{
                l.RUnlock()
                return
        }</span>
        <span class="cov8" title="1">l.RUnlock()

        l.Lock()
        if !l.m[logStatement] </span><span class="cov8" title="1">{
                l.logger.Println(logStatement)
                l.m[logStatement] = true
        }</span>
        <span class="cov8" title="1">l.Unlock()</span>
}

// NewDistinctErrorLogger creates a new DistinctLogger that logs ERRORs
func NewDistinctErrorLogger() *DistinctLogger <span class="cov8" title="1">{
        return &amp;DistinctLogger{m: make(map[string]bool), logger: jww.ERROR}
}</span>

// NewDistinctLogger creates a new DistinctLogger that logs to the provided logger.
func NewDistinctLogger(logger LogPrinter) *DistinctLogger <span class="cov8" title="1">{
        return &amp;DistinctLogger{m: make(map[string]bool), logger: logger}
}</span>

// NewDistinctWarnLogger creates a new DistinctLogger that logs WARNs
func NewDistinctWarnLogger() *DistinctLogger <span class="cov8" title="1">{
        return &amp;DistinctLogger{m: make(map[string]bool), logger: jww.WARN}
}</span>

// NewDistinctFeedbackLogger creates a new DistinctLogger that can be used
// to give feedback to the user while not spamming with duplicates.
func NewDistinctFeedbackLogger() *DistinctLogger <span class="cov8" title="1">{
        return &amp;DistinctLogger{m: make(map[string]bool), logger: jww.FEEDBACK}
}</span>

var (
        // DistinctErrorLog can be used to avoid spamming the logs with errors.
        DistinctErrorLog = NewDistinctErrorLogger()

        // DistinctWarnLog can be used to avoid spamming the logs with warnings.
        DistinctWarnLog = NewDistinctWarnLogger()

        // DistinctFeedbackLog can be used to avoid spamming the logs with info messages.
        DistinctFeedbackLog = NewDistinctFeedbackLogger()
)

// InitLoggers sets up the global distinct loggers.
func InitLoggers() <span class="cov8" title="1">{
        DistinctErrorLog = NewDistinctErrorLogger()
        DistinctWarnLog = NewDistinctWarnLogger()
        DistinctFeedbackLog = NewDistinctFeedbackLogger()
}</span>

// Deprecated informs about a deprecation, but only once for a given set of arguments' values.
// If the err flag is enabled, it logs as an ERROR (will exit with -1) and the text will
// point at the next Hugo release.
// The idea is two remove an item in two Hugo releases to give users and theme authors
// plenty of time to fix their templates.
func Deprecated(object, item, alternative string, err bool) <span class="cov8" title="1">{
        if !strings.HasSuffix(alternative, ".") </span><span class="cov8" title="1">{
                alternative += "."
        }</span>

        <span class="cov8" title="1">if err </span><span class="cov0" title="0">{
                DistinctErrorLog.Printf("%s's %s is deprecated and will be removed in Hugo %s. %s", object, item, hugo.CurrentVersion.Next().ReleaseVersion(), alternative)

        }</span> else<span class="cov8" title="1"> {
                DistinctWarnLog.Printf("%s's %s is deprecated and will be removed in a future release. %s", object, item, alternative)
        }</span>
}

// SliceToLower goes through the source slice and lowers all values.
func SliceToLower(s []string) []string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">l := make([]string, len(s))
        for i, v := range s </span><span class="cov0" title="0">{
                l[i] = strings.ToLower(v)
        }</span>

        <span class="cov0" title="0">return l</span>
}

// MD5String takes a string and returns its MD5 hash.
func MD5String(f string) string <span class="cov8" title="1">{
        h := md5.New()
        h.Write([]byte(f))
        return hex.EncodeToString(h.Sum([]byte{}))
}</span>

// MD5FromFileFast creates a MD5 hash from the given file. It only reads parts of
// the file for speed, so don't use it if the files are very subtly different.
// It will not close the file.
func MD5FromFileFast(r io.ReadSeeker) (string, error) <span class="cov0" title="0">{
        const (
                // Do not change once set in stone!
                maxChunks = 8
                peekSize  = 64
                seek      = 2048
        )

        h := md5.New()
        buff := make([]byte, peekSize)

        for i := 0; i &lt; maxChunks; i++ </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        _, err := r.Seek(seek, 0)
                        if err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">return "", err</span>
                        }
                }

                <span class="cov0" title="0">_, err := io.ReadAtLeast(r, buff, peekSize)
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF || err == io.ErrUnexpectedEOF </span><span class="cov0" title="0">{
                                h.Write(buff)
                                break</span>
                        }
                        <span class="cov0" title="0">return "", err</span>
                }
                <span class="cov0" title="0">h.Write(buff)</span>
        }

        <span class="cov0" title="0">return hex.EncodeToString(h.Sum(nil)), nil</span>
}

// MD5FromReader creates a MD5 hash from the given reader.
func MD5FromReader(r io.Reader) (string, error) <span class="cov0" title="0">{
        h := md5.New()
        if _, err := io.Copy(h, r); err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(h.Sum(nil)), nil</span>
}

// IsWhitespace determines if the given rune is whitespace.
func IsWhitespace(r rune) bool <span class="cov0" title="0">{
        return r == ' ' || r == '\t' || r == '\n' || r == '\r'
}</span>

// NormalizeHugoFlags facilitates transitions of Hugo command-line flags,
// e.g. --baseUrl to --baseURL, --uglyUrls to --uglyURLs
func NormalizeHugoFlags(f *pflag.FlagSet, name string) pflag.NormalizedName <span class="cov8" title="1">{
        switch name </span>{
        case "baseUrl":<span class="cov0" title="0">
                name = "baseURL"</span>
        case "uglyUrls":<span class="cov0" title="0">
                name = "uglyURLs"</span>
        }
        <span class="cov8" title="1">return pflag.NormalizedName(name)</span>
}

// DiffStringSlices returns the difference between two string slices.
// Useful in tests.
// See:
// http://stackoverflow.com/questions/19374219/how-to-find-the-difference-between-two-slices-of-strings-in-golang
func DiffStringSlices(slice1 []string, slice2 []string) []string <span class="cov0" title="0">{
        diffStr := []string{}
        m := map[string]int{}

        for _, s1Val := range slice1 </span><span class="cov0" title="0">{
                m[s1Val] = 1
        }</span>
        <span class="cov0" title="0">for _, s2Val := range slice2 </span><span class="cov0" title="0">{
                m[s2Val] = m[s2Val] + 1
        }</span>

        <span class="cov0" title="0">for mKey, mVal := range m </span><span class="cov0" title="0">{
                if mVal == 1 </span><span class="cov0" title="0">{
                        diffStr = append(diffStr, mKey)
                }</span>
        }

        <span class="cov0" title="0">return diffStr</span>
}

// DiffStrings splits the strings into fields and runs it into DiffStringSlices.
// Useful for tests.
func DiffStrings(s1, s2 string) []string <span class="cov0" title="0">{
        return DiffStringSlices(strings.Fields(s1), strings.Fields(s2))
}</span>

// PrintFs prints the given filesystem to the given writer starting from the given path.
// This is useful for debugging.
func PrintFs(fs afero.Fs, path string, w io.Writer) <span class="cov0" title="0">{
        if fs == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">afero.Walk(fs, path, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                var filename string
                var meta interface{}
                if fim, ok := info.(hugofs.FileMetaInfo); ok </span><span class="cov0" title="0">{
                        filename = fim.Meta().Filename()
                        meta = fim.Meta()
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, "    %q %q\t\t%v\n", path, filename, meta)
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file74" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "unicode"

        "github.com/gohugoio/hugo/config"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/common/hugio"
        _errors "github.com/pkg/errors"
        "github.com/spf13/afero"
        "golang.org/x/text/runes"
        "golang.org/x/text/transform"
        "golang.org/x/text/unicode/norm"
)

var (
        // ErrThemeUndefined is returned when a theme has not be defined by the user.
        ErrThemeUndefined = errors.New("no theme set")
)

// filepathPathBridge is a bridge for common functionality in filepath vs path
type filepathPathBridge interface {
        Base(in string) string
        Clean(in string) string
        Dir(in string) string
        Ext(in string) string
        Join(elem ...string) string
        Separator() string
}

type filepathBridge struct {
}

func (filepathBridge) Base(in string) string <span class="cov8" title="1">{
        return filepath.Base(in)
}</span>

func (filepathBridge) Clean(in string) string <span class="cov0" title="0">{
        return filepath.Clean(in)
}</span>

func (filepathBridge) Dir(in string) string <span class="cov0" title="0">{
        return filepath.Dir(in)
}</span>

func (filepathBridge) Ext(in string) string <span class="cov8" title="1">{
        return filepath.Ext(in)
}</span>

func (filepathBridge) Join(elem ...string) string <span class="cov0" title="0">{
        return filepath.Join(elem...)
}</span>

func (filepathBridge) Separator() string <span class="cov8" title="1">{
        return FilePathSeparator
}</span>

var fpb filepathBridge

// MakePath takes a string with any characters and replace it
// so the string could be used in a path.
// It does so by creating a Unicode-sanitized string, with the spaces replaced,
// whilst preserving the original casing of the string.
// E.g. Social Media -&gt; Social-Media
func (p *PathSpec) MakePath(s string) string <span class="cov8" title="1">{
        return p.UnicodeSanitize(s)
}</span>

// MakePathsSanitized applies MakePathSanitized on every item in the slice
func (p *PathSpec) MakePathsSanitized(paths []string) <span class="cov0" title="0">{
        for i, path := range paths </span><span class="cov0" title="0">{
                paths[i] = p.MakePathSanitized(path)
        }</span>
}

// MakePathSanitized creates a Unicode-sanitized string, with the spaces replaced
func (p *PathSpec) MakePathSanitized(s string) string <span class="cov8" title="1">{
        if p.DisablePathToLower </span><span class="cov0" title="0">{
                return p.MakePath(s)
        }</span>
        <span class="cov8" title="1">return strings.ToLower(p.MakePath(s))</span>
}

// ToSlashTrimLeading is just a filepath.ToSlaas with an added / prefix trimmer.
func ToSlashTrimLeading(s string) string <span class="cov0" title="0">{
        return strings.TrimPrefix(filepath.ToSlash(s), "/")
}</span>

// MakeTitle converts the path given to a suitable title, trimming whitespace
// and replacing hyphens with whitespace.
func MakeTitle(inpath string) string <span class="cov0" title="0">{
        return strings.Replace(strings.TrimSpace(inpath), "-", " ", -1)
}</span>

// From https://golang.org/src/net/url/url.go
func ishex(c rune) bool <span class="cov0" title="0">{
        switch </span>{
        case '0' &lt;= c &amp;&amp; c &lt;= '9':<span class="cov0" title="0">
                return true</span>
        case 'a' &lt;= c &amp;&amp; c &lt;= 'f':<span class="cov0" title="0">
                return true</span>
        case 'A' &lt;= c &amp;&amp; c &lt;= 'F':<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

// UnicodeSanitize sanitizes string to be used in Hugo URL's, allowing only
// a predefined set of special Unicode characters.
// If RemovePathAccents configuration flag is enabled, Uniccode accents
// are also removed.
// Spaces will be replaced with a single hyphen, and sequential hyphens will be reduced to one.
func (p *PathSpec) UnicodeSanitize(s string) string <span class="cov8" title="1">{
        source := []rune(s)
        target := make([]rune, 0, len(source))
        var prependHyphen bool

        for i, r := range source </span><span class="cov8" title="1">{
                isAllowed := r == '.' || r == '/' || r == '\\' || r == '_' || r == '#' || r == '+' || r == '~'
                isAllowed = isAllowed || unicode.IsLetter(r) || unicode.IsDigit(r) || unicode.IsMark(r)
                isAllowed = isAllowed || (r == '%' &amp;&amp; i+2 &lt; len(source) &amp;&amp; ishex(source[i+1]) &amp;&amp; ishex(source[i+2]))

                if isAllowed </span><span class="cov8" title="1">{
                        if prependHyphen </span><span class="cov8" title="1">{
                                target = append(target, '-')
                                prependHyphen = false
                        }</span>
                        <span class="cov8" title="1">target = append(target, r)</span>
                } else<span class="cov8" title="1"> if len(target) &gt; 0 &amp;&amp; (r == '-' || unicode.IsSpace(r)) </span><span class="cov8" title="1">{
                        prependHyphen = true
                }</span>
        }

        <span class="cov8" title="1">var result string

        if p.RemovePathAccents </span><span class="cov0" title="0">{
                // remove accents - see https://blog.golang.org/normalization
                t := transform.Chain(norm.NFD, runes.Remove(runes.In(unicode.Mn)), norm.NFC)
                result, _, _ = transform.String(t, string(target))
        }</span> else<span class="cov8" title="1"> {
                result = string(target)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ReplaceExtension takes a path and an extension, strips the old extension
// and returns the path with the new extension.
func ReplaceExtension(path string, newExt string) string <span class="cov0" title="0">{
        f, _ := fileAndExt(path, fpb)
        return f + "." + newExt
}</span>

func makePathRelative(inPath string, possibleDirectories ...string) (string, error) <span class="cov0" title="0">{

        for _, currentPath := range possibleDirectories </span><span class="cov0" title="0">{
                if strings.HasPrefix(inPath, currentPath) </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(inPath, currentPath), nil
                }</span>
        }
        <span class="cov0" title="0">return inPath, errors.New("can't extract relative path, unknown prefix")</span>
}

// Should be good enough for Hugo.
var isFileRe = regexp.MustCompile(`.*\..{1,6}$`)

// GetDottedRelativePath expects a relative path starting after the content directory.
// It returns a relative path with dots ("..") navigating up the path structure.
func GetDottedRelativePath(inPath string) string <span class="cov0" title="0">{
        inPath = filepath.Clean(filepath.FromSlash(inPath))

        if inPath == "." </span><span class="cov0" title="0">{
                return "./"
        }</span>

        <span class="cov0" title="0">if !isFileRe.MatchString(inPath) &amp;&amp; !strings.HasSuffix(inPath, FilePathSeparator) </span><span class="cov0" title="0">{
                inPath += FilePathSeparator
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(inPath, FilePathSeparator) </span><span class="cov0" title="0">{
                inPath = FilePathSeparator + inPath
        }</span>

        <span class="cov0" title="0">dir, _ := filepath.Split(inPath)

        sectionCount := strings.Count(dir, FilePathSeparator)

        if sectionCount == 0 || dir == FilePathSeparator </span><span class="cov0" title="0">{
                return "./"
        }</span>

        <span class="cov0" title="0">var dottedPath string

        for i := 1; i &lt; sectionCount; i++ </span><span class="cov0" title="0">{
                dottedPath += "../"
        }</span>

        <span class="cov0" title="0">return dottedPath</span>
}

// ExtNoDelimiter takes a path and returns the extension, excluding the delmiter, i.e. "md".
func ExtNoDelimiter(in string) string <span class="cov8" title="1">{
        return strings.TrimPrefix(Ext(in), ".")
}</span>

// Ext takes a path and returns the extension, including the delmiter, i.e. ".md".
func Ext(in string) string <span class="cov8" title="1">{
        _, ext := fileAndExt(in, fpb)
        return ext
}</span>

// PathAndExt is the same as FileAndExt, but it uses the path package.
func PathAndExt(in string) (string, string) <span class="cov0" title="0">{
        return fileAndExt(in, pb)
}</span>

// FileAndExt takes a path and returns the file and extension separated,
// the extension including the delmiter, i.e. ".md".
func FileAndExt(in string) (string, string) <span class="cov0" title="0">{
        return fileAndExt(in, fpb)
}</span>

// FileAndExtNoDelimiter takes a path and returns the file and extension separated,
// the extension excluding the delmiter, e.g "md".
func FileAndExtNoDelimiter(in string) (string, string) <span class="cov0" title="0">{
        file, ext := fileAndExt(in, fpb)
        return file, strings.TrimPrefix(ext, ".")
}</span>

// Filename takes a path, strips out the extension,
// and returns the name of the file.
func Filename(in string) (name string) <span class="cov8" title="1">{
        name, _ = fileAndExt(in, fpb)
        return
}</span>

// FileAndExt returns the filename and any extension of a file path as
// two separate strings.
//
// If the path, in, contains a directory name ending in a slash,
// then both name and ext will be empty strings.
//
// If the path, in, is either the current directory, the parent
// directory or the root directory, or an empty string,
// then both name and ext will be empty strings.
//
// If the path, in, represents the path of a file without an extension,
// then name will be the name of the file and ext will be an empty string.
//
// If the path, in, represents a filename with an extension,
// then name will be the filename minus any extension - including the dot
// and ext will contain the extension - minus the dot.
func fileAndExt(in string, b filepathPathBridge) (name string, ext string) <span class="cov8" title="1">{
        ext = b.Ext(in)
        base := b.Base(in)

        return extractFilename(in, ext, base, b.Separator()), ext
}</span>

func extractFilename(in, ext, base, pathSeparator string) (name string) <span class="cov8" title="1">{

        // No file name cases. These are defined as:
        // 1. any "in" path that ends in a pathSeparator
        // 2. any "base" consisting of just an pathSeparator
        // 3. any "base" consisting of just an empty string
        // 4. any "base" consisting of just the current directory i.e. "."
        // 5. any "base" consisting of just the parent directory i.e. ".."
        if (strings.LastIndex(in, pathSeparator) == len(in)-1) || base == "" || base == "." || base == ".." || base == pathSeparator </span><span class="cov0" title="0">{
                name = "" // there is NO filename
        }</span> else<span class="cov8" title="1"> if ext != "" </span><span class="cov8" title="1">{ // there was an Extension
                // return the filename minus the extension (and the ".")
                name = base[:strings.LastIndex(base, ".")]
        }</span> else<span class="cov0" title="0"> {
                // no extension case so just return base, which willi
                // be the filename
                name = base
        }</span>
        <span class="cov8" title="1">return</span>

}

// GetRelativePath returns the relative path of a given path.
func GetRelativePath(path, base string) (final string, err error) <span class="cov0" title="0">{
        if filepath.IsAbs(path) &amp;&amp; base == "" </span><span class="cov0" title="0">{
                return "", errors.New("source: missing base directory")
        }</span>
        <span class="cov0" title="0">name := filepath.Clean(path)
        base = filepath.Clean(base)

        name, err = filepath.Rel(base, name)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if strings.HasSuffix(filepath.FromSlash(path), FilePathSeparator) &amp;&amp; !strings.HasSuffix(name, FilePathSeparator) </span><span class="cov0" title="0">{
                name += FilePathSeparator
        }</span>
        <span class="cov0" title="0">return name, nil</span>
}

// PathPrep prepares the path using the uglify setting to create paths on
// either the form /section/name/index.html or /section/name.html.
func PathPrep(ugly bool, in string) string <span class="cov0" title="0">{
        if ugly </span><span class="cov0" title="0">{
                return Uglify(in)
        }</span>
        <span class="cov0" title="0">return PrettifyPath(in)</span>
}

// PrettifyPath is the same as PrettifyURLPath but for file paths.
//     /section/name.html       becomes /section/name/index.html
//     /section/name/           becomes /section/name/index.html
//     /section/name/index.html becomes /section/name/index.html
func PrettifyPath(in string) string <span class="cov0" title="0">{
        return prettifyPath(in, fpb)
}</span>

func prettifyPath(in string, b filepathPathBridge) string <span class="cov0" title="0">{
        if filepath.Ext(in) == "" </span><span class="cov0" title="0">{
                // /section/name/  -&gt; /section/name/index.html
                if len(in) &lt; 2 </span><span class="cov0" title="0">{
                        return b.Separator()
                }</span>
                <span class="cov0" title="0">return b.Join(in, "index.html")</span>
        }
        <span class="cov0" title="0">name, ext := fileAndExt(in, b)
        if name == "index" </span><span class="cov0" title="0">{
                // /section/name/index.html -&gt; /section/name/index.html
                return b.Clean(in)
        }</span>
        // /section/name.html -&gt; /section/name/index.html
        <span class="cov0" title="0">return b.Join(b.Dir(in), name, "index"+ext)</span>
}

type NamedSlice struct {
        Name  string
        Slice []string
}

func (n NamedSlice) String() string <span class="cov0" title="0">{
        if len(n.Slice) == 0 </span><span class="cov0" title="0">{
                return n.Name
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s%s{%s}", n.Name, FilePathSeparator, strings.Join(n.Slice, ","))</span>
}

func ExtractAndGroupRootPaths(paths []string) []NamedSlice <span class="cov0" title="0">{
        if len(paths) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">pathsCopy := make([]string, len(paths))
        hadSlashPrefix := strings.HasPrefix(paths[0], FilePathSeparator)

        for i, p := range paths </span><span class="cov0" title="0">{
                pathsCopy[i] = strings.Trim(filepath.ToSlash(p), "/")
        }</span>

        <span class="cov0" title="0">sort.Strings(pathsCopy)

        pathsParts := make([][]string, len(pathsCopy))

        for i, p := range pathsCopy </span><span class="cov0" title="0">{
                pathsParts[i] = strings.Split(p, "/")
        }</span>

        <span class="cov0" title="0">var groups [][]string

        for i, p1 := range pathsParts </span><span class="cov0" title="0">{
                c1 := -1

                for j, p2 := range pathsParts </span><span class="cov0" title="0">{
                        if i == j </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">c2 := -1

                        for i, v := range p1 </span><span class="cov0" title="0">{
                                if i &gt;= len(p2) </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">if v != p2[i] </span><span class="cov0" title="0">{
                                        break</span>
                                }

                                <span class="cov0" title="0">c2 = i</span>
                        }

                        <span class="cov0" title="0">if c1 == -1 || (c2 != -1 &amp;&amp; c2 &lt; c1) </span><span class="cov0" title="0">{
                                c1 = c2
                        }</span>
                }

                <span class="cov0" title="0">if c1 != -1 </span><span class="cov0" title="0">{
                        groups = append(groups, p1[:c1+1])
                }</span> else<span class="cov0" title="0"> {
                        groups = append(groups, p1)
                }</span>
        }

        <span class="cov0" title="0">groupsStr := make([]string, len(groups))
        for i, g := range groups </span><span class="cov0" title="0">{
                groupsStr[i] = strings.Join(g, "/")
        }</span>

        <span class="cov0" title="0">groupsStr = UniqueStringsSorted(groupsStr)

        var result []NamedSlice

        for _, g := range groupsStr </span><span class="cov0" title="0">{
                name := filepath.FromSlash(g)
                if hadSlashPrefix </span><span class="cov0" title="0">{
                        name = FilePathSeparator + name
                }</span>
                <span class="cov0" title="0">ns := NamedSlice{Name: name}
                for _, p := range pathsCopy </span><span class="cov0" title="0">{
                        if !strings.HasPrefix(p, g) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">p = strings.TrimPrefix(p, g)
                        if p != "" </span><span class="cov0" title="0">{
                                ns.Slice = append(ns.Slice, p)
                        }</span>
                }

                <span class="cov0" title="0">ns.Slice = UniqueStrings(ExtractRootPaths(ns.Slice))

                result = append(result, ns)</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ExtractRootPaths extracts the root paths from the supplied list of paths.
// The resulting root path will not contain any file separators, but there
// may be duplicates.
// So "/content/section/" becomes "content"
func ExtractRootPaths(paths []string) []string <span class="cov0" title="0">{
        r := make([]string, len(paths))
        for i, p := range paths </span><span class="cov0" title="0">{
                root := filepath.ToSlash(p)
                sections := strings.Split(root, "/")
                for _, section := range sections </span><span class="cov0" title="0">{
                        if section != "" </span><span class="cov0" title="0">{
                                root = section
                                break</span>
                        }
                }
                <span class="cov0" title="0">r[i] = root</span>
        }
        <span class="cov0" title="0">return r</span>

}

// FindCWD returns the current working directory from where the Hugo
// executable is run.
func FindCWD() (string, error) <span class="cov0" title="0">{
        serverFile, err := filepath.Abs(os.Args[0])

        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("can't get absolute path for executable: %v", err)
        }</span>

        <span class="cov0" title="0">path := filepath.Dir(serverFile)
        realFile, err := filepath.EvalSymlinks(serverFile)

        if err != nil </span><span class="cov0" title="0">{
                if _, err = os.Stat(serverFile + ".exe"); err == nil </span><span class="cov0" title="0">{
                        realFile = filepath.Clean(serverFile + ".exe")
                }</span>
        }

        <span class="cov0" title="0">if err == nil &amp;&amp; realFile != serverFile </span><span class="cov0" title="0">{
                path = filepath.Dir(realFile)
        }</span>

        <span class="cov0" title="0">return path, nil</span>
}

// SymbolicWalk is like filepath.Walk, but it follows symbolic links.
func SymbolicWalk(fs afero.Fs, root string, walker hugofs.WalkFunc) error <span class="cov8" title="1">{
        if _, isOs := fs.(*afero.OsFs); isOs </span><span class="cov0" title="0">{
                // Mainly to track symlinks.
                fs = hugofs.NewBaseFileDecorator(fs)
        }</span>

        <span class="cov8" title="1">w := hugofs.NewWalkway(hugofs.WalkwayConfig{
                Fs:     fs,
                Root:   root,
                WalkFn: walker,
        })

        return w.Walk()</span>

}

// LstatIfPossible can be used to call Lstat if possible, else Stat.
func LstatIfPossible(fs afero.Fs, path string) (os.FileInfo, error) <span class="cov0" title="0">{
        if lstater, ok := fs.(afero.Lstater); ok </span><span class="cov0" title="0">{
                fi, _, err := lstater.LstatIfPossible(path)
                return fi, err
        }</span>

        <span class="cov0" title="0">return fs.Stat(path)</span>
}

// SafeWriteToDisk is the same as WriteToDisk
// but it also checks to see if file/directory already exists.
func SafeWriteToDisk(inpath string, r io.Reader, fs afero.Fs) (err error) <span class="cov0" title="0">{
        return afero.SafeWriteReader(fs, inpath, r)
}</span>

// WriteToDisk writes content to disk.
func WriteToDisk(inpath string, r io.Reader, fs afero.Fs) (err error) <span class="cov0" title="0">{
        return afero.WriteReader(fs, inpath, r)
}</span>

// OpenFilesForWriting opens all the given filenames for writing.
func OpenFilesForWriting(fs afero.Fs, filenames ...string) (io.WriteCloser, error) <span class="cov0" title="0">{
        var writeClosers []io.WriteCloser
        for _, filename := range filenames </span><span class="cov0" title="0">{
                f, err := OpenFileForWriting(fs, filename)
                if err != nil </span><span class="cov0" title="0">{
                        for _, wc := range writeClosers </span><span class="cov0" title="0">{
                                wc.Close()
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov0" title="0">writeClosers = append(writeClosers, f)</span>
        }

        <span class="cov0" title="0">return hugio.NewMultiWriteCloser(writeClosers...), nil</span>

}

// OpenFileForWriting opens or creates the given file. If the target directory
// does not exist, it gets created.
func OpenFileForWriting(fs afero.Fs, filename string) (afero.File, error) <span class="cov8" title="1">{
        filename = filepath.Clean(filename)
        // Create will truncate if file already exists.
        // os.Create will create any new files with mode 0666 (before umask).
        f, err := fs.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err = fs.MkdirAll(filepath.Dir(filename), 0777); err != nil </span><span class="cov0" title="0">{ //  before umask
                        return nil, err
                }</span>
                <span class="cov8" title="1">f, err = fs.Create(filename)</span>
        }

        <span class="cov8" title="1">return f, err</span>
}

// GetCacheDir returns a cache dir from the given filesystem and config.
// The dir will be created if it does not exist.
func GetCacheDir(fs afero.Fs, cfg config.Provider) (string, error) <span class="cov8" title="1">{
        cacheDir := getCacheDir(cfg)
        if cacheDir != "" </span><span class="cov0" title="0">{
                exists, err := DirExists(cacheDir, fs)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        err := fs.MkdirAll(cacheDir, 0777) // Before umask
                        if err != nil </span><span class="cov0" title="0">{
                                return "", _errors.Wrap(err, "failed to create cache dir")
                        }</span>
                }
                <span class="cov0" title="0">return cacheDir, nil</span>
        }

        // Fall back to a cache in /tmp.
        <span class="cov8" title="1">return GetTempDir("hugo_cache", fs), nil</span>

}

func getCacheDir(cfg config.Provider) string <span class="cov8" title="1">{
        // Always use the cacheDir config if set.
        cacheDir := cfg.GetString("cacheDir")
        if len(cacheDir) &gt; 1 </span><span class="cov0" title="0">{
                return addTrailingFileSeparator(cacheDir)
        }</span>

        // Both of these are fairly distinctive OS env keys used by Netlify.
        <span class="cov8" title="1">if os.Getenv("DEPLOY_PRIME_URL") != "" &amp;&amp; os.Getenv("PULL_REQUEST") != "" </span><span class="cov0" title="0">{
                // Netlify's cache behaviour is not documented, the currently best example
                // is this project:
                // https://github.com/philhawksworth/content-shards/blob/master/gulpfile.js
                return "/opt/build/cache/hugo_cache/"

        }</span>

        // This will fall back to an hugo_cache folder in the tmp dir, which should work fine for most CI
        // providers. See this for a working CircleCI setup:
        // https://github.com/bep/hugo-sass-test/blob/6c3960a8f4b90e8938228688bc49bdcdd6b2d99e/.circleci/config.yml
        // If not, they can set the HUGO_CACHEDIR environment variable or cacheDir config key.
        <span class="cov8" title="1">return ""</span>
}

func addTrailingFileSeparator(s string) string <span class="cov0" title="0">{
        if !strings.HasSuffix(s, FilePathSeparator) </span><span class="cov0" title="0">{
                s = s + FilePathSeparator
        }</span>
        <span class="cov0" title="0">return s</span>
}

// GetTempDir returns a temporary directory with the given sub path.
func GetTempDir(subPath string, fs afero.Fs) string <span class="cov8" title="1">{
        return afero.GetTempDir(fs, subPath)
}</span>

// DirExists checks if a path exists and is a directory.
func DirExists(path string, fs afero.Fs) (bool, error) <span class="cov0" title="0">{
        return afero.DirExists(fs, path)
}</span>

// IsDir checks if a given path is a directory.
func IsDir(path string, fs afero.Fs) (bool, error) <span class="cov0" title="0">{
        return afero.IsDir(fs, path)
}</span>

// IsEmpty checks if a given path is empty.
func IsEmpty(path string, fs afero.Fs) (bool, error) <span class="cov0" title="0">{
        return afero.IsEmpty(fs, path)
}</span>

// FileContains checks if a file contains a specified string.
func FileContains(filename string, subslice []byte, fs afero.Fs) (bool, error) <span class="cov0" title="0">{
        return afero.FileContainsBytes(fs, filename, subslice)
}</span>

// FileContainsAny checks if a file contains any of the specified strings.
func FileContainsAny(filename string, subslices [][]byte, fs afero.Fs) (bool, error) <span class="cov8" title="1">{
        return afero.FileContainsAnyBytes(fs, filename, subslices)
}</span>

// Exists checks if a file or directory exists.
func Exists(path string, fs afero.Fs) (bool, error) <span class="cov8" title="1">{
        return afero.Exists(fs, path)
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">// Copyright 2016-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "strings"

        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/hugolib/filesystems"
        "github.com/gohugoio/hugo/hugolib/paths"
)

// PathSpec holds methods that decides how paths in URLs and files in Hugo should look like.
type PathSpec struct {
        *paths.Paths
        *filesystems.BaseFs

        ProcessingStats *ProcessingStats

        // The file systems to use
        Fs *hugofs.Fs

        // The config provider to use
        Cfg config.Provider
}

// NewPathSpec creats a new PathSpec from the given filesystems and language.
func NewPathSpec(fs *hugofs.Fs, cfg config.Provider, logger *loggers.Logger) (*PathSpec, error) <span class="cov8" title="1">{
        return NewPathSpecWithBaseBaseFsProvided(fs, cfg, logger, nil)
}</span>

// NewPathSpecWithBaseBaseFsProvided creats a new PathSpec from the given filesystems and language.
// If an existing BaseFs is provided, parts of that is reused.
func NewPathSpecWithBaseBaseFsProvided(fs *hugofs.Fs, cfg config.Provider, logger *loggers.Logger, baseBaseFs *filesystems.BaseFs) (*PathSpec, error) <span class="cov8" title="1">{

        p, err := paths.New(fs, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var options []func(*filesystems.BaseFs) error
        if baseBaseFs != nil </span><span class="cov0" title="0">{
                options = []func(*filesystems.BaseFs) error{
                        filesystems.WithBaseFs(baseBaseFs),
                }
        }</span>
        <span class="cov8" title="1">bfs, err := filesystems.NewBase(p, logger, options...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ps := &amp;PathSpec{
                Paths:           p,
                BaseFs:          bfs,
                Fs:              fs,
                Cfg:             cfg,
                ProcessingStats: NewProcessingStats(p.Lang()),
        }

        basePath := ps.BaseURL.Path()
        if basePath != "" &amp;&amp; basePath != "/" </span><span class="cov0" title="0">{
                ps.BasePath = basePath
        }</span>

        <span class="cov8" title="1">return ps, nil</span>
}

// PermalinkForBaseURL creates a permalink from the given link and baseURL.
func (p *PathSpec) PermalinkForBaseURL(link, baseURL string) string <span class="cov8" title="1">{
        link = strings.TrimPrefix(link, "/")
        if !strings.HasSuffix(baseURL, "/") </span><span class="cov0" title="0">{
                baseURL += "/"
        }</span>
        <span class="cov8" title="1">return baseURL + link</span>

}
</pre>
		
		<pre class="file" id="file76" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "io"
        "strconv"
        "sync/atomic"

        "github.com/olekukonko/tablewriter"
)

// ProcessingStats represents statistics about a site build.
type ProcessingStats struct {
        Name string

        Pages           uint64
        PaginatorPages  uint64
        Static          uint64
        ProcessedImages uint64
        Files           uint64
        Aliases         uint64
        Sitemaps        uint64
        Cleaned         uint64
}

type processingStatsTitleVal struct {
        name string
        val  uint64
}

func (s *ProcessingStats) toVals() []processingStatsTitleVal <span class="cov8" title="1">{
        return []processingStatsTitleVal{
                {"Pages", s.Pages},
                {"Paginator pages", s.PaginatorPages},
                {"Non-page files", s.Files},
                {"Static files", s.Static},
                {"Processed images", s.ProcessedImages},
                {"Aliases", s.Aliases},
                {"Sitemaps", s.Sitemaps},
                {"Cleaned", s.Cleaned},
        }
}</span>

// NewProcessingStats returns a new ProcessingStats instance.
func NewProcessingStats(name string) *ProcessingStats <span class="cov8" title="1">{
        return &amp;ProcessingStats{Name: name}
}</span>

// Incr increments a given counter.
func (s *ProcessingStats) Incr(counter *uint64) <span class="cov0" title="0">{
        atomic.AddUint64(counter, 1)
}</span>

// Add adds an amount to a given counter.
func (s *ProcessingStats) Add(counter *uint64, amount int) <span class="cov0" title="0">{
        atomic.AddUint64(counter, uint64(amount))
}</span>

// Table writes a table-formatted representation of the stats in a
// ProcessingStats instance to w.
func (s *ProcessingStats) Table(w io.Writer) <span class="cov0" title="0">{
        titleVals := s.toVals()
        data := make([][]string, len(titleVals))
        for i, tv := range titleVals </span><span class="cov0" title="0">{
                data[i] = []string{tv.name, strconv.Itoa(int(tv.val))}
        }</span>

        <span class="cov0" title="0">table := tablewriter.NewWriter(w)

        table.AppendBulk(data)
        table.SetHeader([]string{"", s.Name})
        table.SetBorder(false)
        table.Render()</span>

}

// ProcessingStatsTable writes a table-formatted representation of stats to w.
func ProcessingStatsTable(w io.Writer, stats ...*ProcessingStats) <span class="cov8" title="1">{
        names := make([]string, len(stats)+1)

        var data [][]string

        for i := 0; i &lt; len(stats); i++ </span><span class="cov8" title="1">{
                stat := stats[i]
                names[i+1] = stat.Name

                titleVals := stat.toVals()

                if i == 0 </span><span class="cov8" title="1">{
                        data = make([][]string, len(titleVals))
                }</span>

                <span class="cov8" title="1">for j, tv := range titleVals </span><span class="cov8" title="1">{
                        if i == 0 </span><span class="cov8" title="1">{
                                data[j] = []string{tv.name, strconv.Itoa(int(tv.val))}
                        }</span> else<span class="cov0" title="0"> {
                                data[j] = append(data[j], strconv.Itoa(int(tv.val)))
                        }</span>

                }

        }

        <span class="cov8" title="1">table := tablewriter.NewWriter(w)

        table.AppendBulk(data)
        table.SetHeader(names)
        table.SetBorder(false)
        table.Render()</span>

}
</pre>
		
		<pre class="file" id="file77" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "bytes"
        "crypto/sha1"
        "fmt"
        "io"
        "io/ioutil"
        "os/exec"
        "path/filepath"
        "regexp"
        "sort"
        "strconv"
        "strings"

        "github.com/alecthomas/chroma"
        "github.com/alecthomas/chroma/formatters"
        "github.com/alecthomas/chroma/formatters/html"
        "github.com/alecthomas/chroma/lexers"
        "github.com/alecthomas/chroma/styles"
        bp "github.com/gohugoio/hugo/bufferpool"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/hugofs"
        jww "github.com/spf13/jwalterweatherman"
)

const pygmentsBin = "pygmentize"

// hasPygments checks to see if Pygments is installed and available
// on the system.
func hasPygments() bool <span class="cov0" title="0">{
        if _, err := exec.LookPath(pygmentsBin); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

type highlighters struct {
        cs          *ContentSpec
        ignoreCache bool
        cacheDir    string
}

func newHiglighters(cs *ContentSpec) highlighters <span class="cov8" title="1">{
        return highlighters{cs: cs, ignoreCache: cs.Cfg.GetBool("ignoreCache"), cacheDir: cs.Cfg.GetString("cacheDir")}
}</span>

func (h highlighters) chromaHighlight(code, lang, optsStr string) (string, error) <span class="cov0" title="0">{
        opts, err := h.cs.parsePygmentsOpts(optsStr)
        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Print(err.Error())
                return code, err
        }</span>

        <span class="cov0" title="0">style, found := opts["style"]
        if !found || style == "" </span><span class="cov0" title="0">{
                style = "friendly"
        }</span>

        <span class="cov0" title="0">f, err := h.cs.chromaFormatterFromOptions(opts)
        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Print(err.Error())
                return code, err
        }</span>

        <span class="cov0" title="0">b := bp.GetBuffer()
        defer bp.PutBuffer(b)

        err = chromaHighlight(b, code, lang, style, f)
        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Print(err.Error())
                return code, err
        }</span>

        <span class="cov0" title="0">return h.injectCodeTag(`&lt;div class="highlight"&gt;`+b.String()+"&lt;/div&gt;", lang), nil</span>
}

func (h highlighters) pygmentsHighlight(code, lang, optsStr string) (string, error) <span class="cov0" title="0">{
        options, err := h.cs.createPygmentsOptionsString(optsStr)

        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Print(err.Error())
                return code, nil
        }</span>

        // Try to read from cache first
        <span class="cov0" title="0">hash := sha1.New()
        io.WriteString(hash, code)
        io.WriteString(hash, lang)
        io.WriteString(hash, options)

        fs := hugofs.Os

        var cachefile string

        if !h.ignoreCache &amp;&amp; h.cacheDir != "" </span><span class="cov0" title="0">{
                cachefile = filepath.Join(h.cacheDir, fmt.Sprintf("pygments-%x", hash.Sum(nil)))

                exists, err := Exists(cachefile, fs)
                if err != nil </span><span class="cov0" title="0">{
                        jww.ERROR.Print(err.Error())
                        return code, nil
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        f, err := fs.Open(cachefile)
                        if err != nil </span><span class="cov0" title="0">{
                                jww.ERROR.Print(err.Error())
                                return code, nil
                        }</span>

                        <span class="cov0" title="0">s, err := ioutil.ReadAll(f)
                        if err != nil </span><span class="cov0" title="0">{
                                jww.ERROR.Print(err.Error())
                                return code, nil
                        }</span>

                        <span class="cov0" title="0">return string(s), nil</span>
                }
        }

        // No cache file, render and cache it
        <span class="cov0" title="0">var out bytes.Buffer
        var stderr bytes.Buffer

        var langOpt string
        if lang == "" </span><span class="cov0" title="0">{
                langOpt = "-g" // Try guessing the language
        }</span> else<span class="cov0" title="0"> {
                langOpt = "-l" + lang
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(pygmentsBin, langOpt, "-fhtml", "-O", options)
        cmd.Stdin = strings.NewReader(code)
        cmd.Stdout = &amp;out
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Print(stderr.String())
                return code, err
        }</span>

        <span class="cov0" title="0">str := string(normalizeExternalHelperLineFeeds(out.Bytes()))

        str = h.injectCodeTag(str, lang)

        if !h.ignoreCache &amp;&amp; cachefile != "" </span><span class="cov0" title="0">{
                // Write cache file
                if err := WriteToDisk(cachefile, strings.NewReader(str), fs); err != nil </span><span class="cov0" title="0">{
                        jww.ERROR.Print(stderr.String())
                }</span>
        }

        <span class="cov0" title="0">return str, nil</span>
}

var preRe = regexp.MustCompile(`(?s)(.*?&lt;pre.*?&gt;)(.*?)(&lt;/pre&gt;)`)

func (h highlighters) injectCodeTag(code, lang string) string <span class="cov0" title="0">{
        if lang == "" </span><span class="cov0" title="0">{
                return code
        }</span>
        <span class="cov0" title="0">codeTag := fmt.Sprintf(`&lt;code class="language-%s" data-lang="%s"&gt;`, lang, lang)
        return preRe.ReplaceAllString(code, fmt.Sprintf("$1%s$2&lt;/code&gt;$3", codeTag))</span>
}

func chromaHighlight(w io.Writer, source, lexer, style string, f chroma.Formatter) error <span class="cov0" title="0">{
        l := lexers.Get(lexer)
        if l == nil </span><span class="cov0" title="0">{
                l = lexers.Analyse(source)
        }</span>
        <span class="cov0" title="0">if l == nil </span><span class="cov0" title="0">{
                l = lexers.Fallback
        }</span>
        <span class="cov0" title="0">l = chroma.Coalesce(l)

        if f == nil </span><span class="cov0" title="0">{
                f = formatters.Fallback
        }</span>

        <span class="cov0" title="0">s := styles.Get(style)
        if s == nil </span><span class="cov0" title="0">{
                s = styles.Fallback
        }</span>

        <span class="cov0" title="0">it, err := l.Tokenise(nil, source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return f.Format(w, s, it)</span>
}

var pygmentsKeywords = make(map[string]bool)

func init() <span class="cov8" title="1">{
        pygmentsKeywords["encoding"] = true
        pygmentsKeywords["outencoding"] = true
        pygmentsKeywords["nowrap"] = true
        pygmentsKeywords["full"] = true
        pygmentsKeywords["title"] = true
        pygmentsKeywords["style"] = true
        pygmentsKeywords["noclasses"] = true
        pygmentsKeywords["classprefix"] = true
        pygmentsKeywords["cssclass"] = true
        pygmentsKeywords["cssstyles"] = true
        pygmentsKeywords["prestyles"] = true
        pygmentsKeywords["linenos"] = true
        pygmentsKeywords["hl_lines"] = true
        pygmentsKeywords["linenostart"] = true
        pygmentsKeywords["linenostep"] = true
        pygmentsKeywords["linenospecial"] = true
        pygmentsKeywords["nobackground"] = true
        pygmentsKeywords["lineseparator"] = true
        pygmentsKeywords["lineanchors"] = true
        pygmentsKeywords["linespans"] = true
        pygmentsKeywords["anchorlinenos"] = true
        pygmentsKeywords["startinline"] = true
}</span>

func parseOptions(defaults map[string]string, in string) (map[string]string, error) <span class="cov8" title="1">{
        in = strings.Trim(in, " ")
        opts := make(map[string]string)

        for k, v := range defaults </span><span class="cov0" title="0">{
                opts[k] = v
        }</span>

        <span class="cov8" title="1">if in == "" </span><span class="cov8" title="1">{
                return opts, nil
        }</span>

        <span class="cov0" title="0">for _, v := range strings.Split(in, ",") </span><span class="cov0" title="0">{
                keyVal := strings.Split(v, "=")
                key := strings.ToLower(strings.Trim(keyVal[0], " "))
                if len(keyVal) != 2 || !pygmentsKeywords[key] </span><span class="cov0" title="0">{
                        return opts, fmt.Errorf("invalid Pygments option: %s", key)
                }</span>
                <span class="cov0" title="0">opts[key] = keyVal[1]</span>
        }

        <span class="cov0" title="0">return opts, nil</span>
}

func createOptionsString(options map[string]string) string <span class="cov0" title="0">{
        var keys []string
        for k := range options </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)

        var optionsStr string
        for i, k := range keys </span><span class="cov0" title="0">{
                optionsStr += fmt.Sprintf("%s=%s", k, options[k])
                if i &lt; len(options)-1 </span><span class="cov0" title="0">{
                        optionsStr += ","
                }</span>
        }

        <span class="cov0" title="0">return optionsStr</span>
}

func parseDefaultPygmentsOpts(cfg config.Provider) (map[string]string, error) <span class="cov8" title="1">{
        options, err := parseOptions(nil, cfg.GetString("pygmentsOptions"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if cfg.IsSet("pygmentsStyle") </span><span class="cov8" title="1">{
                options["style"] = cfg.GetString("pygmentsStyle")
        }</span>

        <span class="cov8" title="1">if cfg.IsSet("pygmentsUseClasses") </span><span class="cov8" title="1">{
                if cfg.GetBool("pygmentsUseClasses") </span><span class="cov0" title="0">{
                        options["noclasses"] = "false"
                }</span> else<span class="cov8" title="1"> {
                        options["noclasses"] = "true"
                }</span>

        }

        <span class="cov8" title="1">if _, ok := options["encoding"]; !ok </span><span class="cov8" title="1">{
                options["encoding"] = "utf8"
        }</span>

        <span class="cov8" title="1">return options, nil</span>
}

func (cs *ContentSpec) chromaFormatterFromOptions(pygmentsOpts map[string]string) (chroma.Formatter, error) <span class="cov0" title="0">{
        var options = []html.Option{html.TabWidth(4)}

        if pygmentsOpts["noclasses"] == "false" </span><span class="cov0" title="0">{
                options = append(options, html.WithClasses())
        }</span>

        <span class="cov0" title="0">lineNumbers := pygmentsOpts["linenos"]
        if lineNumbers != "" </span><span class="cov0" title="0">{
                options = append(options, html.WithLineNumbers())
                if lineNumbers != "inline" </span><span class="cov0" title="0">{
                        options = append(options, html.LineNumbersInTable())
                }</span>
        }

        <span class="cov0" title="0">startLineStr := pygmentsOpts["linenostart"]
        var startLine = 1
        if startLineStr != "" </span><span class="cov0" title="0">{

                line, err := strconv.Atoi(strings.TrimSpace(startLineStr))
                if err == nil </span><span class="cov0" title="0">{
                        startLine = line
                        options = append(options, html.BaseLineNumber(startLine))
                }</span>
        }

        <span class="cov0" title="0">hlLines := pygmentsOpts["hl_lines"]

        if hlLines != "" </span><span class="cov0" title="0">{
                ranges, err := hlLinesToRanges(startLine, hlLines)

                if err == nil </span><span class="cov0" title="0">{
                        options = append(options, html.HighlightLines(ranges))
                }</span>
        }

        <span class="cov0" title="0">return html.New(options...), nil</span>
}

func (cs *ContentSpec) parsePygmentsOpts(in string) (map[string]string, error) <span class="cov0" title="0">{
        opts, err := parseOptions(cs.defatultPygmentsOpts, in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return opts, nil</span>

}

func (cs *ContentSpec) createPygmentsOptionsString(in string) (string, error) <span class="cov0" title="0">{
        opts, err := cs.parsePygmentsOpts(in)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return createOptionsString(opts), nil</span>
}

// startLine compansates for https://github.com/alecthomas/chroma/issues/30
func hlLinesToRanges(startLine int, s string) ([][2]int, error) <span class="cov0" title="0">{
        var ranges [][2]int
        s = strings.TrimSpace(s)

        if s == "" </span><span class="cov0" title="0">{
                return ranges, nil
        }</span>

        // Variants:
        // 1 2 3 4
        // 1-2 3-4
        // 1-2 3
        // 1 3-4
        // 1    3-4
        <span class="cov0" title="0">fields := strings.Split(s, " ")
        for _, field := range fields </span><span class="cov0" title="0">{
                field = strings.TrimSpace(field)
                if field == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">numbers := strings.Split(field, "-")
                var r [2]int
                first, err := strconv.Atoi(numbers[0])
                if err != nil </span><span class="cov0" title="0">{
                        return ranges, err
                }</span>
                <span class="cov0" title="0">first = first + startLine - 1
                r[0] = first
                if len(numbers) &gt; 1 </span><span class="cov0" title="0">{
                        second, err := strconv.Atoi(numbers[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return ranges, err
                        }</span>
                        <span class="cov0" title="0">second = second + startLine - 1
                        r[1] = second</span>
                } else<span class="cov0" title="0"> {
                        r[1] = first
                }</span>

                <span class="cov0" title="0">ranges = append(ranges, r)</span>
        }
        <span class="cov0" title="0">return ranges, nil</span>

}
</pre>
		
		<pre class="file" id="file78" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "fmt"
        "net/url"
        "path"
        "path/filepath"
        "strings"

        "github.com/PuerkitoBio/purell"
)

type pathBridge struct {
}

func (pathBridge) Base(in string) string <span class="cov0" title="0">{
        return path.Base(in)
}</span>

func (pathBridge) Clean(in string) string <span class="cov0" title="0">{
        return path.Clean(in)
}</span>

func (pathBridge) Dir(in string) string <span class="cov0" title="0">{
        return path.Dir(in)
}</span>

func (pathBridge) Ext(in string) string <span class="cov0" title="0">{
        return path.Ext(in)
}</span>

func (pathBridge) Join(elem ...string) string <span class="cov0" title="0">{
        return path.Join(elem...)
}</span>

func (pathBridge) Separator() string <span class="cov0" title="0">{
        return "/"
}</span>

var pb pathBridge

func sanitizeURLWithFlags(in string, f purell.NormalizationFlags) string <span class="cov0" title="0">{
        s, err := purell.NormalizeURLString(in, f)
        if err != nil </span><span class="cov0" title="0">{
                return in
        }</span>

        // Temporary workaround for the bug fix and resulting
        // behavioral change in purell.NormalizeURLString():
        // a leading '/' was inadvertently added to relative links,
        // but no longer, see #878.
        //
        // I think the real solution is to allow Hugo to
        // make relative URL with relative path,
        // e.g. "../../post/hello-again/", as wished by users
        // in issues #157, #622, etc., without forcing
        // relative URLs to begin with '/'.
        // Once the fixes are in, let's remove this kludge
        // and restore SanitizeURL() to the way it was.
        //                         -- @anthonyfok, 2015-02-16
        //
        // Begin temporary kludge
        <span class="cov0" title="0">u, err := url.Parse(s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">if len(u.Path) &gt; 0 &amp;&amp; !strings.HasPrefix(u.Path, "/") </span><span class="cov0" title="0">{
                u.Path = "/" + u.Path
        }</span>
        <span class="cov0" title="0">return u.String()</span>
        // End temporary kludge

        //return s

}

// SanitizeURL sanitizes the input URL string.
func SanitizeURL(in string) string <span class="cov0" title="0">{
        return sanitizeURLWithFlags(in, purell.FlagsSafe|purell.FlagRemoveTrailingSlash|purell.FlagRemoveDotSegments|purell.FlagRemoveDuplicateSlashes|purell.FlagRemoveUnnecessaryHostDots|purell.FlagRemoveEmptyPortSeparator)
}</span>

// SanitizeURLKeepTrailingSlash is the same as SanitizeURL, but will keep any trailing slash.
func SanitizeURLKeepTrailingSlash(in string) string <span class="cov0" title="0">{
        return sanitizeURLWithFlags(in, purell.FlagsSafe|purell.FlagRemoveDotSegments|purell.FlagRemoveDuplicateSlashes|purell.FlagRemoveUnnecessaryHostDots|purell.FlagRemoveEmptyPortSeparator)
}</span>

// URLize is similar to MakePath, but with Unicode handling
// Example:
//     uri: Vim (text editor)
//     urlize: vim-text-editor
func (p *PathSpec) URLize(uri string) string <span class="cov0" title="0">{
        return p.URLEscape(p.MakePathSanitized(uri))

}</span>

// URLizeFilename creates an URL from a filename by esacaping unicode letters
// and turn any filepath separator into forward slashes.
func (p *PathSpec) URLizeFilename(filename string) string <span class="cov8" title="1">{
        return p.URLEscape(filepath.ToSlash(filename))
}</span>

// URLEscape escapes unicode letters.
func (p *PathSpec) URLEscape(uri string) string <span class="cov8" title="1">{
        // escape unicode letters
        parsedURI, err := url.Parse(uri)
        if err != nil </span><span class="cov0" title="0">{
                // if net/url can not parse URL it means Sanitize works incorrectly
                panic(err)</span>
        }
        <span class="cov8" title="1">x := parsedURI.String()
        return x</span>
}

// MakePermalink combines base URL with content path to create full URL paths.
// Example
//    base:   http://spf13.com/
//    path:   post/how-i-blog
//    result: http://spf13.com/post/how-i-blog
func MakePermalink(host, plink string) *url.URL <span class="cov0" title="0">{

        base, err := url.Parse(host)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">p, err := url.Parse(plink)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">if p.Host != "" </span><span class="cov0" title="0">{
                panic(fmt.Errorf("can't make permalink from absolute link %q", plink))</span>
        }

        <span class="cov0" title="0">base.Path = path.Join(base.Path, p.Path)

        // path.Join will strip off the last /, so put it back if it was there.
        hadTrailingSlash := (plink == "" &amp;&amp; strings.HasSuffix(host, "/")) || strings.HasSuffix(p.Path, "/")
        if hadTrailingSlash &amp;&amp; !strings.HasSuffix(base.Path, "/") </span><span class="cov0" title="0">{
                base.Path = base.Path + "/"
        }</span>

        <span class="cov0" title="0">return base</span>
}

// AbsURL creates an absolute URL from the relative path given and the BaseURL set in config.
func (p *PathSpec) AbsURL(in string, addLanguage bool) string <span class="cov0" title="0">{
        url, err := url.Parse(in)
        if err != nil </span><span class="cov0" title="0">{
                return in
        }</span>

        <span class="cov0" title="0">if url.IsAbs() || strings.HasPrefix(in, "//") </span><span class="cov0" title="0">{
                return in
        }</span>

        <span class="cov0" title="0">var baseURL string
        if strings.HasPrefix(in, "/") </span><span class="cov0" title="0">{
                u := p.BaseURL.URL()
                u.Path = ""
                baseURL = u.String()
        }</span> else<span class="cov0" title="0"> {
                baseURL = p.BaseURL.String()
        }</span>

        <span class="cov0" title="0">if addLanguage </span><span class="cov0" title="0">{
                prefix := p.GetLanguagePrefix()
                if prefix != "" </span><span class="cov0" title="0">{
                        hasPrefix := false
                        // avoid adding language prefix if already present
                        if strings.HasPrefix(in, "/") </span><span class="cov0" title="0">{
                                hasPrefix = strings.HasPrefix(in[1:], prefix)
                        }</span> else<span class="cov0" title="0"> {
                                hasPrefix = strings.HasPrefix(in, prefix)
                        }</span>

                        <span class="cov0" title="0">if !hasPrefix </span><span class="cov0" title="0">{
                                addSlash := in == "" || strings.HasSuffix(in, "/")
                                in = path.Join(prefix, in)

                                if addSlash </span><span class="cov0" title="0">{
                                        in += "/"
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return MakePermalink(baseURL, in).String()</span>
}

// IsAbsURL determines whether the given path points to an absolute URL.
func IsAbsURL(path string) bool <span class="cov0" title="0">{
        url, err := url.Parse(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return url.IsAbs() || strings.HasPrefix(path, "//")</span>
}

// RelURL creates a URL relative to the BaseURL root.
// Note: The result URL will not include the context root if canonifyURLs is enabled.
func (p *PathSpec) RelURL(in string, addLanguage bool) string <span class="cov8" title="1">{
        baseURL := p.BaseURL.String()
        canonifyURLs := p.CanonifyURLs
        if (!strings.HasPrefix(in, baseURL) &amp;&amp; strings.HasPrefix(in, "http")) || strings.HasPrefix(in, "//") </span><span class="cov0" title="0">{
                return in
        }</span>

        <span class="cov8" title="1">u := in

        if strings.HasPrefix(in, baseURL) </span><span class="cov0" title="0">{
                u = strings.TrimPrefix(u, baseURL)
        }</span>

        <span class="cov8" title="1">if addLanguage </span><span class="cov0" title="0">{
                prefix := p.GetLanguagePrefix()
                if prefix != "" </span><span class="cov0" title="0">{
                        hasPrefix := false
                        // avoid adding language prefix if already present
                        if strings.HasPrefix(in, "/") </span><span class="cov0" title="0">{
                                hasPrefix = strings.HasPrefix(in[1:], prefix)
                        }</span> else<span class="cov0" title="0"> {
                                hasPrefix = strings.HasPrefix(in, prefix)
                        }</span>

                        <span class="cov0" title="0">if !hasPrefix </span><span class="cov0" title="0">{
                                hadSlash := strings.HasSuffix(u, "/")

                                u = path.Join(prefix, u)

                                if hadSlash </span><span class="cov0" title="0">{
                                        u += "/"
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if !canonifyURLs </span><span class="cov8" title="1">{
                u = AddContextRoot(baseURL, u)
        }</span>

        <span class="cov8" title="1">if in == "" &amp;&amp; !strings.HasSuffix(u, "/") &amp;&amp; strings.HasSuffix(baseURL, "/") </span><span class="cov0" title="0">{
                u += "/"
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(u, "/") </span><span class="cov0" title="0">{
                u = "/" + u
        }</span>

        <span class="cov8" title="1">return u</span>
}

// AddContextRoot adds the context root to an URL if it's not already set.
// For relative URL entries on sites with a base url with a context root set (i.e. http://example.com/mysite),
// relative URLs must not include the context root if canonifyURLs is enabled. But if it's disabled, it must be set.
func AddContextRoot(baseURL, relativePath string) string <span class="cov8" title="1">{

        url, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">newPath := path.Join(url.Path, relativePath)

        // path strips traling slash, ignore root path.
        if newPath != "/" &amp;&amp; strings.HasSuffix(relativePath, "/") </span><span class="cov0" title="0">{
                newPath += "/"
        }</span>
        <span class="cov8" title="1">return newPath</span>
}

// PrependBasePath prepends any baseURL sub-folder to the given resource
func (p *PathSpec) PrependBasePath(rel string, isAbs bool) string <span class="cov8" title="1">{
        basePath := p.GetBasePath(!isAbs)
        if basePath != "" </span><span class="cov0" title="0">{
                rel = filepath.ToSlash(rel)
                // Need to prepend any path from the baseURL
                hadSlash := strings.HasSuffix(rel, "/")
                rel = path.Join(basePath, rel)
                if hadSlash </span><span class="cov0" title="0">{
                        rel += "/"
                }</span>
        }
        <span class="cov8" title="1">return rel</span>
}

// URLizeAndPrep applies misc sanitation to the given URL to get it in line
// with the Hugo standard.
func (p *PathSpec) URLizeAndPrep(in string) string <span class="cov0" title="0">{
        return p.URLPrep(p.URLize(in))
}</span>

// URLPrep applies misc sanitation to the given URL.
func (p *PathSpec) URLPrep(in string) string <span class="cov0" title="0">{
        if p.UglyURLs </span><span class="cov0" title="0">{
                return Uglify(SanitizeURL(in))
        }</span>
        <span class="cov0" title="0">pretty := PrettifyURL(SanitizeURL(in))
        if path.Ext(pretty) == ".xml" </span><span class="cov0" title="0">{
                return pretty
        }</span>
        <span class="cov0" title="0">url, err := purell.NormalizeURLString(pretty, purell.FlagAddTrailingSlash)
        if err != nil </span><span class="cov0" title="0">{
                return pretty
        }</span>
        <span class="cov0" title="0">return url</span>
}

// PrettifyURL takes a URL string and returns a semantic, clean URL.
func PrettifyURL(in string) string <span class="cov0" title="0">{
        x := PrettifyURLPath(in)

        if path.Base(x) == "index.html" </span><span class="cov0" title="0">{
                return path.Dir(x)
        }</span>

        <span class="cov0" title="0">if in == "" </span><span class="cov0" title="0">{
                return "/"
        }</span>

        <span class="cov0" title="0">return x</span>
}

// PrettifyURLPath takes a URL path to a content and converts it
// to enable pretty URLs.
//     /section/name.html       becomes /section/name/index.html
//     /section/name/           becomes /section/name/index.html
//     /section/name/index.html becomes /section/name/index.html
func PrettifyURLPath(in string) string <span class="cov0" title="0">{
        return prettifyPath(in, pb)
}</span>

// Uglify does the opposite of PrettifyURLPath().
//     /section/name/index.html becomes /section/name.html
//     /section/name/           becomes /section/name.html
//     /section/name.html       becomes /section/name.html
func Uglify(in string) string <span class="cov0" title="0">{
        if path.Ext(in) == "" </span><span class="cov0" title="0">{
                if len(in) &lt; 2 </span><span class="cov0" title="0">{
                        return "/"
                }</span>
                // /section/name/  -&gt; /section/name.html
                <span class="cov0" title="0">return path.Clean(in) + ".html"</span>
        }

        <span class="cov0" title="0">name, ext := fileAndExt(in, pb)
        if name == "index" </span><span class="cov0" title="0">{
                // /section/name/index.html -&gt; /section/name.html
                d := path.Dir(in)
                if len(d) &gt; 1 </span><span class="cov0" title="0">{
                        return d + ext
                }</span>
                <span class="cov0" title="0">return in</span>
        }
        // /.xml -&gt; /index.xml
        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                return path.Dir(in) + "index" + ext
        }</span>
        // /section/name.html -&gt; /section/name.html
        <span class="cov0" title="0">return path.Clean(in)</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "fmt"
        "os"
        "sort"
        "strings"
        "sync"

        "github.com/spf13/afero"
)

// Reseter is implemented by some of the stateful filesystems.
type Reseter interface {
        Reset()
}

// DuplicatesReporter reports about duplicate filenames.
type DuplicatesReporter interface {
        ReportDuplicates() string
}

func NewCreateCountingFs(fs afero.Fs) afero.Fs <span class="cov0" title="0">{
        return &amp;createCountingFs{Fs: fs, fileCount: make(map[string]int)}
}</span>

// ReportDuplicates reports filenames written more than once.
func (c *createCountingFs) ReportDuplicates() string <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        var dupes []string

        for k, v := range c.fileCount </span><span class="cov0" title="0">{
                if v &gt; 1 </span><span class="cov0" title="0">{
                        dupes = append(dupes, fmt.Sprintf("%s (%d)", k, v))
                }</span>
        }

        <span class="cov0" title="0">if len(dupes) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">sort.Strings(dupes)

        return strings.Join(dupes, ", ")</span>
}

// createCountingFs counts filenames of created files or files opened
// for writing.
type createCountingFs struct {
        afero.Fs

        mu        sync.Mutex
        fileCount map[string]int
}

func (c *createCountingFs) Reset() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.fileCount = make(map[string]int)
}</span>

func (fs *createCountingFs) onCreate(filename string) <span class="cov0" title="0">{
        fs.mu.Lock()
        defer fs.mu.Unlock()

        fs.fileCount[filename] = fs.fileCount[filename] + 1
}</span>

func (fs *createCountingFs) Create(name string) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.Fs.Create(name)
        if err == nil </span><span class="cov0" title="0">{
                fs.onCreate(name)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}

func (fs *createCountingFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.Fs.OpenFile(name, flag, perm)
        if err == nil &amp;&amp; isWrite(flag) </span><span class="cov0" title="0">{
                fs.onCreate(name)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "os"
        "path/filepath"
        "strings"

        "github.com/pkg/errors"

        "github.com/spf13/afero"
)

func decorateDirs(fs afero.Fs, meta FileMeta) afero.Fs <span class="cov8" title="1">{
        ffs := &amp;baseFileDecoratorFs{Fs: fs}

        decorator := func(fi os.FileInfo, name string) (os.FileInfo, error) </span><span class="cov8" title="1">{
                if !fi.IsDir() </span><span class="cov0" title="0">{
                        // Leave regular files as they are.
                        return fi, nil
                }</span>

                <span class="cov8" title="1">return decorateFileInfo(fi, fs, nil, "", "", meta), nil</span>
        }

        <span class="cov8" title="1">ffs.decorate = decorator

        return ffs</span>

}

func decoratePath(fs afero.Fs, createPath func(name string) string) afero.Fs <span class="cov8" title="1">{

        ffs := &amp;baseFileDecoratorFs{Fs: fs}

        decorator := func(fi os.FileInfo, name string) (os.FileInfo, error) </span><span class="cov8" title="1">{
                path := createPath(name)

                return decorateFileInfo(fi, fs, nil, "", path, nil), nil
        }</span>

        <span class="cov8" title="1">ffs.decorate = decorator

        return ffs</span>

}

// DecorateBasePathFs adds Path info to files and directories in the
// provided BasePathFs, using the base as base.
func DecorateBasePathFs(base *afero.BasePathFs) afero.Fs <span class="cov0" title="0">{
        basePath, _ := base.RealPath("")
        if !strings.HasSuffix(basePath, filepathSeparator) </span><span class="cov0" title="0">{
                basePath += filepathSeparator
        }</span>

        <span class="cov0" title="0">ffs := &amp;baseFileDecoratorFs{Fs: base}

        decorator := func(fi os.FileInfo, name string) (os.FileInfo, error) </span><span class="cov0" title="0">{
                path := strings.TrimPrefix(name, basePath)

                return decorateFileInfo(fi, base, nil, "", path, nil), nil
        }</span>

        <span class="cov0" title="0">ffs.decorate = decorator

        return ffs</span>
}

// NewBaseFileDecorator decorates the given Fs to provide the real filename
// and an Opener func. If
func NewBaseFileDecorator(fs afero.Fs) afero.Fs <span class="cov8" title="1">{

        ffs := &amp;baseFileDecoratorFs{Fs: fs}

        decorator := func(fi os.FileInfo, filename string) (os.FileInfo, error) </span><span class="cov8" title="1">{
                // Store away the original in case it's a symlink.
                meta := FileMeta{metaKeyName: fi.Name()}
                isSymlink := isSymlink(fi)
                if isSymlink </span><span class="cov0" title="0">{
                        meta[metaKeyOriginalFilename] = filename
                        var link string
                        var err error
                        link, fi, err = evalSymlinks(fs, filename)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">filename = link
                        meta[metaKeyIsSymlink] = true</span>
                }

                <span class="cov8" title="1">opener := func() (afero.File, error) </span><span class="cov8" title="1">{
                        return ffs.open(filename)

                }</span>

                <span class="cov8" title="1">return decorateFileInfo(fi, ffs, opener, filename, "", meta), nil</span>
        }

        <span class="cov8" title="1">ffs.decorate = decorator
        return ffs</span>
}

func evalSymlinks(fs afero.Fs, filename string) (string, os.FileInfo, error) <span class="cov0" title="0">{
        link, err := filepath.EvalSymlinks(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>

        <span class="cov0" title="0">fi, err := fs.Stat(link)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>

        <span class="cov0" title="0">return link, fi, nil</span>
}

type baseFileDecoratorFs struct {
        afero.Fs
        decorate func(fi os.FileInfo, filename string) (os.FileInfo, error)
}

func (fs *baseFileDecoratorFs) Stat(name string) (os.FileInfo, error) <span class="cov8" title="1">{
        fi, err := fs.Fs.Stat(name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return fs.decorate(fi, name)</span>

}

func (fs *baseFileDecoratorFs) LstatIfPossible(name string) (os.FileInfo, bool, error) <span class="cov8" title="1">{
        var (
                fi  os.FileInfo
                err error
                ok  bool
        )

        if lstater, isLstater := fs.Fs.(afero.Lstater); isLstater </span><span class="cov8" title="1">{
                fi, ok, err = lstater.LstatIfPossible(name)
        }</span> else<span class="cov0" title="0"> {
                fi, err = fs.Fs.Stat(name)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>

        <span class="cov8" title="1">fi, err = fs.decorate(fi, name)

        return fi, ok, err</span>
}

func (fs *baseFileDecoratorFs) Open(name string) (afero.File, error) <span class="cov8" title="1">{
        return fs.open(name)
}</span>

func (fs *baseFileDecoratorFs) open(name string) (afero.File, error) <span class="cov8" title="1">{
        f, err := fs.Fs.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;baseFileDecoratorFile{File: f, fs: fs}, nil</span>
}

type baseFileDecoratorFile struct {
        afero.File
        fs *baseFileDecoratorFs
}

func (l *baseFileDecoratorFile) Readdir(c int) (ofi []os.FileInfo, err error) <span class="cov8" title="1">{
        dirnames, err := l.File.Readdirnames(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fisp := make([]os.FileInfo, 0, len(dirnames))

        for _, dirname := range dirnames </span><span class="cov8" title="1">{
                filename := dirname

                if l.Name() != "" &amp;&amp; l.Name() != filepathSeparator </span><span class="cov8" title="1">{
                        filename = filepath.Join(l.Name(), dirname)
                }</span>

                // We need to resolve any symlink info.
                <span class="cov8" title="1">fi, _, err := lstatIfPossible(l.fs.Fs, filename)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">fi, err = l.fs.decorate(fi, filename)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "decorate")
                }</span>
                <span class="cov8" title="1">fisp = append(fisp, fi)</span>
        }

        <span class="cov8" title="1">return fisp, err</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package hugofs provides the file systems used by Hugo.
package hugofs

import (
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "time"

        "github.com/gohugoio/hugo/hugofs/files"
        "golang.org/x/text/unicode/norm"

        "github.com/pkg/errors"

        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/common/hreflect"

        "github.com/spf13/afero"
)

const (
        metaKeyFilename                   = "filename"
        metaKeyOriginalFilename           = "originalFilename"
        metaKeyName                       = "name"
        metaKeyPath                       = "path"
        metaKeyPathWalk                   = "pathWalk"
        metaKeyLang                       = "lang"
        metaKeyWeight                     = "weight"
        metaKeyOrdinal                    = "ordinal"
        metaKeyFs                         = "fs"
        metaKeyOpener                     = "opener"
        metaKeyIsOrdered                  = "isOrdered"
        metaKeyIsSymlink                  = "isSymlink"
        metaKeySkipDir                    = "skipDir"
        metaKeyClassifier                 = "classifier"
        metaKeyTranslationBaseName        = "translationBaseName"
        metaKeyTranslationBaseNameWithExt = "translationBaseNameWithExt"
        metaKeyTranslations               = "translations"
        metaKeyDecoraterPath              = "decoratorPath"
)

type FileMeta map[string]interface{}

func (f FileMeta) GetInt(key string) int <span class="cov8" title="1">{
        return cast.ToInt(f[key])
}</span>

func (f FileMeta) GetString(key string) string <span class="cov8" title="1">{
        return cast.ToString(f[key])
}</span>

func (f FileMeta) GetBool(key string) bool <span class="cov8" title="1">{
        return cast.ToBool(f[key])
}</span>

func (f FileMeta) Filename() string <span class="cov8" title="1">{
        return f.stringV(metaKeyFilename)
}</span>

func (f FileMeta) OriginalFilename() string <span class="cov0" title="0">{
        return f.stringV(metaKeyOriginalFilename)
}</span>

func (f FileMeta) SkipDir() bool <span class="cov8" title="1">{
        return f.GetBool(metaKeySkipDir)
}</span>
func (f FileMeta) TranslationBaseName() string <span class="cov0" title="0">{
        return f.stringV(metaKeyTranslationBaseName)
}</span>

func (f FileMeta) TranslationBaseNameWithExt() string <span class="cov8" title="1">{
        return f.stringV(metaKeyTranslationBaseNameWithExt)
}</span>

func (f FileMeta) Translations() []string <span class="cov0" title="0">{
        return cast.ToStringSlice(f[metaKeyTranslations])
}</span>

func (f FileMeta) Name() string <span class="cov8" title="1">{
        return f.stringV(metaKeyName)
}</span>

func (f FileMeta) Classifier() string <span class="cov8" title="1">{
        c := f.stringV(metaKeyClassifier)
        if c != "" </span><span class="cov8" title="1">{
                return c
        }</span>

        <span class="cov8" title="1">return files.ContentClassFile</span> // For sorting
}

func (f FileMeta) Lang() string <span class="cov8" title="1">{
        return f.stringV(metaKeyLang)
}</span>

func (f FileMeta) Path() string <span class="cov8" title="1">{
        return f.stringV(metaKeyPath)
}</span>

func (f FileMeta) Weight() int <span class="cov8" title="1">{
        return f.GetInt(metaKeyWeight)
}</span>

func (f FileMeta) Ordinal() int <span class="cov8" title="1">{
        return f.GetInt(metaKeyOrdinal)
}</span>

func (f FileMeta) IsOrdered() bool <span class="cov8" title="1">{
        return f.GetBool(metaKeyIsOrdered)
}</span>

// IsSymlink returns whether this comes from a symlinked file or directory.
func (f FileMeta) IsSymlink() bool <span class="cov8" title="1">{
        return f.GetBool(metaKeyIsSymlink)
}</span>

func (f FileMeta) Watch() bool <span class="cov0" title="0">{
        if v, found := f["watch"]; found </span><span class="cov0" title="0">{
                return v.(bool)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (f FileMeta) Fs() afero.Fs <span class="cov8" title="1">{
        if v, found := f[metaKeyFs]; found </span><span class="cov8" title="1">{
                return v.(afero.Fs)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (f FileMeta) GetOpener() func() (afero.File, error) <span class="cov0" title="0">{
        o, found := f[metaKeyOpener]
        if !found </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return o.(func() (afero.File, error))</span>
}

func (f FileMeta) Open() (afero.File, error) <span class="cov8" title="1">{
        v, found := f[metaKeyOpener]
        if !found </span><span class="cov0" title="0">{
                return nil, errors.New("file opener not found")
        }</span>
        <span class="cov8" title="1">return v.(func() (afero.File, error))()</span>
}

func (f FileMeta) stringV(key string) string <span class="cov8" title="1">{
        if v, found := f[key]; found </span><span class="cov8" title="1">{
                return v.(string)
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func (f FileMeta) setIfNotZero(key string, val interface{}) <span class="cov8" title="1">{
        if !hreflect.IsTruthful(val) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">f[key] = val</span>
}

type FileMetaInfo interface {
        os.FileInfo
        Meta() FileMeta
}

type fileInfoMeta struct {
        os.FileInfo

        m FileMeta
}

// Name returns the file's name. Note that we follow symlinks,
// if supported by the file system, and the Name given here will be the
// name of the symlink, which is what Hugo needs in all situations.
func (fi *fileInfoMeta) Name() string <span class="cov8" title="1">{
        if name := fi.m.Name(); name != "" </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov0" title="0">return fi.FileInfo.Name()</span>
}

func (fi *fileInfoMeta) Meta() FileMeta <span class="cov8" title="1">{
        return fi.m
}</span>

func NewFileMetaInfo(fi os.FileInfo, m FileMeta) FileMetaInfo <span class="cov8" title="1">{

        if fim, ok := fi.(FileMetaInfo); ok </span><span class="cov8" title="1">{
                mergeFileMeta(fim.Meta(), m)
        }</span>
        <span class="cov8" title="1">return &amp;fileInfoMeta{FileInfo: fi, m: m}</span>
}

// Merge metadata, last entry wins.
func mergeFileMeta(from, to FileMeta) <span class="cov8" title="1">{
        if from == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for k, v := range from </span><span class="cov8" title="1">{
                if _, found := to[k]; !found </span><span class="cov8" title="1">{
                        to[k] = v
                }</span>
        }
}

type dirNameOnlyFileInfo struct {
        name string
}

func (fi *dirNameOnlyFileInfo) Name() string <span class="cov0" title="0">{
        return fi.name
}</span>

func (fi *dirNameOnlyFileInfo) Size() int64 <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (fi *dirNameOnlyFileInfo) Mode() os.FileMode <span class="cov0" title="0">{
        return os.ModeDir
}</span>

func (fi *dirNameOnlyFileInfo) ModTime() time.Time <span class="cov8" title="1">{
        return time.Time{}
}</span>

func (fi *dirNameOnlyFileInfo) IsDir() bool <span class="cov8" title="1">{
        return true
}</span>

func (fi *dirNameOnlyFileInfo) Sys() interface{} <span class="cov0" title="0">{
        return nil
}</span>

func newDirNameOnlyFileInfo(name string, isOrdered bool, fileOpener func() (afero.File, error)) FileMetaInfo <span class="cov8" title="1">{
        name = normalizeFilename(name)
        _, base := filepath.Split(name)
        return NewFileMetaInfo(&amp;dirNameOnlyFileInfo{name: base}, FileMeta{
                metaKeyFilename:  name,
                metaKeyIsOrdered: isOrdered,
                metaKeyOpener:    fileOpener})
}</span>

func decorateFileInfo(
        fi os.FileInfo,
        fs afero.Fs, opener func() (afero.File, error),
        filename, filepath string, inMeta FileMeta) FileMetaInfo <span class="cov8" title="1">{

        var meta FileMeta
        var fim FileMetaInfo

        filepath = strings.TrimPrefix(filepath, filepathSeparator)

        var ok bool
        if fim, ok = fi.(FileMetaInfo); ok </span><span class="cov8" title="1">{
                meta = fim.Meta()
        }</span> else<span class="cov8" title="1"> {
                meta = make(FileMeta)
                fim = NewFileMetaInfo(fi, meta)
        }</span>

        <span class="cov8" title="1">meta.setIfNotZero(metaKeyOpener, opener)
        meta.setIfNotZero(metaKeyFs, fs)
        meta.setIfNotZero(metaKeyPath, normalizeFilename(filepath))
        meta.setIfNotZero(metaKeyFilename, normalizeFilename(filename))

        mergeFileMeta(inMeta, meta)

        return fim</span>

}

func isSymlink(fi os.FileInfo) bool <span class="cov8" title="1">{
        return fi != nil &amp;&amp; fi.Mode()&amp;os.ModeSymlink == os.ModeSymlink
}</span>

func fileInfosToFileMetaInfos(fis []os.FileInfo) []FileMetaInfo <span class="cov8" title="1">{
        fims := make([]FileMetaInfo, len(fis))
        for i, v := range fis </span><span class="cov8" title="1">{
                fims[i] = v.(FileMetaInfo)
        }</span>
        <span class="cov8" title="1">return fims</span>
}

func normalizeFilename(filename string) string <span class="cov8" title="1">{
        if filename == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if runtime.GOOS == "darwin" </span><span class="cov8" title="1">{
                // When a file system is HFS+, its filepath is in NFD form.
                return norm.NFC.String(filename)
        }</span>
        <span class="cov0" title="0">return filename</span>
}

func fileInfosToNames(fis []os.FileInfo) []string <span class="cov8" title="1">{
        names := make([]string, len(fis))
        for i, d := range fis </span><span class="cov8" title="1">{
                names[i] = d.Name()
        }</span>
        <span class="cov8" title="1">return names</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package files

import (
        "os"
        "path/filepath"
        "sort"
        "strings"
)

var (
        // This should be the only list of valid extensions for content files.
        contentFileExtensions = []string{
                "html", "htm",
                "mdown", "markdown", "md",
                "asciidoc", "adoc", "ad",
                "rest", "rst",
                "mmark",
                "org",
                "pandoc", "pdc"}

        contentFileExtensionsSet map[string]bool
)

func init() <span class="cov8" title="1">{
        contentFileExtensionsSet = make(map[string]bool)
        for _, ext := range contentFileExtensions </span><span class="cov8" title="1">{
                contentFileExtensionsSet[ext] = true
        }</span>
}

func IsContentFile(filename string) bool <span class="cov8" title="1">{
        return contentFileExtensionsSet[strings.TrimPrefix(filepath.Ext(filename), ".")]
}</span>

func IsContentExt(ext string) bool <span class="cov0" title="0">{
        return contentFileExtensionsSet[ext]
}</span>

const (
        ContentClassLeaf    = "leaf"
        ContentClassBranch  = "branch"
        ContentClassFile    = "zfile" // Sort below
        ContentClassContent = "zcontent"
)

func ClassifyContentFile(filename string) string <span class="cov8" title="1">{
        if !IsContentFile(filename) </span><span class="cov0" title="0">{
                return ContentClassFile
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(filename, "_index.") </span><span class="cov0" title="0">{
                return ContentClassBranch
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(filename, "index.") </span><span class="cov0" title="0">{
                return ContentClassLeaf
        }</span>

        <span class="cov8" title="1">return ContentClassContent</span>
}

const (
        ComponentFolderArchetypes = "archetypes"
        ComponentFolderStatic     = "static"
        ComponentFolderLayouts    = "layouts"
        ComponentFolderContent    = "content"
        ComponentFolderData       = "data"
        ComponentFolderAssets     = "assets"
        ComponentFolderI18n       = "i18n"

        FolderResources = "resources"
)

var (
        ComponentFolders = []string{
                ComponentFolderArchetypes,
                ComponentFolderStatic,
                ComponentFolderLayouts,
                ComponentFolderContent,
                ComponentFolderData,
                ComponentFolderAssets,
                ComponentFolderI18n,
        }

        componentFoldersSet = make(map[string]bool)
)

func init() <span class="cov8" title="1">{
        sort.Strings(ComponentFolders)
        for _, f := range ComponentFolders </span><span class="cov8" title="1">{
                componentFoldersSet[f] = true
        }</span>
}

// ResolveComponentFolder returns "content" from "content/blog/foo.md" etc.
func ResolveComponentFolder(filename string) string <span class="cov8" title="1">{
        filename = strings.TrimPrefix(filename, string(os.PathSeparator))
        for _, cf := range ComponentFolders </span><span class="cov8" title="1">{
                if strings.HasPrefix(filename, cf) </span><span class="cov8" title="1">{
                        return cf
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func IsComponentFolder(name string) bool <span class="cov8" title="1">{
        return componentFoldersSet[name]
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "syscall"
        "time"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/spf13/afero"
)

var (
        _ afero.Fs      = (*FilterFs)(nil)
        _ afero.Lstater = (*FilterFs)(nil)
        _ afero.File    = (*filterDir)(nil)
)

func NewLanguageFs(langs map[string]int, fs afero.Fs) (afero.Fs, error) <span class="cov8" title="1">{

        applyMeta := func(fs *FilterFs, name string, fis []os.FileInfo) </span><span class="cov8" title="1">{

                for i, fi := range fis </span><span class="cov8" title="1">{
                        if fi.IsDir() </span><span class="cov8" title="1">{
                                filename := filepath.Join(name, fi.Name())
                                fis[i] = decorateFileInfo(fi, fs, fs.getOpener(filename), "", "", nil)
                                continue</span>
                        }

                        <span class="cov8" title="1">meta := fi.(FileMetaInfo).Meta()
                        lang := meta.Lang()

                        fileLang, translationBaseName, translationBaseNameWithExt := langInfoFrom(langs, fi.Name())
                        weight := 0

                        if fileLang != "" </span><span class="cov0" title="0">{
                                weight = 1
                                if fileLang == lang </span><span class="cov0" title="0">{
                                        // Give priority to myfile.sv.txt inside the sv filesystem.
                                        weight++
                                }</span>
                                <span class="cov0" title="0">lang = fileLang</span>
                        }

                        <span class="cov8" title="1">fim := NewFileMetaInfo(fi, FileMeta{
                                metaKeyLang:                       lang,
                                metaKeyWeight:                     weight,
                                metaKeyOrdinal:                    langs[lang],
                                metaKeyTranslationBaseName:        translationBaseName,
                                metaKeyTranslationBaseNameWithExt: translationBaseNameWithExt,
                                metaKeyClassifier:                 files.ClassifyContentFile(fi.Name()),
                        })

                        fis[i] = fim</span>
                }
        }

        <span class="cov8" title="1">all := func(fis []os.FileInfo) </span><span class="cov8" title="1">{
                // Maps translation base name to a list of language codes.
                translations := make(map[string][]string)
                trackTranslation := func(meta FileMeta) </span><span class="cov8" title="1">{
                        name := meta.TranslationBaseNameWithExt()
                        translations[name] = append(translations[name], meta.Lang())
                }</span>
                <span class="cov8" title="1">for _, fi := range fis </span><span class="cov8" title="1">{
                        if fi.IsDir() </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">meta := fi.(FileMetaInfo).Meta()

                        trackTranslation(meta)</span>

                }

                <span class="cov8" title="1">for _, fi := range fis </span><span class="cov8" title="1">{
                        fim := fi.(FileMetaInfo)
                        langs := translations[fim.Meta().TranslationBaseNameWithExt()]
                        if len(langs) &gt; 0 </span><span class="cov8" title="1">{
                                fim.Meta()["translations"] = sortAndremoveStringDuplicates(langs)
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;FilterFs{
                fs:             fs,
                applyPerSource: applyMeta,
                applyAll:       all,
        }, nil</span>

}

func NewFilterFs(fs afero.Fs) (afero.Fs, error) <span class="cov0" title="0">{

        applyMeta := func(fs *FilterFs, name string, fis []os.FileInfo) </span><span class="cov0" title="0">{
                for i, fi := range fis </span><span class="cov0" title="0">{
                        if fi.IsDir() </span><span class="cov0" title="0">{
                                fis[i] = decorateFileInfo(fi, fs, fs.getOpener(fi.(FileMetaInfo).Meta().Filename()), "", "", nil)
                        }</span>
                }
        }

        <span class="cov0" title="0">ffs := &amp;FilterFs{
                fs:             fs,
                applyPerSource: applyMeta,
        }

        return ffs, nil</span>

}

// FilterFs is an ordered composite filesystem.
type FilterFs struct {
        fs afero.Fs

        applyPerSource func(fs *FilterFs, name string, fis []os.FileInfo)
        applyAll       func(fis []os.FileInfo)
}

func (fs *FilterFs) Chmod(n string, m os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) Chtimes(n string, a, m time.Time) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) LstatIfPossible(name string) (os.FileInfo, bool, error) <span class="cov8" title="1">{
        fi, b, err := lstatIfPossible(fs.fs, name)

        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov8" title="1">if fi.IsDir() </span><span class="cov8" title="1">{
                return decorateFileInfo(fi, fs, fs.getOpener(name), "", "", nil), false, nil
        }</span>

        <span class="cov0" title="0">fs.applyFilters(name, -1, fi)

        return fi, b, nil</span>

}

func (fs *FilterFs) Mkdir(n string, p os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) MkdirAll(n string, p os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) Name() string <span class="cov0" title="0">{
        return "WeightedFileSystem"
}</span>

func (fs *FilterFs) Open(name string) (afero.File, error) <span class="cov8" title="1">{
        f, err := fs.fs.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;filterDir{
                File: f,
                ffs:  fs,
        }, nil</span>

}

func (fs *FilterFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (fs *FilterFs) ReadDir(name string) ([]os.FileInfo, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (fs *FilterFs) Remove(n string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) RemoveAll(p string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) Rename(o, n string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) Stat(name string) (os.FileInfo, error) <span class="cov8" title="1">{
        fi, _, err := fs.LstatIfPossible(name)
        return fi, err
}</span>

func (fs *FilterFs) Create(n string) (afero.File, error) <span class="cov0" title="0">{
        return nil, syscall.EPERM
}</span>

func (fs *FilterFs) getOpener(name string) func() (afero.File, error) <span class="cov8" title="1">{
        return func() (afero.File, error) </span><span class="cov0" title="0">{
                return fs.Open(name)
        }</span>
}

func (fs *FilterFs) applyFilters(name string, count int, fis ...os.FileInfo) ([]os.FileInfo, error) <span class="cov8" title="1">{
        if fs.applyPerSource != nil </span><span class="cov8" title="1">{
                fs.applyPerSource(fs, name, fis)
        }</span>

        <span class="cov8" title="1">seen := make(map[string]bool)
        var duplicates []int
        for i, dir := range fis </span><span class="cov8" title="1">{
                if !dir.IsDir() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if seen[dir.Name()] </span><span class="cov0" title="0">{
                        duplicates = append(duplicates, i)
                }</span> else<span class="cov8" title="1"> {
                        seen[dir.Name()] = true
                }</span>
        }

        // Remove duplicate directories, keep first.
        <span class="cov8" title="1">if len(duplicates) &gt; 0 </span><span class="cov0" title="0">{
                for i := len(duplicates) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        idx := duplicates[i]
                        fis = append(fis[:idx], fis[idx+1:]...)
                }</span>
        }

        <span class="cov8" title="1">if fs.applyAll != nil </span><span class="cov8" title="1">{
                fs.applyAll(fis)
        }</span>

        <span class="cov8" title="1">if count &gt; 0 &amp;&amp; len(fis) &gt;= count </span><span class="cov0" title="0">{
                return fis[:count], nil
        }</span>

        <span class="cov8" title="1">return fis, nil</span>

}

type filterDir struct {
        afero.File
        ffs *FilterFs
}

func (f *filterDir) Readdir(count int) ([]os.FileInfo, error) <span class="cov8" title="1">{
        fis, err := f.File.Readdir(-1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return f.ffs.applyFilters(f.Name(), count, fis...)</span>
}

func (f *filterDir) Readdirnames(count int) ([]string, error) <span class="cov0" title="0">{
        dirsi, err := f.Readdir(count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dirs := make([]string, len(dirsi))
        for i, d := range dirsi </span><span class="cov0" title="0">{
                dirs[i] = d.Name()
        }</span>
        <span class="cov0" title="0">return dirs, nil</span>
}

// Try to extract the language from the given filename.
// Any valid language identificator in the name will win over the
// language set on the file system, e.g. "mypost.en.md".
func langInfoFrom(languages map[string]int, name string) (string, string, string) <span class="cov8" title="1">{
        var lang string

        baseName := filepath.Base(name)
        ext := filepath.Ext(baseName)
        translationBaseName := baseName

        if ext != "" </span><span class="cov8" title="1">{
                translationBaseName = strings.TrimSuffix(translationBaseName, ext)
        }</span>

        <span class="cov8" title="1">fileLangExt := filepath.Ext(translationBaseName)
        fileLang := strings.TrimPrefix(fileLangExt, ".")

        if _, found := languages[fileLang]; found </span><span class="cov0" title="0">{
                lang = fileLang
                translationBaseName = strings.TrimSuffix(translationBaseName, fileLangExt)
        }</span>

        <span class="cov8" title="1">translationBaseNameWithExt := translationBaseName

        if ext != "" </span><span class="cov8" title="1">{
                translationBaseNameWithExt += ext
        }</span>

        <span class="cov8" title="1">return lang, translationBaseName, translationBaseNameWithExt</span>

}

func printFs(fs afero.Fs, path string, w io.Writer) <span class="cov0" title="0">{
        if fs == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">afero.Walk(fs, path, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                fmt.Println("p:::", path)
                return nil
        }</span>)
}

func sortAndremoveStringDuplicates(s []string) []string <span class="cov8" title="1">{
        ss := sort.StringSlice(s)
        ss.Sort()
        i := 0
        for j := 1; j &lt; len(s); j++ </span><span class="cov0" title="0">{
                if !ss.Less(i, j) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">i++
                s[i] = s[j]</span>
        }

        <span class="cov8" title="1">return s[:i+1]</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package hugofs provides the file systems used by Hugo.
package hugofs

import (
        "os"

        "github.com/gohugoio/hugo/config"
        "github.com/spf13/afero"
)

var (
        // Os points to the (real) Os filesystem.
        Os = &amp;afero.OsFs{}
)

// Fs abstracts the file system to separate source and destination file systems
// and allows both to be mocked for testing.
type Fs struct {
        // Source is Hugo's source file system.
        Source afero.Fs

        // Destination is Hugo's destination file system.
        Destination afero.Fs

        // Os is an OS file system.
        // NOTE: Field is currently unused.
        Os afero.Fs

        // WorkingDir is a read-only file system
        // restricted to the project working dir.
        WorkingDir *afero.BasePathFs
}

// NewDefault creates a new Fs with the OS file system
// as source and destination file systems.
func NewDefault(cfg config.Provider) *Fs <span class="cov0" title="0">{
        fs := &amp;afero.OsFs{}
        return newFs(fs, cfg)
}</span>

// NewMem creates a new Fs with the MemMapFs
// as source and destination file systems.
// Useful for testing.
func NewMem(cfg config.Provider) *Fs <span class="cov0" title="0">{
        fs := &amp;afero.MemMapFs{}
        return newFs(fs, cfg)
}</span>

// NewFrom creates a new Fs based on the provided Afero Fs
// as source and destination file systems.
// Useful for testing.
func NewFrom(fs afero.Fs, cfg config.Provider) *Fs <span class="cov8" title="1">{
        return newFs(fs, cfg)
}</span>

func newFs(base afero.Fs, cfg config.Provider) *Fs <span class="cov8" title="1">{
        return &amp;Fs{
                Source:      base,
                Destination: base,
                Os:          &amp;afero.OsFs{},
                WorkingDir:  getWorkingDirFs(base, cfg),
        }
}</span>

func getWorkingDirFs(base afero.Fs, cfg config.Provider) *afero.BasePathFs <span class="cov8" title="1">{
        workingDir := cfg.GetString("workingDir")

        if workingDir != "" </span><span class="cov8" title="1">{
                return afero.NewBasePathFs(afero.NewReadOnlyFs(base), workingDir).(*afero.BasePathFs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func isWrite(flag int) bool <span class="cov0" title="0">{
        return flag&amp;os.O_RDWR != 0 || flag&amp;os.O_WRONLY != 0
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "errors"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/spf13/afero"
)

// Glob walks the fs and passes all matches to the handle func.
// The handle func can return true to signal a stop.
func Glob(fs afero.Fs, pattern string, handle func(fi FileMetaInfo) (bool, error)) error <span class="cov0" title="0">{
        pattern = glob.NormalizePath(pattern)
        if pattern == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">g, err := glob.GetGlob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">hasSuperAsterisk := strings.Contains(pattern, "**")
        levels := strings.Count(pattern, "/")
        root := glob.ResolveRootDir(pattern)

        // Signals that we're done.
        done := errors.New("done")

        wfn := func(p string, info FileMetaInfo, err error) error </span><span class="cov0" title="0">{
                p = glob.NormalizePath(p)
                if info.IsDir() </span><span class="cov0" title="0">{
                        if !hasSuperAsterisk </span><span class="cov0" title="0">{
                                // Avoid walking to the bottom if we can avoid it.
                                if p != "" &amp;&amp; strings.Count(p, "/") &gt;= levels </span><span class="cov0" title="0">{
                                        return filepath.SkipDir
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if g.Match(p) </span><span class="cov0" title="0">{
                        d, err := handle(info)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if d </span><span class="cov0" title="0">{
                                return done
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">w := NewWalkway(WalkwayConfig{
                Root:   root,
                Fs:     fs,
                WalkFn: wfn,
        })

        err = w.Walk()

        if err != done </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}
</pre>
		
		<pre class="file" id="file86" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package glob

import (
        "path"
        "path/filepath"
        "strings"
        "sync"

        "github.com/gobwas/glob"
        "github.com/gobwas/glob/syntax"
)

var (
        globCache = make(map[string]glob.Glob)
        globMu    sync.RWMutex
)

func GetGlob(pattern string) (glob.Glob, error) <span class="cov8" title="1">{
        var g glob.Glob

        globMu.RLock()
        g, found := globCache[pattern]
        globMu.RUnlock()
        if !found </span><span class="cov8" title="1">{
                var err error
                g, err = glob.Compile(strings.ToLower(pattern), '/')
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">globMu.Lock()
                globCache[pattern] = g
                globMu.Unlock()</span>
        }

        <span class="cov8" title="1">return g, nil</span>

}

func NormalizePath(p string) string <span class="cov0" title="0">{
        return strings.Trim(path.Clean(filepath.ToSlash(strings.ToLower(p))), "/.")
}</span>

// ResolveRootDir takes a normalized path on the form "assets/**.json" and
// determines any root dir, i.e. any start path without any wildcards.
func ResolveRootDir(p string) string <span class="cov0" title="0">{
        parts := strings.Split(path.Dir(p), "/")
        var roots []string
        for _, part := range parts </span><span class="cov0" title="0">{
                if HasGlobChar(part) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">roots = append(roots, part)</span>
        }

        <span class="cov0" title="0">if len(roots) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return strings.Join(roots, "/")</span>
}

// FilterGlobParts removes any string with glob wildcard.
func FilterGlobParts(a []string) []string <span class="cov0" title="0">{
        b := a[:0]
        for _, x := range a </span><span class="cov0" title="0">{
                if !HasGlobChar(x) </span><span class="cov0" title="0">{
                        b = append(b, x)
                }</span>
        }
        <span class="cov0" title="0">return b</span>
}

// HasGlobChar returns whether s contains any glob wildcards.
func HasGlobChar(s string) bool <span class="cov0" title="0">{
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                if syntax.Special(s[i]) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>

}
</pre>
		
		<pre class="file" id="file87" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "crypto/md5"
        "encoding/hex"
        "hash"
        "os"

        "github.com/spf13/afero"
)

var (
        _ afero.Fs = (*md5HashingFs)(nil)
)

// FileHashReceiver will receive the filename an the content's MD5 sum on file close.
type FileHashReceiver interface {
        OnFileClose(name, md5sum string)
}

type md5HashingFs struct {
        afero.Fs
        hashReceiver FileHashReceiver
}

// NewHashingFs creates a new filesystem that will receive MD5 checksums of
// any written file content on Close. Note that this is probably not a good
// idea for "full build" situations, but when doing fast render mode, the amount
// of files published is low, and it would be really nice to know exactly which
// of these files where actually changed.
// Note that this will only work for file operations that use the io.Writer
// to write content to file, but that is fine for the "publish content" use case.
func NewHashingFs(delegate afero.Fs, hashReceiver FileHashReceiver) afero.Fs <span class="cov0" title="0">{
        return &amp;md5HashingFs{Fs: delegate, hashReceiver: hashReceiver}
}</span>

func (fs *md5HashingFs) Create(name string) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.Fs.Create(name)
        if err == nil </span><span class="cov0" title="0">{
                f = fs.wrapFile(f)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}

func (fs *md5HashingFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.Fs.OpenFile(name, flag, perm)
        if err == nil &amp;&amp; isWrite(flag) </span><span class="cov0" title="0">{
                f = fs.wrapFile(f)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}

func (fs *md5HashingFs) wrapFile(f afero.File) afero.File <span class="cov0" title="0">{
        return &amp;hashingFile{File: f, h: md5.New(), hashReceiver: fs.hashReceiver}
}</span>

func (fs *md5HashingFs) Name() string <span class="cov0" title="0">{
        return "md5HashingFs"
}</span>

type hashingFile struct {
        hashReceiver FileHashReceiver
        h            hash.Hash
        afero.File
}

func (h *hashingFile) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        n, err = h.File.Write(p)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return h.h.Write(p)</span>
}

func (h *hashingFile) Close() error <span class="cov0" title="0">{
        sum := hex.EncodeToString(h.h.Sum(nil))
        h.hashReceiver.OnFileClose(h.Name(), sum)
        return h.File.Close()
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "os"
        "path"

        "github.com/spf13/afero"
)

var (
        _ afero.Fs      = (*languageCompositeFs)(nil)
        _ afero.Lstater = (*languageCompositeFs)(nil)
)

type languageCompositeFs struct {
        *afero.CopyOnWriteFs
}

// NewLanguageCompositeFs creates a composite and language aware filesystem.
// This is a hybrid filesystem. To get a specific file in Open, Stat etc., use the full filename
// to the target filesystem. This information is available in Readdir, Stat etc. via the
// special LanguageFileInfo FileInfo implementation.
func NewLanguageCompositeFs(base, overlay afero.Fs) afero.Fs <span class="cov8" title="1">{
        return &amp;languageCompositeFs{afero.NewCopyOnWriteFs(base, overlay).(*afero.CopyOnWriteFs)}
}</span>

// Open takes the full path to the file in the target filesystem. If it is a directory, it gets merged
// using the language as a weight.
func (fs *languageCompositeFs) Open(name string) (afero.File, error) <span class="cov8" title="1">{
        f, err := fs.CopyOnWriteFs.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fu, ok := f.(*afero.UnionFile)
        if ok </span><span class="cov0" title="0">{
                // This is a directory: Merge it.
                fu.Merger = LanguageDirsMerger
        }</span>
        <span class="cov8" title="1">return f, nil</span>
}

// LanguageDirsMerger implements the afero.DirsMerger interface, which is used
// to merge two directories.
var LanguageDirsMerger = func(lofi, bofi []os.FileInfo) ([]os.FileInfo, error) <span class="cov0" title="0">{
        m := make(map[string]FileMetaInfo)

        getKey := func(fim FileMetaInfo) string </span><span class="cov0" title="0">{
                return path.Join(fim.Meta().Lang(), fim.Name())
        }</span>

        <span class="cov0" title="0">for _, fi := range lofi </span><span class="cov0" title="0">{
                fim := fi.(FileMetaInfo)
                m[getKey(fim)] = fim
        }</span>

        <span class="cov0" title="0">for _, fi := range bofi </span><span class="cov0" title="0">{
                fim := fi.(FileMetaInfo)
                key := getKey(fim)
                _, found := m[key]
                if !found </span><span class="cov0" title="0">{
                        m[key] = fim
                }</span>
        }

        <span class="cov0" title="0">merged := make([]os.FileInfo, len(m))
        i := 0
        for _, v := range m </span><span class="cov0" title="0">{
                merged[i] = v
                i++
        }</span>

        <span class="cov0" title="0">return merged, nil</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "errors"
        "os"
        "time"

        "github.com/spf13/afero"
)

var (
        errNoOp          = errors.New("this is a filesystem that does nothing and this operation is not supported")
        _       afero.Fs = (*noOpFs)(nil)

        // NoOpFs provides a no-op filesystem that implements the afero.Fs
        // interface.
        NoOpFs = &amp;noOpFs{}
)

type noOpFs struct {
}

func (fs noOpFs) Create(name string) (afero.File, error) <span class="cov0" title="0">{
        return nil, errNoOp
}</span>

func (fs noOpFs) Mkdir(name string, perm os.FileMode) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs noOpFs) MkdirAll(path string, perm os.FileMode) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs noOpFs) Open(name string) (afero.File, error) <span class="cov0" title="0">{
        return nil, os.ErrNotExist
}</span>

func (fs noOpFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        return nil, os.ErrNotExist
}</span>

func (fs noOpFs) Remove(name string) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs noOpFs) RemoveAll(path string) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs noOpFs) Rename(oldname string, newname string) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs noOpFs) Stat(name string) (os.FileInfo, error) <span class="cov0" title="0">{
        return nil, os.ErrNotExist
}</span>

func (fs noOpFs) Name() string <span class="cov0" title="0">{
        return "noOpFs"
}</span>

func (fs noOpFs) Chmod(name string, mode os.FileMode) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs noOpFs) Chtimes(name string, atime time.Time, mtime time.Time) error <span class="cov0" title="0">{
        return errNoOp
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "errors"
        "os"
        "path/filepath"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/spf13/afero"
)

var (
        ErrPermissionSymlink = errors.New("symlinks not allowed in this filesystem")
)

// NewNoSymlinkFs creates a new filesystem that prevents symlinks.
func NewNoSymlinkFs(fs afero.Fs, logger *loggers.Logger, allowFiles bool) afero.Fs <span class="cov8" title="1">{
        return &amp;noSymlinkFs{Fs: fs, logger: logger, allowFiles: allowFiles}
}</span>

// noSymlinkFs is a filesystem that prevents symlinking.
type noSymlinkFs struct {
        allowFiles bool // block dirs only
        logger     *loggers.Logger
        afero.Fs
}

type noSymlinkFile struct {
        fs *noSymlinkFs
        afero.File
}

func (f *noSymlinkFile) Readdir(count int) ([]os.FileInfo, error) <span class="cov8" title="1">{
        fis, err := f.File.Readdir(count)

        filtered := fis[:0]
        for _, x := range fis </span><span class="cov8" title="1">{
                filename := filepath.Join(f.Name(), x.Name())
                if _, err := f.fs.checkSymlinkStatus(filename, x); err != nil </span><span class="cov0" title="0">{
                        // Log a warning and drop the file from the list
                        logUnsupportedSymlink(filename, f.fs.logger)
                }</span> else<span class="cov8" title="1"> {
                        filtered = append(filtered, x)
                }</span>
        }

        <span class="cov8" title="1">return filtered, err</span>
}

func (f *noSymlinkFile) Readdirnames(count int) ([]string, error) <span class="cov8" title="1">{
        dirs, err := f.Readdir(count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return fileInfosToNames(dirs), nil</span>
}

func (fs *noSymlinkFs) LstatIfPossible(name string) (os.FileInfo, bool, error) <span class="cov8" title="1">{
        return fs.stat(name)
}</span>

func (fs *noSymlinkFs) Stat(name string) (os.FileInfo, error) <span class="cov8" title="1">{
        fi, _, err := fs.stat(name)
        return fi, err
}</span>

func (fs *noSymlinkFs) stat(name string) (os.FileInfo, bool, error) <span class="cov8" title="1">{

        var (
                fi       os.FileInfo
                wasLstat bool
                err      error
        )

        if lstater, ok := fs.Fs.(afero.Lstater); ok </span><span class="cov8" title="1">{
                fi, wasLstat, err = lstater.LstatIfPossible(name)
        }</span> else<span class="cov0" title="0"> {
                fi, err = fs.Fs.Stat(name)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>

        <span class="cov8" title="1">fi, err = fs.checkSymlinkStatus(name, fi)

        return fi, wasLstat, err</span>
}

func (fs *noSymlinkFs) checkSymlinkStatus(name string, fi os.FileInfo) (os.FileInfo, error) <span class="cov8" title="1">{
        var metaIsSymlink bool

        if fim, ok := fi.(FileMetaInfo); ok </span><span class="cov8" title="1">{
                meta := fim.Meta()
                metaIsSymlink = meta.IsSymlink()
        }</span>

        <span class="cov8" title="1">if metaIsSymlink </span><span class="cov0" title="0">{
                if fs.allowFiles &amp;&amp; !fi.IsDir() </span><span class="cov0" title="0">{
                        return fi, nil
                }</span>
                <span class="cov0" title="0">return nil, ErrPermissionSymlink</span>
        }

        // Also support non-decorated filesystems, e.g. the Os fs.
        <span class="cov8" title="1">if isSymlink(fi) </span><span class="cov0" title="0">{
                // Need to determine if this is a directory or not.
                _, sfi, err := evalSymlinks(fs.Fs, name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if fs.allowFiles &amp;&amp; !sfi.IsDir() </span><span class="cov0" title="0">{
                        // Return the original FileInfo to get the expected Name.
                        return fi, nil
                }</span>
                <span class="cov0" title="0">return nil, ErrPermissionSymlink</span>
        }

        <span class="cov8" title="1">return fi, nil</span>
}

func (fs *noSymlinkFs) Open(name string) (afero.File, error) <span class="cov8" title="1">{
        if _, _, err := fs.stat(name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return fs.wrapFile(fs.Fs.Open(name))</span>
}

func (fs *noSymlinkFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        if _, _, err := fs.stat(name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return fs.wrapFile(fs.Fs.OpenFile(name, flag, perm))</span>
}

func (fs *noSymlinkFs) wrapFile(f afero.File, err error) (afero.File, error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;noSymlinkFile{File: f, fs: fs}, nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/pkg/errors"

        radix "github.com/armon/go-radix"
        "github.com/spf13/afero"
)

var filepathSeparator = string(filepath.Separator)

// NewRootMappingFs creates a new RootMappingFs on top of the provided with
// of root mappings with some optional metadata about the root.
// Note that From represents a virtual root that maps to the actual filename in To.
func NewRootMappingFs(fs afero.Fs, rms ...RootMapping) (*RootMappingFs, error) <span class="cov8" title="1">{
        rootMapToReal := radix.New()

        for _, rm := range rms </span><span class="cov8" title="1">{
                (&amp;rm).clean()

                fromBase := files.ResolveComponentFolder(rm.From)
                if fromBase == "" </span><span class="cov0" title="0">{
                        panic("unrecognised component folder in" + rm.From)</span>
                }

                <span class="cov8" title="1">if len(rm.To) &lt; 2 </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("invalid root mapping; from/to: %s/%s", rm.From, rm.To))</span>
                }

                <span class="cov8" title="1">_, err := fs.Stat(rm.To)
                if err != nil </span><span class="cov8" title="1">{
                        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }

                // Extract "blog" from "content/blog"
                <span class="cov8" title="1">rm.path = strings.TrimPrefix(strings.TrimPrefix(rm.From, fromBase), filepathSeparator)

                key := rm.rootKey()
                var mappings []RootMapping
                v, found := rootMapToReal.Get(key)
                if found </span><span class="cov0" title="0">{
                        // There may be more than one language pointing to the same root.
                        mappings = v.([]RootMapping)
                }</span>
                <span class="cov8" title="1">mappings = append(mappings, rm)
                rootMapToReal.Insert(key, mappings)</span>
        }

        <span class="cov8" title="1">rfs := &amp;RootMappingFs{Fs: fs,
                virtualRoots:  rms,
                rootMapToReal: rootMapToReal}

        return rfs, nil</span>
}

// NewRootMappingFsFromFromTo is a convenicence variant of NewRootMappingFs taking
// From and To as string pairs.
func NewRootMappingFsFromFromTo(fs afero.Fs, fromTo ...string) (*RootMappingFs, error) <span class="cov0" title="0">{
        rms := make([]RootMapping, len(fromTo)/2)
        for i, j := 0, 0; j &lt; len(fromTo); i, j = i+1, j+2 </span><span class="cov0" title="0">{
                rms[i] = RootMapping{
                        From: fromTo[j],
                        To:   fromTo[j+1],
                }
        }</span>

        <span class="cov0" title="0">return NewRootMappingFs(fs, rms...)</span>
}

type RootMapping struct {
        From string
        To   string

        path string   // The virtual mount point, e.g. "blog".
        Meta FileMeta // File metadata (lang etc.)
}

func (rm *RootMapping) clean() <span class="cov8" title="1">{
        rm.From = strings.Trim(filepath.Clean(rm.From), filepathSeparator)
        rm.To = filepath.Clean(rm.To)
}</span>

func (r RootMapping) filename(name string) string <span class="cov8" title="1">{
        if name == "" </span><span class="cov0" title="0">{
                return r.To
        }</span>
        <span class="cov8" title="1">return filepath.Join(r.To, strings.TrimPrefix(name, r.From))</span>
}

func (r RootMapping) rootKey() string <span class="cov8" title="1">{
        return r.From
}</span>

// A RootMappingFs maps several roots into one. Note that the root of this filesystem
// is directories only, and they will be returned in Readdir and Readdirnames
// in the order given.
type RootMappingFs struct {
        afero.Fs
        rootMapToReal *radix.Tree
        virtualRoots  []RootMapping
        filter        func(r RootMapping) bool
}

func (fs *RootMappingFs) Dirs(base string) ([]FileMetaInfo, error) <span class="cov8" title="1">{
        roots := fs.getRootsWithPrefix(base)

        if roots == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">fss := make([]FileMetaInfo, len(roots))
        for i, r := range roots </span><span class="cov8" title="1">{
                bfs := afero.NewBasePathFs(fs.Fs, r.To)
                bfs = decoratePath(bfs, func(name string) string </span><span class="cov8" title="1">{
                        p := strings.TrimPrefix(name, r.To)
                        if r.path != "" </span><span class="cov0" title="0">{
                                // Make sure it's mounted to a any sub path, e.g. blog
                                p = filepath.Join(r.path, p)
                        }</span>
                        <span class="cov8" title="1">p = strings.TrimLeft(p, filepathSeparator)
                        return p</span>
                })
                <span class="cov8" title="1">fs := decorateDirs(bfs, r.Meta)
                fi, err := fs.Stat("")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "RootMappingFs.Dirs")
                }</span>
                <span class="cov8" title="1">fss[i] = fi.(FileMetaInfo)</span>
        }

        <span class="cov8" title="1">return fss, nil</span>
}

// LstatIfPossible returns the os.FileInfo structure describing a given file.
func (fs *RootMappingFs) LstatIfPossible(name string) (os.FileInfo, bool, error) <span class="cov8" title="1">{
        fis, _, b, err := fs.doLstat(name, false)
        if err != nil </span><span class="cov8" title="1">{
                return nil, b, err
        }</span>
        <span class="cov8" title="1">return fis[0], b, nil</span>
}

func (fs *RootMappingFs) virtualDirOpener(name string, isRoot bool) func() (afero.File, error) <span class="cov0" title="0">{
        return func() (afero.File, error) </span><span class="cov0" title="0">{ return &amp;rootMappingFile{name: name, isRoot: isRoot, fs: fs}, nil }</span>
}

func (fs *RootMappingFs) doLstat(name string, allowMultiple bool) ([]FileMetaInfo, []FileMetaInfo, bool, error) <span class="cov8" title="1">{

        if fs.isRoot(name) </span><span class="cov0" title="0">{
                return []FileMetaInfo{newDirNameOnlyFileInfo(name, true, fs.virtualDirOpener(name, true))}, nil, false, nil
        }</span>

        <span class="cov8" title="1">roots := fs.getRoots(name)
        rootsWithPrefix := fs.getRootsWithPrefix(name)
        hasRootMappingsBelow := len(rootsWithPrefix) != 0

        if len(roots) == 0 </span><span class="cov8" title="1">{
                if hasRootMappingsBelow </span><span class="cov0" title="0">{
                        // No exact matches, but we have root mappings below name,
                        // let's make it look like a directory.
                        return []FileMetaInfo{newDirNameOnlyFileInfo(name, true, fs.virtualDirOpener(name, false))}, nil, false, nil
                }</span>

                <span class="cov8" title="1">return nil, nil, false, os.ErrNotExist</span>
        }

        // We may have a mapping for both static and static/subdir.
        // These will not show in any Readdir so append them
        // manually.
        <span class="cov8" title="1">rootsInDir := fs.filterRootsBelow(rootsWithPrefix, name)

        var (
                fis  []FileMetaInfo
                dirs []FileMetaInfo
                b    bool
                fi   os.FileInfo
                root RootMapping
                err  error
        )

        for _, root = range roots </span><span class="cov8" title="1">{
                fi, b, err = fs.statRoot(root, name)
                if err != nil </span><span class="cov8" title="1">{
                        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, nil, false, err</span>
                }
                <span class="cov8" title="1">fim := fi.(FileMetaInfo)
                fis = append(fis, fim)</span>
        }

        <span class="cov8" title="1">for _, root = range rootsInDir </span><span class="cov0" title="0">{
                fi, _, err := fs.statRoot(root, "")
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, nil, false, err</span>
                }
                <span class="cov0" title="0">fim := fi.(FileMetaInfo)
                dirs = append(dirs, fim)</span>
        }

        <span class="cov8" title="1">if len(fis) == 0 &amp;&amp; len(dirs) == 0 </span><span class="cov8" title="1">{
                return nil, nil, false, os.ErrNotExist
        }</span>

        <span class="cov8" title="1">if allowMultiple || len(fis) == 1 </span><span class="cov8" title="1">{
                return fis, dirs, b, nil
        }</span>

        // Open it in this composite filesystem.
        <span class="cov0" title="0">opener := func() (afero.File, error) </span><span class="cov0" title="0">{
                return fs.Open(name)
        }</span>

        <span class="cov0" title="0">return []FileMetaInfo{decorateFileInfo(fi, fs, opener, "", "", root.Meta)}, nil, b, nil</span>

}

// Open opens the namedrootMappingFile file for reading.
func (fs *RootMappingFs) Open(name string) (afero.File, error) <span class="cov8" title="1">{
        if fs.isRoot(name) </span><span class="cov0" title="0">{
                return &amp;rootMappingFile{name: name, fs: fs, isRoot: true}, nil
        }</span>

        <span class="cov8" title="1">fis, dirs, _, err := fs.doLstat(name, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(fis) == 1 </span><span class="cov8" title="1">{
                fi := fis[0]
                meta := fi.(FileMetaInfo).Meta()
                f, err := meta.Open()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">f = &amp;rootMappingFile{File: f, fs: fs, name: name, meta: meta}

                if len(dirs) &gt; 0 </span><span class="cov0" title="0">{
                        return &amp;readDirDirsAppender{File: f, dirs: dirs}, nil
                }</span>

                <span class="cov8" title="1">return f, nil</span>
        }

        <span class="cov0" title="0">f, err := fs.newUnionFile(fis...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(dirs) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;readDirDirsAppender{File: f, dirs: dirs}, nil
        }</span>

        <span class="cov0" title="0">return f, nil</span>

}

// Stat returns the os.FileInfo structure describing a given file.  If there is
// an error, it will be of type *os.PathError.
func (fs *RootMappingFs) Stat(name string) (os.FileInfo, error) <span class="cov8" title="1">{
        fi, _, err := fs.LstatIfPossible(name)
        return fi, err

}</span>

// Filter creates a copy of this filesystem with the applied filter.
func (fs RootMappingFs) Filter(f func(m RootMapping) bool) *RootMappingFs <span class="cov0" title="0">{
        fs.filter = f
        return &amp;fs
}</span>

func (fs *RootMappingFs) isRoot(name string) bool <span class="cov8" title="1">{
        return name == "" || name == filepathSeparator

}</span>

func (fs *RootMappingFs) getRoots(name string) []RootMapping <span class="cov8" title="1">{
        name = filepath.Clean(name)
        _, v, found := fs.rootMapToReal.LongestPrefix(name)
        if !found </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">rm := v.([]RootMapping)

        return fs.applyFilterToRoots(rm)</span>
}

func (fs *RootMappingFs) applyFilterToRoots(rm []RootMapping) []RootMapping <span class="cov8" title="1">{
        if fs.filter == nil </span><span class="cov8" title="1">{
                return rm
        }</span>

        <span class="cov0" title="0">var filtered []RootMapping
        for _, m := range rm </span><span class="cov0" title="0">{
                if fs.filter(m) </span><span class="cov0" title="0">{
                        filtered = append(filtered, m)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

func (fs *RootMappingFs) getRootsWithPrefix(prefix string) []RootMapping <span class="cov8" title="1">{
        if fs.isRoot(prefix) </span><span class="cov0" title="0">{
                return fs.virtualRoots
        }</span>
        <span class="cov8" title="1">prefix = filepath.Clean(prefix)
        var roots []RootMapping

        fs.rootMapToReal.WalkPrefix(prefix, func(b string, v interface{}) bool </span><span class="cov8" title="1">{
                roots = append(roots, v.([]RootMapping)...)
                return false
        }</span>)

        <span class="cov8" title="1">return fs.applyFilterToRoots(roots)</span>
}

// Filter out the mappings inside the name directory.
func (fs *RootMappingFs) filterRootsBelow(roots []RootMapping, name string) []RootMapping <span class="cov8" title="1">{
        if len(roots) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">sepCount := strings.Count(name, filepathSeparator)
        var filtered []RootMapping
        for _, x := range roots </span><span class="cov8" title="1">{
                if name == x.From </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov0" title="0">if strings.Count(x.From, filepathSeparator)-sepCount != 1 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">filtered = append(filtered, x)</span>

        }
        <span class="cov8" title="1">return filtered</span>
}

func (fs *RootMappingFs) newUnionFile(fis ...FileMetaInfo) (afero.File, error) <span class="cov0" title="0">{
        meta := fis[0].Meta()
        f, err := meta.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rf := &amp;rootMappingFile{File: f, fs: fs, name: meta.Name(), meta: meta}
        if len(fis) == 1 </span><span class="cov0" title="0">{
                return rf, err
        }</span>

        <span class="cov0" title="0">next, err := fs.newUnionFile(fis[1:]...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">uf := &amp;afero.UnionFile{Base: rf, Layer: next}

        uf.Merger = func(lofi, bofi []os.FileInfo) ([]os.FileInfo, error) </span><span class="cov0" title="0">{
                // Ignore duplicate directory entries
                seen := make(map[string]bool)
                var result []os.FileInfo

                for _, fis := range [][]os.FileInfo{bofi, lofi} </span><span class="cov0" title="0">{
                        for _, fi := range fis </span><span class="cov0" title="0">{

                                if fi.IsDir() &amp;&amp; seen[fi.Name()] </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                                        seen[fi.Name()] = true
                                }</span>

                                <span class="cov0" title="0">result = append(result, fi)</span>
                        }
                }

                <span class="cov0" title="0">return result, nil</span>
        }

        <span class="cov0" title="0">return uf, nil</span>

}

func (fs *RootMappingFs) statRoot(root RootMapping, name string) (os.FileInfo, bool, error) <span class="cov8" title="1">{
        filename := root.filename(name)

        var b bool
        var fi os.FileInfo
        var err error

        if ls, ok := fs.Fs.(afero.Lstater); ok </span><span class="cov8" title="1">{
                fi, b, err = ls.LstatIfPossible(filename)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, b, err
                }</span>

        } else<span class="cov0" title="0"> {
                fi, err = fs.Fs.Stat(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, b, err
                }</span>
        }

        // Opens the real directory/file.
        <span class="cov8" title="1">opener := func() (afero.File, error) </span><span class="cov8" title="1">{
                return fs.Fs.Open(filename)
        }</span>

        <span class="cov8" title="1">if fi.IsDir() </span><span class="cov8" title="1">{
                if name == "" </span><span class="cov0" title="0">{
                        name = root.From
                }</span>
                <span class="cov8" title="1">_, name = filepath.Split(name)
                fi = newDirNameOnlyFileInfo(name, false, opener)</span>
        }

        <span class="cov8" title="1">return decorateFileInfo(fi, fs.Fs, opener, "", "", root.Meta), b, nil</span>

}

type rootMappingFile struct {
        afero.File
        fs     *RootMappingFs
        name   string
        meta   FileMeta
        isRoot bool
}

type readDirDirsAppender struct {
        afero.File
        dirs []FileMetaInfo
}

func (f *readDirDirsAppender) Readdir(count int) ([]os.FileInfo, error) <span class="cov0" title="0">{
        fis, err := f.File.Readdir(count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, dir := range f.dirs </span><span class="cov0" title="0">{
                fis = append(fis, dir)
        }</span>
        <span class="cov0" title="0">return fis, nil</span>

}

func (f *readDirDirsAppender) Readdirnames(count int) ([]string, error) <span class="cov0" title="0">{
        fis, err := f.Readdir(count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return fileInfosToNames(fis), nil</span>
}

func (f *rootMappingFile) Close() error <span class="cov8" title="1">{
        if f.File == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return f.File.Close()</span>
}

func (f *rootMappingFile) Name() string <span class="cov8" title="1">{
        return f.name
}</span>

func (f *rootMappingFile) Readdir(count int) ([]os.FileInfo, error) <span class="cov8" title="1">{
        if f.File == nil </span><span class="cov0" title="0">{
                dirsn := make([]os.FileInfo, 0)
                roots := f.fs.getRootsWithPrefix(f.name)
                seen := make(map[string]bool)

                j := 0
                for _, rm := range roots </span><span class="cov0" title="0">{
                        if count != -1 &amp;&amp; j &gt;= count </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">opener := func() (afero.File, error) </span><span class="cov0" title="0">{
                                return f.fs.Open(rm.From)
                        }</span>

                        <span class="cov0" title="0">name := rm.From
                        if !f.isRoot </span><span class="cov0" title="0">{
                                _, name = filepath.Split(rm.From)
                        }</span>

                        <span class="cov0" title="0">if seen[name] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">seen[name] = true

                        j++

                        fi := newDirNameOnlyFileInfo(name, false, opener)
                        if rm.Meta != nil </span><span class="cov0" title="0">{
                                mergeFileMeta(rm.Meta, fi.Meta())
                        }</span>

                        <span class="cov0" title="0">dirsn = append(dirsn, fi)</span>
                }
                <span class="cov0" title="0">return dirsn, nil</span>
        }

        <span class="cov8" title="1">if f.File == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("no File for %q", f.name))</span>
        }

        <span class="cov8" title="1">fis, err := f.File.Readdir(count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for i, fi := range fis </span><span class="cov8" title="1">{
                fis[i] = decorateFileInfo(fi, f.fs, nil, "", "", f.meta)
        }</span>

        <span class="cov8" title="1">return fis, nil</span>
}

func (f *rootMappingFile) Readdirnames(count int) ([]string, error) <span class="cov0" title="0">{
        dirs, err := f.Readdir(count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return fileInfosToNames(dirs), nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "os"
        "syscall"
        "time"

        "github.com/pkg/errors"

        "github.com/spf13/afero"
)

var (
        _ afero.Fs      = (*SliceFs)(nil)
        _ afero.Lstater = (*SliceFs)(nil)
        _ afero.File    = (*sliceDir)(nil)
)

func NewSliceFs(dirs ...FileMetaInfo) (afero.Fs, error) <span class="cov8" title="1">{
        if len(dirs) == 0 </span><span class="cov0" title="0">{
                return NoOpFs, nil
        }</span>

        <span class="cov8" title="1">for _, dir := range dirs </span><span class="cov8" title="1">{
                if !dir.IsDir() </span><span class="cov0" title="0">{
                        return nil, errors.New("this fs supports directories only")
                }</span>
        }

        <span class="cov8" title="1">fs := &amp;SliceFs{
                dirs: dirs,
        }

        return fs, nil</span>

}

// SliceFs is an ordered composite filesystem.
type SliceFs struct {
        dirs []FileMetaInfo
}

func (fs *SliceFs) Chmod(n string, m os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) Chtimes(n string, a, m time.Time) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) LstatIfPossible(name string) (os.FileInfo, bool, error) <span class="cov0" title="0">{
        fi, _, err := fs.pickFirst(name)

        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                return decorateFileInfo(fi, fs, fs.getOpener(name), "", "", nil), false, nil
        }</span>

        <span class="cov0" title="0">return nil, false, errors.Errorf("lstat: files not supported: %q", name)</span>

}

func (fs *SliceFs) Mkdir(n string, p os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) MkdirAll(n string, p os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) Name() string <span class="cov0" title="0">{
        return "SliceFs"
}</span>

func (fs *SliceFs) Open(name string) (afero.File, error) <span class="cov0" title="0">{
        fi, idx, err := fs.pickFirst(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !fi.IsDir() </span><span class="cov0" title="0">{
                panic("currently only dirs in here")</span>
        }

        <span class="cov0" title="0">return &amp;sliceDir{
                lfs:     fs,
                idx:     idx,
                dirname: name,
        }, nil</span>

}

func (fs *SliceFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (fs *SliceFs) ReadDir(name string) ([]os.FileInfo, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (fs *SliceFs) Remove(n string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) RemoveAll(p string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) Rename(o, n string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) Stat(name string) (os.FileInfo, error) <span class="cov0" title="0">{
        fi, _, err := fs.LstatIfPossible(name)
        return fi, err
}</span>

func (fs *SliceFs) Create(n string) (afero.File, error) <span class="cov0" title="0">{
        return nil, syscall.EPERM
}</span>

func (fs *SliceFs) getOpener(name string) func() (afero.File, error) <span class="cov0" title="0">{
        return func() (afero.File, error) </span><span class="cov0" title="0">{
                return fs.Open(name)
        }</span>
}

func (fs *SliceFs) pickFirst(name string) (os.FileInfo, int, error) <span class="cov0" title="0">{
        for i, mfs := range fs.dirs </span><span class="cov0" title="0">{
                meta := mfs.Meta()
                fs := meta.Fs()
                fi, _, err := lstatIfPossible(fs, name)
                if err == nil </span><span class="cov0" title="0">{
                        // Gotta match!
                        return fi, i, nil
                }</span>

                <span class="cov0" title="0">if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // Real error
                        return nil, -1, err
                }</span>
        }

        // Not found
        <span class="cov0" title="0">return nil, -1, os.ErrNotExist</span>
}

func (fs *SliceFs) readDirs(name string, startIdx, count int) ([]os.FileInfo, error) <span class="cov0" title="0">{
        collect := func(lfs FileMeta) ([]os.FileInfo, error) </span><span class="cov0" title="0">{
                d, err := lfs.Fs().Open(name)
                if err != nil </span><span class="cov0" title="0">{
                        if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return nil, nil</span>
                } else<span class="cov0" title="0"> {
                        defer d.Close()
                        dirs, err := d.Readdir(-1)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return dirs, nil</span>
                }
        }

        <span class="cov0" title="0">var dirs []os.FileInfo

        for i := startIdx; i &lt; len(fs.dirs); i++ </span><span class="cov0" title="0">{
                mfs := fs.dirs[i]

                fis, err := collect(mfs.Meta())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">dirs = append(dirs, fis...)</span>

        }

        <span class="cov0" title="0">seen := make(map[string]bool)
        var duplicates []int
        for i, fi := range dirs </span><span class="cov0" title="0">{
                if !fi.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if seen[fi.Name()] </span><span class="cov0" title="0">{
                        duplicates = append(duplicates, i)
                }</span> else<span class="cov0" title="0"> {
                        // Make sure it's opened by this filesystem.
                        dirs[i] = decorateFileInfo(fi, fs, fs.getOpener(fi.(FileMetaInfo).Meta().Filename()), "", "", nil)
                        seen[fi.Name()] = true
                }</span>
        }

        // Remove duplicate directories, keep first.
        <span class="cov0" title="0">if len(duplicates) &gt; 0 </span><span class="cov0" title="0">{
                for i := len(duplicates) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        idx := duplicates[i]
                        dirs = append(dirs[:idx], dirs[idx+1:]...)
                }</span>
        }

        <span class="cov0" title="0">if count &gt; 0 &amp;&amp; len(dirs) &gt;= count </span><span class="cov0" title="0">{
                return dirs[:count], nil
        }</span>

        <span class="cov0" title="0">return dirs, nil</span>

}

type sliceDir struct {
        lfs     *SliceFs
        idx     int
        dirname string
}

func (f *sliceDir) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func (f *sliceDir) Name() string <span class="cov0" title="0">{
        return f.dirname
}</span>

func (f *sliceDir) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) ReadAt(p []byte, off int64) (n int, err error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) Readdir(count int) ([]os.FileInfo, error) <span class="cov0" title="0">{
        return f.lfs.readDirs(f.dirname, f.idx, count)
}</span>

func (f *sliceDir) Readdirnames(count int) ([]string, error) <span class="cov0" title="0">{
        dirsi, err := f.Readdir(count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dirs := make([]string, len(dirsi))
        for i, d := range dirsi </span><span class="cov0" title="0">{
                dirs[i] = d.Name()
        }</span>
        <span class="cov0" title="0">return dirs, nil</span>
}

func (f *sliceDir) Seek(offset int64, whence int) (int64, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) Stat() (os.FileInfo, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) Sync() error <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) Truncate(size int64) error <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) WriteAt(p []byte, off int64) (n int, err error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) WriteString(s string) (ret int, err error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "fmt"
        "os"
        "regexp"
        "runtime"

        "github.com/gohugoio/hugo/common/types"

        "github.com/spf13/afero"
)

// Make sure we don't accidentally use this in the real Hugo.
var _ types.DevMarker = (*stacktracerFs)(nil)

// NewStacktracerFs wraps the given fs printing stack traces for file creates
// matching the given regexp pattern.
func NewStacktracerFs(fs afero.Fs, pattern string) afero.Fs <span class="cov0" title="0">{
        return &amp;stacktracerFs{Fs: fs, re: regexp.MustCompile(pattern)}
}</span>

// stacktracerFs can be used in hard-to-debug development situations where
// you get some input you don't understand where comes from.
type stacktracerFs struct {
        afero.Fs

        // Will print stacktrace for every file creates matching this pattern.
        re *regexp.Regexp
}

func (fs *stacktracerFs) DevOnly() {<span class="cov0" title="0">
}</span>

func (fs *stacktracerFs) onCreate(filename string) <span class="cov0" title="0">{
        if fs.re.MatchString(filename) </span><span class="cov0" title="0">{
                trace := make([]byte, 1500)
                runtime.Stack(trace, true)
                fmt.Printf("\n===========\n%q:\n%s\n", filename, trace)
        }</span>
}

func (fs *stacktracerFs) Create(name string) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.Fs.Create(name)
        if err == nil </span><span class="cov0" title="0">{
                fs.onCreate(name)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}

func (fs *stacktracerFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.Fs.OpenFile(name, flag, perm)
        if err == nil &amp;&amp; isWrite(flag) </span><span class="cov0" title="0">{
                fs.onCreate(name)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/pkg/errors"

        "github.com/spf13/afero"
)

type (
        WalkFunc func(path string, info FileMetaInfo, err error) error
        WalkHook func(dir FileMetaInfo, path string, readdir []FileMetaInfo) ([]FileMetaInfo, error)
)

type Walkway struct {
        fs       afero.Fs
        root     string
        basePath string

        logger *loggers.Logger

        // May be pre-set
        fi         FileMetaInfo
        dirEntries []FileMetaInfo

        walkFn WalkFunc
        walked bool

        // We may traverse symbolic links and bite ourself.
        seen map[string]bool

        // Optional hooks
        hookPre  WalkHook
        hookPost WalkHook
}

type WalkwayConfig struct {
        Fs       afero.Fs
        Root     string
        BasePath string

        Logger *loggers.Logger

        // One or both of these may be pre-set.
        Info       FileMetaInfo
        DirEntries []FileMetaInfo

        WalkFn   WalkFunc
        HookPre  WalkHook
        HookPost WalkHook
}

func NewWalkway(cfg WalkwayConfig) *Walkway <span class="cov8" title="1">{
        var fs afero.Fs
        if cfg.Info != nil </span><span class="cov8" title="1">{
                fs = cfg.Info.Meta().Fs()
        }</span> else<span class="cov8" title="1"> {
                fs = cfg.Fs
        }</span>

        <span class="cov8" title="1">basePath := cfg.BasePath
        if basePath != "" &amp;&amp; !strings.HasSuffix(basePath, filepathSeparator) </span><span class="cov0" title="0">{
                basePath += filepathSeparator
        }</span>

        <span class="cov8" title="1">logger := cfg.Logger
        if logger == nil </span><span class="cov8" title="1">{
                logger = loggers.NewWarningLogger()
        }</span>

        <span class="cov8" title="1">return &amp;Walkway{
                fs:         fs,
                root:       cfg.Root,
                basePath:   basePath,
                fi:         cfg.Info,
                dirEntries: cfg.DirEntries,
                walkFn:     cfg.WalkFn,
                hookPre:    cfg.HookPre,
                hookPost:   cfg.HookPost,
                logger:     logger,
                seen:       make(map[string]bool)}</span>
}

func (w *Walkway) Walk() error <span class="cov8" title="1">{
        if w.walked </span><span class="cov0" title="0">{
                panic("this walkway is already walked")</span>
        }
        <span class="cov8" title="1">w.walked = true

        if w.fs == NoOpFs </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var fi FileMetaInfo
        if w.fi != nil </span><span class="cov8" title="1">{
                fi = w.fi
        }</span> else<span class="cov8" title="1"> {
                info, _, err := lstatIfPossible(w.fs, w.root)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">if w.checkErr(w.root, err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">return w.walkFn(w.root, nil, errors.Wrapf(err, "walk: %q", w.root))</span>
                }
                <span class="cov8" title="1">fi = info.(FileMetaInfo)</span>
        }

        <span class="cov8" title="1">if !fi.IsDir() </span><span class="cov0" title="0">{
                return w.walkFn(w.root, nil, errors.New("file to walk must be a directory"))
        }</span>

        <span class="cov8" title="1">return w.walk(w.root, fi, w.dirEntries, w.walkFn)</span>

}

// if the filesystem supports it, use Lstat, else use fs.Stat
func lstatIfPossible(fs afero.Fs, path string) (os.FileInfo, bool, error) <span class="cov8" title="1">{
        if lfs, ok := fs.(afero.Lstater); ok </span><span class="cov8" title="1">{
                fi, b, err := lfs.LstatIfPossible(path)
                return fi, b, err
        }</span>
        <span class="cov0" title="0">fi, err := fs.Stat(path)
        return fi, false, err</span>
}

// checkErr returns true if the error is handled.
func (w *Walkway) checkErr(filename string, err error) bool <span class="cov0" title="0">{
        if err == ErrPermissionSymlink </span><span class="cov0" title="0">{
                logUnsupportedSymlink(filename, w.logger)
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func logUnsupportedSymlink(filename string, logger *loggers.Logger) <span class="cov0" title="0">{
        logger.WARN.Printf("Unsupported symlink found in %q, skipping.", filename)
}</span>

// walk recursively descends path, calling walkFn.
// It follow symlinks if supported by the filesystem, but only the same path once.
func (w *Walkway) walk(path string, info FileMetaInfo, dirEntries []FileMetaInfo, walkFn WalkFunc) error <span class="cov8" title="1">{
        err := walkFn(path, info, nil)
        if err != nil </span><span class="cov0" title="0">{
                if info.IsDir() &amp;&amp; err == filepath.SkipDir </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">meta := info.Meta()
        filename := meta.Filename()

        if dirEntries == nil </span><span class="cov8" title="1">{
                f, err := w.fs.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        if w.checkErr(path, err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return walkFn(path, info, errors.Wrapf(err, "walk: open %q (%q)", path, w.root))</span>
                }

                <span class="cov8" title="1">fis, err := f.Readdir(-1)
                f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        if w.checkErr(filename, err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return walkFn(path, info, errors.Wrap(err, "walk: Readdir"))</span>
                }

                <span class="cov8" title="1">dirEntries = fileInfosToFileMetaInfos(fis)

                if !meta.IsOrdered() </span><span class="cov8" title="1">{
                        sort.Slice(dirEntries, func(i, j int) bool </span><span class="cov8" title="1">{
                                fii := dirEntries[i]
                                fij := dirEntries[j]

                                fim, fjm := fii.Meta(), fij.Meta()

                                // Pull bundle headers to the top.
                                ficlass, fjclass := fim.Classifier(), fjm.Classifier()
                                if ficlass != fjclass </span><span class="cov0" title="0">{
                                        return ficlass &lt; fjclass
                                }</span>

                                // With multiple content dirs with different languages,
                                // there can be duplicate files, and a weight will be added
                                // to the closest one.
                                <span class="cov8" title="1">fiw, fjw := fim.Weight(), fjm.Weight()
                                if fiw != fjw </span><span class="cov0" title="0">{
                                        return fiw &gt; fjw
                                }</span>

                                // Explicit order set.
                                <span class="cov8" title="1">fio, fjo := fim.Ordinal(), fjm.Ordinal()
                                if fio != fjo </span><span class="cov0" title="0">{
                                        return fio &lt; fjo
                                }</span>

                                // When we walk into a symlink, we keep the reference to
                                // the original name.
                                <span class="cov8" title="1">fin, fjn := fim.Name(), fjm.Name()
                                if fin != "" &amp;&amp; fjn != "" </span><span class="cov8" title="1">{
                                        return fin &lt; fjn
                                }</span>

                                <span class="cov0" title="0">return fii.Name() &lt; fij.Name()</span>
                        })
                }
        }

        // First add some metadata to the dir entries
        <span class="cov8" title="1">for _, fi := range dirEntries </span><span class="cov8" title="1">{
                fim := fi.(FileMetaInfo)

                meta := fim.Meta()

                // Note that we use the original Name even if it's a symlink.
                name := meta.Name()
                if name == "" </span><span class="cov0" title="0">{
                        name = fim.Name()
                }</span>

                <span class="cov8" title="1">if name == "" </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("[%s] no name set in %v", path, meta))</span>
                }
                <span class="cov8" title="1">pathn := filepath.Join(path, name)

                pathMeta := pathn
                if w.basePath != "" </span><span class="cov0" title="0">{
                        pathMeta = strings.TrimPrefix(pathn, w.basePath)
                }</span>

                <span class="cov8" title="1">meta[metaKeyPath] = normalizeFilename(pathMeta)
                meta[metaKeyPathWalk] = pathn

                if fim.IsDir() &amp;&amp; w.isSeen(meta.Filename()) </span><span class="cov0" title="0">{
                        // Prevent infinite recursion
                        // Possible cyclic reference
                        meta[metaKeySkipDir] = true
                }</span>
        }

        <span class="cov8" title="1">if w.hookPre != nil </span><span class="cov8" title="1">{
                dirEntries, err = w.hookPre(info, path, dirEntries)
                if err != nil </span><span class="cov0" title="0">{
                        if err == filepath.SkipDir </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        <span class="cov8" title="1">for _, fi := range dirEntries </span><span class="cov8" title="1">{
                fim := fi.(FileMetaInfo)
                meta := fim.Meta()

                if meta.SkipDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">err := w.walk(meta.GetString(metaKeyPathWalk), fim, nil, walkFn)
                if err != nil </span><span class="cov0" title="0">{
                        if !fi.IsDir() || err != filepath.SkipDir </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">if w.hookPost != nil </span><span class="cov0" title="0">{
                dirEntries, err = w.hookPost(info, path, dirEntries)
                if err != nil </span><span class="cov0" title="0">{
                        if err == filepath.SkipDir </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (w *Walkway) isSeen(filename string) bool <span class="cov8" title="1">{
        if filename == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if w.seen[filename] </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">w.seen[filename] = true
        return false</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "bytes"
        "fmt"
        "html/template"
        "io"
        "path"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/publisher"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/tpl"
)

const (
        alias      = "&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;{{ .Permalink }}&lt;/title&gt;&lt;link rel=\"canonical\" href=\"{{ .Permalink }}\"/&gt;&lt;meta name=\"robots\" content=\"noindex\"&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;meta http-equiv=\"refresh\" content=\"0; url={{ .Permalink }}\" /&gt;&lt;/head&gt;&lt;/html&gt;"
        aliasXHtml = "&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;title&gt;{{ .Permalink }}&lt;/title&gt;&lt;link rel=\"canonical\" href=\"{{ .Permalink }}\"/&gt;&lt;meta name=\"robots\" content=\"noindex\"&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /&gt;&lt;meta http-equiv=\"refresh\" content=\"0; url={{ .Permalink }}\" /&gt;&lt;/head&gt;&lt;/html&gt;"
)

var defaultAliasTemplates *template.Template

func init() <span class="cov8" title="1">{
        //TODO(bep) consolidate
        defaultAliasTemplates = template.New("")
        template.Must(defaultAliasTemplates.New("alias").Parse(alias))
        template.Must(defaultAliasTemplates.New("alias-xhtml").Parse(aliasXHtml))
}</span>

type aliasHandler struct {
        t         tpl.TemplateFinder
        log       *loggers.Logger
        allowRoot bool
}

func newAliasHandler(t tpl.TemplateFinder, l *loggers.Logger, allowRoot bool) aliasHandler <span class="cov8" title="1">{
        return aliasHandler{t, l, allowRoot}
}</span>

type aliasPage struct {
        Permalink string
        page.Page
}

func (a aliasHandler) renderAlias(isXHTML bool, permalink string, p page.Page) (io.Reader, error) <span class="cov8" title="1">{
        t := "alias"
        if isXHTML </span><span class="cov0" title="0">{
                t = "alias-xhtml"
        }</span>

        <span class="cov8" title="1">var templ tpl.Template
        var found bool

        if a.t != nil </span><span class="cov8" title="1">{
                templ, found = a.t.Lookup("alias.html")
        }</span>

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                def := defaultAliasTemplates.Lookup(t)
                if def != nil </span><span class="cov8" title="1">{
                        templ = &amp;tpl.TemplateAdapter{Template: def}
                }</span>

        }
        <span class="cov8" title="1">data := aliasPage{
                permalink,
                p,
        }

        buffer := new(bytes.Buffer)
        err := templ.Execute(buffer, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return buffer, nil</span>
}

func (s *Site) writeDestAlias(path, permalink string, outputFormat output.Format, p page.Page) (err error) <span class="cov8" title="1">{
        return s.publishDestAlias(false, path, permalink, outputFormat, p)
}</span>

func (s *Site) publishDestAlias(allowRoot bool, path, permalink string, outputFormat output.Format, p page.Page) (err error) <span class="cov8" title="1">{
        handler := newAliasHandler(s.Tmpl, s.Log, allowRoot)

        isXHTML := strings.HasSuffix(path, ".xhtml")

        s.Log.DEBUG.Println("creating alias:", path, "redirecting to", permalink)

        targetPath, err := handler.targetPathAlias(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">aliasContent, err := handler.renderAlias(isXHTML, permalink, p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pd := publisher.Descriptor{
                Src:          aliasContent,
                TargetPath:   targetPath,
                StatCounter:  &amp;s.PathSpec.ProcessingStats.Aliases,
                OutputFormat: outputFormat,
        }

        return s.publisher.Publish(pd)</span>

}

func (a aliasHandler) targetPathAlias(src string) (string, error) <span class="cov8" title="1">{
        originalAlias := src
        if len(src) &lt;= 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("alias \"\" is an empty string")
        }</span>

        <span class="cov8" title="1">alias := path.Clean(filepath.ToSlash(src))

        if !a.allowRoot &amp;&amp; alias == "/" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("alias \"%s\" resolves to website root directory", originalAlias)
        }</span>

        <span class="cov8" title="1">components := strings.Split(alias, "/")

        // Validate against directory traversal
        if components[0] == ".." </span><span class="cov0" title="0">{
                return "", fmt.Errorf("alias \"%s\" traverses outside the website root directory", originalAlias)
        }</span>

        // Handle Windows file and directory naming restrictions
        // See "Naming Files, Paths, and Namespaces" on MSDN
        // https://msdn.microsoft.com/en-us/library/aa365247%28v=VS.85%29.aspx?f=255&amp;MSPPError=-2147217396
        <span class="cov8" title="1">msgs := []string{}
        reservedNames := []string{"CON", "PRN", "AUX", "NUL", "COM0", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "LPT0", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9"}

        if strings.ContainsAny(alias, ":*?\"&lt;&gt;|") </span><span class="cov0" title="0">{
                msgs = append(msgs, fmt.Sprintf("Alias \"%s\" contains invalid characters on Windows: : * ? \" &lt; &gt; |", originalAlias))
        }</span>
        <span class="cov8" title="1">for _, ch := range alias </span><span class="cov8" title="1">{
                if ch &lt; ' ' </span><span class="cov0" title="0">{
                        msgs = append(msgs, fmt.Sprintf("Alias \"%s\" contains ASCII control code (0x00 to 0x1F), invalid on Windows: : * ? \" &lt; &gt; |", originalAlias))
                        continue</span>
                }
        }
        <span class="cov8" title="1">for _, comp := range components </span><span class="cov8" title="1">{
                if strings.HasSuffix(comp, " ") || strings.HasSuffix(comp, ".") </span><span class="cov0" title="0">{
                        msgs = append(msgs, fmt.Sprintf("Alias \"%s\" contains component with a trailing space or period, problematic on Windows", originalAlias))
                }</span>
                <span class="cov8" title="1">for _, r := range reservedNames </span><span class="cov8" title="1">{
                        if comp == r </span><span class="cov0" title="0">{
                                msgs = append(msgs, fmt.Sprintf("Alias \"%s\" contains component with reserved name \"%s\" on Windows", originalAlias, r))
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(msgs) &gt; 0 </span><span class="cov0" title="0">{
                if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                        for _, m := range msgs </span><span class="cov0" title="0">{
                                a.log.ERROR.Println(m)
                        }</span>
                        <span class="cov0" title="0">return "", fmt.Errorf("cannot create \"%s\": Windows filename restriction", originalAlias)</span>
                }
                <span class="cov0" title="0">for _, m := range msgs </span><span class="cov0" title="0">{
                        a.log.INFO.Println(m)
                }</span>
        }

        // Add the final touch
        <span class="cov8" title="1">alias = strings.TrimPrefix(alias, "/")
        if strings.HasSuffix(alias, "/") </span><span class="cov0" title="0">{
                alias = alias + "index.html"
        }</span> else<span class="cov8" title="1"> if !strings.HasSuffix(alias, ".html") </span><span class="cov0" title="0">{
                alias = alias + "/" + "index.html"
        }</span>

        <span class="cov8" title="1">return filepath.FromSlash(alias), nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/gohugoio/hugo/common/collections"
        "github.com/gohugoio/hugo/resources/page"
)

var (
        _ collections.Grouper = (*pageState)(nil)
        _ collections.Slicer  = (*pageState)(nil)
)

// collections.Slicer implementations below. We keep these bridge implementations
// here as it makes it easier to get an idea of "type coverage". These
// implementations have no value on their own.

// Slice is not meant to be used externally. It's a bridge function
// for the template functions. See collections.Slice.
func (p *pageState) Slice(items interface{}) (interface{}, error) <span class="cov0" title="0">{
        return page.ToPages(items)
}</span>

// collections.Grouper  implementations below

// Group creates a PageGroup from a key and a Pages object
// This method is not meant for external use. It got its non-typed arguments to satisfy
// a very generic interface in the tpl package.
func (p *pageState) Group(key interface{}, in interface{}) (interface{}, error) <span class="cov0" title="0">{
        pages, err := page.ToPages(in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return page.PageGroup{Key: key, Pages: pages}, nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "os"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/gohugoio/hugo/cache/filecache"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/hugolib/paths"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/modules"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/config/privacy"
        "github.com/gohugoio/hugo/config/services"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/afero"
        "github.com/spf13/viper"
)

// SiteConfig represents the config in .Site.Config.
type SiteConfig struct {
        // This contains all privacy related settings that can be used to
        // make the YouTube template etc. GDPR compliant.
        Privacy privacy.Config

        // Services contains config for services such as Google Analytics etc.
        Services services.Config
}

func loadSiteConfig(cfg config.Provider) (scfg SiteConfig, err error) <span class="cov8" title="1">{
        privacyConfig, err := privacy.DecodeConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">servicesConfig, err := services.DecodeConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">scfg.Privacy = privacyConfig
        scfg.Services = servicesConfig

        return</span>
}

// ConfigSourceDescriptor describes where to find the config (e.g. config.toml etc.).
type ConfigSourceDescriptor struct {
        Fs     afero.Fs
        Logger *loggers.Logger

        // Path to the config file to use, e.g. /my/project/config.toml
        Filename string

        // The path to the directory to look for configuration. Is used if Filename is not
        // set or if it is set to a relative filename.
        Path string

        // The project's working dir. Is used to look for additional theme config.
        WorkingDir string

        // The (optional) directory for additional configuration files.
        AbsConfigDir string

        // production, development
        Environment string

        // Defaults to os.Environ if not set.
        Environ []string
}

func (d ConfigSourceDescriptor) configFilenames() []string <span class="cov8" title="1">{
        if d.Filename == "" </span><span class="cov0" title="0">{
                return []string{"config"}
        }</span>
        <span class="cov8" title="1">return strings.Split(d.Filename, ",")</span>
}

func (d ConfigSourceDescriptor) configFileDir() string <span class="cov8" title="1">{
        if d.Path != "" </span><span class="cov8" title="1">{
                return d.Path
        }</span>
        <span class="cov0" title="0">return d.WorkingDir</span>
}

// LoadConfigDefault is a convenience method to load the default "config.toml" config.
func LoadConfigDefault(fs afero.Fs) (*viper.Viper, error) <span class="cov0" title="0">{
        v, _, err := LoadConfig(ConfigSourceDescriptor{Fs: fs, Filename: "config.toml"})
        return v, err
}</span>

var ErrNoConfigFile = errors.New("Unable to locate config file or config directory. Perhaps you need to create a new site.\n       Run `hugo help new` for details.\n")

// LoadConfig loads Hugo configuration into a new Viper and then adds
// a set of defaults.
func LoadConfig(d ConfigSourceDescriptor, doWithConfig ...func(cfg config.Provider) error) (*viper.Viper, []string, error) <span class="cov8" title="1">{

        if d.Environment == "" </span><span class="cov0" title="0">{
                d.Environment = hugo.EnvironmentProduction
        }</span>

        <span class="cov8" title="1">if len(d.Environ) == 0 </span><span class="cov0" title="0">{
                d.Environ = os.Environ()
        }</span>

        <span class="cov8" title="1">var configFiles []string

        v := viper.New()
        l := configLoader{ConfigSourceDescriptor: d}

        for _, name := range d.configFilenames() </span><span class="cov8" title="1">{
                var filename string
                filename, err := l.loadConfig(name, v)
                if err == nil </span><span class="cov8" title="1">{
                        configFiles = append(configFiles, filename)
                }</span> else<span class="cov0" title="0"> if err != ErrNoConfigFile </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }

        <span class="cov8" title="1">if d.AbsConfigDir != "" </span><span class="cov8" title="1">{
                dirnames, err := l.loadConfigFromConfigDir(v)
                if err == nil </span><span class="cov8" title="1">{
                        configFiles = append(configFiles, dirnames...)
                }</span> else<span class="cov0" title="0"> if err != ErrNoConfigFile </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }

        <span class="cov8" title="1">if err := loadDefaultSettingsFor(v); err != nil </span><span class="cov0" title="0">{
                return v, configFiles, err
        }</span>

        // We create languages based on the settings, so we need to make sure that
        // all configuration is loaded/set before doing that.
        <span class="cov8" title="1">for _, d := range doWithConfig </span><span class="cov8" title="1">{
                if err := d(v); err != nil </span><span class="cov0" title="0">{
                        return v, configFiles, err
                }</span>
        }

        // Apply environment overrides
        <span class="cov8" title="1">if len(d.Environ) &gt; 0 </span><span class="cov8" title="1">{
                // Extract all that start with the HUGO_ prefix
                const hugoEnvPrefix = "HUGO_"
                var hugoEnv []string
                for _, v := range d.Environ </span><span class="cov8" title="1">{
                        key, val := config.SplitEnvVar(v)
                        if strings.HasPrefix(key, hugoEnvPrefix) </span><span class="cov0" title="0">{
                                hugoEnv = append(hugoEnv, strings.ToLower(strings.TrimPrefix(key, hugoEnvPrefix)), val)
                        }</span>
                }

                <span class="cov8" title="1">if len(hugoEnv) &gt; 0 </span><span class="cov0" title="0">{
                        for i := 0; i &lt; len(hugoEnv); i += 2 </span><span class="cov0" title="0">{
                                key, valStr := strings.ToLower(hugoEnv[i]), hugoEnv[i+1]

                                existing, nestedKey, owner, err := maps.GetNestedParamFn(key, "_", v.Get)
                                if err != nil </span><span class="cov0" title="0">{
                                        return v, configFiles, err
                                }</span>

                                <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                                        val, err := metadecoders.Default.UnmarshalStringTo(valStr, existing)
                                        if err != nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">if owner != nil </span><span class="cov0" title="0">{
                                                owner[nestedKey] = val
                                        }</span> else<span class="cov0" title="0"> {
                                                v.Set(key, val)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        v.Set(key, valStr)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">modulesConfig, err := l.loadModulesConfig(v)
        if err != nil </span><span class="cov0" title="0">{
                return v, configFiles, err
        }</span>

        // Need to run these after the modules are loaded, but before
        // they are finalized.
        <span class="cov8" title="1">collectHook := func(m *modules.ModulesConfig) error </span><span class="cov8" title="1">{
                if err := loadLanguageSettings(v, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">mods := m.ActiveModules

                // Apply default project mounts.
                if err := modules.ApplyProjectConfigDefaults(v, mods[0]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">_, modulesConfigFiles, err := l.collectModules(modulesConfig, v, collectHook)
        if err != nil </span><span class="cov0" title="0">{
                return v, configFiles, err
        }</span>

        <span class="cov8" title="1">if len(modulesConfigFiles) &gt; 0 </span><span class="cov8" title="1">{
                configFiles = append(configFiles, modulesConfigFiles...)
        }</span>

        <span class="cov8" title="1">return v, configFiles, nil</span>

}

func loadLanguageSettings(cfg config.Provider, oldLangs langs.Languages) error <span class="cov8" title="1">{
        _, err := langs.LoadLanguageSettings(cfg, oldLangs)
        return err
}</span>

type configLoader struct {
        ConfigSourceDescriptor
}

func (l configLoader) loadConfig(configName string, v *viper.Viper) (string, error) <span class="cov8" title="1">{
        baseDir := l.configFileDir()
        var baseFilename string
        if filepath.IsAbs(configName) </span><span class="cov0" title="0">{
                baseFilename = configName
        }</span> else<span class="cov8" title="1"> {
                baseFilename = filepath.Join(baseDir, configName)
        }</span>

        <span class="cov8" title="1">var filename string
        if helpers.ExtNoDelimiter(configName) != "" </span><span class="cov8" title="1">{
                exists, _ := helpers.Exists(baseFilename, l.Fs)
                if exists </span><span class="cov8" title="1">{
                        filename = baseFilename
                }</span>
        } else<span class="cov0" title="0"> {
                for _, ext := range config.ValidConfigFileExtensions </span><span class="cov0" title="0">{
                        filenameToCheck := baseFilename + "." + ext
                        exists, _ := helpers.Exists(filenameToCheck, l.Fs)
                        if exists </span><span class="cov0" title="0">{
                                filename = filenameToCheck
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if filename == "" </span><span class="cov0" title="0">{
                return "", ErrNoConfigFile
        }</span>

        <span class="cov8" title="1">m, err := config.FromFileToMap(l.Fs, filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", l.wrapFileError(err, filename)
        }</span>

        <span class="cov8" title="1">if err = v.MergeConfigMap(m); err != nil </span><span class="cov0" title="0">{
                return "", l.wrapFileError(err, filename)
        }</span>

        <span class="cov8" title="1">return filename, nil</span>

}

func (l configLoader) wrapFileError(err error, filename string) error <span class="cov0" title="0">{
        err, _ = herrors.WithFileContextForFile(
                err,
                filename,
                filename,
                l.Fs,
                herrors.SimpleLineMatcher)
        return err
}</span>

func (l configLoader) loadConfigFromConfigDir(v *viper.Viper) ([]string, error) <span class="cov8" title="1">{
        sourceFs := l.Fs
        configDir := l.AbsConfigDir

        if _, err := sourceFs.Stat(configDir); err != nil </span><span class="cov0" title="0">{
                // Config dir does not exist.
                return nil, nil
        }</span>

        <span class="cov8" title="1">defaultConfigDir := filepath.Join(configDir, "_default")
        environmentConfigDir := filepath.Join(configDir, l.Environment)

        var configDirs []string
        // Merge from least to most specific.
        for _, dir := range []string{defaultConfigDir, environmentConfigDir} </span><span class="cov8" title="1">{
                if _, err := sourceFs.Stat(dir); err == nil </span><span class="cov0" title="0">{
                        configDirs = append(configDirs, dir)
                }</span>
        }

        <span class="cov8" title="1">if len(configDirs) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // Keep track of these so we can watch them for changes.
        <span class="cov0" title="0">var dirnames []string

        for _, configDir := range configDirs </span><span class="cov0" title="0">{
                err := afero.Walk(sourceFs, configDir, func(path string, fi os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if fi == nil || err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                                dirnames = append(dirnames, path)
                                return nil
                        }</span>

                        <span class="cov0" title="0">if !config.IsValidConfigFilename(path) </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">name := helpers.Filename(filepath.Base(path))

                        item, err := metadecoders.Default.UnmarshalFileToMap(sourceFs, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return l.wrapFileError(err, path)
                        }</span>

                        <span class="cov0" title="0">var keyPath []string

                        if name != "config" </span><span class="cov0" title="0">{
                                // Can be params.jp, menus.en etc.
                                name, lang := helpers.FileAndExtNoDelimiter(name)

                                keyPath = []string{name}

                                if lang != "" </span><span class="cov0" title="0">{
                                        keyPath = []string{"languages", lang}
                                        switch name </span>{
                                        case "menu", "menus":<span class="cov0" title="0">
                                                keyPath = append(keyPath, "menus")</span>
                                        case "params":<span class="cov0" title="0">
                                                keyPath = append(keyPath, "params")</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">root := item
                        if len(keyPath) &gt; 0 </span><span class="cov0" title="0">{
                                root = make(map[string]interface{})
                                m := root
                                for i, key := range keyPath </span><span class="cov0" title="0">{
                                        if i &gt;= len(keyPath)-1 </span><span class="cov0" title="0">{
                                                m[key] = item
                                        }</span> else<span class="cov0" title="0"> {
                                                nm := make(map[string]interface{})
                                                m[key] = nm
                                                m = nm
                                        }</span>
                                }
                        }

                        // Migrate menu =&gt; menus etc.
                        <span class="cov0" title="0">config.RenameKeys(root)

                        if err := v.MergeConfigMap(root); err != nil </span><span class="cov0" title="0">{
                                return l.wrapFileError(err, path)
                        }</span>

                        <span class="cov0" title="0">return nil</span>

                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        }

        <span class="cov0" title="0">return dirnames, nil</span>
}

func (l configLoader) loadModulesConfig(v1 *viper.Viper) (modules.Config, error) <span class="cov8" title="1">{

        modConfig, err := modules.DecodeConfig(v1)
        if err != nil </span><span class="cov0" title="0">{
                return modules.Config{}, err
        }</span>

        <span class="cov8" title="1">return modConfig, nil</span>
}

func (l configLoader) collectModules(modConfig modules.Config, v1 *viper.Viper, hookBeforeFinalize func(m *modules.ModulesConfig) error) (modules.Modules, []string, error) <span class="cov8" title="1">{
        workingDir := l.WorkingDir
        if workingDir == "" </span><span class="cov0" title="0">{
                workingDir = v1.GetString("workingDir")
        }</span>

        <span class="cov8" title="1">themesDir := paths.AbsPathify(l.WorkingDir, v1.GetString("themesDir"))

        ignoreVendor := v1.GetBool("ignoreVendor")

        filecacheConfigs, err := filecache.DecodeConfig(l.Fs, v1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">v1.Set("filecacheConfigs", filecacheConfigs)

        var configFilenames []string

        hook := func(m *modules.ModulesConfig) error </span><span class="cov8" title="1">{
                for _, tc := range m.ActiveModules </span><span class="cov8" title="1">{
                        if tc.ConfigFilename() != "" </span><span class="cov0" title="0">{
                                if tc.Watch() </span><span class="cov0" title="0">{
                                        configFilenames = append(configFilenames, tc.ConfigFilename())
                                }</span>
                                <span class="cov0" title="0">if err := l.applyThemeConfig(v1, tc); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov8" title="1">if hookBeforeFinalize != nil </span><span class="cov8" title="1">{
                        return hookBeforeFinalize(m)
                }</span>

                <span class="cov0" title="0">return nil</span>

        }

        <span class="cov8" title="1">modulesClient := modules.NewClient(modules.ClientConfig{
                Fs:                 l.Fs,
                Logger:             l.Logger,
                HookBeforeFinalize: hook,
                WorkingDir:         workingDir,
                ThemesDir:          themesDir,
                CacheDir:           filecacheConfigs.CacheDirModules(),
                ModuleConfig:       modConfig,
                IgnoreVendor:       ignoreVendor,
        })

        v1.Set("modulesClient", modulesClient)

        moduleConfig, err := modulesClient.Collect()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Avoid recreating these later.
        <span class="cov8" title="1">v1.Set("allModules", moduleConfig.ActiveModules)

        if moduleConfig.GoModulesFilename != "" </span><span class="cov8" title="1">{
                // We want to watch this for changes and trigger rebuild on version
                // changes etc.
                configFilenames = append(configFilenames, moduleConfig.GoModulesFilename)
        }</span>

        <span class="cov8" title="1">return moduleConfig.ActiveModules, configFilenames, nil</span>

}

func (l configLoader) applyThemeConfig(v1 *viper.Viper, theme modules.Module) error <span class="cov0" title="0">{

        const (
                paramsKey    = "params"
                languagesKey = "languages"
                menuKey      = "menus"
        )

        v2 := theme.Cfg()

        for _, key := range []string{paramsKey, "outputformats", "mediatypes"} </span><span class="cov0" title="0">{
                l.mergeStringMapKeepLeft("", key, v1, v2)
        }</span>

        // Only add params and new menu entries, we do not add language definitions.
        <span class="cov0" title="0">if v1.IsSet(languagesKey) &amp;&amp; v2.IsSet(languagesKey) </span><span class="cov0" title="0">{
                v1Langs := v1.GetStringMap(languagesKey)
                for k := range v1Langs </span><span class="cov0" title="0">{
                        langParamsKey := languagesKey + "." + k + "." + paramsKey
                        l.mergeStringMapKeepLeft(paramsKey, langParamsKey, v1, v2)
                }</span>
                <span class="cov0" title="0">v2Langs := v2.GetStringMap(languagesKey)
                for k := range v2Langs </span><span class="cov0" title="0">{
                        if k == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">langMenuKey := languagesKey + "." + k + "." + menuKey
                        if v2.IsSet(langMenuKey) </span><span class="cov0" title="0">{
                                // Only add if not in the main config.
                                v2menus := v2.GetStringMap(langMenuKey)
                                for k, v := range v2menus </span><span class="cov0" title="0">{
                                        menuEntry := menuKey + "." + k
                                        menuLangEntry := langMenuKey + "." + k
                                        if !v1.IsSet(menuEntry) &amp;&amp; !v1.IsSet(menuLangEntry) </span><span class="cov0" title="0">{
                                                v1.Set(menuLangEntry, v)
                                        }</span>
                                }
                        }
                }
        }

        // Add menu definitions from theme not found in project
        <span class="cov0" title="0">if v2.IsSet(menuKey) </span><span class="cov0" title="0">{
                v2menus := v2.GetStringMap(menuKey)
                for k, v := range v2menus </span><span class="cov0" title="0">{
                        menuEntry := menuKey + "." + k
                        if !v1.IsSet(menuEntry) </span><span class="cov0" title="0">{
                                v1.SetDefault(menuEntry, v)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>

}

func (configLoader) mergeStringMapKeepLeft(rootKey, key string, v1, v2 config.Provider) <span class="cov0" title="0">{
        if !v2.IsSet(key) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if !v1.IsSet(key) &amp;&amp; !(rootKey != "" &amp;&amp; rootKey != key &amp;&amp; v1.IsSet(rootKey)) </span><span class="cov0" title="0">{
                v1.Set(key, v2.Get(key))
                return
        }</span>

        <span class="cov0" title="0">m1 := v1.GetStringMap(key)
        m2 := v2.GetStringMap(key)

        for k, v := range m2 </span><span class="cov0" title="0">{
                if _, found := m1[k]; !found </span><span class="cov0" title="0">{
                        if rootKey != "" &amp;&amp; v1.IsSet(rootKey+"."+k) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">m1[k] = v</span>
                }
        }
}

func loadDefaultSettingsFor(v *viper.Viper) error <span class="cov8" title="1">{

        c, err := helpers.NewContentSpec(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">v.RegisterAlias("indexes", "taxonomies")

        /*

                TODO(bep) from 0.56 these are configured as module mounts.
                        v.SetDefault("contentDir", "content")
                        v.SetDefault("layoutDir", "layouts")
                        v.SetDefault("assetDir", "assets")
                        v.SetDefault("staticDir", "static")
                        v.SetDefault("dataDir", "data")
                        v.SetDefault("i18nDir", "i18n")
                        v.SetDefault("archetypeDir", "archetypes")
        */

        v.SetDefault("cleanDestinationDir", false)
        v.SetDefault("watch", false)
        v.SetDefault("resourceDir", "resources")
        v.SetDefault("publishDir", "public")
        v.SetDefault("themesDir", "themes")
        v.SetDefault("buildDrafts", false)
        v.SetDefault("buildFuture", false)
        v.SetDefault("buildExpired", false)
        v.SetDefault("environment", hugo.EnvironmentProduction)
        v.SetDefault("uglyURLs", false)
        v.SetDefault("verbose", false)
        v.SetDefault("ignoreCache", false)
        v.SetDefault("canonifyURLs", false)
        v.SetDefault("relativeURLs", false)
        v.SetDefault("removePathAccents", false)
        v.SetDefault("titleCaseStyle", "AP")
        v.SetDefault("taxonomies", map[string]string{"tag": "tags", "category": "categories"})
        v.SetDefault("permalinks", make(map[string]string))
        v.SetDefault("sitemap", config.Sitemap{Priority: -1, Filename: "sitemap.xml"})
        v.SetDefault("pygmentsStyle", "monokai")
        v.SetDefault("pygmentsUseClasses", false)
        v.SetDefault("pygmentsCodeFences", false)
        v.SetDefault("pygmentsUseClassic", false)
        v.SetDefault("pygmentsOptions", "")
        v.SetDefault("disableLiveReload", false)
        v.SetDefault("pluralizeListTitles", true)
        v.SetDefault("forceSyncStatic", false)
        v.SetDefault("footnoteAnchorPrefix", "")
        v.SetDefault("footnoteReturnLinkContents", "")
        v.SetDefault("newContentEditor", "")
        v.SetDefault("paginate", 10)
        v.SetDefault("paginatePath", "page")
        v.SetDefault("summaryLength", 70)
        v.SetDefault("blackfriday", c.BlackFriday)
        v.SetDefault("rssLimit", -1)
        v.SetDefault("sectionPagesMenu", "")
        v.SetDefault("disablePathToLower", false)
        v.SetDefault("hasCJKLanguage", false)
        v.SetDefault("enableEmoji", false)
        v.SetDefault("pygmentsCodeFencesGuessSyntax", false)
        v.SetDefault("defaultContentLanguage", "en")
        v.SetDefault("defaultContentLanguageInSubdir", false)
        v.SetDefault("enableMissingTranslationPlaceholders", false)
        v.SetDefault("enableGitInfo", false)
        v.SetDefault("ignoreFiles", make([]string, 0))
        v.SetDefault("disableAliases", false)
        v.SetDefault("debug", false)
        v.SetDefault("disableFastRender", false)
        v.SetDefault("timeout", 15000) // 15 seconds
        v.SetDefault("enableInlineShortcodes", false)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "strings"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/source"
)

// fileInfo implements the File and ReadableFile interface.
var (
        _ source.File = (*fileInfo)(nil)
)

type fileInfo struct {
        source.File

        overriddenLang string
}

func (fi *fileInfo) Open() (afero.File, error) <span class="cov0" title="0">{
        f, err := fi.FileInfo().Meta().Open()
        if err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, "fileInfo")
        }</span>

        <span class="cov0" title="0">return f, err</span>
}

func (fi *fileInfo) Lang() string <span class="cov0" title="0">{
        if fi.overriddenLang != "" </span><span class="cov0" title="0">{
                return fi.overriddenLang
        }</span>
        <span class="cov0" title="0">return fi.File.Lang()</span>
}

func (fi *fileInfo) String() string <span class="cov0" title="0">{
        if fi == nil || fi.File == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return fi.Path()</span>
}

// TODO(bep) rename
func newFileInfo(sp *source.SourceSpec, fi hugofs.FileMetaInfo) (*fileInfo, error) <span class="cov8" title="1">{

        baseFi, err := sp.NewFileInfo(fi)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">f := &amp;fileInfo{
                File: baseFi,
        }

        return f, nil</span>

}

type bundleDirType int

const (
        bundleNot bundleDirType = iota

        // All from here are bundles in one form or another.
        bundleLeaf
        bundleBranch
)

// Returns the given file's name's bundle type and whether it is a content
// file or not.
func classifyBundledFile(name string) (bundleDirType, bool) <span class="cov0" title="0">{
        if !files.IsContentFile(name) </span><span class="cov0" title="0">{
                return bundleNot, false
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(name, "_index.") </span><span class="cov0" title="0">{
                return bundleBranch, true
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(name, "index.") </span><span class="cov0" title="0">{
                return bundleLeaf, true
        }</span>

        <span class="cov0" title="0">return bundleNot, true</span>
}

func (b bundleDirType) String() string <span class="cov0" title="0">{
        switch b </span>{
        case bundleNot:<span class="cov0" title="0">
                return "Not a bundle"</span>
        case bundleLeaf:<span class="cov0" title="0">
                return "Regular bundle"</span>
        case bundleBranch:<span class="cov0" title="0">
                return "Branch bundle"</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package filesystems provides the fine grained file systems used by Hugo. These
// are typically virtual filesystems that are composites of project and theme content.
package filesystems

import (
        "io"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/modules"

        "github.com/gohugoio/hugo/hugofs"

        "fmt"

        "github.com/gohugoio/hugo/hugolib/paths"
        "github.com/spf13/afero"
)

var filePathSeparator = string(filepath.Separator)

// BaseFs contains the core base filesystems used by Hugo. The name "base" is used
// to underline that even if they can be composites, they all have a base path set to a specific
// resource folder, e.g "/my-project/content". So, no absolute filenames needed.
type BaseFs struct {

        // SourceFilesystems contains the different source file systems.
        *SourceFilesystems

        // The filesystem used to publish the rendered site.
        // This usually maps to /my-project/public.
        PublishFs afero.Fs

        theBigFs *filesystemsCollector
}

func (fs *BaseFs) WatchDirs() []hugofs.FileMetaInfo <span class="cov0" title="0">{
        var dirs []hugofs.FileMetaInfo
        for _, dir := range fs.AllDirs() </span><span class="cov0" title="0">{
                if dir.Meta().Watch() </span><span class="cov0" title="0">{
                        dirs = append(dirs, dir)
                }</span>
        }

        <span class="cov0" title="0">return dirs</span>
}

func (fs *BaseFs) AllDirs() []hugofs.FileMetaInfo <span class="cov0" title="0">{
        var dirs []hugofs.FileMetaInfo
        for _, dirSet := range [][]hugofs.FileMetaInfo{
                fs.Archetypes.Dirs,
                fs.I18n.Dirs,
                fs.Data.Dirs,
                fs.Content.Dirs,
                fs.Assets.Dirs,
                fs.Layouts.Dirs,
                //fs.Resources.Dirs,
                fs.StaticDirs,
        } </span><span class="cov0" title="0">{
                dirs = append(dirs, dirSet...)
        }</span>

        <span class="cov0" title="0">return dirs</span>
}

// RelContentDir tries to create a path relative to the content root from
// the given filename. The return value is the path and language code.
func (b *BaseFs) RelContentDir(filename string) string <span class="cov0" title="0">{
        for _, dir := range b.SourceFilesystems.Content.Dirs </span><span class="cov0" title="0">{
                dirname := dir.Meta().Filename()
                if strings.HasPrefix(filename, dirname) </span><span class="cov0" title="0">{
                        rel := strings.TrimPrefix(filename, dirname)
                        return strings.TrimPrefix(rel, filePathSeparator)
                }</span>
        }
        // Either not a content dir or already relative.
        <span class="cov0" title="0">return filename</span>
}

// SourceFilesystems contains the different source file systems. These can be
// composite file systems (theme and project etc.), and they have all root
// set to the source type the provides: data, i18n, static, layouts.
type SourceFilesystems struct {
        Content    *SourceFilesystem
        Data       *SourceFilesystem
        I18n       *SourceFilesystem
        Layouts    *SourceFilesystem
        Archetypes *SourceFilesystem
        Assets     *SourceFilesystem

        // Writable filesystem on top the project's resources directory,
        // with any sub module's resource fs layered below.
        ResourcesCache afero.Fs

        // The project folder.
        Work afero.Fs

        // When in multihost we have one static filesystem per language. The sync
        // static files is currently done outside of the Hugo build (where there is
        // a concept of a site per language).
        // When in non-multihost mode there will be one entry in this map with a blank key.
        Static map[string]*SourceFilesystem

        // All the /static dirs (including themes/modules).
        StaticDirs []hugofs.FileMetaInfo
}

// A SourceFilesystem holds the filesystem for a given source type in Hugo (data,
// i18n, layouts, static) and additional metadata to be able to use that filesystem
// in server mode.
type SourceFilesystem struct {
        // This is a virtual composite filesystem. It expects path relative to a context.
        Fs afero.Fs

        // This filesystem as separate root directories, starting from project and down
        // to the themes/modules.
        Dirs []hugofs.FileMetaInfo

        // When syncing a source folder to the target (e.g. /public), this may
        // be set to publish into a subfolder. This is used for static syncing
        // in multihost mode.
        PublishFolder string
}

// ContentStaticAssetFs will create a new composite filesystem from the content,
// static, and asset filesystems. The site language is needed to pick the correct static filesystem.
// The order is content, static and then assets.
// TODO(bep) check usage
func (s SourceFilesystems) ContentStaticAssetFs(lang string) afero.Fs <span class="cov0" title="0">{
        staticFs := s.StaticFs(lang)

        base := afero.NewCopyOnWriteFs(s.Assets.Fs, staticFs)
        return afero.NewCopyOnWriteFs(base, s.Content.Fs)

}</span>

// StaticFs returns the static filesystem for the given language.
// This can be a composite filesystem.
func (s SourceFilesystems) StaticFs(lang string) afero.Fs <span class="cov0" title="0">{
        var staticFs afero.Fs = hugofs.NoOpFs

        if fs, ok := s.Static[lang]; ok </span><span class="cov0" title="0">{
                staticFs = fs.Fs
        }</span> else<span class="cov0" title="0"> if fs, ok := s.Static[""]; ok </span><span class="cov0" title="0">{
                staticFs = fs.Fs
        }</span>

        <span class="cov0" title="0">return staticFs</span>
}

// StatResource looks for a resource in these filesystems in order: static, assets and finally content.
// If found in any of them, it returns FileInfo and the relevant filesystem.
// Any non os.IsNotExist error will be returned.
// An os.IsNotExist error wil be returned only if all filesystems return such an error.
// Note that if we only wanted to find the file, we could create a composite Afero fs,
// but we also need to know which filesystem root it lives in.
func (s SourceFilesystems) StatResource(lang, filename string) (fi os.FileInfo, fs afero.Fs, err error) <span class="cov0" title="0">{
        for _, fsToCheck := range []afero.Fs{s.StaticFs(lang), s.Assets.Fs, s.Content.Fs} </span><span class="cov0" title="0">{
                fs = fsToCheck
                fi, err = fs.Stat(filename)
                if err == nil || !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        // Not found.
        <span class="cov0" title="0">return</span>
}

// IsStatic returns true if the given filename is a member of one of the static
// filesystems.
func (s SourceFilesystems) IsStatic(filename string) bool <span class="cov0" title="0">{
        for _, staticFs := range s.Static </span><span class="cov0" title="0">{
                if staticFs.Contains(filename) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsContent returns true if the given filename is a member of the content filesystem.
func (s SourceFilesystems) IsContent(filename string) bool <span class="cov0" title="0">{
        return s.Content.Contains(filename)
}</span>

// IsLayout returns true if the given filename is a member of the layouts filesystem.
func (s SourceFilesystems) IsLayout(filename string) bool <span class="cov0" title="0">{
        return s.Layouts.Contains(filename)
}</span>

// IsData returns true if the given filename is a member of the data filesystem.
func (s SourceFilesystems) IsData(filename string) bool <span class="cov0" title="0">{
        return s.Data.Contains(filename)
}</span>

// IsAsset returns true if the given filename is a member of the asset filesystem.
func (s SourceFilesystems) IsAsset(filename string) bool <span class="cov0" title="0">{
        return s.Assets.Contains(filename)
}</span>

// IsI18n returns true if the given filename is a member of the i18n filesystem.
func (s SourceFilesystems) IsI18n(filename string) bool <span class="cov0" title="0">{
        return s.I18n.Contains(filename)
}</span>

// MakeStaticPathRelative makes an absolute static filename into a relative one.
// It will return an empty string if the filename is not a member of a static filesystem.
func (s SourceFilesystems) MakeStaticPathRelative(filename string) string <span class="cov0" title="0">{
        for _, staticFs := range s.Static </span><span class="cov0" title="0">{
                rel := staticFs.MakePathRelative(filename)
                if rel != "" </span><span class="cov0" title="0">{
                        return rel
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// MakePathRelative creates a relative path from the given filename.
// It will return an empty string if the filename is not a member of this filesystem.
func (d *SourceFilesystem) MakePathRelative(filename string) string <span class="cov0" title="0">{
        for _, dir := range d.Dirs </span><span class="cov0" title="0">{
                meta := dir.(hugofs.FileMetaInfo).Meta()
                currentPath := meta.Filename()

                if strings.HasPrefix(filename, currentPath) </span><span class="cov0" title="0">{
                        rel := strings.TrimPrefix(filename, currentPath)
                        if mp := meta.Path(); mp != "" </span><span class="cov0" title="0">{
                                rel = filepath.Join(mp, rel)
                        }</span>
                        <span class="cov0" title="0">return strings.TrimPrefix(rel, filePathSeparator)</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func (d *SourceFilesystem) RealFilename(rel string) string <span class="cov0" title="0">{
        fi, err := d.Fs.Stat(rel)
        if err != nil </span><span class="cov0" title="0">{
                return rel
        }</span>
        <span class="cov0" title="0">if realfi, ok := fi.(hugofs.FileMetaInfo); ok </span><span class="cov0" title="0">{
                return realfi.Meta().Filename()
        }</span>

        <span class="cov0" title="0">return rel</span>
}

// Contains returns whether the given filename is a member of the current filesystem.
func (d *SourceFilesystem) Contains(filename string) bool <span class="cov0" title="0">{
        for _, dir := range d.Dirs </span><span class="cov0" title="0">{
                if strings.HasPrefix(filename, dir.Meta().Filename()) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// RealDirs gets a list of absolute paths to directories starting from the given
// path.
func (d *SourceFilesystem) RealDirs(from string) []string <span class="cov0" title="0">{
        var dirnames []string
        for _, dir := range d.Dirs </span><span class="cov0" title="0">{
                meta := dir.Meta()
                dirname := filepath.Join(meta.Filename(), from)
                _, err := meta.Fs().Stat(from)

                if err == nil </span><span class="cov0" title="0">{
                        dirnames = append(dirnames, dirname)
                }</span>
        }
        <span class="cov0" title="0">return dirnames</span>
}

// WithBaseFs allows reuse of some potentially expensive to create parts that remain
// the same across sites/languages.
func WithBaseFs(b *BaseFs) func(*BaseFs) error <span class="cov0" title="0">{
        return func(bb *BaseFs) error </span><span class="cov0" title="0">{
                bb.theBigFs = b.theBigFs
                bb.SourceFilesystems = b.SourceFilesystems
                return nil
        }</span>
}

// NewBase builds the filesystems used by Hugo given the paths and options provided.NewBase
func NewBase(p *paths.Paths, logger *loggers.Logger, options ...func(*BaseFs) error) (*BaseFs, error) <span class="cov8" title="1">{
        fs := p.Fs
        if logger == nil </span><span class="cov0" title="0">{
                logger = loggers.NewWarningLogger()
        }</span>

        <span class="cov8" title="1">publishFs := afero.NewBasePathFs(fs.Destination, p.AbsPublishDir)

        b := &amp;BaseFs{
                PublishFs: publishFs,
        }

        for _, opt := range options </span><span class="cov0" title="0">{
                if err := opt(b); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if b.theBigFs != nil &amp;&amp; b.SourceFilesystems != nil </span><span class="cov0" title="0">{
                return b, nil
        }</span>

        <span class="cov8" title="1">builder := newSourceFilesystemsBuilder(p, logger, b)
        sourceFilesystems, err := builder.Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "build filesystems")
        }</span>

        <span class="cov8" title="1">b.SourceFilesystems = sourceFilesystems
        b.theBigFs = builder.theBigFs

        return b, nil</span>
}

type sourceFilesystemsBuilder struct {
        logger   *loggers.Logger
        p        *paths.Paths
        sourceFs afero.Fs
        result   *SourceFilesystems
        theBigFs *filesystemsCollector
}

func newSourceFilesystemsBuilder(p *paths.Paths, logger *loggers.Logger, b *BaseFs) *sourceFilesystemsBuilder <span class="cov8" title="1">{
        sourceFs := hugofs.NewBaseFileDecorator(p.Fs.Source)
        return &amp;sourceFilesystemsBuilder{p: p, logger: logger, sourceFs: sourceFs, theBigFs: b.theBigFs, result: &amp;SourceFilesystems{}}
}</span>

func (b *sourceFilesystemsBuilder) newSourceFilesystem(fs afero.Fs, dirs []hugofs.FileMetaInfo) *SourceFilesystem <span class="cov8" title="1">{
        return &amp;SourceFilesystem{
                Fs:   fs,
                Dirs: dirs,
        }
}</span>
func (b *sourceFilesystemsBuilder) Build() (*SourceFilesystems, error) <span class="cov8" title="1">{

        if b.theBigFs == nil </span><span class="cov8" title="1">{

                theBigFs, err := b.createMainOverlayFs(b.p)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "create main fs")
                }</span>

                <span class="cov8" title="1">b.theBigFs = theBigFs</span>
        }

        <span class="cov8" title="1">createView := func(componentID string) *SourceFilesystem </span><span class="cov8" title="1">{
                if b.theBigFs == nil || b.theBigFs.overlayMounts == nil </span><span class="cov0" title="0">{
                        return b.newSourceFilesystem(hugofs.NoOpFs, nil)
                }</span>

                <span class="cov8" title="1">dirs := b.theBigFs.overlayDirs[componentID]

                return b.newSourceFilesystem(afero.NewBasePathFs(b.theBigFs.overlayMounts, componentID), dirs)</span>

        }

        <span class="cov8" title="1">b.theBigFs.finalizeDirs()

        b.result.Archetypes = createView(files.ComponentFolderArchetypes)
        b.result.Layouts = createView(files.ComponentFolderLayouts)
        b.result.Assets = createView(files.ComponentFolderAssets)
        b.result.ResourcesCache = b.theBigFs.overlayResources

        // Data, i18n and content cannot use the overlay fs
        dataDirs := b.theBigFs.overlayDirs[files.ComponentFolderData]
        dataFs, err := hugofs.NewSliceFs(dataDirs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">b.result.Data = b.newSourceFilesystem(dataFs, dataDirs)

        i18nDirs := b.theBigFs.overlayDirs[files.ComponentFolderI18n]
        i18nFs, err := hugofs.NewSliceFs(i18nDirs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">b.result.I18n = b.newSourceFilesystem(i18nFs, i18nDirs)

        contentDirs := b.theBigFs.overlayDirs[files.ComponentFolderContent]
        contentBfs := afero.NewBasePathFs(b.theBigFs.overlayMountsContent, files.ComponentFolderContent)

        contentFs, err := hugofs.NewLanguageFs(b.p.LanguagesDefaultFirst.AsOrdinalSet(), contentBfs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "create content filesystem")
        }</span>

        <span class="cov8" title="1">b.result.Content = b.newSourceFilesystem(contentFs, contentDirs)

        b.result.Work = afero.NewReadOnlyFs(b.theBigFs.overlayFull)

        // Create static filesystem(s)
        ms := make(map[string]*SourceFilesystem)
        b.result.Static = ms
        b.result.StaticDirs = b.theBigFs.overlayDirs[files.ComponentFolderStatic]

        if b.theBigFs.staticPerLanguage != nil </span><span class="cov0" title="0">{
                // Multihost mode
                for k, v := range b.theBigFs.staticPerLanguage </span><span class="cov0" title="0">{
                        sfs := b.newSourceFilesystem(v, b.result.StaticDirs)
                        sfs.PublishFolder = k
                        ms[k] = sfs
                }</span>
        } else<span class="cov8" title="1"> {
                bfs := afero.NewBasePathFs(b.theBigFs.overlayMountsStatic, files.ComponentFolderStatic)
                ms[""] = b.newSourceFilesystem(bfs, b.result.StaticDirs)
        }</span>

        <span class="cov8" title="1">return b.result, nil</span>

}

func (b *sourceFilesystemsBuilder) createMainOverlayFs(p *paths.Paths) (*filesystemsCollector, error) <span class="cov8" title="1">{

        var staticFsMap map[string]afero.Fs
        if b.p.Cfg.GetBool("multihost") </span><span class="cov0" title="0">{
                staticFsMap = make(map[string]afero.Fs)
        }</span>

        <span class="cov8" title="1">collector := &amp;filesystemsCollector{
                sourceProject:     b.sourceFs,
                sourceModules:     hugofs.NewNoSymlinkFs(b.sourceFs, b.logger, false),
                overlayDirs:       make(map[string][]hugofs.FileMetaInfo),
                staticPerLanguage: staticFsMap,
        }

        mods := p.AllModules

        if len(mods) == 0 </span><span class="cov0" title="0">{
                return collector, nil
        }</span>

        <span class="cov8" title="1">modsReversed := make([]mountsDescriptor, len(mods))

        // The theme components are ordered from left to right.
        // We need to revert it to get the
        // overlay logic below working as expected, with the project on top.
        j := 0
        for i := len(mods) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                mod := mods[i]
                dir := mod.Dir()

                isMainProject := mod.Owner() == nil
                modsReversed[j] = mountsDescriptor{
                        Module:        mod,
                        dir:           dir,
                        isMainProject: isMainProject,
                }
                j++
        }</span>

        <span class="cov8" title="1">err := b.createOverlayFs(collector, modsReversed)

        return collector, err</span>

}

func (b *sourceFilesystemsBuilder) isContentMount(mnt modules.Mount) bool <span class="cov8" title="1">{
        return strings.HasPrefix(mnt.Target, files.ComponentFolderContent)
}</span>

func (b *sourceFilesystemsBuilder) isStaticMount(mnt modules.Mount) bool <span class="cov8" title="1">{
        return strings.HasPrefix(mnt.Target, files.ComponentFolderStatic)
}</span>

func (b *sourceFilesystemsBuilder) createModFs(
        collector *filesystemsCollector,
        md mountsDescriptor) error <span class="cov8" title="1">{

        var (
                fromTo        []hugofs.RootMapping
                fromToContent []hugofs.RootMapping
                fromToStatic  []hugofs.RootMapping
        )

        absPathify := func(path string) string </span><span class="cov8" title="1">{
                return paths.AbsPathify(md.dir, path)
        }</span>

        <span class="cov8" title="1">for _, mount := range md.Mounts() </span><span class="cov8" title="1">{

                mountWeight := 1
                if md.isMainProject </span><span class="cov8" title="1">{
                        mountWeight++
                }</span>

                <span class="cov8" title="1">rm := hugofs.RootMapping{
                        From: mount.Target,
                        To:   absPathify(mount.Source),
                        Meta: hugofs.FileMeta{
                                "watch":       md.Watch(),
                                "mountWeight": mountWeight,
                        },
                }

                isContentMount := b.isContentMount(mount)

                lang := mount.Lang
                if lang == "" &amp;&amp; isContentMount </span><span class="cov0" title="0">{
                        lang = b.p.DefaultContentLanguage
                }</span>

                <span class="cov8" title="1">rm.Meta["lang"] = lang

                if isContentMount </span><span class="cov8" title="1">{
                        fromToContent = append(fromToContent, rm)
                }</span> else<span class="cov8" title="1"> if b.isStaticMount(mount) </span><span class="cov8" title="1">{
                        fromToStatic = append(fromToStatic, rm)
                }</span> else<span class="cov8" title="1"> {
                        fromTo = append(fromTo, rm)
                }</span>
        }

        <span class="cov8" title="1">modBase := collector.sourceProject
        if !md.isMainProject </span><span class="cov8" title="1">{
                modBase = collector.sourceModules
        }</span>
        <span class="cov8" title="1">sourceStatic := hugofs.NewNoSymlinkFs(modBase, b.logger, true)

        rmfs, err := hugofs.NewRootMappingFs(modBase, fromTo...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rmfsContent, err := hugofs.NewRootMappingFs(modBase, fromToContent...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rmfsStatic, err := hugofs.NewRootMappingFs(sourceStatic, fromToStatic...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // We need to keep the ordered list of directories for watching and
        // some special merge operations (data, i18n).
        <span class="cov8" title="1">collector.addDirs(rmfs)
        collector.addDirs(rmfsContent)
        collector.addDirs(rmfsStatic)

        if collector.staticPerLanguage != nil </span><span class="cov0" title="0">{
                for _, l := range b.p.Languages </span><span class="cov0" title="0">{
                        lang := l.Lang

                        lfs := rmfsStatic.Filter(func(rm hugofs.RootMapping) bool </span><span class="cov0" title="0">{
                                rlang := rm.Meta.Lang()
                                return rlang == "" || rlang == lang
                        }</span>)

                        <span class="cov0" title="0">bfs := afero.NewBasePathFs(lfs, files.ComponentFolderStatic)

                        sfs, found := collector.staticPerLanguage[lang]
                        if found </span><span class="cov0" title="0">{
                                collector.staticPerLanguage[lang] = afero.NewCopyOnWriteFs(sfs, bfs)

                        }</span> else<span class="cov0" title="0"> {
                                collector.staticPerLanguage[lang] = bfs
                        }</span>
                }
        }

        <span class="cov8" title="1">getResourcesDir := func() string </span><span class="cov8" title="1">{
                if md.isMainProject </span><span class="cov8" title="1">{
                        return b.p.AbsResourcesDir
                }</span>
                <span class="cov8" title="1">return absPathify(files.FolderResources)</span>
        }

        <span class="cov8" title="1">if collector.overlayMounts == nil </span><span class="cov8" title="1">{
                collector.overlayMounts = rmfs
                collector.overlayMountsContent = rmfsContent
                collector.overlayMountsStatic = rmfsStatic
                collector.overlayFull = afero.NewBasePathFs(modBase, md.dir)
                collector.overlayResources = afero.NewBasePathFs(modBase, getResourcesDir())
        }</span> else<span class="cov8" title="1"> {

                collector.overlayMounts = afero.NewCopyOnWriteFs(collector.overlayMounts, rmfs)
                collector.overlayMountsContent = hugofs.NewLanguageCompositeFs(collector.overlayMountsContent, rmfsContent)
                collector.overlayMountsStatic = hugofs.NewLanguageCompositeFs(collector.overlayMountsStatic, rmfsStatic)
                collector.overlayFull = afero.NewCopyOnWriteFs(collector.overlayFull, afero.NewBasePathFs(modBase, md.dir))
                collector.overlayResources = afero.NewCopyOnWriteFs(collector.overlayResources, afero.NewBasePathFs(modBase, getResourcesDir()))
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func printFs(fs afero.Fs, path string, w io.Writer) <span class="cov0" title="0">{
        if fs == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">afero.Walk(fs, path, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">var filename string
                if fim, ok := info.(hugofs.FileMetaInfo); ok </span><span class="cov0" title="0">{
                        filename = fim.Meta().Filename()
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, "    %q %q\n", path, filename)
                return nil</span>
        })
}

type filesystemsCollector struct {
        sourceProject afero.Fs // Source for project folders
        sourceModules afero.Fs // Source for modules/themes

        overlayMounts        afero.Fs
        overlayMountsContent afero.Fs
        overlayMountsStatic  afero.Fs
        overlayFull          afero.Fs
        overlayResources     afero.Fs

        // Maps component type (layouts, static, content etc.) an ordered list of
        // directories representing the overlay filesystems above.
        overlayDirs map[string][]hugofs.FileMetaInfo

        // Set if in multihost mode
        staticPerLanguage map[string]afero.Fs

        finalizerInit sync.Once
}

func (c *filesystemsCollector) addDirs(rfs *hugofs.RootMappingFs) <span class="cov8" title="1">{
        for _, componentFolder := range files.ComponentFolders </span><span class="cov8" title="1">{
                dirs, err := rfs.Dirs(componentFolder)

                if err == nil </span><span class="cov8" title="1">{
                        c.overlayDirs[componentFolder] = append(c.overlayDirs[componentFolder], dirs...)
                }</span>
        }
}

func (c *filesystemsCollector) finalizeDirs() <span class="cov8" title="1">{
        c.finalizerInit.Do(func() </span><span class="cov8" title="1">{
                // Order the directories from top to bottom (project, theme a, theme ...).
                for _, dirs := range c.overlayDirs </span><span class="cov8" title="1">{
                        c.reverseFis(dirs)
                }</span>
        })

}

func (c *filesystemsCollector) reverseFis(fis []hugofs.FileMetaInfo) <span class="cov8" title="1">{
        for i := len(fis)/2 - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                opp := len(fis) - 1 - i
                fis[i], fis[opp] = fis[opp], fis[i]
        }</span>
}

type mountsDescriptor struct {
        modules.Module
        dir           string
        isMainProject bool
}

func (b *sourceFilesystemsBuilder) createOverlayFs(collector *filesystemsCollector, mounts []mountsDescriptor) error <span class="cov8" title="1">{
        if len(mounts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">err := b.createModFs(collector, mounts[0])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(mounts) == 1 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return b.createOverlayFs(collector, mounts[1:])</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "path/filepath"
        "strings"

        "github.com/bep/gitmap"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/resources/page"
)

type gitInfo struct {
        contentDir string
        repo       *gitmap.GitRepo
}

func (g *gitInfo) forPage(p page.Page) *gitmap.GitInfo <span class="cov0" title="0">{
        name := strings.TrimPrefix(filepath.ToSlash(p.File().Filename()), g.contentDir)
        name = strings.TrimPrefix(name, "/")

        return g.repo.Files[name]

}</span>

func newGitInfo(cfg config.Provider) (*gitInfo, error) <span class="cov0" title="0">{
        workingDir := cfg.GetString("workingDir")

        gitRepo, err := gitmap.Map(workingDir, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;gitInfo{contentDir: gitRepo.TopLevelAbsPath, repo: gitRepo}, nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "io"
        "path/filepath"
        "sort"
        "strings"
        "sync"

        radix "github.com/armon/go-radix"

        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/source"

        "github.com/bep/gitmap"
        "github.com/gohugoio/hugo/config"

        "github.com/gohugoio/hugo/publisher"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/lazy"

        "github.com/gohugoio/hugo/langs/i18n"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/tpl"
        "github.com/gohugoio/hugo/tpl/tplimpl"
)

// HugoSites represents the sites to build. Each site represents a language.
type HugoSites struct {
        Sites []*Site

        multilingual *Multilingual

        // Multihost is set if multilingual and baseURL set on the language level.
        multihost bool

        // If this is running in the dev server.
        running bool

        // Serializes rebuilds when server is running.
        runningMu sync.Mutex

        // Render output formats for all sites.
        renderFormats output.Formats

        *deps.Deps

        gitInfo *gitInfo

        // As loaded from the /data dirs
        data map[string]interface{}

        // Keeps track of bundle directories and symlinks to enable partial rebuilding.
        ContentChanges *contentChangeMap

        init *hugoSitesInit

        *fatalErrorHandler
}

type fatalErrorHandler struct {
        mu sync.Mutex

        h *HugoSites

        err error

        done  bool
        donec chan bool // will be closed when done
}

// FatalError error is used in some rare situations where it does not make sense to
// continue processing, to abort as soon as possible and log the error.
func (f *fatalErrorHandler) FatalError(err error) <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()
        if !f.done </span><span class="cov0" title="0">{
                f.done = true
                close(f.donec)
        }</span>
        <span class="cov0" title="0">f.err = err</span>
}

func (f *fatalErrorHandler) getErr() error <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()
        return f.err
}</span>

func (f *fatalErrorHandler) Done() &lt;-chan bool <span class="cov8" title="1">{
        return f.donec
}</span>

type hugoSitesInit struct {
        // Loads the data from all of the /data folders.
        data *lazy.Init

        // Loads the Git info for all the pages if enabled.
        gitInfo *lazy.Init

        // Maps page translations.
        translations *lazy.Init
}

func (h *hugoSitesInit) Reset() <span class="cov0" title="0">{
        h.data.Reset()
        h.gitInfo.Reset()
        h.translations.Reset()
}</span>

func (h *HugoSites) Data() map[string]interface{} <span class="cov8" title="1">{
        if _, err := h.init.data.Do(); err != nil </span><span class="cov0" title="0">{
                h.SendError(errors.Wrap(err, "failed to load data"))
                return nil
        }</span>
        <span class="cov8" title="1">return h.data</span>
}

func (h *HugoSites) gitInfoForPage(p page.Page) (*gitmap.GitInfo, error) <span class="cov8" title="1">{
        if _, err := h.init.gitInfo.Do(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if h.gitInfo == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return h.gitInfo.forPage(p), nil</span>
}

func (h *HugoSites) siteInfos() page.Sites <span class="cov0" title="0">{
        infos := make(page.Sites, len(h.Sites))
        for i, site := range h.Sites </span><span class="cov0" title="0">{
                infos[i] = &amp;site.Info
        }</span>
        <span class="cov0" title="0">return infos</span>
}

func (h *HugoSites) pickOneAndLogTheRest(errors []error) error <span class="cov8" title="1">{
        if len(errors) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var i int

        for j, err := range errors </span><span class="cov8" title="1">{
                // If this is in server mode, we want to return an error to the client
                // with a file context, if possible.
                if herrors.UnwrapErrorWithFileContext(err) != nil </span><span class="cov0" title="0">{
                        i = j
                        break</span>
                }
        }

        // Log the rest, but add a threshold to avoid flooding the log.
        <span class="cov8" title="1">const errLogThreshold = 5

        for j, err := range errors </span><span class="cov8" title="1">{
                if j == i || err == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov0" title="0">if j &gt;= errLogThreshold </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">h.Log.ERROR.Println(err)</span>
        }

        <span class="cov8" title="1">return errors[i]</span>
}

func (h *HugoSites) IsMultihost() bool <span class="cov8" title="1">{
        return h != nil &amp;&amp; h.multihost
}</span>

// TODO(bep) consolidate
func (h *HugoSites) LanguageSet() map[string]int <span class="cov0" title="0">{
        set := make(map[string]int)
        for i, s := range h.Sites </span><span class="cov0" title="0">{
                set[s.language.Lang] = i
        }</span>
        <span class="cov0" title="0">return set</span>
}

func (h *HugoSites) NumLogErrors() int <span class="cov8" title="1">{
        if h == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return int(h.Log.ErrorCounter.Count())</span>
}

func (h *HugoSites) PrintProcessingStats(w io.Writer) <span class="cov8" title="1">{
        stats := make([]*helpers.ProcessingStats, len(h.Sites))
        for i := 0; i &lt; len(h.Sites); i++ </span><span class="cov8" title="1">{
                stats[i] = h.Sites[i].PathSpec.ProcessingStats
        }</span>
        <span class="cov8" title="1">helpers.ProcessingStatsTable(w, stats...)</span>
}

// GetContentPage finds a Page with content given the absolute filename.
// Returns nil if none found.
func (h *HugoSites) GetContentPage(filename string) page.Page <span class="cov0" title="0">{
        for _, s := range h.Sites </span><span class="cov0" title="0">{
                pos := s.rawAllPages.findPagePosByFilename(filename)
                if pos == -1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">return s.rawAllPages[pos]</span>
        }

        // If not found already, this may be bundled in another content file.
        <span class="cov0" title="0">dir := filepath.Dir(filename)

        for _, s := range h.Sites </span><span class="cov0" title="0">{
                pos := s.rawAllPages.findPagePosByFilnamePrefix(dir)
                if pos == -1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">return s.rawAllPages[pos]</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// NewHugoSites creates a new collection of sites given the input sites, building
// a language configuration based on those.
func newHugoSites(cfg deps.DepsCfg, sites ...*Site) (*HugoSites, error) <span class="cov8" title="1">{

        if cfg.Language != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Cannot provide Language in Cfg when sites are provided")
        }</span>

        <span class="cov8" title="1">langConfig, err := newMultiLingualFromSites(cfg.Cfg, sites...)

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to create language config")
        }</span>

        <span class="cov8" title="1">var contentChangeTracker *contentChangeMap

        h := &amp;HugoSites{
                running:      cfg.Running,
                multilingual: langConfig,
                multihost:    cfg.Cfg.GetBool("multihost"),
                Sites:        sites,
                init: &amp;hugoSitesInit{
                        data:         lazy.New(),
                        gitInfo:      lazy.New(),
                        translations: lazy.New(),
                },
        }

        h.fatalErrorHandler = &amp;fatalErrorHandler{
                h:     h,
                donec: make(chan bool),
        }

        h.init.data.Add(func() (interface{}, error) </span><span class="cov8" title="1">{
                err := h.loadData(h.PathSpec.BaseFs.Data.Dirs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to load data")
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">h.init.translations.Add(func() (interface{}, error) </span><span class="cov8" title="1">{
                if len(h.Sites) &gt; 1 </span><span class="cov0" title="0">{
                        allTranslations := pagesToTranslationsMap(h.Sites)
                        assignTranslationsToPages(allTranslations, h.Sites)
                }</span>

                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">h.init.gitInfo.Add(func() (interface{}, error) </span><span class="cov8" title="1">{
                err := h.loadGitInfo()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to load Git info")
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">for _, s := range sites </span><span class="cov8" title="1">{
                s.h = h
        }</span>

        <span class="cov8" title="1">if err := applyDeps(cfg, sites...); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "add site dependencies")
        }</span>

        <span class="cov8" title="1">h.Deps = sites[0].Deps

        // Only needed in server mode.
        // TODO(bep) clean up the running vs watching terms
        if cfg.Running </span><span class="cov0" title="0">{
                contentChangeTracker = &amp;contentChangeMap{
                        pathSpec:      h.PathSpec,
                        symContent:    make(map[string]map[string]bool),
                        leafBundles:   radix.New(),
                        branchBundles: make(map[string]bool),
                }
                h.ContentChanges = contentChangeTracker
        }</span>

        <span class="cov8" title="1">return h, nil</span>
}

func (h *HugoSites) loadGitInfo() error <span class="cov8" title="1">{
        if h.Cfg.GetBool("enableGitInfo") </span><span class="cov0" title="0">{
                gi, err := newGitInfo(h.Cfg)
                if err != nil </span><span class="cov0" title="0">{
                        h.Log.ERROR.Println("Failed to read Git log:", err)
                }</span> else<span class="cov0" title="0"> {
                        h.gitInfo = gi
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func applyDeps(cfg deps.DepsCfg, sites ...*Site) error <span class="cov8" title="1">{
        if cfg.TemplateProvider == nil </span><span class="cov8" title="1">{
                cfg.TemplateProvider = tplimpl.DefaultTemplateProvider
        }</span>

        <span class="cov8" title="1">if cfg.TranslationProvider == nil </span><span class="cov8" title="1">{
                cfg.TranslationProvider = i18n.NewTranslationProvider()
        }</span>

        <span class="cov8" title="1">var (
                d   *deps.Deps
                err error
        )

        for _, s := range sites </span><span class="cov8" title="1">{
                if s.Deps != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">onCreated := func(d *deps.Deps) error </span><span class="cov8" title="1">{
                        s.Deps = d

                        // Set up the main publishing chain.
                        s.publisher = publisher.NewDestinationPublisher(d.PathSpec.BaseFs.PublishFs, s.outputFormatsConfig, s.mediaTypesConfig, cfg.Cfg.GetBool("minify"))

                        if err := s.initializeSiteInfo(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">d.Site = &amp;s.Info

                        siteConfig, err := loadSiteConfig(s.language)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "load site config")
                        }</span>
                        <span class="cov8" title="1">s.siteConfigConfig = siteConfig
                        s.siteRefLinker, err = newSiteRefLinker(s.language, s)
                        return err</span>
                }

                <span class="cov8" title="1">cfg.Language = s.language
                cfg.MediaTypes = s.mediaTypesConfig
                cfg.OutputFormats = s.outputFormatsConfig

                if d == nil </span><span class="cov8" title="1">{
                        cfg.WithTemplate = s.withSiteTemplates(cfg.WithTemplate)

                        var err error
                        d, err = deps.New(cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "create deps")
                        }</span>

                        <span class="cov8" title="1">d.OutputFormatsConfig = s.outputFormatsConfig

                        if err := onCreated(d); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "on created")
                        }</span>

                        <span class="cov8" title="1">if err = d.LoadResources(); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "load resources")
                        }</span>

                } else<span class="cov0" title="0"> {
                        d, err = d.ForLanguage(cfg, onCreated)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">d.OutputFormatsConfig = s.outputFormatsConfig</span>
                }

        }

        <span class="cov8" title="1">return nil</span>
}

// NewHugoSites creates HugoSites from the given config.
func NewHugoSites(cfg deps.DepsCfg) (*HugoSites, error) <span class="cov8" title="1">{
        sites, err := createSitesFromConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "from config")
        }</span>
        <span class="cov8" title="1">return newHugoSites(cfg, sites...)</span>
}

func (s *Site) withSiteTemplates(withTemplates ...func(templ tpl.TemplateHandler) error) func(templ tpl.TemplateHandler) error <span class="cov8" title="1">{
        return func(templ tpl.TemplateHandler) error </span><span class="cov8" title="1">{
                if err := templ.LoadTemplates(""); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">for _, wt := range withTemplates </span><span class="cov8" title="1">{
                        if wt == nil </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if err := wt(templ); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }
}

func createSitesFromConfig(cfg deps.DepsCfg) ([]*Site, error) <span class="cov8" title="1">{

        var (
                sites []*Site
        )

        languages := getLanguages(cfg.Cfg)

        for _, lang := range languages </span><span class="cov8" title="1">{
                if lang.Disabled </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">var s *Site
                var err error
                cfg.Language = lang
                s, err = newSite(cfg)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">sites = append(sites, s)</span>
        }

        <span class="cov8" title="1">return sites, nil</span>
}

// Reset resets the sites and template caches etc., making it ready for a full rebuild.
func (h *HugoSites) reset(config *BuildCfg) <span class="cov0" title="0">{
        if config.ResetState </span><span class="cov0" title="0">{
                for i, s := range h.Sites </span><span class="cov0" title="0">{
                        h.Sites[i] = s.reset()
                        if r, ok := s.Fs.Destination.(hugofs.Reseter); ok </span><span class="cov0" title="0">{
                                r.Reset()
                        }</span>
                }
        }

        <span class="cov0" title="0">h.fatalErrorHandler = &amp;fatalErrorHandler{
                h:     h,
                donec: make(chan bool),
        }

        h.init.Reset()</span>
}

// resetLogs resets the log counters etc. Used to do a new build on the same sites.
func (h *HugoSites) resetLogs() <span class="cov0" title="0">{
        h.Log.Reset()
        loggers.GlobalErrorCounter.Reset()
        for _, s := range h.Sites </span><span class="cov0" title="0">{
                s.Deps.DistinctErrorLog = helpers.NewDistinctLogger(h.Log.ERROR)
        }</span>
}

func (h *HugoSites) createSitesFromConfig(cfg config.Provider) error <span class="cov0" title="0">{
        oldLangs, _ := h.Cfg.Get("languagesSorted").(langs.Languages)

        if err := loadLanguageSettings(h.Cfg, oldLangs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">depsCfg := deps.DepsCfg{Fs: h.Fs, Cfg: cfg}

        sites, err := createSitesFromConfig(depsCfg)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">langConfig, err := newMultiLingualFromSites(depsCfg.Cfg, sites...)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">h.Sites = sites

        for _, s := range sites </span><span class="cov0" title="0">{
                s.h = h
        }</span>

        <span class="cov0" title="0">if err := applyDeps(depsCfg, sites...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">h.Deps = sites[0].Deps

        h.multilingual = langConfig
        h.multihost = h.Deps.Cfg.GetBool("multihost")

        return nil</span>
}

func (h *HugoSites) toSiteInfos() []*SiteInfo <span class="cov0" title="0">{
        infos := make([]*SiteInfo, len(h.Sites))
        for i, s := range h.Sites </span><span class="cov0" title="0">{
                infos[i] = &amp;s.Info
        }</span>
        <span class="cov0" title="0">return infos</span>
}

// BuildCfg holds build options used to, as an example, skip the render step.
type BuildCfg struct {
        // Reset site state before build. Use to force full rebuilds.
        ResetState bool
        // If set, we re-create the sites from the given configuration before a build.
        // This is needed if new languages are added.
        NewConfig config.Provider
        // Skip rendering. Useful for testing.
        SkipRender bool
        // Use this to indicate what changed (for rebuilds).
        whatChanged *whatChanged

        // This is a partial re-render of some selected pages. This means
        // we should skip most of the processing.
        PartialReRender bool

        // Recently visited URLs. This is used for partial re-rendering.
        RecentlyVisited map[string]bool
}

// shouldRender is used in the Fast Render Mode to determine if we need to re-render
// a Page: If it is recently visited (the home pages will always be in this set) or changed.
// Note that a page does not have to have a content page / file.
// For regular builds, this will allways return true.
// TODO(bep) rename/work this.
func (cfg *BuildCfg) shouldRender(p *pageState) bool <span class="cov8" title="1">{
        if !p.render </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if p.forceRender </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if len(cfg.RecentlyVisited) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">if cfg.RecentlyVisited[p.RelPermalink()] </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if cfg.whatChanged != nil &amp;&amp; !p.File().IsZero() </span><span class="cov0" title="0">{
                return cfg.whatChanged.files[p.File().Filename()]
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (h *HugoSites) renderCrossSitesArtifacts() error <span class="cov8" title="1">{

        if !h.multilingual.enabled() || h.IsMultihost() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">sitemapEnabled := false
        for _, s := range h.Sites </span><span class="cov0" title="0">{
                if s.isEnabled(kindSitemap) </span><span class="cov0" title="0">{
                        sitemapEnabled = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !sitemapEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">s := h.Sites[0]

        smLayouts := []string{"sitemapindex.xml", "_default/sitemapindex.xml", "_internal/_default/sitemapindex.xml"}

        return s.renderAndWriteXML(&amp;s.PathSpec.ProcessingStats.Sitemaps, "sitemapindex",
                s.siteCfg.sitemap.Filename, h.toSiteInfos(), smLayouts...)</span>
}

func (h *HugoSites) removePageByFilename(filename string) <span class="cov0" title="0">{
        for _, s := range h.Sites </span><span class="cov0" title="0">{
                s.removePageFilename(filename)
        }</span>
}

func (h *HugoSites) createPageCollections() error <span class="cov8" title="1">{

        allPages := newLazyPagesFactory(func() page.Pages </span><span class="cov0" title="0">{
                var pages page.Pages
                for _, s := range h.Sites </span><span class="cov0" title="0">{
                        pages = append(pages, s.Pages()...)
                }</span>

                <span class="cov0" title="0">page.SortByDefault(pages)

                return pages</span>
        })

        <span class="cov8" title="1">allRegularPages := newLazyPagesFactory(func() page.Pages </span><span class="cov0" title="0">{
                return h.findPagesByKindIn(page.KindPage, allPages.get())
        }</span>)

        <span class="cov8" title="1">for _, s := range h.Sites </span><span class="cov8" title="1">{
                s.PageCollections.allPages = allPages
                s.PageCollections.allRegularPages = allRegularPages
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *Site) preparePagesForRender(isRenderingSite bool, idx int) error <span class="cov8" title="1">{

        for _, p := range s.workAllPages </span><span class="cov8" title="1">{
                if err := p.initOutputFormat(isRenderingSite, idx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">for _, p := range s.headlessPages </span><span class="cov0" title="0">{
                if err := p.initOutputFormat(isRenderingSite, idx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Pages returns all pages for all sites.
func (h *HugoSites) Pages() page.Pages <span class="cov0" title="0">{
        return h.Sites[0].AllPages()
}</span>

func (h *HugoSites) loadData(fis []hugofs.FileMetaInfo) (err error) <span class="cov8" title="1">{
        spec := source.NewSourceSpec(h.PathSpec, nil)

        h.data = make(map[string]interface{})
        for _, fi := range fis </span><span class="cov8" title="1">{
                fileSystem := spec.NewFilesystemFromFileMetaInfo(fi)
                files, err := fileSystem.Files()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, r := range files </span><span class="cov8" title="1">{
                        if err := h.handleDataFile(r); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return</span>
}

func (h *HugoSites) handleDataFile(r source.File) error <span class="cov8" title="1">{
        var current map[string]interface{}

        f, err := r.FileInfo().Meta().Open()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "data: failed to open %q:", r.LogicalName())
        }</span>
        <span class="cov8" title="1">defer f.Close()

        // Crawl in data tree to insert data
        current = h.data
        keyParts := strings.Split(r.Dir(), helpers.FilePathSeparator)

        for _, key := range keyParts </span><span class="cov8" title="1">{
                if key != "" </span><span class="cov0" title="0">{
                        if _, ok := current[key]; !ok </span><span class="cov0" title="0">{
                                current[key] = make(map[string]interface{})
                        }</span>
                        <span class="cov0" title="0">current = current[key].(map[string]interface{})</span>
                }
        }

        <span class="cov8" title="1">data, err := h.readData(r)
        if err != nil </span><span class="cov0" title="0">{
                return h.errWithFileContext(err, r)
        }</span>

        <span class="cov8" title="1">if data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // filepath.Walk walks the files in lexical order, '/' comes before '.'
        <span class="cov8" title="1">higherPrecedentData := current[r.BaseFileName()]

        switch data.(type) </span>{
        case nil:<span class="cov0" title="0"></span>
        case map[string]interface{}:<span class="cov8" title="1">

                switch higherPrecedentData.(type) </span>{
                case nil:<span class="cov8" title="1">
                        current[r.BaseFileName()] = data</span>
                case map[string]interface{}:<span class="cov0" title="0">
                        // merge maps: insert entries from data for keys that
                        // don't already exist in higherPrecedentData
                        higherPrecedentMap := higherPrecedentData.(map[string]interface{})
                        for key, value := range data.(map[string]interface{}) </span><span class="cov0" title="0">{
                                if _, exists := higherPrecedentMap[key]; exists </span><span class="cov0" title="0">{
                                        // this warning could happen if
                                        // 1. A theme uses the same key; the main data folder wins
                                        // 2. A sub folder uses the same key: the sub folder wins
                                        // TODO(bep) figure out a way to detect 2) above and make that a WARN
                                        h.Log.INFO.Printf("Data for key '%s' in path '%s' is overridden by higher precedence data already in the data tree", key, r.Path())
                                }</span> else<span class="cov0" title="0"> {
                                        higherPrecedentMap[key] = value
                                }</span>
                        }
                default:<span class="cov0" title="0">
                        // can't merge: higherPrecedentData is not a map
                        h.Log.WARN.Printf("The %T data from '%s' overridden by "+
                                "higher precedence %T data already in the data tree", data, r.Path(), higherPrecedentData)</span>
                }

        case []interface{}:<span class="cov0" title="0">
                if higherPrecedentData == nil </span><span class="cov0" title="0">{
                        current[r.BaseFileName()] = data
                }</span> else<span class="cov0" title="0"> {
                        // we don't merge array data
                        h.Log.WARN.Printf("The %T data from '%s' overridden by "+
                                "higher precedence %T data already in the data tree", data, r.Path(), higherPrecedentData)
                }</span>

        default:<span class="cov0" title="0">
                h.Log.ERROR.Printf("unexpected data type %T in file %s", data, r.LogicalName())</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (h *HugoSites) errWithFileContext(err error, f source.File) error <span class="cov0" title="0">{
        fim, ok := f.FileInfo().(hugofs.FileMetaInfo)
        if !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">realFilename := fim.Meta().Filename()

        err, _ = herrors.WithFileContextForFile(
                err,
                realFilename,
                realFilename,
                h.SourceSpec.Fs.Source,
                herrors.SimpleLineMatcher)

        return err</span>
}

func (h *HugoSites) readData(f source.File) (interface{}, error) <span class="cov8" title="1">{
        file, err := f.FileInfo().Meta().Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "readData: failed to open data file")
        }</span>
        <span class="cov8" title="1">defer file.Close()
        content := helpers.ReaderToBytes(file)

        format := metadecoders.FormatFromString(f.Extension())
        return metadecoders.Default.Unmarshal(content, format)</span>
}

func (h *HugoSites) findPagesByKindIn(kind string, inPages page.Pages) page.Pages <span class="cov0" title="0">{
        return h.Sites[0].findPagesByKindIn(kind, inPages)
}</span>

func (h *HugoSites) findPagesByShortcode(shortcode string) page.Pages <span class="cov0" title="0">{
        var pages page.Pages
        for _, s := range h.Sites </span><span class="cov0" title="0">{
                pages = append(pages, s.findPagesByShortcode(shortcode)...)
        }</span>
        <span class="cov0" title="0">return pages</span>
}

// Used in partial reloading to determine if the change is in a bundle.
type contentChangeMap struct {
        mu sync.RWMutex

        // Holds directories with leaf bundles.
        leafBundles *radix.Tree

        // Holds directories with branch bundles.
        branchBundles map[string]bool

        pathSpec *helpers.PathSpec

        // Hugo supports symlinked content (both directories and files). This
        // can lead to situations where the same file can be referenced from several
        // locations in /content -- which is really cool, but also means we have to
        // go an extra mile to handle changes.
        // This map is only used in watch mode.
        // It maps either file to files or the real dir to a set of content directories
        // where it is in use.
        symContentMu sync.Mutex
        symContent   map[string]map[string]bool
}

func (m *contentChangeMap) add(dirname string, tp bundleDirType) <span class="cov0" title="0">{
        m.mu.Lock()
        if !strings.HasSuffix(dirname, helpers.FilePathSeparator) </span><span class="cov0" title="0">{
                dirname += helpers.FilePathSeparator
        }</span>
        <span class="cov0" title="0">switch tp </span>{
        case bundleBranch:<span class="cov0" title="0">
                m.branchBundles[dirname] = true</span>
        case bundleLeaf:<span class="cov0" title="0">
                m.leafBundles.Insert(dirname, true)</span>
        default:<span class="cov0" title="0">
                panic("invalid bundle type")</span>
        }
        <span class="cov0" title="0">m.mu.Unlock()</span>
}

func (m *contentChangeMap) resolveAndRemove(filename string) (string, string, bundleDirType) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // Bundles share resources, so we need to start from the virtual root.
        relFilename := m.pathSpec.RelContentDir(filename)
        dir, name := filepath.Split(relFilename)
        if !strings.HasSuffix(dir, helpers.FilePathSeparator) </span><span class="cov0" title="0">{
                dir += helpers.FilePathSeparator
        }</span>

        <span class="cov0" title="0">if _, found := m.branchBundles[dir]; found </span><span class="cov0" title="0">{
                delete(m.branchBundles, dir)
                return dir, dir, bundleBranch
        }</span>

        <span class="cov0" title="0">if key, _, found := m.leafBundles.LongestPrefix(dir); found </span><span class="cov0" title="0">{
                m.leafBundles.Delete(key)
                dir = string(key)
                return dir, dir, bundleLeaf
        }</span>

        <span class="cov0" title="0">fileTp, isContent := classifyBundledFile(name)
        if isContent &amp;&amp; fileTp != bundleNot </span><span class="cov0" title="0">{
                // A new bundle.
                return dir, dir, fileTp
        }</span>

        <span class="cov0" title="0">return dir, filename, bundleNot</span>

}

func (m *contentChangeMap) addSymbolicLinkMapping(fim hugofs.FileMetaInfo) <span class="cov0" title="0">{
        meta := fim.Meta()
        if !meta.IsSymlink() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">m.symContentMu.Lock()

        from, to := meta.Filename(), meta.OriginalFilename()
        if fim.IsDir() </span><span class="cov0" title="0">{
                if !strings.HasSuffix(from, helpers.FilePathSeparator) </span><span class="cov0" title="0">{
                        from += helpers.FilePathSeparator
                }</span>
        }

        <span class="cov0" title="0">mm, found := m.symContent[from]

        if !found </span><span class="cov0" title="0">{
                mm = make(map[string]bool)
                m.symContent[from] = mm
        }</span>
        <span class="cov0" title="0">mm[to] = true
        m.symContentMu.Unlock()</span>
}

func (m *contentChangeMap) GetSymbolicLinkMappings(dir string) []string <span class="cov0" title="0">{
        mm, found := m.symContent[dir]
        if !found </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">dirs := make([]string, len(mm))
        i := 0
        for dir := range mm </span><span class="cov0" title="0">{
                dirs[i] = dir
                i++
        }</span>

        <span class="cov0" title="0">sort.Strings(dirs)

        return dirs</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "bytes"
        "context"
        "fmt"
        "runtime/trace"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/output"
        "golang.org/x/sync/errgroup"
        "golang.org/x/sync/semaphore"

        "github.com/pkg/errors"

        "github.com/fsnotify/fsnotify"
        "github.com/gohugoio/hugo/helpers"
)

// Build builds all sites. If filesystem events are provided,
// this is considered to be a potential partial rebuild.
func (h *HugoSites) Build(config BuildCfg, events ...fsnotify.Event) error <span class="cov8" title="1">{

        if h.running </span><span class="cov0" title="0">{
                // Make sure we don't trigger rebuilds in parallel.
                h.runningMu.Lock()
                defer h.runningMu.Unlock()
        }</span>

        <span class="cov8" title="1">ctx, task := trace.NewTask(context.Background(), "Build")
        defer task.End()

        errCollector := h.StartErrorCollector()
        errs := make(chan error)

        go func(from, to chan error) </span><span class="cov8" title="1">{
                var errors []error
                i := 0
                for e := range from </span><span class="cov8" title="1">{
                        i++
                        if i &gt; 50 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">errors = append(errors, e)</span>
                }
                <span class="cov8" title="1">to &lt;- h.pickOneAndLogTheRest(errors)

                close(to)</span>

        }(errCollector, errs)

        <span class="cov8" title="1">if h.Metrics != nil </span><span class="cov0" title="0">{
                h.Metrics.Reset()
        }</span>

        // Need a pointer as this may be modified.
        <span class="cov8" title="1">conf := &amp;config

        if conf.whatChanged == nil </span><span class="cov8" title="1">{
                // Assume everything has changed
                conf.whatChanged = &amp;whatChanged{source: true, other: true}
        }</span>

        <span class="cov8" title="1">var prepareErr error

        if !config.PartialReRender </span><span class="cov8" title="1">{
                prepare := func() error </span><span class="cov8" title="1">{
                        init := func(conf *BuildCfg) error </span><span class="cov0" title="0">{
                                for _, s := range h.Sites </span><span class="cov0" title="0">{
                                        s.Deps.BuildStartListeners.Notify()
                                }</span>

                                <span class="cov0" title="0">if len(events) &gt; 0 </span><span class="cov0" title="0">{
                                        // Rebuild
                                        if err := h.initRebuild(conf); err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "initRebuild")
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        if err := h.initSites(conf); err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "initSites")
                                        }</span>
                                }

                                <span class="cov0" title="0">return nil</span>
                        }

                        <span class="cov8" title="1">var err error

                        f := func() </span><span class="cov8" title="1">{
                                err = h.process(conf, init, events...)
                        }</span>
                        <span class="cov8" title="1">trace.WithRegion(ctx, "process", f)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "process")
                        }</span>

                        <span class="cov8" title="1">f = func() </span><span class="cov8" title="1">{
                                err = h.assemble(conf)
                        }</span>
                        <span class="cov8" title="1">trace.WithRegion(ctx, "assemble", f)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                }

                <span class="cov8" title="1">f := func() </span><span class="cov8" title="1">{
                        prepareErr = prepare()
                }</span>
                <span class="cov8" title="1">trace.WithRegion(ctx, "prepare", f)
                if prepareErr != nil </span><span class="cov0" title="0">{
                        h.SendError(prepareErr)
                }</span>

        }

        <span class="cov8" title="1">if prepareErr == nil </span><span class="cov8" title="1">{
                var err error
                f := func() </span><span class="cov8" title="1">{
                        err = h.render(conf)
                }</span>
                <span class="cov8" title="1">trace.WithRegion(ctx, "render", f)
                if err != nil </span><span class="cov0" title="0">{
                        h.SendError(err)
                }</span>
        }

        <span class="cov8" title="1">if h.Metrics != nil </span><span class="cov0" title="0">{
                var b bytes.Buffer
                h.Metrics.WriteMetrics(&amp;b)

                h.Log.FEEDBACK.Printf("\nTemplate Metrics:\n\n")
                h.Log.FEEDBACK.Print(b.String())
                h.Log.FEEDBACK.Println()
        }</span>

        <span class="cov8" title="1">select </span>{
        // Make sure the channel always gets something.
        case errCollector &lt;- nil:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov8" title="1">close(errCollector)

        err := &lt;-errs
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := h.fatalErrorHandler.getErr(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">errorCount := h.Log.ErrorCounter.Count()
        if errorCount &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("logged %d error(s)", errorCount)
        }</span>

        <span class="cov8" title="1">return nil</span>

}

// Build lifecycle methods below.
// The order listed matches the order of execution.

func (h *HugoSites) initSites(config *BuildCfg) error <span class="cov0" title="0">{
        h.reset(config)

        if config.NewConfig != nil </span><span class="cov0" title="0">{
                if err := h.createSitesFromConfig(config.NewConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *HugoSites) initRebuild(config *BuildCfg) error <span class="cov0" title="0">{
        if config.NewConfig != nil </span><span class="cov0" title="0">{
                return errors.New("rebuild does not support 'NewConfig'")
        }</span>

        <span class="cov0" title="0">if config.ResetState </span><span class="cov0" title="0">{
                return errors.New("rebuild does not support 'ResetState'")
        }</span>

        <span class="cov0" title="0">if !h.running </span><span class="cov0" title="0">{
                return errors.New("rebuild called when not in watch mode")
        }</span>

        <span class="cov0" title="0">for _, s := range h.Sites </span><span class="cov0" title="0">{
                s.resetBuildState(config.whatChanged.source)
        }</span>

        <span class="cov0" title="0">h.reset(config)
        h.resetLogs()
        helpers.InitLoggers()

        return nil</span>
}

func (h *HugoSites) process(config *BuildCfg, init func(config *BuildCfg) error, events ...fsnotify.Event) error <span class="cov8" title="1">{
        // We should probably refactor the Site and pull up most of the logic from there to here,
        // but that seems like a daunting task.
        // So for now, if there are more than one site (language),
        // we pre-process the first one, then configure all the sites based on that.

        firstSite := h.Sites[0]

        if len(events) &gt; 0 </span><span class="cov0" title="0">{
                // This is a rebuild
                return firstSite.processPartial(config, init, events)
        }</span>

        <span class="cov8" title="1">return firstSite.process(*config)</span>

}

func (h *HugoSites) assemble(bcfg *BuildCfg) error <span class="cov8" title="1">{

        if len(h.Sites) &gt; 1 </span><span class="cov0" title="0">{
                // The first is initialized during process; initialize the rest
                for _, site := range h.Sites[1:] </span><span class="cov0" title="0">{
                        if err := site.initializeSiteInfo(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">if !bcfg.whatChanged.source </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">numWorkers := config.GetNumWorkerMultiplier()
        sem := semaphore.NewWeighted(int64(numWorkers))
        g, ctx := errgroup.WithContext(context.Background())

        for _, s := range h.Sites </span><span class="cov8" title="1">{
                s := s
                g.Go(func() error </span><span class="cov8" title="1">{
                        err := sem.Acquire(ctx, 1)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">defer sem.Release(1)

                        if err := s.assemblePagesMap(s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if err := s.pagesMap.assemblePageMeta(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if err := s.pagesMap.assembleTaxonomies(s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if err := s.createWorkAllPages(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">return nil</span>

                })
        }

        <span class="cov8" title="1">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := h.createPageCollections(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func (h *HugoSites) render(config *BuildCfg) error <span class="cov8" title="1">{
        siteRenderContext := &amp;siteRenderContext{cfg: config, multihost: h.multihost}

        if !config.PartialReRender </span><span class="cov8" title="1">{
                h.renderFormats = output.Formats{}
                for _, s := range h.Sites </span><span class="cov8" title="1">{
                        s.initRenderFormats()
                        h.renderFormats = append(h.renderFormats, s.renderFormats...)
                }</span>
        }

        <span class="cov8" title="1">i := 0
        for _, s := range h.Sites </span><span class="cov8" title="1">{
                for siteOutIdx, renderFormat := range s.renderFormats </span><span class="cov8" title="1">{
                        siteRenderContext.outIdx = siteOutIdx
                        siteRenderContext.sitesOutIdx = i
                        i++

                        select </span>{
                        case &lt;-h.Done():<span class="cov0" title="0">
                                return nil</span>
                        default:<span class="cov8" title="1">
                                // For the non-renderable pages, we use the content iself as
                                // template and we may have to re-parse and execute it for
                                // each output format.
                                h.TemplateHandler().RebuildClone()

                                for _, s2 := range h.Sites </span><span class="cov8" title="1">{
                                        // We render site by site, but since the content is lazily rendered
                                        // and a site can "borrow" content from other sites, every site
                                        // needs this set.
                                        s2.rc = &amp;siteRenderingContext{Format: renderFormat}

                                        if err := s2.preparePagesForRender(s == s2, siteRenderContext.sitesOutIdx); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }

                                <span class="cov8" title="1">if !config.SkipRender </span><span class="cov8" title="1">{
                                        if config.PartialReRender </span><span class="cov0" title="0">{
                                                if err := s.renderPages(siteRenderContext); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        } else<span class="cov8" title="1"> {
                                                if err := s.render(siteRenderContext); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        }
                                }
                        }

                }

        }

        <span class="cov8" title="1">if !config.SkipRender </span><span class="cov8" title="1">{
                if err := h.renderCrossSitesArtifacts(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "sync"

        "errors"

        "github.com/gohugoio/hugo/langs"

        "github.com/gohugoio/hugo/config"
)

// Multilingual manages the all languages used in a multilingual site.
type Multilingual struct {
        Languages langs.Languages

        DefaultLang *langs.Language

        langMap     map[string]*langs.Language
        langMapInit sync.Once
}

// Language returns the Language associated with the given string.
func (ml *Multilingual) Language(lang string) *langs.Language <span class="cov0" title="0">{
        ml.langMapInit.Do(func() </span><span class="cov0" title="0">{
                ml.langMap = make(map[string]*langs.Language)
                for _, l := range ml.Languages </span><span class="cov0" title="0">{
                        ml.langMap[l.Lang] = l
                }</span>
        })
        <span class="cov0" title="0">return ml.langMap[lang]</span>
}

func getLanguages(cfg config.Provider) langs.Languages <span class="cov8" title="1">{
        if cfg.IsSet("languagesSorted") </span><span class="cov8" title="1">{
                return cfg.Get("languagesSorted").(langs.Languages)
        }</span>

        <span class="cov0" title="0">return langs.Languages{langs.NewDefaultLanguage(cfg)}</span>
}

func newMultiLingualFromSites(cfg config.Provider, sites ...*Site) (*Multilingual, error) <span class="cov8" title="1">{
        languages := make(langs.Languages, len(sites))

        for i, s := range sites </span><span class="cov8" title="1">{
                if s.language == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("missing language for site")
                }</span>
                <span class="cov8" title="1">languages[i] = s.language</span>
        }

        <span class="cov8" title="1">defaultLang := cfg.GetString("defaultContentLanguage")

        if defaultLang == "" </span><span class="cov0" title="0">{
                defaultLang = "en"
        }</span>

        <span class="cov8" title="1">return &amp;Multilingual{Languages: languages, DefaultLang: langs.NewLanguage(defaultLang, cfg)}, nil</span>

}

func (ml *Multilingual) enabled() bool <span class="cov8" title="1">{
        return len(ml.Languages) &gt; 1
}</span>

func (s *Site) multilingualEnabled() bool <span class="cov8" title="1">{
        if s.h == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return s.h.multilingual != nil &amp;&amp; s.h.multilingual.enabled()</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "bytes"
        "fmt"
        "html/template"
        "os"
        "path"
        "path/filepath"
        "sort"
        "strings"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/bep/gitmap"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/gohugoio/hugo/parser/pageparser"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/output"

        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/source"

        "github.com/gohugoio/hugo/common/collections"
        "github.com/gohugoio/hugo/common/text"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"
)

var (
        _ page.Page           = (*pageState)(nil)
        _ collections.Grouper = (*pageState)(nil)
        _ collections.Slicer  = (*pageState)(nil)
)

var (
        pageTypesProvider = resource.NewResourceTypesProvider(media.OctetType, pageResourceType)
        nopPageOutput     = &amp;pageOutput{pagePerOutputProviders: nopPagePerOutput}
)

// pageContext provides contextual information about this page, for error
// logging and similar.
type pageContext interface {
        posOffset(offset int) text.Position
        wrapError(err error) error
        getRenderingConfig() *helpers.BlackFriday
}

// wrapErr adds some context to the given error if possible.
func wrapErr(err error, ctx interface{}) error <span class="cov0" title="0">{
        if pc, ok := ctx.(pageContext); ok </span><span class="cov0" title="0">{
                return pc.wrapError(err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

type pageSiteAdapter struct {
        p page.Page
        s *Site
}

func (pa pageSiteAdapter) GetPage(ref string) (page.Page, error) <span class="cov0" title="0">{
        p, err := pa.s.getPageNew(pa.p, ref)
        if p == nil </span><span class="cov0" title="0">{
                // The nil struct has meaning in some situations, mostly to avoid breaking
                // existing sites doing $nilpage.IsDescendant($p), which will always return
                // false.
                p = page.NilPage
        }</span>
        <span class="cov0" title="0">return p, err</span>
}

type pageState struct {
        // This slice will be of same length as the number of global slice of output
        // formats (for all sites).
        pageOutputs []*pageOutput

        // This will be shifted out when we start to render a new output format.
        *pageOutput

        // Common for all output formats.
        *pageCommon
}

// Eq returns whether the current page equals the given page.
// This is what's invoked when doing `{{ if eq $page $otherPage }}`
func (p *pageState) Eq(other interface{}) bool <span class="cov0" title="0">{
        pp, err := unwrapPage(other)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return p == pp</span>
}

func (p *pageState) GitInfo() *gitmap.GitInfo <span class="cov0" title="0">{
        return p.gitInfo
}</span>

func (p *pageState) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return page.MarshalPageToJSON(p)
}</span>

func (p *pageState) getPages() page.Pages <span class="cov8" title="1">{
        b := p.bucket
        if b == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return b.getPages()</span>
}

func (p *pageState) getPagesAndSections() page.Pages <span class="cov0" title="0">{
        b := p.bucket
        if b == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return b.getPagesAndSections()</span>
}

// TODO(bep) cm add a test
func (p *pageState) RegularPages() page.Pages <span class="cov8" title="1">{
        p.regularPagesInit.Do(func() </span><span class="cov8" title="1">{
                var pages page.Pages

                switch p.Kind() </span>{
                case page.KindPage:<span class="cov0" title="0"></span>
                case page.KindSection, page.KindHome, page.KindTaxonomyTerm:<span class="cov8" title="1">
                        pages = p.getPages()</span>
                case page.KindTaxonomy:<span class="cov0" title="0">
                        all := p.Pages()
                        for _, p := range all </span><span class="cov0" title="0">{
                                if p.IsPage() </span><span class="cov0" title="0">{
                                        pages = append(pages, p)
                                }</span>
                        }
                default:<span class="cov0" title="0">
                        pages = p.s.RegularPages()</span>
                }

                <span class="cov8" title="1">p.regularPages = pages</span>

        })

        <span class="cov8" title="1">return p.regularPages</span>
}

func (p *pageState) Pages() page.Pages <span class="cov8" title="1">{
        p.pagesInit.Do(func() </span><span class="cov8" title="1">{
                var pages page.Pages

                switch p.Kind() </span>{
                case page.KindPage:<span class="cov0" title="0"></span>
                case page.KindSection, page.KindHome:<span class="cov0" title="0">
                        pages = p.getPagesAndSections()</span>
                case page.KindTaxonomy:<span class="cov0" title="0">
                        termInfo := p.bucket
                        plural := maps.GetString(termInfo.meta, "plural")
                        term := maps.GetString(termInfo.meta, "termKey")
                        taxonomy := p.s.Taxonomies[plural].Get(term)
                        pages = taxonomy.Pages()</span>
                case page.KindTaxonomyTerm:<span class="cov0" title="0">
                        pages = p.getPagesAndSections()</span>
                default:<span class="cov8" title="1">
                        pages = p.s.Pages()</span>
                }

                <span class="cov8" title="1">p.pages = pages</span>
        })

        <span class="cov8" title="1">return p.pages</span>
}

// RawContent returns the un-rendered source content without
// any leading front matter.
func (p *pageState) RawContent() string <span class="cov0" title="0">{
        if p.source.parsed == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">start := p.source.posMainContent
        if start == -1 </span><span class="cov0" title="0">{
                start = 0
        }</span>
        <span class="cov0" title="0">return string(p.source.parsed.Input()[start:])</span>
}

func (p *pageState) Resources() resource.Resources <span class="cov8" title="1">{
        p.resourcesInit.Do(func() </span><span class="cov8" title="1">{

                sort := func() </span><span class="cov8" title="1">{
                        sort.SliceStable(p.resources, func(i, j int) bool </span><span class="cov0" title="0">{
                                ri, rj := p.resources[i], p.resources[j]
                                if ri.ResourceType() &lt; rj.ResourceType() </span><span class="cov0" title="0">{
                                        return true
                                }</span>

                                <span class="cov0" title="0">p1, ok1 := ri.(page.Page)
                                p2, ok2 := rj.(page.Page)

                                if ok1 != ok2 </span><span class="cov0" title="0">{
                                        return ok2
                                }</span>

                                <span class="cov0" title="0">if ok1 </span><span class="cov0" title="0">{
                                        return page.DefaultPageSort(p1, p2)
                                }</span>

                                <span class="cov0" title="0">return ri.RelPermalink() &lt; rj.RelPermalink()</span>
                        })
                }

                <span class="cov8" title="1">sort()

                if len(p.m.resourcesMetadata) &gt; 0 </span><span class="cov0" title="0">{
                        resources.AssignMetadata(p.m.resourcesMetadata, p.resources...)
                        sort()
                }</span>

        })
        <span class="cov8" title="1">return p.resources</span>
}

func (p *pageState) HasShortcode(name string) bool <span class="cov0" title="0">{
        if p.shortcodeState == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return p.shortcodeState.nameSet[name]</span>
}

func (p *pageState) Site() page.Site <span class="cov8" title="1">{
        return &amp;p.s.Info
}</span>

func (p *pageState) String() string <span class="cov0" title="0">{
        if sourceRef := p.sourceRef(); sourceRef != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Page(%s)", sourceRef)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Page(%q)", p.Title())</span>
}

// IsTranslated returns whether this content file is translated to
// other language(s).
func (p *pageState) IsTranslated() bool <span class="cov8" title="1">{
        p.s.h.init.translations.Do()
        return len(p.translations) &gt; 0
}</span>

// TranslationKey returns the key used to map language translations of this page.
// It will use the translationKey set in front matter if set, or the content path and
// filename (excluding any language code and extension), e.g. "about/index".
// The Page Kind is always prepended.
func (p *pageState) TranslationKey() string <span class="cov0" title="0">{
        p.translationKeyInit.Do(func() </span><span class="cov0" title="0">{
                if p.m.translationKey != "" </span><span class="cov0" title="0">{
                        p.translationKey = p.Kind() + "/" + p.m.translationKey
                }</span> else<span class="cov0" title="0"> if p.IsPage() &amp;&amp; !p.File().IsZero() </span><span class="cov0" title="0">{
                        p.translationKey = path.Join(p.Kind(), filepath.ToSlash(p.File().Dir()), p.File().TranslationBaseName())
                }</span> else<span class="cov0" title="0"> if p.IsNode() </span><span class="cov0" title="0">{
                        p.translationKey = path.Join(p.Kind(), p.SectionsPath())
                }</span>

        })

        <span class="cov0" title="0">return p.translationKey</span>

}

// AllTranslations returns all translations, including the current Page.
func (p *pageState) AllTranslations() page.Pages <span class="cov0" title="0">{
        p.s.h.init.translations.Do()
        return p.allTranslations
}</span>

// Translations returns the translations excluding the current Page.
func (p *pageState) Translations() page.Pages <span class="cov0" title="0">{
        p.s.h.init.translations.Do()
        return p.translations
}</span>

func (p *pageState) getRenderingConfig() *helpers.BlackFriday <span class="cov8" title="1">{
        if p.m.renderingConfig == nil </span><span class="cov8" title="1">{
                return p.s.ContentSpec.BlackFriday
        }</span>
        <span class="cov0" title="0">return p.m.renderingConfig</span>
}

func (ps *pageState) initCommonProviders(pp pagePaths) error <span class="cov8" title="1">{
        if ps.IsPage() </span><span class="cov8" title="1">{
                ps.posNextPrev = &amp;nextPrev{init: ps.s.init.prevNext}
                ps.posNextPrevSection = &amp;nextPrev{init: ps.s.init.prevNextInSection}
                ps.InSectionPositioner = newPagePositionInSection(ps.posNextPrevSection)
                ps.Positioner = newPagePosition(ps.posNextPrev)
        }</span>

        <span class="cov8" title="1">ps.OutputFormatsProvider = pp
        ps.targetPathDescriptor = pp.targetPathDescriptor
        ps.RefProvider = newPageRef(ps)
        ps.SitesProvider = &amp;ps.s.Info

        return nil</span>
}

func (p *pageState) getLayoutDescriptor() output.LayoutDescriptor <span class="cov8" title="1">{
        p.layoutDescriptorInit.Do(func() </span><span class="cov8" title="1">{
                var section string
                sections := p.SectionsEntries()

                switch p.Kind() </span>{
                case page.KindSection:<span class="cov8" title="1">
                        if len(sections) &gt; 0 </span><span class="cov8" title="1">{
                                section = sections[0]
                        }</span>
                case page.KindTaxonomyTerm, page.KindTaxonomy:<span class="cov8" title="1">
                        section = maps.GetString(p.bucket.meta, "singular")</span>

                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">p.layoutDescriptor = output.LayoutDescriptor{
                        Kind:    p.Kind(),
                        Type:    p.Type(),
                        Lang:    p.Language().Lang,
                        Layout:  p.Layout(),
                        Section: section,
                }</span>
        })

        <span class="cov8" title="1">return p.layoutDescriptor</span>

}

func (p *pageState) getLayouts(layouts ...string) ([]string, error) <span class="cov8" title="1">{
        f := p.outputFormat()

        if len(layouts) == 0 </span><span class="cov8" title="1">{
                selfLayout := p.selfLayoutForOutput(f)
                if selfLayout != "" </span><span class="cov0" title="0">{
                        return []string{selfLayout}, nil
                }</span>
        }

        <span class="cov8" title="1">layoutDescriptor := p.getLayoutDescriptor()

        if len(layouts) &gt; 0 </span><span class="cov0" title="0">{
                layoutDescriptor.Layout = layouts[0]
                layoutDescriptor.LayoutOverride = true
        }</span>

        <span class="cov8" title="1">return p.s.layoutHandler.For(layoutDescriptor, f)</span>
}

// This is serialized
func (p *pageState) initOutputFormat(isRenderingSite bool, idx int) error <span class="cov8" title="1">{
        if err := p.shiftToOutputFormat(isRenderingSite, idx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !p.renderable </span><span class="cov8" title="1">{
                if _, err := p.Content(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>

}

// Must be run after the site section tree etc. is built and ready.
func (p *pageState) initPage() error <span class="cov8" title="1">{
        if _, err := p.init.Do(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (p *pageState) renderResources() (err error) <span class="cov8" title="1">{
        p.resourcesPublishInit.Do(func() </span><span class="cov8" title="1">{
                var toBeDeleted []int

                for i, r := range p.Resources() </span><span class="cov0" title="0">{

                        if _, ok := r.(page.Page); ok </span><span class="cov0" title="0">{
                                // Pages gets rendered with the owning page but we count them here.
                                p.s.PathSpec.ProcessingStats.Incr(&amp;p.s.PathSpec.ProcessingStats.Pages)
                                continue</span>
                        }

                        <span class="cov0" title="0">src, ok := r.(resource.Source)
                        if !ok </span><span class="cov0" title="0">{
                                err = errors.Errorf("Resource %T does not support resource.Source", src)
                                return
                        }</span>

                        <span class="cov0" title="0">if err := src.Publish(); err != nil </span><span class="cov0" title="0">{
                                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        // The resource has been deleted from the file system.
                                        // This should be extremely rare, but can happen on live reload in server
                                        // mode when the same resource is member of different page bundles.
                                        toBeDeleted = append(toBeDeleted, i)
                                }</span> else<span class="cov0" title="0"> {
                                        p.s.Log.ERROR.Printf("Failed to publish Resource for page %q: %s", p.pathOrTitle(), err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                p.s.PathSpec.ProcessingStats.Incr(&amp;p.s.PathSpec.ProcessingStats.Files)
                        }</span>
                }

                <span class="cov8" title="1">for _, i := range toBeDeleted </span><span class="cov0" title="0">{
                        p.deleteResource(i)
                }</span>

        })

        <span class="cov8" title="1">return</span>
}

func (p *pageState) deleteResource(i int) <span class="cov0" title="0">{
        p.resources = append(p.resources[:i], p.resources[i+1:]...)
}</span>

func (p *pageState) getTargetPaths() page.TargetPaths <span class="cov0" title="0">{
        return p.targetPaths()
}</span>

func (p *pageState) setTranslations(pages page.Pages) <span class="cov0" title="0">{
        p.allTranslations = pages
        page.SortByLanguage(p.allTranslations)
        translations := make(page.Pages, 0)
        for _, t := range p.allTranslations </span><span class="cov0" title="0">{
                if !t.Eq(p) </span><span class="cov0" title="0">{
                        translations = append(translations, t)
                }</span>
        }
        <span class="cov0" title="0">p.translations = translations</span>
}

func (p *pageState) AlternativeOutputFormats() page.OutputFormats <span class="cov0" title="0">{
        f := p.outputFormat()
        var o page.OutputFormats
        for _, of := range p.OutputFormats() </span><span class="cov0" title="0">{
                if of.Format.NotAlternative || of.Format.Name == f.Name </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">o = append(o, of)</span>
        }
        <span class="cov0" title="0">return o</span>
}

func (p *pageState) Render(layout ...string) template.HTML <span class="cov0" title="0">{
        l, err := p.getLayouts(layout...)
        if err != nil </span><span class="cov0" title="0">{
                p.s.SendError(p.wrapError(errors.Errorf(".Render: failed to resolve layout %v", layout)))
                return ""
        }</span>

        <span class="cov0" title="0">for _, layout := range l </span><span class="cov0" title="0">{
                templ, found := p.s.Tmpl.Lookup(layout)
                if !found </span><span class="cov0" title="0">{
                        // This is legacy from when we had only one output format and
                        // HTML templates only. Some have references to layouts without suffix.
                        // We default to good old HTML.
                        templ, _ = p.s.Tmpl.Lookup(layout + ".html")
                }</span>
                <span class="cov0" title="0">if templ != nil </span><span class="cov0" title="0">{
                        res, err := executeToString(templ, p)
                        if err != nil </span><span class="cov0" title="0">{
                                p.s.SendError(p.wrapError(errors.Wrapf(err, ".Render: failed to execute template %q v", layout)))
                                return ""
                        }</span>
                        <span class="cov0" title="0">return template.HTML(res)</span>
                }
        }

        <span class="cov0" title="0">return ""</span>

}

// wrapError adds some more context to the given error if possible
func (p *pageState) wrapError(err error) error <span class="cov0" title="0">{

        var filename string
        if !p.File().IsZero() </span><span class="cov0" title="0">{
                filename = p.File().Filename()
        }</span>

        <span class="cov0" title="0">err, _ = herrors.WithFileContextForFile(
                err,
                filename,
                filename,
                p.s.SourceSpec.Fs.Source,
                herrors.SimpleLineMatcher)

        return err</span>
}

func (p *pageState) addResources(r ...resource.Resource) <span class="cov0" title="0">{
        p.resources = append(p.resources, r...)
}</span>

func (p *pageState) mapContent(bucket *pagesMapBucket, meta *pageMeta) error <span class="cov8" title="1">{

        s := p.shortcodeState

        p.renderable = true

        rn := &amp;pageContentMap{
                items: make([]interface{}, 0, 20),
        }

        iter := p.source.parsed.Iterator()

        fail := func(err error, i pageparser.Item) error </span><span class="cov0" title="0">{
                return p.parseError(err, iter.Input(), i.Pos)
        }</span>

        // the parser is guaranteed to return items in proper order or fail, so 
        //  it's safe to keep some "global" state
        <span class="cov8" title="1">var currShortcode shortcode
        var ordinal int

Loop:
        for </span><span class="cov8" title="1">{
                it := iter.Next()

                switch </span>{
                case it.Type == pageparser.TypeIgnore:<span class="cov0" title="0"></span>
                case it.Type == pageparser.TypeHTMLStart:<span class="cov0" title="0">
                        // This is HTML without front matter. It can still have shortcodes.
                        p.selfLayout = "__" + p.File().Filename()
                        p.renderable = false
                        rn.AddBytes(it)</span>
                case it.IsFrontMatter():<span class="cov8" title="1">
                        f := metadecoders.FormatFromFrontMatterType(it.Type)
                        m, err := metadecoders.Default.UnmarshalToMap(it.Val, f)
                        if err != nil </span><span class="cov0" title="0">{
                                if fe, ok := err.(herrors.FileError); ok </span><span class="cov0" title="0">{
                                        return herrors.ToFileErrorWithOffset(fe, iter.LineNumber()-1)
                                }</span> else<span class="cov0" title="0"> {
                                        return err
                                }</span>
                        }

                        <span class="cov8" title="1">if err := meta.setMetadata(bucket, p, m); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">next := iter.Peek()
                        if !next.IsDone() </span><span class="cov8" title="1">{
                                p.source.posMainContent = next.Pos
                        }</span>

                        <span class="cov8" title="1">if !p.s.shouldBuild(p) </span><span class="cov0" title="0">{
                                // Nothing more to do.
                                return nil
                        }</span>

                case it.Type == pageparser.TypeLeadSummaryDivider:<span class="cov0" title="0">
                        posBody := -1
                        f := func(item pageparser.Item) bool </span><span class="cov0" title="0">{
                                if posBody == -1 &amp;&amp; !item.IsDone() </span><span class="cov0" title="0">{
                                        posBody = item.Pos
                                }</span>

                                <span class="cov0" title="0">if item.IsNonWhitespace() </span><span class="cov0" title="0">{
                                        p.truncated = true

                                        // Done
                                        return false
                                }</span>
                                <span class="cov0" title="0">return true</span>
                        }
                        <span class="cov0" title="0">iter.PeekWalk(f)

                        p.source.posSummaryEnd = it.Pos
                        p.source.posBodyStart = posBody
                        p.source.hasSummaryDivider = true

                        if meta.markup != "html" </span><span class="cov0" title="0">{
                                // The content will be rendered by Blackfriday or similar,
                                // and we need to track the summary.
                                rn.AddReplacement(internalSummaryDividerPre, it)
                        }</span>

                // Handle shortcode
                case it.IsLeftShortcodeDelim():<span class="cov0" title="0">
                        // let extractShortcode handle left delim (will do so recursively)
                        iter.Backup()

                        currShortcode, err := s.extractShortcode(ordinal, 0, iter)
                        if err != nil </span><span class="cov0" title="0">{
                                return fail(errors.Wrap(err, "failed to extract shortcode"), it)
                        }</span>

                        <span class="cov0" title="0">currShortcode.pos = it.Pos
                        currShortcode.length = iter.Current().Pos - it.Pos
                        if currShortcode.placeholder == "" </span><span class="cov0" title="0">{
                                currShortcode.placeholder = createShortcodePlaceholder("s", currShortcode.ordinal)
                        }</span>

                        <span class="cov0" title="0">if currShortcode.name != "" </span><span class="cov0" title="0">{
                                s.nameSet[currShortcode.name] = true
                        }</span>

                        <span class="cov0" title="0">if currShortcode.params == nil </span><span class="cov0" title="0">{
                                var s []string
                                currShortcode.params = s
                        }</span>

                        <span class="cov0" title="0">currShortcode.placeholder = createShortcodePlaceholder("s", ordinal)
                        ordinal++
                        s.shortcodes = append(s.shortcodes, currShortcode)

                        rn.AddShortcode(currShortcode)</span>

                case it.Type == pageparser.TypeEmoji:<span class="cov0" title="0">
                        if emoji := helpers.Emoji(it.ValStr()); emoji != nil </span><span class="cov0" title="0">{
                                rn.AddReplacement(emoji, it)
                        }</span> else<span class="cov0" title="0"> {
                                rn.AddBytes(it)
                        }</span>
                case it.IsEOF():<span class="cov8" title="1">
                        break Loop</span>
                case it.IsError():<span class="cov0" title="0">
                        err := fail(errors.WithStack(errors.New(it.ValStr())), it)
                        currShortcode.err = err
                        return err</span>

                default:<span class="cov8" title="1">
                        rn.AddBytes(it)</span>
                }
        }

        <span class="cov8" title="1">p.cmap = rn

        return nil</span>
}

func (p *pageState) errorf(err error, format string, a ...interface{}) error <span class="cov0" title="0">{
        if herrors.UnwrapErrorWithFileContext(err) != nil </span><span class="cov0" title="0">{
                // More isn't always better.
                return err
        }</span>
        <span class="cov0" title="0">args := append([]interface{}{p.Language().Lang, p.pathOrTitle()}, a...)
        format = "[%s] page %q: " + format
        if err == nil </span><span class="cov0" title="0">{
                errors.Errorf(format, args...)
                return fmt.Errorf(format, args...)
        }</span>
        <span class="cov0" title="0">return errors.Wrapf(err, format, args...)</span>
}

func (p *pageState) outputFormat() (f output.Format) <span class="cov8" title="1">{
        if p.pageOutput == nil </span><span class="cov0" title="0">{
                panic("no pageOutput")</span>
        }
        <span class="cov8" title="1">return p.pageOutput.f</span>
}

func (p *pageState) parseError(err error, input []byte, offset int) error <span class="cov0" title="0">{
        if herrors.UnwrapFileError(err) != nil </span><span class="cov0" title="0">{
                // Use the most specific location.
                return err
        }</span>
        <span class="cov0" title="0">pos := p.posFromInput(input, offset)
        return herrors.NewFileError("md", -1, pos.LineNumber, pos.ColumnNumber, err)</span>

}

func (p *pageState) pathOrTitle() string <span class="cov0" title="0">{
        if !p.File().IsZero() </span><span class="cov0" title="0">{
                return p.File().Filename()
        }</span>

        <span class="cov0" title="0">if p.Path() != "" </span><span class="cov0" title="0">{
                return p.Path()
        }</span>

        <span class="cov0" title="0">return p.Title()</span>
}

func (p *pageState) posFromPage(offset int) text.Position <span class="cov0" title="0">{
        return p.posFromInput(p.source.parsed.Input(), offset)
}</span>

func (p *pageState) posFromInput(input []byte, offset int) text.Position <span class="cov0" title="0">{
        lf := []byte("\n")
        input = input[:offset]
        lineNumber := bytes.Count(input, lf) + 1
        endOfLastLine := bytes.LastIndex(input, lf)

        return text.Position{
                Filename:     p.pathOrTitle(),
                LineNumber:   lineNumber,
                ColumnNumber: offset - endOfLastLine,
                Offset:       offset,
        }
}</span>

func (p *pageState) posOffset(offset int) text.Position <span class="cov0" title="0">{
        return p.posFromInput(p.source.parsed.Input(), offset)
}</span>

// shiftToOutputFormat is serialized. The output format idx refers to the
// full set of output formats for all sites.
func (p *pageState) shiftToOutputFormat(isRenderingSite bool, idx int) error <span class="cov8" title="1">{
        if err := p.initPage(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if idx &gt;= len(p.pageOutputs) </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("invalid page state for %q: got output format index %d, have %d", p.pathOrTitle(), idx, len(p.pageOutputs)))</span>
        }

        <span class="cov8" title="1">p.pageOutput = p.pageOutputs[idx]

        if p.pageOutput == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("pageOutput is nil for output idx %d", idx))</span>
        }

        // Reset any built paginator. This will trigger when re-rendering pages in
        // server mode.
        <span class="cov8" title="1">if isRenderingSite &amp;&amp; p.pageOutput.paginator != nil &amp;&amp; p.pageOutput.paginator.current != nil </span><span class="cov0" title="0">{
                p.pageOutput.paginator.reset()
        }</span>

        <span class="cov8" title="1">if idx &gt; 0 </span><span class="cov8" title="1">{
                // Check if we can reuse content from one of the previous formats.
                for i := idx - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        po := p.pageOutputs[i]
                        if po.cp != nil &amp;&amp; po.cp.reuse </span><span class="cov8" title="1">{
                                p.pageOutput.cp = po.cp
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">for _, r := range p.Resources().ByType(pageResourceType) </span><span class="cov0" title="0">{
                rp := r.(*pageState)
                if err := rp.shiftToOutputFormat(isRenderingSite, idx); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to shift outputformat in Page resource")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// sourceRef returns the reference used by GetPage and ref/relref shortcodes to refer to
// this page. It is prefixed with a "/".
//
// For pages that have a source file, it is returns the path to this file as an
// absolute path rooted in this site's content dir.
// For pages that do not (sections witout content page etc.), it returns the
// virtual path, consistent with where you would add a source file.
func (p *pageState) sourceRef() string <span class="cov8" title="1">{
        if !p.File().IsZero() </span><span class="cov8" title="1">{
                sourcePath := p.File().Path()
                if sourcePath != "" </span><span class="cov8" title="1">{
                        return "/" + filepath.ToSlash(sourcePath)
                }</span>
        }

        <span class="cov8" title="1">if len(p.SectionsEntries()) &gt; 0 </span><span class="cov8" title="1">{
                // no backing file, return the virtual source path
                return "/" + p.SectionsPath()
        }</span>

        <span class="cov8" title="1">return ""</span>
}

type pageStatePages []*pageState

// Implement sorting.
func (ps pageStatePages) Len() int <span class="cov8" title="1">{ return len(ps) }</span>

func (ps pageStatePages) Less(i, j int) bool <span class="cov8" title="1">{ return page.DefaultPageSort(ps[i], ps[j]) }</span>

func (ps pageStatePages) Swap(i, j int) <span class="cov8" title="1">{ ps[i], ps[j] = ps[j], ps[i] }</span>

// findPagePos Given a page, it will find the position in Pages
// will return -1 if not found
func (ps pageStatePages) findPagePos(page *pageState) int <span class="cov0" title="0">{
        for i, x := range ps </span><span class="cov0" title="0">{
                if x.File().Filename() == page.File().Filename() </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func (ps pageStatePages) findPagePosByFilename(filename string) int <span class="cov0" title="0">{
        for i, x := range ps </span><span class="cov0" title="0">{
                if x.File().Filename() == filename </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func (ps pageStatePages) findPagePosByFilnamePrefix(prefix string) int <span class="cov0" title="0">{
        if prefix == "" </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">lenDiff := -1
        currPos := -1
        prefixLen := len(prefix)

        // Find the closest match
        for i, x := range ps </span><span class="cov0" title="0">{
                if strings.HasPrefix(x.File().Filename(), prefix) </span><span class="cov0" title="0">{
                        diff := len(x.File().Filename()) - prefixLen
                        if lenDiff == -1 || diff &lt; lenDiff </span><span class="cov0" title="0">{
                                lenDiff = diff
                                currPos = i
                        }</span>
                }
        }
        <span class="cov0" title="0">return currPos</span>
}

func (s *Site) sectionsFromFile(fi source.File) []string <span class="cov8" title="1">{
        dirname := fi.Dir()

        dirname = strings.Trim(dirname, helpers.FilePathSeparator)
        if dirname == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := strings.Split(dirname, helpers.FilePathSeparator)

        if fii, ok := fi.(*fileInfo); ok </span><span class="cov8" title="1">{
                if len(parts) &gt; 0 &amp;&amp; fii.FileInfo().Meta().Classifier() == files.ContentClassLeaf </span><span class="cov0" title="0">{
                        // my-section/mybundle/index.md =&gt; my-section
                        return parts[:len(parts)-1]
                }</span>
        }

        <span class="cov8" title="1">return parts</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"

        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/parser/pageparser"
)

var (
        internalSummaryDividerBase      = "HUGOMORE42"
        internalSummaryDividerBaseBytes = []byte(internalSummaryDividerBase)
        internalSummaryDividerPre       = []byte("\n\n" + internalSummaryDividerBase + "\n\n")
)

// The content related items on a Page.
type pageContent struct {
        renderable bool
        selfLayout string

        truncated bool

        cmap *pageContentMap

        shortcodeState *shortcodeHandler

        source rawPageContent
}

// returns the content to be processed by Blackfriday or similar.
func (p pageContent) contentToRender(renderedShortcodes map[string]string) []byte <span class="cov8" title="1">{
        source := p.source.parsed.Input()

        c := make([]byte, 0, len(source)+(len(source)/10))

        for _, it := range p.cmap.items </span><span class="cov8" title="1">{
                switch v := it.(type) </span>{
                case pageparser.Item:<span class="cov8" title="1">
                        c = append(c, source[v.Pos:v.Pos+len(v.Val)]...)</span>
                case pageContentReplacement:<span class="cov0" title="0">
                        c = append(c, v.val...)</span>
                case *shortcode:<span class="cov0" title="0">
                        if !p.renderable || !v.insertPlaceholder() </span><span class="cov0" title="0">{
                                // Insert the rendered shortcode.
                                renderedShortcode, found := renderedShortcodes[v.placeholder]
                                if !found </span><span class="cov0" title="0">{
                                        // This should never happen.
                                        panic(fmt.Sprintf("rendered shortcode %q not found", v.placeholder))</span>
                                }

                                <span class="cov0" title="0">c = append(c, []byte(renderedShortcode)...)</span>

                        } else<span class="cov0" title="0"> {
                                // Insert the placeholder so we can insert the content after
                                // markdown processing.
                                c = append(c, []byte(v.placeholder)...)

                        }</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("unknown item type %T", it))</span>
                }
        }

        <span class="cov8" title="1">return c</span>
}

func (p pageContent) selfLayoutForOutput(f output.Format) string <span class="cov8" title="1">{
        if p.selfLayout == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov0" title="0">return p.selfLayout + f.Name</span>
}

type rawPageContent struct {
        hasSummaryDivider bool

        // The AST of the parsed page. Contains information about:
        // shortcodes, front matter, summary indicators.
        parsed pageparser.Result

        // Returns the position in bytes after any front matter.
        posMainContent int

        // These are set if we're able to determine this from the source.
        posSummaryEnd int
        posBodyStart  int
}

type pageContentReplacement struct {
        val []byte

        source pageparser.Item
}

type pageContentMap struct {

        // If not, we can skip any pre-rendering of shortcodes.
        hasMarkdownShortcode bool

        // Indicates whether we must do placeholder replacements.
        hasNonMarkdownShortcode bool

        //  *shortcode, pageContentReplacement or pageparser.Item
        items []interface{}
}

func (p *pageContentMap) AddBytes(item pageparser.Item) <span class="cov8" title="1">{
        p.items = append(p.items, item)
}</span>

func (p *pageContentMap) AddReplacement(val []byte, source pageparser.Item) <span class="cov0" title="0">{
        p.items = append(p.items, pageContentReplacement{val: val, source: source})
}</span>

func (p *pageContentMap) AddShortcode(s *shortcode) <span class="cov0" title="0">{
        p.items = append(p.items, s)
        if s.insertPlaceholder() </span><span class="cov0" title="0">{
                p.hasNonMarkdownShortcode = true
        }</span> else<span class="cov0" title="0"> {
                p.hasMarkdownShortcode = true
        }</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "sync"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/resources/page"
)

type pageData struct {
        *pageState

        dataInit sync.Once
        data     page.Data
}

func (p *pageData) Data() interface{} <span class="cov8" title="1">{
        p.dataInit.Do(func() </span><span class="cov8" title="1">{
                p.data = make(page.Data)

                if p.Kind() == page.KindPage </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">switch p.Kind() </span>{
                case page.KindTaxonomy:<span class="cov0" title="0">
                        bucket := p.bucket
                        meta := bucket.meta
                        plural := maps.GetString(meta, "plural")
                        singular := maps.GetString(meta, "singular")

                        taxonomy := p.s.Taxonomies[plural].Get(maps.GetString(meta, "termKey"))

                        p.data[singular] = taxonomy
                        p.data["Singular"] = meta["singular"]
                        p.data["Plural"] = plural
                        p.data["Term"] = meta["term"]</span>
                case page.KindTaxonomyTerm:<span class="cov8" title="1">
                        bucket := p.bucket
                        meta := bucket.meta
                        plural := maps.GetString(meta, "plural")
                        singular := maps.GetString(meta, "singular")

                        p.data["Singular"] = singular
                        p.data["Plural"] = plural
                        p.data["Terms"] = p.s.Taxonomies[plural]
                        // keep the following just for legacy reasons
                        p.data["OrderedIndex"] = p.data["Terms"]
                        p.data["Index"] = p.data["Terms"]</span>
                }

                // Assign the function to the map to make sure it is lazily initialized
                <span class="cov8" title="1">p.data["pages"] = p.Pages</span>

        })

        <span class="cov8" title="1">return p.data</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "sync"

        "github.com/gohugoio/hugo/navigation"
)

type pageMenus struct {
        p *pageState

        q navigation.MenuQueryProvider

        pmInit sync.Once
        pm     navigation.PageMenus
}

func (p *pageMenus) HasMenuCurrent(menuID string, me *navigation.MenuEntry) bool <span class="cov0" title="0">{
        p.p.s.init.menus.Do()
        p.init()
        return p.q.HasMenuCurrent(menuID, me)
}</span>

func (p *pageMenus) IsMenuCurrent(menuID string, inme *navigation.MenuEntry) bool <span class="cov0" title="0">{
        p.p.s.init.menus.Do()
        p.init()
        return p.q.IsMenuCurrent(menuID, inme)
}</span>

func (p *pageMenus) Menus() navigation.PageMenus <span class="cov0" title="0">{
        // There is a reverse dependency here. initMenus will, once, build the
        // site menus and update any relevant page.
        p.p.s.init.menus.Do()

        return p.menus()
}</span>

func (p *pageMenus) menus() navigation.PageMenus <span class="cov8" title="1">{
        p.init()
        return p.pm

}</span>

func (p *pageMenus) init() <span class="cov8" title="1">{
        p.pmInit.Do(func() </span><span class="cov8" title="1">{
                p.q = navigation.NewMenuQueryProvider(
                        p.p.s.Info.sectionPagesMenu,
                        p,
                        p.p.s,
                        p.p,
                )

                var err error
                p.pm, err = navigation.PageMenusFromPage(p.p)
                if err != nil </span><span class="cov0" title="0">{
                        p.p.s.Log.ERROR.Println(p.p.wrapError(err))
                }</span>

        })

}
</pre>
		
		<pre class="file" id="file108" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "path"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/common/hugo"

        "github.com/gohugoio/hugo/related"

        "github.com/gohugoio/hugo/source"
        "github.com/markbates/inflect"
        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/page/pagemeta"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/spf13/cast"
)

var cjkRe = regexp.MustCompile(`\p{Han}|\p{Hangul}|\p{Hiragana}|\p{Katakana}`)

type pageMeta struct {
        // kind is the discriminator that identifies the different page types
        // in the different page collections. This can, as an example, be used
        // to to filter regular pages, find sections etc.
        // Kind will, for the pages available to the templates, be one of:
        // page, home, section, taxonomy and taxonomyTerm.
        // It is of string type to make it easy to reason about in
        // the templates.
        kind string

        // This is a standalone page not part of any page collection. These
        // include sitemap, robotsTXT and similar. It will have no pageOutputs, but
        // a fixed pageOutput.
        standalone bool

        bundleType string

        // Params contains configuration defined in the params section of page frontmatter.
        params map[string]interface{}

        title     string
        linkTitle string

        summary string

        resourcePath string

        weight int

        markup      string
        contentType string

        // whether the content is in a CJK language.
        isCJKLanguage bool

        layout string

        aliases []string

        draft bool

        description string
        keywords    []string

        urlPaths pagemeta.URLPath

        resource.Dates

        // This is enabled if it is a leaf bundle (the "index.md" type) and it is marked as headless in front matter.
        // Being headless means that
        // 1. The page itself is not rendered to disk
        // 2. It is not available in .Site.Pages etc.
        // 3. But you can get it via .Site.GetPage
        headless bool

        // Set if this page is bundled inside another.
        bundled bool

        // A key that maps to translation(s) of this page. This value is fetched
        // from the page front matter.
        translationKey string

        // From front matter.
        configuredOutputFormats output.Formats

        // This is the raw front matter metadata that is going to be assigned to
        // the Resources above.
        resourcesMetadata []map[string]interface{}

        f source.File

        sections []string

        // Sitemap overrides from front matter.
        sitemap config.Sitemap

        s *Site

        renderingConfig *helpers.BlackFriday
}

func (p *pageMeta) Aliases() []string <span class="cov8" title="1">{
        return p.aliases
}</span>

func (p *pageMeta) Author() page.Author <span class="cov0" title="0">{
        authors := p.Authors()

        for _, author := range authors </span><span class="cov0" title="0">{
                return author
        }</span>
        <span class="cov0" title="0">return page.Author{}</span>
}

func (p *pageMeta) Authors() page.AuthorList <span class="cov0" title="0">{
        authorKeys, ok := p.params["authors"]
        if !ok </span><span class="cov0" title="0">{
                return page.AuthorList{}
        }</span>
        <span class="cov0" title="0">authors := authorKeys.([]string)
        if len(authors) &lt; 1 || len(p.s.Info.Authors) &lt; 1 </span><span class="cov0" title="0">{
                return page.AuthorList{}
        }</span>

        <span class="cov0" title="0">al := make(page.AuthorList)
        for _, author := range authors </span><span class="cov0" title="0">{
                a, ok := p.s.Info.Authors[author]
                if ok </span><span class="cov0" title="0">{
                        al[author] = a
                }</span>
        }
        <span class="cov0" title="0">return al</span>
}

func (p *pageMeta) BundleType() string <span class="cov0" title="0">{
        return p.bundleType
}</span>

func (p *pageMeta) Description() string <span class="cov8" title="1">{
        return p.description
}</span>

func (p *pageMeta) Lang() string <span class="cov0" title="0">{
        return p.s.Lang()
}</span>

func (p *pageMeta) Draft() bool <span class="cov8" title="1">{
        return p.draft
}</span>

func (p *pageMeta) File() source.File <span class="cov8" title="1">{
        return p.f
}</span>

func (p *pageMeta) IsHome() bool <span class="cov8" title="1">{
        return p.Kind() == page.KindHome
}</span>

func (p *pageMeta) Keywords() []string <span class="cov0" title="0">{
        return p.keywords
}</span>

func (p *pageMeta) Kind() string <span class="cov8" title="1">{
        return p.kind
}</span>

func (p *pageMeta) Layout() string <span class="cov8" title="1">{
        return p.layout
}</span>

func (p *pageMeta) LinkTitle() string <span class="cov8" title="1">{
        if p.linkTitle != "" </span><span class="cov0" title="0">{
                return p.linkTitle
        }</span>

        <span class="cov8" title="1">return p.Title()</span>
}

func (p *pageMeta) Name() string <span class="cov0" title="0">{
        if p.resourcePath != "" </span><span class="cov0" title="0">{
                return p.resourcePath
        }</span>
        <span class="cov0" title="0">return p.Title()</span>
}

func (p *pageMeta) IsNode() bool <span class="cov8" title="1">{
        return !p.IsPage()
}</span>

func (p *pageMeta) IsPage() bool <span class="cov8" title="1">{
        return p.Kind() == page.KindPage
}</span>

// Param is a convenience method to do lookups in Page's and Site's Params map,
// in that order.
//
// This method is also implemented on SiteInfo.
// TODO(bep) interface
func (p *pageMeta) Param(key interface{}) (interface{}, error) <span class="cov8" title="1">{
        return resource.Param(p, p.s.Info.Params(), key)
}</span>

func (p *pageMeta) Params() map[string]interface{} <span class="cov8" title="1">{
        return p.params
}</span>

func (p *pageMeta) Path() string <span class="cov0" title="0">{
        if !p.File().IsZero() </span><span class="cov0" title="0">{
                return p.File().Path()
        }</span>
        <span class="cov0" title="0">return p.SectionsPath()</span>
}

// RelatedKeywords implements the related.Document interface needed for fast page searches.
func (p *pageMeta) RelatedKeywords(cfg related.IndexConfig) ([]related.Keyword, error) <span class="cov8" title="1">{

        v, err := p.Param(cfg.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return cfg.ToKeywords(v)</span>
}

func (p *pageMeta) IsSection() bool <span class="cov8" title="1">{
        return p.Kind() == page.KindSection
}</span>

func (p *pageMeta) Section() string <span class="cov8" title="1">{
        if p.IsHome() </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if p.IsNode() </span><span class="cov8" title="1">{
                if len(p.sections) == 0 </span><span class="cov0" title="0">{
                        // May be a sitemap or similar.
                        return ""
                }</span>
                <span class="cov8" title="1">return p.sections[0]</span>
        }

        <span class="cov8" title="1">if !p.File().IsZero() </span><span class="cov8" title="1">{
                return p.File().Section()
        }</span>

        <span class="cov0" title="0">panic("invalid page state")</span>

}

func (p *pageMeta) SectionsEntries() []string <span class="cov8" title="1">{
        return p.sections
}</span>

func (p *pageMeta) SectionsPath() string <span class="cov8" title="1">{
        return path.Join(p.SectionsEntries()...)
}</span>

func (p *pageMeta) Sitemap() config.Sitemap <span class="cov8" title="1">{
        return p.sitemap
}</span>

func (p *pageMeta) Title() string <span class="cov8" title="1">{
        return p.title
}</span>

func (p *pageMeta) Type() string <span class="cov8" title="1">{
        if p.contentType != "" </span><span class="cov0" title="0">{
                return p.contentType
        }</span>

        <span class="cov8" title="1">if x := p.Section(); x != "" </span><span class="cov8" title="1">{
                return x
        }</span>

        <span class="cov8" title="1">return "page"</span>
}

func (p *pageMeta) Weight() int <span class="cov8" title="1">{
        return p.weight
}</span>

func (pm *pageMeta) setMetadata(bucket *pagesMapBucket, p *pageState, frontmatter map[string]interface{}) error <span class="cov8" title="1">{
        if frontmatter == nil &amp;&amp; bucket.cascade == nil </span><span class="cov0" title="0">{
                return errors.New("missing frontmatter data")
        }</span>

        <span class="cov8" title="1">pm.params = make(map[string]interface{})

        if frontmatter != nil </span><span class="cov8" title="1">{
                // Needed for case insensitive fetching of params values
                maps.ToLower(frontmatter)
                if p.IsNode() </span><span class="cov8" title="1">{
                        // Check for any cascade define on itself.
                        if cv, found := frontmatter["cascade"]; found </span><span class="cov0" title="0">{
                                cvm := cast.ToStringMap(cv)
                                if bucket.cascade == nil </span><span class="cov0" title="0">{
                                        bucket.cascade = cvm
                                }</span> else<span class="cov0" title="0"> {
                                        for k, v := range cvm </span><span class="cov0" title="0">{
                                                bucket.cascade[k] = v
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">if bucket != nil &amp;&amp; bucket.cascade != nil </span><span class="cov8" title="1">{
                        for k, v := range bucket.cascade </span><span class="cov0" title="0">{
                                if _, found := frontmatter[k]; !found </span><span class="cov0" title="0">{
                                        frontmatter[k] = v
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                frontmatter = make(map[string]interface{})
                for k, v := range bucket.cascade </span><span class="cov0" title="0">{
                        frontmatter[k] = v
                }</span>
        }

        <span class="cov8" title="1">var mtime time.Time
        var contentBaseName string
        if !p.File().IsZero() </span><span class="cov8" title="1">{
                contentBaseName = p.File().ContentBaseName()
                if p.File().FileInfo() != nil </span><span class="cov8" title="1">{
                        mtime = p.File().FileInfo().ModTime()
                }</span>
        }

        <span class="cov8" title="1">var gitAuthorDate time.Time
        if p.gitInfo != nil </span><span class="cov0" title="0">{
                gitAuthorDate = p.gitInfo.AuthorDate
        }</span>

        <span class="cov8" title="1">descriptor := &amp;pagemeta.FrontMatterDescriptor{
                Frontmatter:   frontmatter,
                Params:        pm.params,
                Dates:         &amp;pm.Dates,
                PageURLs:      &amp;pm.urlPaths,
                BaseFilename:  contentBaseName,
                ModTime:       mtime,
                GitAuthorDate: gitAuthorDate,
        }

        // Handle the date separately
        // TODO(bep) we need to "do more" in this area so this can be split up and
        // more easily tested without the Page, but the coupling is strong.
        err := pm.s.frontmatterHandler.HandleDates(descriptor)
        if err != nil </span><span class="cov0" title="0">{
                p.s.Log.ERROR.Printf("Failed to handle dates for page %q: %s", p.pathOrTitle(), err)
        }</span>

        <span class="cov8" title="1">var sitemapSet bool

        var draft, published, isCJKLanguage *bool
        for k, v := range frontmatter </span><span class="cov8" title="1">{
                loki := strings.ToLower(k)

                if loki == "published" </span><span class="cov0" title="0">{ // Intentionally undocumented
                        vv, err := cast.ToBoolE(v)
                        if err == nil </span><span class="cov0" title="0">{
                                published = &amp;vv
                        }</span>
                        // published may also be a date
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">if pm.s.frontmatterHandler.IsDateKey(loki) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">switch loki </span>{
                case "title":<span class="cov8" title="1">
                        pm.title = cast.ToString(v)
                        pm.params[loki] = pm.title</span>
                case "linktitle":<span class="cov0" title="0">
                        pm.linkTitle = cast.ToString(v)
                        pm.params[loki] = pm.linkTitle</span>
                case "summary":<span class="cov0" title="0">
                        pm.summary = cast.ToString(v)
                        pm.params[loki] = pm.summary</span>
                case "description":<span class="cov0" title="0">
                        pm.description = cast.ToString(v)
                        pm.params[loki] = pm.description</span>
                case "slug":<span class="cov0" title="0">
                        // Don't start or end with a -
                        pm.urlPaths.Slug = strings.Trim(cast.ToString(v), "-")
                        pm.params[loki] = pm.Slug()</span>
                case "url":<span class="cov0" title="0">
                        url := cast.ToString(v)
                        if strings.HasPrefix(url, "http://") || strings.HasPrefix(url, "https://") </span><span class="cov0" title="0">{
                                return fmt.Errorf("URLs with protocol (http*) not supported: %q. In page %q", url, p.pathOrTitle())
                        }</span>
                        <span class="cov0" title="0">lang := p.s.GetLanguagePrefix()
                        if lang != "" &amp;&amp; !strings.HasPrefix(url, "/") &amp;&amp; strings.HasPrefix(url, lang+"/") </span><span class="cov0" title="0">{
                                if strings.HasPrefix(hugo.CurrentVersion.String(), "0.55") </span><span class="cov0" title="0">{
                                        // We added support for page relative URLs in Hugo 0.55 and
                                        // this may get its language path added twice.
                                        // TODO(bep) eventually remove this.
                                        p.s.Log.WARN.Printf(`Front matter in %q with the url %q with no leading / has what looks like the language prefix added. In Hugo 0.55 we added support for page relative URLs in front matter, no language prefix needed. Check the URL and consider to either add a leading / or remove the language prefix.`, p.pathOrTitle(), url)

                                }</span>
                        }
                        <span class="cov0" title="0">pm.urlPaths.URL = url
                        pm.params[loki] = url</span>
                case "type":<span class="cov0" title="0">
                        pm.contentType = cast.ToString(v)
                        pm.params[loki] = pm.contentType</span>
                case "keywords":<span class="cov0" title="0">
                        pm.keywords = cast.ToStringSlice(v)
                        pm.params[loki] = pm.keywords</span>
                case "headless":<span class="cov0" title="0">
                        // For now, only the leaf bundles ("index.md") can be headless (i.e. produce no output).
                        // We may expand on this in the future, but that gets more complex pretty fast.
                        if p.File().TranslationBaseName() == "index" </span><span class="cov0" title="0">{
                                pm.headless = cast.ToBool(v)
                        }</span>
                        <span class="cov0" title="0">pm.params[loki] = pm.headless</span>
                case "outputs":<span class="cov0" title="0">
                        o := cast.ToStringSlice(v)
                        if len(o) &gt; 0 </span><span class="cov0" title="0">{
                                // Output formats are exlicitly set in front matter, use those.
                                outFormats, err := p.s.outputFormatsConfig.GetByNames(o...)

                                if err != nil </span><span class="cov0" title="0">{
                                        p.s.Log.ERROR.Printf("Failed to resolve output formats: %s", err)
                                }</span> else<span class="cov0" title="0"> {
                                        pm.configuredOutputFormats = outFormats
                                        pm.params[loki] = outFormats
                                }</span>

                        }
                case "draft":<span class="cov0" title="0">
                        draft = new(bool)
                        *draft = cast.ToBool(v)</span>
                case "layout":<span class="cov0" title="0">
                        pm.layout = cast.ToString(v)
                        pm.params[loki] = pm.layout</span>
                case "markup":<span class="cov0" title="0">
                        pm.markup = cast.ToString(v)
                        pm.params[loki] = pm.markup</span>
                case "weight":<span class="cov0" title="0">
                        pm.weight = cast.ToInt(v)
                        pm.params[loki] = pm.weight</span>
                case "aliases":<span class="cov0" title="0">
                        pm.aliases = cast.ToStringSlice(v)
                        for i, alias := range pm.aliases </span><span class="cov0" title="0">{
                                if strings.HasPrefix(alias, "http://") || strings.HasPrefix(alias, "https://") </span><span class="cov0" title="0">{
                                        return fmt.Errorf("http* aliases not supported: %q", alias)
                                }</span>
                                <span class="cov0" title="0">pm.aliases[i] = filepath.ToSlash(alias)</span>
                        }
                        <span class="cov0" title="0">pm.params[loki] = pm.aliases</span>
                case "sitemap":<span class="cov0" title="0">
                        p.m.sitemap = config.DecodeSitemap(p.s.siteCfg.sitemap, cast.ToStringMap(v))
                        pm.params[loki] = p.m.sitemap
                        sitemapSet = true</span>
                case "iscjklanguage":<span class="cov0" title="0">
                        isCJKLanguage = new(bool)
                        *isCJKLanguage = cast.ToBool(v)</span>
                case "translationkey":<span class="cov0" title="0">
                        pm.translationKey = cast.ToString(v)
                        pm.params[loki] = pm.translationKey</span>
                case "resources":<span class="cov0" title="0">
                        var resources []map[string]interface{}
                        handled := true

                        switch vv := v.(type) </span>{
                        case []map[interface{}]interface{}:<span class="cov0" title="0">
                                for _, vvv := range vv </span><span class="cov0" title="0">{
                                        resources = append(resources, cast.ToStringMap(vvv))
                                }</span>
                        case []map[string]interface{}:<span class="cov0" title="0">
                                resources = append(resources, vv...)</span>
                        case []interface{}:<span class="cov0" title="0">
                                for _, vvv := range vv </span><span class="cov0" title="0">{
                                        switch vvvv := vvv.(type) </span>{
                                        case map[interface{}]interface{}:<span class="cov0" title="0">
                                                resources = append(resources, cast.ToStringMap(vvvv))</span>
                                        case map[string]interface{}:<span class="cov0" title="0">
                                                resources = append(resources, vvvv)</span>
                                        }
                                }
                        default:<span class="cov0" title="0">
                                handled = false</span>
                        }

                        <span class="cov0" title="0">if handled </span><span class="cov0" title="0">{
                                pm.params[loki] = resources
                                pm.resourcesMetadata = resources
                                break</span>
                        }
                        <span class="cov0" title="0">fallthrough</span>

                default:<span class="cov0" title="0">
                        // If not one of the explicit values, store in Params
                        switch vv := v.(type) </span>{
                        case bool:<span class="cov0" title="0">
                                pm.params[loki] = vv</span>
                        case string:<span class="cov0" title="0">
                                pm.params[loki] = vv</span>
                        case int64, int32, int16, int8, int:<span class="cov0" title="0">
                                pm.params[loki] = vv</span>
                        case float64, float32:<span class="cov0" title="0">
                                pm.params[loki] = vv</span>
                        case time.Time:<span class="cov0" title="0">
                                pm.params[loki] = vv</span>
                        default:<span class="cov0" title="0"> // handle array of strings as well
                                switch vvv := vv.(type) </span>{
                                case []interface{}:<span class="cov0" title="0">
                                        if len(vvv) &gt; 0 </span><span class="cov0" title="0">{
                                                switch vvv[0].(type) </span>{
                                                case map[interface{}]interface{}:<span class="cov0" title="0"> // Proper parsing structured array from YAML based FrontMatter
                                                        pm.params[loki] = vvv</span>
                                                case map[string]interface{}:<span class="cov0" title="0"> // Proper parsing structured array from JSON based FrontMatter
                                                        pm.params[loki] = vvv</span>
                                                case []interface{}:<span class="cov0" title="0">
                                                        pm.params[loki] = vvv</span>
                                                default:<span class="cov0" title="0">
                                                        a := make([]string, len(vvv))
                                                        for i, u := range vvv </span><span class="cov0" title="0">{
                                                                a[i] = cast.ToString(u)
                                                        }</span>

                                                        <span class="cov0" title="0">pm.params[loki] = a</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                pm.params[loki] = []string{}
                                        }</span>
                                default:<span class="cov0" title="0">
                                        pm.params[loki] = vv</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">if !sitemapSet </span><span class="cov8" title="1">{
                pm.sitemap = p.s.siteCfg.sitemap
        }</span>

        <span class="cov8" title="1">pm.markup = helpers.GuessType(pm.markup)

        if draft != nil &amp;&amp; published != nil </span><span class="cov0" title="0">{
                pm.draft = *draft
                p.m.s.Log.WARN.Printf("page %q has both draft and published settings in its frontmatter. Using draft.", p.File().Filename())
        }</span> else<span class="cov8" title="1"> if draft != nil </span><span class="cov0" title="0">{
                pm.draft = *draft
        }</span> else<span class="cov8" title="1"> if published != nil </span><span class="cov0" title="0">{
                pm.draft = !*published
        }</span>
        <span class="cov8" title="1">pm.params["draft"] = pm.draft

        if isCJKLanguage != nil </span><span class="cov0" title="0">{
                pm.isCJKLanguage = *isCJKLanguage
        }</span> else<span class="cov8" title="1"> if p.s.siteCfg.hasCJKLanguage &amp;&amp; p.source.parsed != nil </span><span class="cov0" title="0">{
                if cjkRe.Match(p.source.parsed.Input()) </span><span class="cov0" title="0">{
                        pm.isCJKLanguage = true
                }</span> else<span class="cov0" title="0"> {
                        pm.isCJKLanguage = false
                }</span>
        }

        <span class="cov8" title="1">pm.params["iscjklanguage"] = p.m.isCJKLanguage

        return nil</span>
}

func (p *pageMeta) applyDefaultValues() error <span class="cov8" title="1">{
        if p.markup == "" </span><span class="cov8" title="1">{
                if !p.File().IsZero() </span><span class="cov8" title="1">{
                        // Fall back to file extension
                        p.markup = helpers.GuessType(p.File().Ext())
                }</span>
                <span class="cov8" title="1">if p.markup == "" </span><span class="cov8" title="1">{
                        p.markup = "unknown"
                }</span>
        }

        <span class="cov8" title="1">if p.title == "" &amp;&amp; p.f.IsZero() </span><span class="cov8" title="1">{
                switch p.Kind() </span>{
                case page.KindHome:<span class="cov8" title="1">
                        p.title = p.s.Info.title</span>
                case page.KindSection:<span class="cov8" title="1">
                        sectionName := helpers.FirstUpper(p.sections[0])
                        if p.s.Cfg.GetBool("pluralizeListTitles") </span><span class="cov8" title="1">{
                                p.title = inflect.Pluralize(sectionName)
                        }</span> else<span class="cov0" title="0"> {
                                p.title = sectionName
                        }</span>
                case page.KindTaxonomy:<span class="cov0" title="0">
                        key := p.sections[len(p.sections)-1]
                        p.title = strings.Replace(p.s.titleFunc(key), "-", " ", -1)</span>
                case page.KindTaxonomyTerm:<span class="cov8" title="1">
                        p.title = p.s.titleFunc(p.sections[0])</span>
                case kind404:<span class="cov8" title="1">
                        p.title = "404 Page not found"</span>

                }
        }

        <span class="cov8" title="1">if p.IsNode() </span><span class="cov8" title="1">{
                p.bundleType = files.ContentClassBranch
        }</span> else<span class="cov8" title="1"> {
                source := p.File()
                if fi, ok := source.(*fileInfo); ok </span><span class="cov8" title="1">{
                        class := fi.FileInfo().Meta().Classifier()
                        switch class </span>{
                        case files.ContentClassBranch, files.ContentClassLeaf:<span class="cov0" title="0">
                                p.bundleType = class</span>
                        }
                }
        }

        <span class="cov8" title="1">bfParam := getParamToLower(p, "blackfriday")
        if bfParam != nil </span><span class="cov0" title="0">{
                p.renderingConfig = p.s.ContentSpec.BlackFriday

                // Create a copy so we can modify it.
                bf := *p.s.ContentSpec.BlackFriday
                p.renderingConfig = &amp;bf
                pageParam := cast.ToStringMap(bfParam)
                if err := mapstructure.Decode(pageParam, &amp;p.renderingConfig); err != nil </span><span class="cov0" title="0">{
                        return errors.WithMessage(err, "failed to decode rendering config")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>

}

// The output formats this page will be rendered to.
func (m *pageMeta) outputFormats() output.Formats <span class="cov8" title="1">{
        if len(m.configuredOutputFormats) &gt; 0 </span><span class="cov8" title="1">{
                return m.configuredOutputFormats
        }</span>

        <span class="cov8" title="1">return m.s.outputFormats[m.Kind()]</span>
}

func (p *pageMeta) Slug() string <span class="cov8" title="1">{
        return p.urlPaths.Slug
}</span>

func getParam(m resource.ResourceParamsProvider, key string, stringToLower bool) interface{} <span class="cov8" title="1">{
        v := m.Params()[strings.ToLower(key)]

        if v == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">switch val := v.(type) </span>{
        case bool:<span class="cov0" title="0">
                return val</span>
        case string:<span class="cov0" title="0">
                if stringToLower </span><span class="cov0" title="0">{
                        return strings.ToLower(val)
                }</span>
                <span class="cov0" title="0">return val</span>
        case int64, int32, int16, int8, int:<span class="cov0" title="0">
                return cast.ToInt(v)</span>
        case float64, float32:<span class="cov0" title="0">
                return cast.ToFloat64(v)</span>
        case time.Time:<span class="cov0" title="0">
                return val</span>
        case []string:<span class="cov0" title="0">
                if stringToLower </span><span class="cov0" title="0">{
                        return helpers.SliceToLower(val)
                }</span>
                <span class="cov0" title="0">return v</span>
        case map[string]interface{}:<span class="cov0" title="0"> // JSON and TOML
                return v</span>
        case map[interface{}]interface{}:<span class="cov0" title="0"> // YAML
                return v</span>
        }

        //p.s.Log.ERROR.Printf("GetParam(\"%s\"): Unknown type %s\n", key, reflect.TypeOf(v))
        <span class="cov0" title="0">return nil</span>
}

func getParamToLower(m resource.ResourceParamsProvider, key string) interface{} <span class="cov8" title="1">{
        return getParam(m, key, true)
}</span>
</pre>
		
		<pre class="file" id="file109" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "html/template"
        "strings"

        "github.com/gohugoio/hugo/common/hugo"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/source"

        "github.com/gohugoio/hugo/parser/pageparser"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/output"

        "github.com/gohugoio/hugo/lazy"

        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"
)

func newPageBase(metaProvider *pageMeta) (*pageState, error) <span class="cov8" title="1">{
        if metaProvider.s == nil </span><span class="cov0" title="0">{
                panic("must provide a Site")</span>
        }

        <span class="cov8" title="1">s := metaProvider.s

        ps := &amp;pageState{
                pageOutput: nopPageOutput,
                pageCommon: &amp;pageCommon{
                        FileProvider:            metaProvider,
                        AuthorProvider:          metaProvider,
                        Scratcher:               maps.NewScratcher(),
                        Positioner:              page.NopPage,
                        InSectionPositioner:     page.NopPage,
                        ResourceMetaProvider:    metaProvider,
                        ResourceParamsProvider:  metaProvider,
                        PageMetaProvider:        metaProvider,
                        RelatedKeywordsProvider: metaProvider,
                        OutputFormatsProvider:   page.NopPage,
                        ResourceTypesProvider:   pageTypesProvider,
                        RefProvider:             page.NopPage,
                        ShortcodeInfoProvider:   page.NopPage,
                        LanguageProvider:        s,
                        pagePages:               &amp;pagePages{},

                        InternalDependencies: s,
                        init:                 lazy.New(),
                        m:                    metaProvider,
                        s:                    s},
        }

        siteAdapter := pageSiteAdapter{s: s, p: ps}

        deprecatedWarningPage := struct {
                source.FileWithoutOverlap
                page.DeprecatedWarningPageMethods1
        }{
                FileWithoutOverlap:            metaProvider.File(),
                DeprecatedWarningPageMethods1: &amp;pageDeprecatedWarning{p: ps},
        }

        ps.DeprecatedWarningPageMethods = page.NewDeprecatedWarningPage(deprecatedWarningPage)
        ps.pageMenus = &amp;pageMenus{p: ps}
        ps.PageMenusProvider = ps.pageMenus
        ps.GetPageProvider = siteAdapter
        ps.GitInfoProvider = ps
        ps.TranslationsProvider = ps
        ps.ResourceDataProvider = &amp;pageData{pageState: ps}
        ps.RawContentProvider = ps
        ps.ChildCareProvider = ps
        ps.TreeProvider = pageTree{p: ps}
        ps.Eqer = ps
        ps.TranslationKeyProvider = ps
        ps.ShortcodeInfoProvider = ps
        ps.PageRenderProvider = ps
        ps.AlternativeOutputFormatsProvider = ps

        return ps, nil</span>

}

func newPageFromMeta(meta map[string]interface{}, metaProvider *pageMeta) (*pageState, error) <span class="cov8" title="1">{
        if metaProvider.f == nil </span><span class="cov8" title="1">{
                metaProvider.f = page.NewZeroFile(metaProvider.s.DistinctWarningLog)
        }</span>

        <span class="cov8" title="1">ps, err := newPageBase(metaProvider)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">initMeta := func(bucket *pagesMapBucket) error </span><span class="cov8" title="1">{
                if meta != nil || bucket != nil </span><span class="cov8" title="1">{
                        if err := metaProvider.setMetadata(bucket, ps, meta); err != nil </span><span class="cov0" title="0">{
                                return ps.wrapError(err)
                        }</span>
                }

                <span class="cov8" title="1">if err := metaProvider.applyDefaultValues(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if metaProvider.standalone </span><span class="cov8" title="1">{
                initMeta(nil)
        }</span> else<span class="cov8" title="1"> {
                // Because of possible cascade keywords, we need to delay this
                // until we have the complete page graph.
                ps.metaInitFn = initMeta
        }</span>

        <span class="cov8" title="1">ps.init.Add(func() (interface{}, error) </span><span class="cov8" title="1">{
                pp, err := newPagePaths(metaProvider.s, ps, metaProvider)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">makeOut := func(f output.Format, render bool) *pageOutput </span><span class="cov8" title="1">{
                        return newPageOutput(nil, ps, pp, f, render)
                }</span>

                <span class="cov8" title="1">if ps.m.standalone </span><span class="cov8" title="1">{
                        ps.pageOutput = makeOut(ps.m.outputFormats()[0], true)
                }</span> else<span class="cov8" title="1"> {
                        ps.pageOutputs = make([]*pageOutput, len(ps.s.h.renderFormats))
                        created := make(map[string]*pageOutput)
                        outputFormatsForPage := ps.m.outputFormats()
                        for i, f := range ps.s.h.renderFormats </span><span class="cov8" title="1">{
                                po, found := created[f.Name]
                                if !found </span><span class="cov8" title="1">{
                                        _, shouldRender := outputFormatsForPage.GetByName(f.Name)
                                        po = makeOut(f, shouldRender)
                                        created[f.Name] = po
                                }</span>
                                <span class="cov8" title="1">ps.pageOutputs[i] = po</span>
                        }
                }

                <span class="cov8" title="1">if err := ps.initCommonProviders(pp); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return nil, nil</span>

        })

        <span class="cov8" title="1">return ps, err</span>

}

// Used by the legacy 404, sitemap and robots.txt rendering
func newPageStandalone(m *pageMeta, f output.Format) (*pageState, error) <span class="cov8" title="1">{
        m.configuredOutputFormats = output.Formats{f}
        m.standalone = true
        p, err := newPageFromMeta(nil, m)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := p.initPage(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return p, nil</span>

}

func newPageWithContent(f *fileInfo, s *Site, bundled bool, content resource.OpenReadSeekCloser) (*pageState, error) <span class="cov8" title="1">{
        sections := s.sectionsFromFile(f)
        kind := s.kindFromFileInfoOrSections(f, sections)
        if kind == page.KindTaxonomy </span><span class="cov0" title="0">{
                s.PathSpec.MakePathsSanitized(sections)
        }</span>

        <span class="cov8" title="1">metaProvider := &amp;pageMeta{kind: kind, sections: sections, bundled: bundled, s: s, f: f}

        ps, err := newPageBase(metaProvider)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">gi, err := s.h.gitInfoForPage(ps)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to load Git data")
        }</span>
        <span class="cov8" title="1">ps.gitInfo = gi

        r, err := content()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer r.Close()

        parseResult, err := pageparser.Parse(
                r,
                pageparser.Config{EnableEmoji: s.siteCfg.enableEmoji},
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ps.pageContent = pageContent{
                source: rawPageContent{
                        parsed:         parseResult,
                        posMainContent: -1,
                        posSummaryEnd:  -1,
                        posBodyStart:   -1,
                },
        }

        ps.shortcodeState = newShortcodeHandler(ps, ps.s, nil)

        ps.metaInitFn = func(bucket *pagesMapBucket) error </span><span class="cov8" title="1">{
                if err := ps.mapContent(bucket, metaProvider); err != nil </span><span class="cov0" title="0">{
                        return ps.wrapError(err)
                }</span>

                <span class="cov8" title="1">if err := metaProvider.applyDefaultValues(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">ps.init.Add(func() (interface{}, error) </span><span class="cov8" title="1">{
                reuseContent := ps.renderable &amp;&amp; !ps.shortcodeState.hasShortcodes()

                // Creates what's needed for each output format.
                contentPerOutput := newPageContentOutput(ps)

                pp, err := newPagePaths(s, ps, metaProvider)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Prepare output formats for all sites.
                <span class="cov8" title="1">ps.pageOutputs = make([]*pageOutput, len(ps.s.h.renderFormats))
                created := make(map[string]*pageOutput)
                outputFormatsForPage := ps.m.outputFormats()

                for i, f := range ps.s.h.renderFormats </span><span class="cov8" title="1">{
                        if po, found := created[f.Name]; found </span><span class="cov0" title="0">{
                                ps.pageOutputs[i] = po
                                continue</span>
                        }

                        <span class="cov8" title="1">_, render := outputFormatsForPage.GetByName(f.Name)
                        var contentProvider *pageContentOutput
                        if reuseContent &amp;&amp; i &gt; 0 </span><span class="cov8" title="1">{
                                contentProvider = ps.pageOutputs[0].cp
                        }</span> else<span class="cov8" title="1"> {
                                var err error
                                contentProvider, err = contentPerOutput(f)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }

                        <span class="cov8" title="1">po := newPageOutput(contentProvider, ps, pp, f, render)
                        ps.pageOutputs[i] = po
                        created[f.Name] = po</span>
                }

                <span class="cov8" title="1">if err := ps.initCommonProviders(pp); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">return ps, nil</span>
}

type pageDeprecatedWarning struct {
        p *pageState
}

func (p *pageDeprecatedWarning) IsDraft() bool          <span class="cov0" title="0">{ return p.p.m.draft }</span>
func (p *pageDeprecatedWarning) Hugo() hugo.Info        <span class="cov8" title="1">{ return p.p.s.Info.Hugo() }</span>
func (p *pageDeprecatedWarning) LanguagePrefix() string <span class="cov0" title="0">{ return p.p.s.Info.LanguagePrefix }</span>
func (p *pageDeprecatedWarning) GetParam(key string) interface{} <span class="cov0" title="0">{
        return p.p.m.params[strings.ToLower(key)]
}</span>
func (p *pageDeprecatedWarning) RSSLink() template.URL <span class="cov8" title="1">{
        f := p.p.OutputFormats().Get("RSS")
        if f == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return template.URL(f.Permalink())</span>
}
func (p *pageDeprecatedWarning) URL() string <span class="cov8" title="1">{
        if p.p.IsPage() &amp;&amp; p.p.m.urlPaths.URL != "" </span><span class="cov0" title="0">{
                // This is the url set in front matter
                return p.p.m.urlPaths.URL
        }</span>
        // Fall back to the relative permalink.
        <span class="cov8" title="1">return p.p.RelPermalink()</span>

}
</pre>
		
		<pre class="file" id="file110" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"
)

func newPageOutput(
        cp *pageContentOutput, // may be nil
        ps *pageState,
        pp pagePaths,
        f output.Format,
        render bool) *pageOutput <span class="cov8" title="1">{

        var targetPathsProvider targetPathsHolder
        var linksProvider resource.ResourceLinksProvider

        ft, found := pp.targetPaths[f.Name]
        if !found </span><span class="cov8" title="1">{
                // Link to the main output format
                ft = pp.targetPaths[pp.OutputFormats()[0].Format.Name]
        }</span>
        <span class="cov8" title="1">targetPathsProvider = ft
        linksProvider = ft

        var paginatorProvider page.PaginatorProvider = page.NopPage
        var pag *pagePaginator

        if render &amp;&amp; ps.IsNode() </span><span class="cov8" title="1">{
                pag = newPagePaginator(ps)
                paginatorProvider = pag
        }</span>

        <span class="cov8" title="1">var contentProvider page.ContentProvider = page.NopPage
        var tableOfContentsProvider page.TableOfContentsProvider = page.NopPage

        if cp != nil </span><span class="cov8" title="1">{
                contentProvider = cp
                tableOfContentsProvider = cp
        }</span>

        <span class="cov8" title="1">providers := struct {
                page.ContentProvider
                page.TableOfContentsProvider
                page.PaginatorProvider
                resource.ResourceLinksProvider
                targetPather
        }{
                contentProvider,
                tableOfContentsProvider,
                paginatorProvider,
                linksProvider,
                targetPathsProvider,
        }

        po := &amp;pageOutput{
                f:                      f,
                cp:                     cp,
                pagePerOutputProviders: providers,
                render:                 render,
                paginator:              pag,
        }

        return po</span>

}

// We create a pageOutput for every output format combination, even if this
// particular page isn't configured to be rendered to that format.
type pageOutput struct {
        // Set if this page isn't configured to be rendered to this format.
        render bool

        f output.Format

        // Only set if render is set.
        // Note that this will be lazily initialized, so only used if actually
        // used in template(s).
        paginator *pagePaginator

        // This interface provides the functionality that is specific for this
        // output format.
        pagePerOutputProviders

        // This may be nil.
        cp *pageContentOutput
}

func (p *pageOutput) enablePlaceholders() <span class="cov0" title="0">{
        if p.cp != nil </span><span class="cov0" title="0">{
                p.cp.enablePlaceholders()
        }</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "sync"

        "github.com/gohugoio/hugo/resources/page"
)

func newPagePaginator(source *pageState) *pagePaginator <span class="cov8" title="1">{
        return &amp;pagePaginator{
                source:            source,
                pagePaginatorInit: &amp;pagePaginatorInit{},
        }
}</span>

type pagePaginator struct {
        *pagePaginatorInit
        source *pageState
}

type pagePaginatorInit struct {
        init    sync.Once
        current *page.Pager
}

// reset resets the paginator to allow for a rebuild.
func (p *pagePaginator) reset() <span class="cov0" title="0">{
        p.pagePaginatorInit = &amp;pagePaginatorInit{}
}</span>

func (p *pagePaginator) Paginate(seq interface{}, options ...interface{}) (*page.Pager, error) <span class="cov0" title="0">{
        var initErr error
        p.init.Do(func() </span><span class="cov0" title="0">{
                pagerSize, err := page.ResolvePagerSize(p.source.s.Cfg, options...)
                if err != nil </span><span class="cov0" title="0">{
                        initErr = err
                        return
                }</span>

                <span class="cov0" title="0">pd := p.source.targetPathDescriptor
                pd.Type = p.source.outputFormat()
                paginator, err := page.Paginate(pd, seq, pagerSize)
                if err != nil </span><span class="cov0" title="0">{
                        initErr = err
                        return
                }</span>

                <span class="cov0" title="0">p.current = paginator.Pagers()[0]</span>

        })

        <span class="cov0" title="0">if initErr != nil </span><span class="cov0" title="0">{
                return nil, initErr
        }</span>

        <span class="cov0" title="0">return p.current, nil</span>
}

func (p *pagePaginator) Paginator(options ...interface{}) (*page.Pager, error) <span class="cov8" title="1">{
        var initErr error
        p.init.Do(func() </span><span class="cov8" title="1">{
                pagerSize, err := page.ResolvePagerSize(p.source.s.Cfg, options...)
                if err != nil </span><span class="cov0" title="0">{
                        initErr = err
                        return
                }</span>

                <span class="cov8" title="1">pd := p.source.targetPathDescriptor
                pd.Type = p.source.outputFormat()

                var pages page.Pages
                if p.source.IsHome() </span><span class="cov0" title="0">{
                        // From Hugo 0.57 we made home.Pages() work like any other
                        // section. To avoid the default paginators for the home page
                        // changing in the wild, we make this a special case.
                        pages = p.source.s.RegularPages()
                }</span> else<span class="cov8" title="1"> {
                        pages = p.source.RegularPages()
                }</span>
                <span class="cov8" title="1">paginator, err := page.Paginate(pd, pages, pagerSize)
                if err != nil </span><span class="cov0" title="0">{
                        initErr = err
                        return
                }</span>

                <span class="cov8" title="1">p.current = paginator.Pagers()[0]</span>

        })

        <span class="cov8" title="1">if initErr != nil </span><span class="cov0" title="0">{
                return nil, initErr
        }</span>

        <span class="cov8" title="1">return p.current, nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "net/url"
        "strings"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/resources/page"
)

func newPagePaths(
        s *Site,
        p page.Page,
        pm *pageMeta) (pagePaths, error) <span class="cov8" title="1">{

        targetPathDescriptor, err := createTargetPathDescriptor(s, p, pm)
        if err != nil </span><span class="cov0" title="0">{
                return pagePaths{}, err
        }</span>

        <span class="cov8" title="1">outputFormats := pm.outputFormats()
        if len(outputFormats) == 0 </span><span class="cov0" title="0">{
                outputFormats = pm.s.outputFormats[pm.Kind()]
        }</span>

        <span class="cov8" title="1">if len(outputFormats) == 0 </span><span class="cov0" title="0">{
                return pagePaths{}, nil
        }</span>

        <span class="cov8" title="1">if pm.headless </span><span class="cov0" title="0">{
                outputFormats = outputFormats[:1]
        }</span>

        <span class="cov8" title="1">pageOutputFormats := make(page.OutputFormats, len(outputFormats))
        targets := make(map[string]targetPathsHolder)

        for i, f := range outputFormats </span><span class="cov8" title="1">{
                desc := targetPathDescriptor
                desc.Type = f
                paths := page.CreateTargetPaths(desc)

                var relPermalink, permalink string

                // If a page is headless or bundled in another, it will not get published
                // on its own and it will have no links.
                if !pm.headless &amp;&amp; !pm.bundled </span><span class="cov8" title="1">{
                        relPermalink = paths.RelPermalink(s.PathSpec)
                        permalink = paths.PermalinkForOutputFormat(s.PathSpec, f)
                }</span>

                <span class="cov8" title="1">pageOutputFormats[i] = page.NewOutputFormat(relPermalink, permalink, len(outputFormats) == 1, f)

                // Use the main format for permalinks, usually HTML.
                permalinksIndex := 0
                if f.Permalinkable </span><span class="cov8" title="1">{
                        // Unless it's permalinkable
                        permalinksIndex = i
                }</span>

                <span class="cov8" title="1">targets[f.Name] = targetPathsHolder{
                        paths:        paths,
                        OutputFormat: pageOutputFormats[permalinksIndex]}</span>

        }

        <span class="cov8" title="1">return pagePaths{
                outputFormats:        pageOutputFormats,
                targetPaths:          targets,
                targetPathDescriptor: targetPathDescriptor,
        }, nil</span>

}

type pagePaths struct {
        outputFormats page.OutputFormats

        targetPaths          map[string]targetPathsHolder
        targetPathDescriptor page.TargetPathDescriptor
}

func (l pagePaths) OutputFormats() page.OutputFormats <span class="cov8" title="1">{
        return l.outputFormats
}</span>

func createTargetPathDescriptor(s *Site, p page.Page, pm *pageMeta) (page.TargetPathDescriptor, error) <span class="cov8" title="1">{
        var (
                dir             string
                baseName        string
                contentBaseName string
        )

        d := s.Deps

        if !p.File().IsZero() </span><span class="cov8" title="1">{
                dir = p.File().Dir()
                baseName = p.File().TranslationBaseName()
                contentBaseName = p.File().ContentBaseName()
        }</span>

        <span class="cov8" title="1">if baseName != contentBaseName </span><span class="cov0" title="0">{
                // See https://github.com/gohugoio/hugo/issues/4870
                // A leaf bundle
                dir = strings.TrimSuffix(dir, contentBaseName+helpers.FilePathSeparator)
                baseName = contentBaseName
        }</span>

        <span class="cov8" title="1">alwaysInSubDir := p.Kind() == kindSitemap

        desc := page.TargetPathDescriptor{
                PathSpec:    d.PathSpec,
                Kind:        p.Kind(),
                Sections:    p.SectionsEntries(),
                UglyURLs:    s.Info.uglyURLs(p),
                ForcePrefix: s.h.IsMultihost() || alwaysInSubDir,
                Dir:         dir,
                URL:         pm.urlPaths.URL,
        }

        if pm.Slug() != "" </span><span class="cov0" title="0">{
                desc.BaseName = pm.Slug()
        }</span> else<span class="cov8" title="1"> {
                desc.BaseName = baseName
        }</span>

        <span class="cov8" title="1">desc.PrefixFilePath = s.getLanguageTargetPathLang(alwaysInSubDir)
        desc.PrefixLink = s.getLanguagePermalinkLang(alwaysInSubDir)

        // Expand only page.KindPage and page.KindTaxonomy; don't expand other Kinds of Pages
        // like page.KindSection or page.KindTaxonomyTerm because they are "shallower" and
        // the permalink configuration values are likely to be redundant, e.g.
        // naively expanding /category/:slug/ would give /category/categories/ for
        // the "categories" page.KindTaxonomyTerm.
        if p.Kind() == page.KindPage || p.Kind() == page.KindTaxonomy </span><span class="cov8" title="1">{
                opath, err := d.ResourceSpec.Permalinks.Expand(p.Section(), p)
                if err != nil </span><span class="cov0" title="0">{
                        return desc, err
                }</span>

                <span class="cov8" title="1">if opath != "" </span><span class="cov0" title="0">{
                        opath, _ = url.QueryUnescape(opath)
                        desc.ExpandedPermalink = opath
                }</span>

        }

        <span class="cov8" title="1">return desc, nil</span>

}
</pre>
		
		<pre class="file" id="file113" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "bytes"
        "context"
        "fmt"
        "html/template"
        "runtime/debug"
        "strings"
        "sync"
        "unicode/utf8"

        "github.com/gohugoio/hugo/lazy"

        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/tpl"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"
)

var (
        nopTargetPath    = targetPathsHolder{}
        nopPagePerOutput = struct {
                resource.ResourceLinksProvider
                page.ContentProvider
                page.PageRenderProvider
                page.PaginatorProvider
                page.TableOfContentsProvider
                page.AlternativeOutputFormatsProvider

                targetPather
        }{
                page.NopPage,
                page.NopPage,
                page.NopPage,
                page.NopPage,
                page.NopPage,
                page.NopPage,
                nopTargetPath,
        }
)

func newPageContentOutput(p *pageState) func(f output.Format) (*pageContentOutput, error) <span class="cov8" title="1">{

        parent := p.init

        return func(f output.Format) (*pageContentOutput, error) </span><span class="cov8" title="1">{
                cp := &amp;pageContentOutput{
                        p: p,
                        f: f,
                }

                initContent := func() (err error) </span><span class="cov8" title="1">{
                        if p.cmap == nil </span><span class="cov0" title="0">{
                                // Nothing to do.
                                return nil
                        }</span>
                        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                                // See https://github.com/gohugoio/hugo/issues/6210
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        err = fmt.Errorf("%s", r)
                                        p.s.Log.ERROR.Println("[BUG] Got panic:\n", string(debug.Stack()))
                                }</span>
                        }()

                        <span class="cov8" title="1">var hasVariants bool

                        cp.contentPlaceholders, hasVariants, err = p.shortcodeState.renderShortcodesForPage(p, f)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if p.render &amp;&amp; !hasVariants </span><span class="cov8" title="1">{
                                // We can reuse this for the other output formats
                                cp.enableReuse()
                        }</span>

                        <span class="cov8" title="1">cp.workContent = p.contentToRender(cp.contentPlaceholders)

                        isHTML := cp.p.m.markup == "html"

                        if p.renderable </span><span class="cov8" title="1">{
                                if !isHTML </span><span class="cov8" title="1">{
                                        cp.workContent = cp.renderContent(p, cp.workContent)
                                        tmpContent, tmpTableOfContents := helpers.ExtractTOC(cp.workContent)
                                        cp.tableOfContents = helpers.BytesToHTML(tmpTableOfContents)
                                        cp.workContent = tmpContent
                                }</span>

                                <span class="cov8" title="1">if cp.placeholdersEnabled </span><span class="cov0" title="0">{
                                        // ToC was accessed via .Page.TableOfContents in the shortcode,
                                        // at a time when the ToC wasn't ready.
                                        cp.contentPlaceholders[tocShortcodePlaceholder] = string(cp.tableOfContents)
                                }</span>

                                <span class="cov8" title="1">if p.cmap.hasNonMarkdownShortcode || cp.placeholdersEnabled </span><span class="cov0" title="0">{
                                        // There are one or more replacement tokens to be replaced.
                                        cp.workContent, err = replaceShortcodeTokens(cp.workContent, cp.contentPlaceholders)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }

                                <span class="cov8" title="1">if cp.p.source.hasSummaryDivider </span><span class="cov0" title="0">{
                                        if isHTML </span><span class="cov0" title="0">{
                                                src := p.source.parsed.Input()

                                                // Use the summary sections as they are provided by the user.
                                                if p.source.posSummaryEnd != -1 </span><span class="cov0" title="0">{
                                                        cp.summary = helpers.BytesToHTML(src[p.source.posMainContent:p.source.posSummaryEnd])
                                                }</span>

                                                <span class="cov0" title="0">if cp.p.source.posBodyStart != -1 </span><span class="cov0" title="0">{
                                                        cp.workContent = src[cp.p.source.posBodyStart:]
                                                }</span>

                                        } else<span class="cov0" title="0"> {
                                                summary, content, err := splitUserDefinedSummaryAndContent(cp.p.m.markup, cp.workContent)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        cp.p.s.Log.ERROR.Printf("Failed to set user defined summary for page %q: %s", cp.p.pathOrTitle(), err)
                                                }</span> else<span class="cov0" title="0"> {
                                                        cp.workContent = content
                                                        cp.summary = helpers.BytesToHTML(summary)
                                                }</span>
                                        }
                                } else<span class="cov8" title="1"> if cp.p.m.summary != "" </span><span class="cov0" title="0">{
                                        html := cp.p.s.ContentSpec.RenderBytes(&amp;helpers.RenderingContext{
                                                Content: []byte(cp.p.m.summary), RenderTOC: false, PageFmt: cp.p.m.markup,
                                                Cfg:        p.Language(),
                                                DocumentID: p.File().UniqueID(), DocumentName: p.File().Path(),
                                                Config: cp.p.getRenderingConfig()})
                                        html = cp.p.s.ContentSpec.TrimShortHTML(html)
                                        cp.summary = helpers.BytesToHTML(html)
                                }</span>
                        }

                        <span class="cov8" title="1">cp.content = helpers.BytesToHTML(cp.workContent)

                        if !p.renderable </span><span class="cov0" title="0">{
                                err := cp.addSelfTemplate()
                                return err
                        }</span>

                        <span class="cov8" title="1">return nil</span>

                }

                // Recursive loops can only happen in content files with template code (shortcodes etc.)
                // Avoid creating new goroutines if we don't have to.
                <span class="cov8" title="1">needTimeout := !p.renderable || p.shortcodeState.hasShortcodes()

                if needTimeout </span><span class="cov0" title="0">{
                        cp.initMain = parent.BranchdWithTimeout(p.s.siteCfg.timeout, func(ctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                                return nil, initContent()
                        }</span>)
                } else<span class="cov8" title="1"> {
                        cp.initMain = parent.Branch(func() (interface{}, error) </span><span class="cov8" title="1">{
                                return nil, initContent()
                        }</span>)
                }

                <span class="cov8" title="1">cp.initPlain = cp.initMain.Branch(func() (interface{}, error) </span><span class="cov8" title="1">{
                        cp.plain = helpers.StripHTML(string(cp.content))
                        cp.plainWords = strings.Fields(cp.plain)
                        cp.setWordCounts(p.m.isCJKLanguage)

                        if err := cp.setAutoSummary(); err != nil </span><span class="cov0" title="0">{
                                return err, nil
                        }</span>

                        <span class="cov8" title="1">return nil, nil</span>
                })

                <span class="cov8" title="1">return cp, nil</span>

        }

}

// pageContentOutput represents the Page content for a given output format.
type pageContentOutput struct {
        f output.Format

        // If we can safely reuse this for other output formats.
        reuse     bool
        reuseInit sync.Once

        p *pageState

        // Lazy load dependencies
        initMain  *lazy.Init
        initPlain *lazy.Init

        placeholdersEnabled     bool
        placeholdersEnabledInit sync.Once

        // Content state

        workContent []byte

        // Temporary storage of placeholders mapped to their content.
        // These are shortcodes etc. Some of these will need to be replaced
        // after any markup is rendered, so they share a common prefix.
        contentPlaceholders map[string]string

        // Content sections
        content         template.HTML
        summary         template.HTML
        tableOfContents template.HTML

        truncated bool

        plainWords     []string
        plain          string
        fuzzyWordCount int
        wordCount      int
        readingTime    int
}

func (p *pageContentOutput) Content() (interface{}, error) <span class="cov8" title="1">{
        p.p.s.initInit(p.initMain, p.p)
        return p.content, nil
}</span>

func (p *pageContentOutput) FuzzyWordCount() int <span class="cov0" title="0">{
        p.p.s.initInit(p.initPlain, p.p)
        return p.fuzzyWordCount
}</span>

func (p *pageContentOutput) Len() int <span class="cov0" title="0">{
        p.p.s.initInit(p.initMain, p.p)
        return len(p.content)
}</span>

func (p *pageContentOutput) Plain() string <span class="cov0" title="0">{
        p.p.s.initInit(p.initPlain, p.p)
        return p.plain
}</span>

func (p *pageContentOutput) PlainWords() []string <span class="cov0" title="0">{
        p.p.s.initInit(p.initPlain, p.p)
        return p.plainWords
}</span>

func (p *pageContentOutput) ReadingTime() int <span class="cov0" title="0">{
        p.p.s.initInit(p.initPlain, p.p)
        return p.readingTime
}</span>

func (p *pageContentOutput) Summary() template.HTML <span class="cov8" title="1">{
        p.p.s.initInit(p.initMain, p.p)
        if !p.p.source.hasSummaryDivider </span><span class="cov8" title="1">{
                p.p.s.initInit(p.initPlain, p.p)
        }</span>
        <span class="cov8" title="1">return p.summary</span>
}

func (p *pageContentOutput) TableOfContents() template.HTML <span class="cov0" title="0">{
        p.p.s.initInit(p.initMain, p.p)
        return p.tableOfContents
}</span>

func (p *pageContentOutput) Truncated() bool <span class="cov0" title="0">{
        if p.p.truncated </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">p.p.s.initInit(p.initPlain, p.p)
        return p.truncated</span>
}

func (p *pageContentOutput) WordCount() int <span class="cov8" title="1">{
        p.p.s.initInit(p.initPlain, p.p)
        return p.wordCount
}</span>

func (p *pageContentOutput) setAutoSummary() error <span class="cov8" title="1">{
        if p.p.source.hasSummaryDivider || p.p.m.summary != "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var summary string
        var truncated bool

        if p.p.m.isCJKLanguage </span><span class="cov0" title="0">{
                summary, truncated = p.p.s.ContentSpec.TruncateWordsByRune(p.plainWords)
        }</span> else<span class="cov8" title="1"> {
                summary, truncated = p.p.s.ContentSpec.TruncateWordsToWholeSentence(p.plain)
        }</span>
        <span class="cov8" title="1">p.summary = template.HTML(summary)

        p.truncated = truncated

        return nil</span>

}

func (cp *pageContentOutput) renderContent(p page.Page, content []byte) []byte <span class="cov8" title="1">{
        return cp.p.s.ContentSpec.RenderBytes(&amp;helpers.RenderingContext{
                Content: content, RenderTOC: true, PageFmt: cp.p.m.markup,
                Cfg:        p.Language(),
                DocumentID: p.File().UniqueID(), DocumentName: p.File().Path(),
                Config: cp.p.getRenderingConfig()})
}</span>

func (p *pageContentOutput) setWordCounts(isCJKLanguage bool) <span class="cov8" title="1">{
        if isCJKLanguage </span><span class="cov0" title="0">{
                p.wordCount = 0
                for _, word := range p.plainWords </span><span class="cov0" title="0">{
                        runeCount := utf8.RuneCountInString(word)
                        if len(word) == runeCount </span><span class="cov0" title="0">{
                                p.wordCount++
                        }</span> else<span class="cov0" title="0"> {
                                p.wordCount += runeCount
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                p.wordCount = helpers.TotalWords(p.plain)
        }</span>

        // TODO(bep) is set in a test. Fix that.
        <span class="cov8" title="1">if p.fuzzyWordCount == 0 </span><span class="cov8" title="1">{
                p.fuzzyWordCount = (p.wordCount + 100) / 100 * 100
        }</span>

        <span class="cov8" title="1">if isCJKLanguage </span><span class="cov0" title="0">{
                p.readingTime = (p.wordCount + 500) / 501
        }</span> else<span class="cov8" title="1"> {
                p.readingTime = (p.wordCount + 212) / 213
        }</span>
}

func (p *pageContentOutput) addSelfTemplate() error <span class="cov0" title="0">{
        self := p.p.selfLayoutForOutput(p.f)
        err := p.p.s.TemplateHandler().AddLateTemplate(self, string(p.content))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// A callback to signal that we have inserted a placeholder into the rendered
// content. This avoids doing extra replacement work.
func (p *pageContentOutput) enablePlaceholders() <span class="cov0" title="0">{
        p.placeholdersEnabledInit.Do(func() </span><span class="cov0" title="0">{
                p.placeholdersEnabled = true
        }</span>)
}

func (p *pageContentOutput) enableReuse() <span class="cov8" title="1">{
        p.reuseInit.Do(func() </span><span class="cov8" title="1">{
                p.reuse = true
        }</span>)
}

// these will be shifted out when rendering a given output format.
type pagePerOutputProviders interface {
        targetPather
        page.ContentProvider
        page.PaginatorProvider
        page.TableOfContentsProvider
        resource.ResourceLinksProvider
}

type targetPather interface {
        targetPaths() page.TargetPaths
}

type targetPathsHolder struct {
        paths page.TargetPaths
        page.OutputFormat
}

func (t targetPathsHolder) targetPaths() page.TargetPaths <span class="cov8" title="1">{
        return t.paths
}</span>

func executeToString(templ tpl.Template, data interface{}) (string, error) <span class="cov0" title="0">{
        b := bp.GetBuffer()
        defer bp.PutBuffer(b)
        if err := templ.Execute(b, data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return b.String(), nil</span>

}

func splitUserDefinedSummaryAndContent(markup string, c []byte) (summary []byte, content []byte, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("summary split failed: %s", r)
                }</span>
        }()

        <span class="cov0" title="0">startDivider := bytes.Index(c, internalSummaryDividerBaseBytes)

        if startDivider == -1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">startTag := "p"
        switch markup </span>{
        case "asciidoc":<span class="cov0" title="0">
                startTag = "div"</span>

        }

        // Walk back and forward to the surrounding tags.
        <span class="cov0" title="0">start := bytes.LastIndex(c[:startDivider], []byte("&lt;"+startTag))
        end := bytes.Index(c[startDivider:], []byte("&lt;/"+startTag))

        if start == -1 </span><span class="cov0" title="0">{
                start = startDivider
        }</span> else<span class="cov0" title="0"> {
                start = startDivider - (startDivider - start)
        }</span>

        <span class="cov0" title="0">if end == -1 </span><span class="cov0" title="0">{
                end = startDivider + len(internalSummaryDividerBase)
        }</span> else<span class="cov0" title="0"> {
                end = startDivider + end + len(startTag) + 3
        }</span>

        <span class="cov0" title="0">var addDiv bool

        switch markup </span>{
        case "rst":<span class="cov0" title="0">
                addDiv = true</span>
        }

        <span class="cov0" title="0">withoutDivider := append(c[:start], bytes.Trim(c[end:], "\n")...)

        if len(withoutDivider) &gt; 0 </span><span class="cov0" title="0">{
                summary = bytes.TrimSpace(withoutDivider[:start])
        }</span>

        <span class="cov0" title="0">if addDiv </span><span class="cov0" title="0">{
                // For the rst
                summary = append(append([]byte(nil), summary...), []byte("&lt;/div&gt;")...)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">content = bytes.TrimSpace(withoutDivider)

        return</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/gohugoio/hugo/lazy"
        "github.com/gohugoio/hugo/resources/page"
)

func newPagePosition(n *nextPrev) pagePosition <span class="cov8" title="1">{
        return pagePosition{nextPrev: n}
}</span>

func newPagePositionInSection(n *nextPrev) pagePositionInSection <span class="cov8" title="1">{
        return pagePositionInSection{nextPrev: n}

}</span>

type nextPrev struct {
        init     *lazy.Init
        prevPage page.Page
        nextPage page.Page
}

func (n *nextPrev) next() page.Page <span class="cov0" title="0">{
        n.init.Do()
        return n.nextPage
}</span>

func (n *nextPrev) prev() page.Page <span class="cov0" title="0">{
        n.init.Do()
        return n.prevPage
}</span>

type pagePosition struct {
        *nextPrev
}

func (p pagePosition) Next() page.Page <span class="cov0" title="0">{
        return p.next()
}</span>

func (p pagePosition) NextPage() page.Page <span class="cov0" title="0">{
        return p.Next()
}</span>

func (p pagePosition) Prev() page.Page <span class="cov0" title="0">{
        return p.prev()
}</span>

func (p pagePosition) PrevPage() page.Page <span class="cov0" title="0">{
        return p.Prev()
}</span>

type pagePositionInSection struct {
        *nextPrev
}

func (p pagePositionInSection) NextInSection() page.Page <span class="cov0" title="0">{
        return p.next()
}</span>

func (p pagePositionInSection) PrevInSection() page.Page <span class="cov0" title="0">{
        return p.prev()
}</span>
</pre>
		
		<pre class="file" id="file115" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"

        "github.com/gohugoio/hugo/common/text"

        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"
)

func newPageRef(p *pageState) pageRef <span class="cov8" title="1">{
        return pageRef{p: p}
}</span>

type pageRef struct {
        p *pageState
}

func (p pageRef) Ref(argsm map[string]interface{}) (string, error) <span class="cov0" title="0">{
        return p.ref(argsm, p.p)
}</span>

func (p pageRef) RefFrom(argsm map[string]interface{}, source interface{}) (string, error) <span class="cov0" title="0">{
        return p.ref(argsm, source)
}</span>

func (p pageRef) RelRef(argsm map[string]interface{}) (string, error) <span class="cov0" title="0">{
        return p.relRef(argsm, p.p)
}</span>

func (p pageRef) RelRefFrom(argsm map[string]interface{}, source interface{}) (string, error) <span class="cov0" title="0">{
        return p.relRef(argsm, source)
}</span>

func (p pageRef) decodeRefArgs(args map[string]interface{}) (refArgs, *Site, error) <span class="cov0" title="0">{
        var ra refArgs
        err := mapstructure.WeakDecode(args, &amp;ra)
        if err != nil </span><span class="cov0" title="0">{
                return ra, nil, nil
        }</span>

        <span class="cov0" title="0">s := p.p.s

        if ra.Lang != "" &amp;&amp; ra.Lang != p.p.s.Language().Lang </span><span class="cov0" title="0">{
                // Find correct site
                found := false
                for _, ss := range p.p.s.h.Sites </span><span class="cov0" title="0">{
                        if ss.Lang() == ra.Lang </span><span class="cov0" title="0">{
                                found = true
                                s = ss
                        }</span>
                }

                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        p.p.s.siteRefLinker.logNotFound(ra.Path, fmt.Sprintf("no site found with lang %q", ra.Lang), nil, text.Position{})
                        return ra, nil, nil
                }</span>
        }

        <span class="cov0" title="0">return ra, s, nil</span>
}

func (p pageRef) ref(argsm map[string]interface{}, source interface{}) (string, error) <span class="cov0" title="0">{
        args, s, err := p.decodeRefArgs(argsm)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "invalid arguments to Ref")
        }</span>

        <span class="cov0" title="0">if s == nil </span><span class="cov0" title="0">{
                return p.p.s.siteRefLinker.notFoundURL, nil
        }</span>

        <span class="cov0" title="0">if args.Path == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">return s.refLink(args.Path, source, false, args.OutputFormat)</span>

}

func (p pageRef) relRef(argsm map[string]interface{}, source interface{}) (string, error) <span class="cov0" title="0">{
        args, s, err := p.decodeRefArgs(argsm)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "invalid arguments to Ref")
        }</span>

        <span class="cov0" title="0">if s == nil </span><span class="cov0" title="0">{
                return p.p.s.siteRefLinker.notFoundURL, nil
        }</span>

        <span class="cov0" title="0">if args.Path == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">return s.refLink(args.Path, source, true, args.OutputFormat)</span>

}

type refArgs struct {
        Path         string
        Lang         string
        OutputFormat string
}
</pre>
		
		<pre class="file" id="file116" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/resources/page"
)

type pageTree struct {
        p *pageState
}

func (pt pageTree) IsAncestor(other interface{}) (bool, error) <span class="cov0" title="0">{
        if pt.p == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">pp, err := unwrapPage(other)
        if err != nil || pp == nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if pt.p.Kind() == page.KindPage &amp;&amp; len(pt.p.SectionsEntries()) == len(pp.SectionsEntries()) </span><span class="cov0" title="0">{
                // A regular page is never its section's ancestor.
                return false, nil
        }</span>

        <span class="cov0" title="0">return helpers.HasStringsPrefix(pp.SectionsEntries(), pt.p.SectionsEntries()), nil</span>
}

func (pt pageTree) CurrentSection() page.Page <span class="cov8" title="1">{
        p := pt.p

        if p.IsHome() || p.IsSection() </span><span class="cov0" title="0">{
                return p
        }</span>

        <span class="cov8" title="1">return p.Parent()</span>
}

func (pt pageTree) IsDescendant(other interface{}) (bool, error) <span class="cov0" title="0">{
        if pt.p == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">pp, err := unwrapPage(other)
        if err != nil || pp == nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if pp.Kind() == page.KindPage &amp;&amp; len(pt.p.SectionsEntries()) == len(pp.SectionsEntries()) </span><span class="cov0" title="0">{
                // A regular page is never its section's descendant.
                return false, nil
        }</span>
        <span class="cov0" title="0">return helpers.HasStringsPrefix(pt.p.SectionsEntries(), pp.SectionsEntries()), nil</span>
}

func (pt pageTree) FirstSection() page.Page <span class="cov0" title="0">{
        p := pt.p

        parent := p.Parent()

        if types.IsNil(parent) || parent.IsHome() </span><span class="cov0" title="0">{
                return p
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                current := parent
                parent = parent.Parent()
                if types.IsNil(parent) || parent.IsHome() </span><span class="cov0" title="0">{
                        return current
                }</span>
        }

}

func (pt pageTree) InSection(other interface{}) (bool, error) <span class="cov0" title="0">{
        if pt.p == nil || types.IsNil(other) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">pp, err := unwrapPage(other)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if pp == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return pp.CurrentSection().Eq(pt.p.CurrentSection()), nil</span>

}

func (pt pageTree) Page() page.Page <span class="cov0" title="0">{
        return pt.p
}</span>

func (pt pageTree) Parent() page.Page <span class="cov8" title="1">{
        if pt.p.parent != nil </span><span class="cov8" title="1">{
                return pt.p.parent
        }</span>

        <span class="cov0" title="0">if pt.p.bucket == nil || pt.p.bucket.parent == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return pt.p.bucket.parent.owner</span>
}

func (pt pageTree) Sections() page.Pages <span class="cov0" title="0">{
        if pt.p.bucket == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return pt.p.bucket.getSections()</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "strings"

        "github.com/gohugoio/hugo/resources/page"
)

var (

        // This is all the kinds we can expect to find in .Site.Pages.
        allKindsInPages = []string{page.KindPage, page.KindHome, page.KindSection, page.KindTaxonomy, page.KindTaxonomyTerm}
        allKinds        = append(allKindsInPages, []string{kindRSS, kindSitemap, kindRobotsTXT, kind404}...)
)

const (

        // Temporary state.
        kindUnknown = "unknown"

        // The following are (currently) temporary nodes,
        // i.e. nodes we create just to render in isolation.
        kindRSS       = "RSS"
        kindSitemap   = "sitemap"
        kindRobotsTXT = "robotsTXT"
        kind404       = "404"

        pageResourceType = "page"
)

var kindMap = map[string]string{
        strings.ToLower(kindRSS):       kindRSS,
        strings.ToLower(kindSitemap):   kindSitemap,
        strings.ToLower(kindRobotsTXT): kindRobotsTXT,
        strings.ToLower(kind404):       kind404,
}

func getKind(s string) string <span class="cov0" title="0">{
        if pkind := page.GetKind(s); pkind != "" </span><span class="cov0" title="0">{
                return pkind
        }</span>
        <span class="cov0" title="0">return kindMap[strings.ToLower(s)]</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/resources/page"
)

// Wraps a Page.
type pageWrapper interface {
        page() page.Page
}

// unwrapPage is used in equality checks and similar.
func unwrapPage(in interface{}) (page.Page, error) <span class="cov0" title="0">{
        switch v := in.(type) </span>{
        case *pageState:<span class="cov0" title="0">
                return v, nil</span>
        case pageWrapper:<span class="cov0" title="0">
                return v.page(), nil</span>
        case page.Page:<span class="cov0" title="0">
                return v, nil</span>
        case nil:<span class="cov0" title="0">
                return nil, nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unwrapPage: %T not supported", in)</span>
        }
}

func mustUnwrapPage(in interface{}) page.Page <span class="cov0" title="0">{
        p, err := unwrapPage(in)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return p</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "path"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/gohugoio/hugo/resources/resource"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/cache"
        "github.com/gohugoio/hugo/resources/page"
)

// Used in the page cache to mark more than one hit for a given key.
var ambiguityFlag = &amp;pageState{}

// PageCollections contains the page collections for a site.
type PageCollections struct {
        pagesMap *pagesMap

        // Includes absolute all pages (of all types), including drafts etc.
        rawAllPages pageStatePages

        // rawAllPages plus additional pages created during the build process.
        workAllPages pageStatePages

        // Includes headless bundles, i.e. bundles that produce no output for its content page.
        headlessPages pageStatePages

        // Lazy initialized page collections
        pages           *lazyPagesFactory
        regularPages    *lazyPagesFactory
        allPages        *lazyPagesFactory
        allRegularPages *lazyPagesFactory

        // The index for .Site.GetPage etc.
        pageIndex *cache.Lazy
}

// Pages returns all pages.
// This is for the current language only.
func (c *PageCollections) Pages() page.Pages <span class="cov8" title="1">{
        return c.pages.get()
}</span>

// RegularPages returns all the regular pages.
// This is for the current language only.
func (c *PageCollections) RegularPages() page.Pages <span class="cov8" title="1">{
        return c.regularPages.get()
}</span>

// AllPages returns all pages for all languages.
func (c *PageCollections) AllPages() page.Pages <span class="cov0" title="0">{
        return c.allPages.get()
}</span>

// AllPages returns all regular pages for all languages.
func (c *PageCollections) AllRegularPages() page.Pages <span class="cov0" title="0">{
        return c.allRegularPages.get()
}</span>

// Get initializes the index if not already done so, then
// looks up the given page ref, returns nil if no value found.
func (c *PageCollections) getFromCache(ref string) (page.Page, error) <span class="cov8" title="1">{
        v, found, err := c.pageIndex.Get(ref)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">p := v.(page.Page)

        if p != ambiguityFlag </span><span class="cov8" title="1">{
                return p, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("page reference %q is ambiguous", ref)</span>
}

type lazyPagesFactory struct {
        pages page.Pages

        init    sync.Once
        factory page.PagesFactory
}

func (l *lazyPagesFactory) get() page.Pages <span class="cov8" title="1">{
        l.init.Do(func() </span><span class="cov8" title="1">{
                l.pages = l.factory()
        }</span>)
        <span class="cov8" title="1">return l.pages</span>
}

func newLazyPagesFactory(factory page.PagesFactory) *lazyPagesFactory <span class="cov8" title="1">{
        return &amp;lazyPagesFactory{factory: factory}
}</span>

func newPageCollections() *PageCollections <span class="cov8" title="1">{
        return newPageCollectionsFromPages(nil)
}</span>

func newPageCollectionsFromPages(pages pageStatePages) *PageCollections <span class="cov8" title="1">{

        c := &amp;PageCollections{rawAllPages: pages}

        c.pages = newLazyPagesFactory(func() page.Pages </span><span class="cov8" title="1">{
                pages := make(page.Pages, len(c.workAllPages))
                for i, p := range c.workAllPages </span><span class="cov8" title="1">{
                        pages[i] = p
                }</span>
                <span class="cov8" title="1">return pages</span>
        })

        <span class="cov8" title="1">c.regularPages = newLazyPagesFactory(func() page.Pages </span><span class="cov8" title="1">{
                return c.findPagesByKindInWorkPages(page.KindPage, c.workAllPages)
        }</span>)

        <span class="cov8" title="1">c.pageIndex = cache.NewLazy(func() (map[string]interface{}, error) </span><span class="cov8" title="1">{
                index := make(map[string]interface{})

                add := func(ref string, p page.Page) </span><span class="cov8" title="1">{
                        ref = strings.ToLower(ref)
                        existing := index[ref]
                        if existing == nil </span><span class="cov8" title="1">{
                                index[ref] = p
                        }</span> else<span class="cov8" title="1"> if existing != ambiguityFlag &amp;&amp; existing != p </span><span class="cov0" title="0">{
                                index[ref] = ambiguityFlag
                        }</span>
                }

                <span class="cov8" title="1">for _, pageCollection := range []pageStatePages{c.workAllPages, c.headlessPages} </span><span class="cov8" title="1">{
                        for _, p := range pageCollection </span><span class="cov8" title="1">{
                                if p.IsPage() </span><span class="cov8" title="1">{
                                        sourceRef := p.sourceRef()
                                        if sourceRef != "" </span><span class="cov8" title="1">{
                                                // index the canonical ref
                                                // e.g. /section/article.md
                                                add(sourceRef, p)
                                        }</span>

                                        // Ref/Relref supports this potentially ambiguous lookup.
                                        <span class="cov8" title="1">add(p.File().LogicalName(), p)

                                        translationBaseName := p.File().TranslationBaseName()

                                        dir, _ := path.Split(sourceRef)
                                        dir = strings.TrimSuffix(dir, "/")

                                        if translationBaseName == "index" </span><span class="cov0" title="0">{
                                                add(dir, p)
                                                add(path.Base(dir), p)
                                        }</span> else<span class="cov8" title="1"> {
                                                add(translationBaseName, p)
                                        }</span>

                                        // We need a way to get to the current language version.
                                        <span class="cov8" title="1">pathWithNoExtensions := path.Join(dir, translationBaseName)
                                        add(pathWithNoExtensions, p)</span>
                                } else<span class="cov8" title="1"> {
                                        // index the canonical, unambiguous ref for any backing file
                                        // e.g. /section/_index.md
                                        sourceRef := p.sourceRef()
                                        if sourceRef != "" </span><span class="cov8" title="1">{
                                                add(sourceRef, p)
                                        }</span>

                                        <span class="cov8" title="1">ref := p.SectionsPath()

                                        // index the canonical, unambiguous virtual ref
                                        // e.g. /section
                                        // (this may already have been indexed above)
                                        add("/"+ref, p)</span>
                                }
                        }
                }

                <span class="cov8" title="1">return index, nil</span>
        })

        <span class="cov8" title="1">return c</span>
}

// This is an adapter func for the old API with Kind as first argument.
// This is invoked when you do .Site.GetPage. We drop the Kind and fails
// if there are more than 2 arguments, which would be ambigous.
func (c *PageCollections) getPageOldVersion(ref ...string) (page.Page, error) <span class="cov8" title="1">{
        var refs []string
        for _, r := range ref </span><span class="cov8" title="1">{
                // A common construct in the wild is
                // .Site.GetPage "home" "" or
                // .Site.GetPage "home" "/"
                if r != "" &amp;&amp; r != "/" </span><span class="cov8" title="1">{
                        refs = append(refs, r)
                }</span>
        }

        <span class="cov8" title="1">var key string

        if len(refs) &gt; 2 </span><span class="cov0" title="0">{
                // This was allowed in Hugo &lt;= 0.44, but we cannot support this with the
                // new API. This should be the most unusual case.
                return nil, fmt.Errorf(`too many arguments to .Site.GetPage: %v. Use lookups on the form {{ .Site.GetPage "/posts/mypage-md" }}`, ref)
        }</span>

        <span class="cov8" title="1">if len(refs) == 0 || refs[0] == page.KindHome </span><span class="cov0" title="0">{
                key = "/"
        }</span> else<span class="cov8" title="1"> if len(refs) == 1 </span><span class="cov0" title="0">{
                if len(ref) == 2 &amp;&amp; refs[0] == page.KindSection </span><span class="cov0" title="0">{
                        // This is an old style reference to the "Home Page section".
                        // Typically fetched via {{ .Site.GetPage "section" .Section }}
                        // See https://github.com/gohugoio/hugo/issues/4989
                        key = "/"
                }</span> else<span class="cov0" title="0"> {
                        key = refs[0]
                }</span>
        } else<span class="cov8" title="1"> {
                key = refs[1]
        }</span>

        <span class="cov8" title="1">key = filepath.ToSlash(key)
        if !strings.HasPrefix(key, "/") </span><span class="cov8" title="1">{
                key = "/" + key
        }</span>

        <span class="cov8" title="1">return c.getPageNew(nil, key)</span>
}

//         Only used in tests.
func (c *PageCollections) getPage(typ string, sections ...string) page.Page <span class="cov0" title="0">{
        refs := append([]string{typ}, path.Join(sections...))
        p, _ := c.getPageOldVersion(refs...)
        return p
}</span>

// Case insensitive page lookup.
func (c *PageCollections) getPageNew(context page.Page, ref string) (page.Page, error) <span class="cov8" title="1">{
        var anError error

        ref = strings.ToLower(ref)

        // Absolute (content root relative) reference.
        if strings.HasPrefix(ref, "/") </span><span class="cov8" title="1">{
                p, err := c.getFromCache(ref)
                if err == nil &amp;&amp; p != nil </span><span class="cov8" title="1">{
                        return p, nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        anError = err
                }</span>

        } else<span class="cov0" title="0"> if context != nil </span><span class="cov0" title="0">{
                // Try the page-relative path.
                ppath := path.Join("/", strings.ToLower(context.SectionsPath()), ref)
                p, err := c.getFromCache(ppath)
                if err == nil &amp;&amp; p != nil </span><span class="cov0" title="0">{
                        return p, nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        anError = err
                }</span>
        }

        <span class="cov0" title="0">if !strings.HasPrefix(ref, "/") </span><span class="cov0" title="0">{
                // Many people will have "post/foo.md" in their content files.
                p, err := c.getFromCache("/" + ref)
                if err == nil &amp;&amp; p != nil </span><span class="cov0" title="0">{
                        return p, nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        anError = err
                }</span>
        }

        // Last try.
        <span class="cov0" title="0">ref = strings.TrimPrefix(ref, "/")
        p, err := c.getFromCache(ref)
        if err != nil </span><span class="cov0" title="0">{
                anError = err
        }</span>

        <span class="cov0" title="0">if p == nil &amp;&amp; anError != nil </span><span class="cov0" title="0">{
                return nil, wrapErr(errors.Wrap(anError, "failed to resolve ref"), context)
        }</span>

        <span class="cov0" title="0">return p, nil</span>
}

func (*PageCollections) findPagesByKindIn(kind string, inPages page.Pages) page.Pages <span class="cov0" title="0">{
        var pages page.Pages
        for _, p := range inPages </span><span class="cov0" title="0">{
                if p.Kind() == kind </span><span class="cov0" title="0">{
                        pages = append(pages, p)
                }</span>
        }
        <span class="cov0" title="0">return pages</span>
}

func (c *PageCollections) findPagesByKind(kind string) page.Pages <span class="cov0" title="0">{
        return c.findPagesByKindIn(kind, c.Pages())
}</span>

func (c *PageCollections) findWorkPagesByKind(kind string) pageStatePages <span class="cov0" title="0">{
        var pages pageStatePages
        for _, p := range c.workAllPages </span><span class="cov0" title="0">{
                if p.Kind() == kind </span><span class="cov0" title="0">{
                        pages = append(pages, p)
                }</span>
        }
        <span class="cov0" title="0">return pages</span>
}

func (*PageCollections) findPagesByKindInWorkPages(kind string, inPages pageStatePages) page.Pages <span class="cov8" title="1">{
        var pages page.Pages
        for _, p := range inPages </span><span class="cov8" title="1">{
                if p.Kind() == kind </span><span class="cov8" title="1">{
                        pages = append(pages, p)
                }</span>
        }
        <span class="cov8" title="1">return pages</span>
}

func (c *PageCollections) addPage(page *pageState) <span class="cov8" title="1">{
        c.rawAllPages = append(c.rawAllPages, page)
}</span>

func (c *PageCollections) removePageFilename(filename string) <span class="cov0" title="0">{
        if i := c.rawAllPages.findPagePosByFilename(filename); i &gt;= 0 </span><span class="cov0" title="0">{
                c.clearResourceCacheForPage(c.rawAllPages[i])
                c.rawAllPages = append(c.rawAllPages[:i], c.rawAllPages[i+1:]...)
        }</span>

}

func (c *PageCollections) removePage(page *pageState) <span class="cov0" title="0">{
        if i := c.rawAllPages.findPagePos(page); i &gt;= 0 </span><span class="cov0" title="0">{
                c.clearResourceCacheForPage(c.rawAllPages[i])
                c.rawAllPages = append(c.rawAllPages[:i], c.rawAllPages[i+1:]...)
        }</span>
}

func (c *PageCollections) findPagesByShortcode(shortcode string) page.Pages <span class="cov0" title="0">{
        var pages page.Pages
        for _, p := range c.rawAllPages </span><span class="cov0" title="0">{
                if p.HasShortcode(shortcode) </span><span class="cov0" title="0">{
                        pages = append(pages, p)
                }</span>
        }
        <span class="cov0" title="0">return pages</span>
}

func (c *PageCollections) replacePage(page *pageState) <span class="cov0" title="0">{
        // will find existing page that matches filepath and remove it
        c.removePage(page)
        c.addPage(page)
}</span>

func (c *PageCollections) clearResourceCacheForPage(page *pageState) <span class="cov0" title="0">{
        if len(page.resources) &gt; 0 </span><span class="cov0" title="0">{
                page.s.ResourceSpec.DeleteCacheByPrefix(page.targetPaths().SubResourceBaseTarget)
        }</span>
}

func (c *PageCollections) assemblePagesMap(s *Site) error <span class="cov8" title="1">{

        c.pagesMap = newPagesMap(s)

        rootSections := make(map[string]bool)

        // Add all branch nodes first.
        for _, p := range c.rawAllPages </span><span class="cov8" title="1">{
                rootSections[p.Section()] = true
                if p.IsPage() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">c.pagesMap.addPage(p)</span>
        }

        // Create missing home page and the first level sections if no
        // _index provided.
        <span class="cov8" title="1">s.home = c.pagesMap.getOrCreateHome()
        for k := range rootSections </span><span class="cov8" title="1">{
                c.pagesMap.createSectionIfNotExists(k)
        }</span>

        // Attach the regular pages to their section.
        <span class="cov8" title="1">for _, p := range c.rawAllPages </span><span class="cov8" title="1">{
                if p.IsNode() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">c.pagesMap.addPage(p)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *PageCollections) createWorkAllPages() error <span class="cov8" title="1">{
        c.workAllPages = make(pageStatePages, 0, len(c.rawAllPages))
        c.headlessPages = make(pageStatePages, 0)

        var (
                homeDates    *resource.Dates
                sectionDates *resource.Dates
                siteLastmod  time.Time
                siteLastDate time.Time

                sectionsParamId      = "mainSections"
                sectionsParamIdLower = strings.ToLower(sectionsParamId)
        )

        mainSections, mainSectionsFound := c.pagesMap.s.Info.Params()[sectionsParamIdLower]

        var (
                bucketsToRemove []string
                rootBuckets     []*pagesMapBucket
                walkErr         error
        )

        c.pagesMap.r.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                bucket := v.(*pagesMapBucket)
                parentBucket := c.pagesMap.parentBucket(s)

                if parentBucket != nil </span><span class="cov8" title="1">{

                        if !mainSectionsFound &amp;&amp; strings.Count(s, "/") == 1 &amp;&amp; bucket.owner.IsSection() </span><span class="cov8" title="1">{
                                // Root section
                                rootBuckets = append(rootBuckets, bucket)
                        }</span>
                }

                <span class="cov8" title="1">if bucket.owner.IsHome() </span><span class="cov8" title="1">{
                        if resource.IsZeroDates(bucket.owner) </span><span class="cov8" title="1">{
                                // Calculate dates from the page tree.
                                homeDates = &amp;bucket.owner.m.Dates
                        }</span>
                }

                <span class="cov8" title="1">sectionDates = nil
                if resource.IsZeroDates(bucket.owner) </span><span class="cov8" title="1">{
                        sectionDates = &amp;bucket.owner.m.Dates
                }</span>

                <span class="cov8" title="1">if parentBucket != nil </span><span class="cov8" title="1">{
                        bucket.parent = parentBucket
                        if bucket.owner.IsSection() </span><span class="cov8" title="1">{
                                parentBucket.bucketSections = append(parentBucket.bucketSections, bucket)
                        }</span>
                }

                <span class="cov8" title="1">if bucket.isEmpty() </span><span class="cov8" title="1">{
                        if bucket.owner.IsSection() &amp;&amp; bucket.owner.File().IsZero() </span><span class="cov0" title="0">{
                                // Check for any nested section.
                                var hasDescendant bool
                                c.pagesMap.r.WalkPrefix(s, func(ss string, v interface{}) bool </span><span class="cov0" title="0">{
                                        if s != ss </span><span class="cov0" title="0">{
                                                hasDescendant = true
                                                return true
                                        }</span>
                                        <span class="cov0" title="0">return false</span>
                                })
                                <span class="cov0" title="0">if !hasDescendant </span><span class="cov0" title="0">{
                                        // This is an auto-created section with, now, nothing in it.
                                        bucketsToRemove = append(bucketsToRemove, s)
                                        return false
                                }</span>
                        }
                }

                <span class="cov8" title="1">if !bucket.disabled </span><span class="cov8" title="1">{
                        c.workAllPages = append(c.workAllPages, bucket.owner)
                }</span>

                <span class="cov8" title="1">if !bucket.view </span><span class="cov8" title="1">{
                        for _, p := range bucket.pages </span><span class="cov8" title="1">{
                                ps := p.(*pageState)
                                ps.parent = bucket.owner
                                if ps.m.headless </span><span class="cov0" title="0">{
                                        c.headlessPages = append(c.headlessPages, ps)
                                }</span> else<span class="cov8" title="1"> {
                                        c.workAllPages = append(c.workAllPages, ps)
                                }</span>

                                <span class="cov8" title="1">if homeDates != nil </span><span class="cov8" title="1">{
                                        homeDates.UpdateDateAndLastmodIfAfter(ps)
                                }</span>

                                <span class="cov8" title="1">if sectionDates != nil </span><span class="cov8" title="1">{
                                        sectionDates.UpdateDateAndLastmodIfAfter(ps)
                                }</span>

                                <span class="cov8" title="1">if p.Lastmod().After(siteLastmod) </span><span class="cov8" title="1">{
                                        siteLastmod = p.Lastmod()
                                }</span>
                                <span class="cov8" title="1">if p.Date().After(siteLastDate) </span><span class="cov8" title="1">{
                                        siteLastDate = p.Date()
                                }</span>
                        }
                }

                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">if walkErr != nil </span><span class="cov0" title="0">{
                return walkErr
        }</span>

        <span class="cov8" title="1">c.pagesMap.s.lastmod = siteLastmod

        if !mainSectionsFound </span><span class="cov8" title="1">{

                // Calculare main section
                var (
                        maxRootBucketWeight int
                        maxRootBucket       *pagesMapBucket
                )

                for _, b := range rootBuckets </span><span class="cov8" title="1">{
                        weight := len(b.pages) + (len(b.bucketSections) * 5)
                        if weight &gt;= maxRootBucketWeight </span><span class="cov8" title="1">{
                                maxRootBucket = b
                                maxRootBucketWeight = weight
                        }</span>
                }

                <span class="cov8" title="1">if maxRootBucket != nil </span><span class="cov8" title="1">{
                        // Try to make this as backwards compatible as possible.
                        mainSections = []string{maxRootBucket.owner.Section()}
                }</span>
        }

        <span class="cov8" title="1">c.pagesMap.s.Info.Params()[sectionsParamId] = mainSections
        c.pagesMap.s.Info.Params()[sectionsParamIdLower] = mainSections

        for _, key := range bucketsToRemove </span><span class="cov0" title="0">{
                c.pagesMap.r.Delete(key)
        }</span>

        <span class="cov8" title="1">sort.Sort(c.workAllPages)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "context"
        "fmt"
        "os"
        pth "path"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/config"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/resources"

        "github.com/pkg/errors"
        "golang.org/x/sync/errgroup"

        "github.com/gohugoio/hugo/common/hugio"

        "github.com/gohugoio/hugo/resources/resource"

        "github.com/gohugoio/hugo/source"

        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/spf13/afero"
)

func newPagesCollector(
        sp *source.SourceSpec,
        logger *loggers.Logger,
        contentTracker *contentChangeMap,
        proc pagesCollectorProcessorProvider, filenames ...string) *pagesCollector <span class="cov8" title="1">{

        return &amp;pagesCollector{
                fs:        sp.SourceFs,
                proc:      proc,
                sp:        sp,
                logger:    logger,
                filenames: filenames,
                tracker:   contentTracker,
        }
}</span>

func newPagesProcessor(h *HugoSites, sp *source.SourceSpec, partialBuild bool) *pagesProcessor <span class="cov8" title="1">{

        return &amp;pagesProcessor{
                h:            h,
                sp:           sp,
                partialBuild: partialBuild,
                numWorkers:   config.GetNumWorkerMultiplier() * 3,
        }
}</span>

type fileinfoBundle struct {
        header    hugofs.FileMetaInfo
        resources []hugofs.FileMetaInfo
}

func (b *fileinfoBundle) containsResource(name string) bool <span class="cov0" title="0">{
        for _, r := range b.resources </span><span class="cov0" title="0">{
                if r.Name() == name </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>

}

type pageBundles map[string]*fileinfoBundle

type pagesCollector struct {
        sp     *source.SourceSpec
        fs     afero.Fs
        logger *loggers.Logger

        // Ordered list (bundle headers first) used in partial builds.
        filenames []string

        // Content files tracker used in partial builds.
        tracker *contentChangeMap

        proc pagesCollectorProcessorProvider
}

type contentDirKey struct {
        dirname  string
        filename string
        tp       bundleDirType
}

// Collect.
func (c *pagesCollector) Collect() error <span class="cov8" title="1">{
        c.proc.Start(context.Background())

        var collectErr error
        if len(c.filenames) == 0 </span><span class="cov8" title="1">{
                // Collect everything.
                collectErr = c.collectDir("", false, nil)
        }</span> else<span class="cov0" title="0"> {
                dirs := make(map[contentDirKey]bool)
                for _, filename := range c.filenames </span><span class="cov0" title="0">{
                        dir, filename, btype := c.tracker.resolveAndRemove(filename)
                        dirs[contentDirKey{dir, filename, btype}] = true
                }</span>

                <span class="cov0" title="0">for dir := range dirs </span><span class="cov0" title="0">{
                        switch dir.tp </span>{
                        case bundleLeaf, bundleBranch:<span class="cov0" title="0">
                                collectErr = c.collectDir(dir.dirname, true, nil)</span>
                        default:<span class="cov0" title="0">
                                // We always start from a directory.
                                collectErr = c.collectDir(dir.dirname, true, func(fim hugofs.FileMetaInfo) bool </span><span class="cov0" title="0">{
                                        return strings.HasSuffix(dir.filename, fim.Meta().Path())
                                }</span>)
                        }

                        <span class="cov0" title="0">if collectErr != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

        }

        <span class="cov8" title="1">err := c.proc.Wait()

        if collectErr != nil </span><span class="cov0" title="0">{
                return collectErr
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (c *pagesCollector) collectDir(dirname string, partial bool, inFilter func(fim hugofs.FileMetaInfo) bool) error <span class="cov8" title="1">{
        fi, err := c.fs.Stat(dirname)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // May have been deleted.
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">handleDir := func(
                btype bundleDirType,
                dir hugofs.FileMetaInfo,
                path string,
                readdir []hugofs.FileMetaInfo) error </span><span class="cov8" title="1">{

                if btype &gt; bundleNot &amp;&amp; c.tracker != nil </span><span class="cov0" title="0">{
                        c.tracker.add(path, btype)
                }</span>

                <span class="cov8" title="1">if btype == bundleBranch </span><span class="cov0" title="0">{
                        if err := c.handleBundleBranch(readdir); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // A branch bundle is only this directory level, so keep walking.
                        <span class="cov0" title="0">return nil</span>
                } else<span class="cov8" title="1"> if btype == bundleLeaf </span><span class="cov0" title="0">{
                        if err := c.handleBundleLeaf(dir, path, readdir); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov8" title="1">if err := c.handleFiles(readdir...); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>

        }

        <span class="cov8" title="1">filter := func(fim hugofs.FileMetaInfo) bool </span><span class="cov8" title="1">{
                if fim.Meta().SkipDir() </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">if c.sp.IgnoreFile(fim.Meta().Filename()) </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">if inFilter != nil </span><span class="cov0" title="0">{
                        return inFilter(fim)
                }</span>
                <span class="cov8" title="1">return true</span>
        }

        <span class="cov8" title="1">preHook := func(dir hugofs.FileMetaInfo, path string, readdir []hugofs.FileMetaInfo) ([]hugofs.FileMetaInfo, error) </span><span class="cov8" title="1">{
                var btype bundleDirType

                filtered := readdir[:0]
                for _, fi := range readdir </span><span class="cov8" title="1">{
                        if filter(fi) </span><span class="cov8" title="1">{
                                filtered = append(filtered, fi)
                                if c.tracker != nil </span><span class="cov0" title="0">{
                                        // Track symlinks.
                                        c.tracker.addSymbolicLinkMapping(fi)
                                }</span>
                        }
                }
                <span class="cov8" title="1">readdir = filtered

                // We merge language directories, so there can be duplicates, but they
                // will be ordered, most important first.
                var duplicates []int
                seen := make(map[string]bool)

                for i, fi := range readdir </span><span class="cov8" title="1">{

                        if fi.IsDir() </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">meta := fi.Meta()
                        class := meta.Classifier()
                        translationBase := meta.TranslationBaseNameWithExt()
                        key := pth.Join(meta.Lang(), translationBase)

                        if seen[key] </span><span class="cov0" title="0">{
                                duplicates = append(duplicates, i)
                                continue</span>
                        }
                        <span class="cov8" title="1">seen[key] = true

                        var thisBtype bundleDirType

                        switch class </span>{
                        case files.ContentClassLeaf:<span class="cov0" title="0">
                                thisBtype = bundleLeaf</span>
                        case files.ContentClassBranch:<span class="cov0" title="0">
                                thisBtype = bundleBranch</span>
                        }

                        // Folders with both index.md and _index.md type of files have
                        // undefined behaviour and can never work.
                        // The branch variant will win because of sort order, but log
                        // a warning about it.
                        <span class="cov8" title="1">if thisBtype &gt; bundleNot &amp;&amp; btype &gt; bundleNot &amp;&amp; thisBtype != btype </span><span class="cov0" title="0">{
                                c.logger.WARN.Printf("Content directory %q have both index.* and _index.* files, pick one.", dir.Meta().Filename())
                                // Reclassify it so it will be handled as a content file inside the
                                // section, which is in line with the &lt;= 0.55 behaviour.
                                meta["classifier"] = files.ContentClassContent
                        }</span> else<span class="cov8" title="1"> if thisBtype &gt; bundleNot </span><span class="cov0" title="0">{
                                btype = thisBtype
                        }</span>

                }

                <span class="cov8" title="1">if len(duplicates) &gt; 0 </span><span class="cov0" title="0">{
                        for i := len(duplicates) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                idx := duplicates[i]
                                readdir = append(readdir[:idx], readdir[idx+1:]...)
                        }</span>
                }

                <span class="cov8" title="1">err := handleDir(btype, dir, path, readdir)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if btype == bundleLeaf || partial </span><span class="cov0" title="0">{
                        return nil, filepath.SkipDir
                }</span>

                // Keep walking.
                <span class="cov8" title="1">return readdir, nil</span>

        }

        <span class="cov8" title="1">var postHook hugofs.WalkHook
        if c.tracker != nil </span><span class="cov0" title="0">{
                postHook = func(dir hugofs.FileMetaInfo, path string, readdir []hugofs.FileMetaInfo) ([]hugofs.FileMetaInfo, error) </span><span class="cov0" title="0">{
                        if c.tracker == nil </span><span class="cov0" title="0">{
                                // Nothing to do.
                                return readdir, nil
                        }</span>

                        <span class="cov0" title="0">return readdir, nil</span>
                }
        }

        <span class="cov8" title="1">wfn := func(path string, info hugofs.FileMetaInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">w := hugofs.NewWalkway(hugofs.WalkwayConfig{
                Fs:       c.fs,
                Logger:   c.logger,
                Root:     dirname,
                Info:     fi.(hugofs.FileMetaInfo),
                HookPre:  preHook,
                HookPost: postHook,
                WalkFn:   wfn})

        return w.Walk()</span>

}

func (c *pagesCollector) isBundleHeader(fi hugofs.FileMetaInfo) bool <span class="cov0" title="0">{
        class := fi.Meta().Classifier()
        return class == files.ContentClassLeaf || class == files.ContentClassBranch
}</span>

func (c *pagesCollector) getLang(fi hugofs.FileMetaInfo) string <span class="cov0" title="0">{
        lang := fi.Meta().Lang()
        if lang != "" </span><span class="cov0" title="0">{
                return lang
        }</span>

        <span class="cov0" title="0">return c.sp.DefaultContentLanguage</span>
}

func (c *pagesCollector) addToBundle(info hugofs.FileMetaInfo, btyp bundleDirType, bundles pageBundles) error <span class="cov0" title="0">{
        getBundle := func(lang string) *fileinfoBundle </span><span class="cov0" title="0">{
                return bundles[lang]
        }</span>

        <span class="cov0" title="0">cloneBundle := func(lang string) *fileinfoBundle </span><span class="cov0" title="0">{
                // Every bundled content file needs a content file header.
                // Use the default content language if found, else just
                // pick one.
                var (
                        source *fileinfoBundle
                        found  bool
                )

                source, found = bundles[c.sp.DefaultContentLanguage]
                if !found </span><span class="cov0" title="0">{
                        for _, b := range bundles </span><span class="cov0" title="0">{
                                source = b
                                break</span>
                        }
                }

                <span class="cov0" title="0">if source == nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("no source found, %d", len(bundles)))</span>
                }

                <span class="cov0" title="0">clone := c.cloneFileInfo(source.header)
                clone.Meta()["lang"] = lang

                return &amp;fileinfoBundle{
                        header: clone,
                }</span>
        }

        <span class="cov0" title="0">lang := c.getLang(info)
        bundle := getBundle(lang)
        isBundleHeader := c.isBundleHeader(info)
        if bundle != nil &amp;&amp; isBundleHeader </span><span class="cov0" title="0">{
                // index.md file inside a bundle, see issue 6208.
                info.Meta()["classifier"] = files.ContentClassContent
                isBundleHeader = false
        }</span>
        <span class="cov0" title="0">classifier := info.Meta().Classifier()
        isContent := classifier == files.ContentClassContent
        if bundle == nil </span><span class="cov0" title="0">{
                if isBundleHeader </span><span class="cov0" title="0">{
                        bundle = &amp;fileinfoBundle{header: info}
                        bundles[lang] = bundle
                }</span> else<span class="cov0" title="0"> {
                        if btyp == bundleBranch </span><span class="cov0" title="0">{
                                // No special logic for branch bundles.
                                // Every language needs its own _index.md file.
                                // Also, we only clone bundle headers for lonsesome, bundled,
                                // content files.
                                return c.handleFiles(info)
                        }</span>

                        <span class="cov0" title="0">if isContent </span><span class="cov0" title="0">{
                                bundle = cloneBundle(lang)
                                bundles[lang] = bundle
                        }</span>
                }
        }

        <span class="cov0" title="0">if !isBundleHeader &amp;&amp; bundle != nil </span><span class="cov0" title="0">{
                bundle.resources = append(bundle.resources, info)
        }</span>

        <span class="cov0" title="0">if classifier == files.ContentClassFile </span><span class="cov0" title="0">{
                translations := info.Meta().Translations()

                for lang, b := range bundles </span><span class="cov0" title="0">{
                        if !stringSliceContains(lang, translations...) &amp;&amp; !b.containsResource(info.Name()) </span><span class="cov0" title="0">{

                                // Clone and add it to the bundle.
                                clone := c.cloneFileInfo(info)
                                clone.Meta()["lang"] = lang
                                b.resources = append(b.resources, clone)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *pagesCollector) cloneFileInfo(fi hugofs.FileMetaInfo) hugofs.FileMetaInfo <span class="cov0" title="0">{
        cm := hugofs.FileMeta{}
        meta := fi.Meta()
        if meta == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("not meta: %v", fi.Name()))</span>
        }
        <span class="cov0" title="0">for k, v := range meta </span><span class="cov0" title="0">{
                cm[k] = v
        }</span>

        <span class="cov0" title="0">return hugofs.NewFileMetaInfo(fi, cm)</span>
}

func (c *pagesCollector) handleBundleBranch(readdir []hugofs.FileMetaInfo) error <span class="cov0" title="0">{

        // Maps bundles to its language.
        bundles := pageBundles{}

        for _, fim := range readdir </span><span class="cov0" title="0">{

                if fim.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">meta := fim.Meta()

                switch meta.Classifier() </span>{
                case files.ContentClassContent:<span class="cov0" title="0">
                        if err := c.handleFiles(fim); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        if err := c.addToBundle(fim, bundleBranch, bundles); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        }

        <span class="cov0" title="0">return c.proc.Process(bundles)</span>

}

func (c *pagesCollector) handleBundleLeaf(dir hugofs.FileMetaInfo, path string, readdir []hugofs.FileMetaInfo) error <span class="cov0" title="0">{
        // Maps bundles to its language.
        bundles := pageBundles{}

        walk := func(path string, info hugofs.FileMetaInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return c.addToBundle(info, bundleLeaf, bundles)</span>

        }

        // Start a new walker from the given path.
        <span class="cov0" title="0">w := hugofs.NewWalkway(hugofs.WalkwayConfig{
                Root:       path,
                Fs:         c.fs,
                Logger:     c.logger,
                Info:       dir,
                DirEntries: readdir,
                WalkFn:     walk})

        if err := w.Walk(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.proc.Process(bundles)</span>

}

func (c *pagesCollector) handleFiles(fis ...hugofs.FileMetaInfo) error <span class="cov8" title="1">{
        for _, fi := range fis </span><span class="cov8" title="1">{
                if fi.IsDir() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if err := c.proc.Process(fi); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type pagesCollectorProcessorProvider interface {
        Process(item interface{}) error
        Start(ctx context.Context) context.Context
        Wait() error
}

type pagesProcessor struct {
        h  *HugoSites
        sp *source.SourceSpec

        itemChan  chan interface{}
        itemGroup *errgroup.Group

        // The output Pages
        pagesChan  chan *pageState
        pagesGroup *errgroup.Group

        numWorkers int

        partialBuild bool
}

func (proc *pagesProcessor) Process(item interface{}) error <span class="cov8" title="1">{
        proc.itemChan &lt;- item
        return nil
}</span>

func (proc *pagesProcessor) Start(ctx context.Context) context.Context <span class="cov8" title="1">{
        proc.pagesChan = make(chan *pageState, proc.numWorkers)
        proc.pagesGroup, ctx = errgroup.WithContext(ctx)
        proc.itemChan = make(chan interface{}, proc.numWorkers)
        proc.itemGroup, ctx = errgroup.WithContext(ctx)

        proc.pagesGroup.Go(func() error </span><span class="cov8" title="1">{
                for p := range proc.pagesChan </span><span class="cov8" title="1">{
                        s := p.s
                        p.forceRender = proc.partialBuild

                        if p.forceRender </span><span class="cov0" title="0">{
                                s.replacePage(p)
                        }</span> else<span class="cov8" title="1"> {
                                s.addPage(p)
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">for i := 0; i &lt; proc.numWorkers; i++ </span><span class="cov8" title="1">{
                proc.itemGroup.Go(func() error </span><span class="cov8" title="1">{
                        for item := range proc.itemChan </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-proc.h.Done():<span class="cov0" title="0">
                                        return nil</span>
                                default:<span class="cov8" title="1">
                                        if err := proc.process(item); err != nil </span><span class="cov0" title="0">{
                                                proc.h.SendError(err)
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">return nil</span>
                })
        }

        <span class="cov8" title="1">return ctx</span>
}

func (proc *pagesProcessor) Wait() error <span class="cov8" title="1">{
        close(proc.itemChan)

        err := proc.itemGroup.Wait()

        close(proc.pagesChan)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return proc.pagesGroup.Wait()</span>
}

func (proc *pagesProcessor) newPageFromBundle(b *fileinfoBundle) (*pageState, error) <span class="cov0" title="0">{
        p, err := proc.newPageFromFi(b.header, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(b.resources) &gt; 0 </span><span class="cov0" title="0">{

                resources := make(resource.Resources, len(b.resources))

                for i, rfi := range b.resources </span><span class="cov0" title="0">{
                        meta := rfi.Meta()
                        classifier := meta.Classifier()
                        var r resource.Resource
                        switch classifier </span>{
                        case files.ContentClassContent:<span class="cov0" title="0">
                                rp, err := proc.newPageFromFi(rfi, p)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">rp.m.resourcePath = filepath.ToSlash(strings.TrimPrefix(rp.Path(), p.File().Dir()))

                                r = rp</span>

                        case files.ContentClassFile:<span class="cov0" title="0">
                                r, err = proc.newResource(rfi, p)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        default:<span class="cov0" title="0">
                                panic(fmt.Sprintf("invalid classifier: %q", classifier))</span>
                        }

                        <span class="cov0" title="0">resources[i] = r</span>

                }

                <span class="cov0" title="0">p.addResources(resources...)</span>
        }

        <span class="cov0" title="0">return p, nil</span>
}

func (proc *pagesProcessor) newPageFromFi(fim hugofs.FileMetaInfo, owner *pageState) (*pageState, error) <span class="cov8" title="1">{
        fi, err := newFileInfo(proc.sp, fim)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var s *Site
        meta := fim.Meta()

        if owner != nil </span><span class="cov0" title="0">{
                s = owner.s
        }</span> else<span class="cov8" title="1"> {
                lang := meta.Lang()
                s = proc.getSite(lang)
        }</span>

        <span class="cov8" title="1">r := func() (hugio.ReadSeekCloser, error) </span><span class="cov8" title="1">{
                return meta.Open()
        }</span>

        <span class="cov8" title="1">p, err := newPageWithContent(fi, s, owner != nil, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">p.parent = owner
        return p, nil</span>
}

func (proc *pagesProcessor) newResource(fim hugofs.FileMetaInfo, owner *pageState) (resource.Resource, error) <span class="cov0" title="0">{

        // TODO(bep) consolidate with multihost logic + clean up
        outputFormats := owner.m.outputFormats()
        seen := make(map[string]bool)
        var targetBasePaths []string
        // Make sure bundled resources are published to all of the ouptput formats'
        // sub paths.
        for _, f := range outputFormats </span><span class="cov0" title="0">{
                p := f.Path
                if seen[p] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seen[p] = true
                targetBasePaths = append(targetBasePaths, p)</span>

        }

        <span class="cov0" title="0">meta := fim.Meta()
        r := func() (hugio.ReadSeekCloser, error) </span><span class="cov0" title="0">{
                return meta.Open()
        }</span>

        <span class="cov0" title="0">target := strings.TrimPrefix(meta.Path(), owner.File().Dir())

        return owner.s.ResourceSpec.New(
                resources.ResourceSourceDescriptor{
                        TargetPaths:        owner.getTargetPaths,
                        OpenReadSeekCloser: r,
                        FileInfo:           fim,
                        RelTargetFilename:  target,
                        TargetBasePaths:    targetBasePaths,
                })</span>
}

func (proc *pagesProcessor) getSite(lang string) *Site <span class="cov8" title="1">{
        if lang == "" </span><span class="cov0" title="0">{
                return proc.h.Sites[0]
        }</span>

        <span class="cov8" title="1">for _, s := range proc.h.Sites </span><span class="cov8" title="1">{
                if lang == s.Lang() </span><span class="cov8" title="1">{
                        return s
                }</span>
        }
        <span class="cov0" title="0">return proc.h.Sites[0]</span>
}

func (proc *pagesProcessor) copyFile(fim hugofs.FileMetaInfo) error <span class="cov0" title="0">{
        meta := fim.Meta()
        s := proc.getSite(meta.Lang())
        f, err := meta.Open()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "copyFile: failed to open")
        }</span>

        <span class="cov0" title="0">target := filepath.Join(s.PathSpec.GetTargetLanguageBasePath(), meta.Path())

        defer f.Close()

        return s.publish(&amp;s.PathSpec.ProcessingStats.Files, target, f)</span>

}

func (proc *pagesProcessor) process(item interface{}) error <span class="cov8" title="1">{
        send := func(p *pageState, err error) </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        proc.sendError(err)
                }</span> else<span class="cov8" title="1"> {
                        proc.pagesChan &lt;- p
                }</span>
        }

        <span class="cov8" title="1">switch v := item.(type) </span>{
        // Page bundles mapped to their language.
        case pageBundles:<span class="cov0" title="0">
                for _, bundle := range v </span><span class="cov0" title="0">{
                        if proc.shouldSkip(bundle.header) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">send(proc.newPageFromBundle(bundle))</span>
                }
        case hugofs.FileMetaInfo:<span class="cov8" title="1">
                if proc.shouldSkip(v) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">meta := v.Meta()

                classifier := meta.Classifier()
                switch classifier </span>{
                case files.ContentClassContent:<span class="cov8" title="1">
                        send(proc.newPageFromFi(v, nil))</span>
                case files.ContentClassFile:<span class="cov0" title="0">
                        proc.sendError(proc.copyFile(v))</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("invalid classifier: %q", classifier))</span>
                }
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("unrecognized item type in Process: %T", item))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (proc *pagesProcessor) sendError(err error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">proc.h.SendError(err)</span>
}

func (proc *pagesProcessor) shouldSkip(fim hugofs.FileMetaInfo) bool <span class="cov8" title="1">{
        return proc.sp.DisabledLanguages[fim.Meta().Lang()]
}</span>

func stringSliceContains(k string, values ...string) bool <span class="cov0" title="0">{
        for _, v := range values </span><span class="cov0" title="0">{
                if k == v </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "path"
        "path/filepath"
        "strings"
        "sync"

        radix "github.com/armon/go-radix"
        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/resources/page"
)

func newPagesMap(s *Site) *pagesMap <span class="cov8" title="1">{
        return &amp;pagesMap{
                r: radix.New(),
                s: s,
        }
}</span>

type pagesMap struct {
        r *radix.Tree
        s *Site
}

func (m *pagesMap) Get(key string) *pagesMapBucket <span class="cov8" title="1">{
        key = m.cleanKey(key)
        v, found := m.r.Get(key)
        if !found </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">return v.(*pagesMapBucket)</span>
}

func (m *pagesMap) getKey(p *pageState) string <span class="cov8" title="1">{
        if !p.File().IsZero() </span><span class="cov8" title="1">{
                return m.cleanKey(p.File().Dir())
        }</span>
        <span class="cov0" title="0">return m.cleanKey(p.SectionsPath())</span>
}

func (m *pagesMap) getOrCreateHome() *pageState <span class="cov8" title="1">{
        var home *pageState
        b, found := m.r.Get("/")
        if !found </span><span class="cov8" title="1">{
                home = m.s.newPage(page.KindHome)
                m.addBucketFor("/", home, nil)
        }</span> else<span class="cov0" title="0"> {
                home = b.(*pagesMapBucket).owner
        }</span>

        <span class="cov8" title="1">return home</span>
}

func (m *pagesMap) initPageMeta(p *pageState, bucket *pagesMapBucket) error <span class="cov8" title="1">{
        var err error
        p.metaInit.Do(func() </span><span class="cov8" title="1">{
                if p.metaInitFn != nil </span><span class="cov8" title="1">{
                        err = p.metaInitFn(bucket)
                }</span>
        })
        <span class="cov8" title="1">return err</span>
}

func (m *pagesMap) initPageMetaFor(prefix string, bucket *pagesMapBucket) error <span class="cov8" title="1">{
        parentBucket := m.parentBucket(prefix)

        m.mergeCascades(bucket, parentBucket)

        if err := m.initPageMeta(bucket.owner, bucket); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !bucket.view </span><span class="cov8" title="1">{
                for _, p := range bucket.pages </span><span class="cov8" title="1">{
                        ps := p.(*pageState)
                        if err := m.initPageMeta(ps, bucket); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">for _, p := range ps.resources.ByType(pageResourceType) </span><span class="cov0" title="0">{
                                if err := m.initPageMeta(p.(*pageState), bucket); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                // Now that the metadata is initialized (with dates, draft set etc.)
                // we can remove the pages that we for some reason should not include
                // in this build.
                <span class="cov8" title="1">tmp := bucket.pages[:0]
                for _, x := range bucket.pages </span><span class="cov8" title="1">{
                        if m.s.shouldBuild(x) </span><span class="cov8" title="1">{
                                tmp = append(tmp, x)
                        }</span>
                }
                <span class="cov8" title="1">bucket.pages = tmp</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m *pagesMap) createSectionIfNotExists(section string) <span class="cov8" title="1">{
        key := m.cleanKey(section)
        _, found := m.r.Get(key)
        if !found </span><span class="cov8" title="1">{
                kind := m.s.kindFromSectionPath(section)
                p := m.s.newPage(kind, section)
                m.addBucketFor(key, p, nil)
        }</span>
}

func (m *pagesMap) addBucket(p *pageState) <span class="cov0" title="0">{
        key := m.getKey(p)

        m.addBucketFor(key, p, nil)
}</span>

func (m *pagesMap) addBucketFor(key string, p *pageState, meta map[string]interface{}) *pagesMapBucket <span class="cov8" title="1">{
        var isView bool
        switch p.Kind() </span>{
        case page.KindTaxonomy, page.KindTaxonomyTerm:<span class="cov8" title="1">
                isView = true</span>
        }

        <span class="cov8" title="1">disabled := !m.s.isEnabled(p.Kind())

        bucket := &amp;pagesMapBucket{owner: p, view: isView, meta: meta, disabled: disabled}
        p.bucket = bucket

        m.r.Insert(key, bucket)

        return bucket</span>
}

func (m *pagesMap) addPage(p *pageState) <span class="cov8" title="1">{
        if !p.IsPage() </span><span class="cov0" title="0">{
                m.addBucket(p)
                return
        }</span>

        <span class="cov8" title="1">if !m.s.isEnabled(page.KindPage) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">key := m.getKey(p)

        var bucket *pagesMapBucket

        _, v, found := m.r.LongestPrefix(key)
        if !found </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("[BUG] bucket with key %q not found", key))</span>
        }

        <span class="cov8" title="1">bucket = v.(*pagesMapBucket)
        p.bucket = bucket

        bucket.pages = append(bucket.pages, p)</span>
}

func (m *pagesMap) assemblePageMeta() error <span class="cov8" title="1">{
        var walkErr error
        m.r.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                bucket := v.(*pagesMapBucket)

                if err := m.initPageMetaFor(s, bucket); err != nil </span><span class="cov0" title="0">{
                        walkErr = err
                        return true
                }</span>
                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">return walkErr</span>
}

func (m *pagesMap) assembleTaxonomies(s *Site) error <span class="cov8" title="1">{
        s.Taxonomies = make(TaxonomyList)

        type bucketKey struct {
                plural  string
                termKey string
        }

        // Temporary cache.
        taxonomyBuckets := make(map[bucketKey]*pagesMapBucket)

        for singular, plural := range s.siteCfg.taxonomiesConfig </span><span class="cov8" title="1">{
                s.Taxonomies[plural] = make(Taxonomy)
                bkey := bucketKey{
                        plural: plural,
                }

                bucket := m.Get(plural)

                if bucket == nil </span><span class="cov8" title="1">{
                        // Create the page and bucket
                        n := s.newPage(page.KindTaxonomyTerm, plural)

                        key := m.cleanKey(plural)
                        bucket = m.addBucketFor(key, n, nil)
                        if err := m.initPageMetaFor(key, bucket); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">if bucket.meta == nil </span><span class="cov8" title="1">{
                        bucket.meta = map[string]interface{}{
                                "singular": singular,
                                "plural":   plural,
                        }
                }</span>

                // Add it to the temporary cache.
                <span class="cov8" title="1">taxonomyBuckets[bkey] = bucket

                // Taxonomy entries used in page front matter will be picked up later,
                // but there may be some yet to be used.
                pluralPrefix := m.cleanKey(plural) + "/"
                m.r.WalkPrefix(pluralPrefix, func(k string, v interface{}) bool </span><span class="cov0" title="0">{
                        tb := v.(*pagesMapBucket)
                        termKey := strings.TrimPrefix(k, pluralPrefix)
                        if tb.meta == nil </span><span class="cov0" title="0">{
                                tb.meta = map[string]interface{}{
                                        "singular": singular,
                                        "plural":   plural,
                                        "term":     tb.owner.Title(),
                                        "termKey":  termKey,
                                }
                        }</span>

                        <span class="cov0" title="0">bucket.pages = append(bucket.pages, tb.owner)
                        bkey.termKey = termKey
                        taxonomyBuckets[bkey] = tb

                        return false</span>
                })

        }

        <span class="cov8" title="1">addTaxonomy := func(singular, plural, term string, weight int, p page.Page) error </span><span class="cov0" title="0">{
                bkey := bucketKey{
                        plural: plural,
                }

                termKey := s.getTaxonomyKey(term)

                b1 := taxonomyBuckets[bkey]

                var b2 *pagesMapBucket
                bkey.termKey = termKey
                b, found := taxonomyBuckets[bkey]
                if found </span><span class="cov0" title="0">{
                        b2 = b
                }</span> else<span class="cov0" title="0"> {

                        // Create the page and bucket
                        n := s.newTaxonomyPage(term, plural, termKey)
                        meta := map[string]interface{}{
                                "singular": singular,
                                "plural":   plural,
                                "term":     term,
                                "termKey":  termKey,
                        }

                        key := m.cleanKey(path.Join(plural, termKey))
                        b2 = m.addBucketFor(key, n, meta)
                        if err := m.initPageMetaFor(key, b2); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">b1.pages = append(b1.pages, b2.owner)
                        taxonomyBuckets[bkey] = b2</span>

                }

                <span class="cov0" title="0">w := page.NewWeightedPage(weight, p, b2.owner)

                s.Taxonomies[plural].add(termKey, w)

                b1.owner.m.Dates.UpdateDateAndLastmodIfAfter(p)
                b2.owner.m.Dates.UpdateDateAndLastmodIfAfter(p)

                return nil</span>
        }

        <span class="cov8" title="1">m.r.Walk(func(k string, v interface{}) bool </span><span class="cov8" title="1">{
                b := v.(*pagesMapBucket)
                if b.view </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">for singular, plural := range s.siteCfg.taxonomiesConfig </span><span class="cov8" title="1">{
                        for _, p := range b.pages </span><span class="cov8" title="1">{

                                vals := getParam(p, plural, false)

                                w := getParamToLower(p, plural+"_weight")
                                weight, err := cast.ToIntE(w)
                                if err != nil </span><span class="cov0" title="0">{
                                        m.s.Log.ERROR.Printf("Unable to convert taxonomy weight %#v to int for %q", w, p.Path())
                                        // weight will equal zero, so let the flow continue
                                }</span>

                                <span class="cov8" title="1">if vals != nil </span><span class="cov0" title="0">{
                                        if v, ok := vals.([]string); ok </span><span class="cov0" title="0">{
                                                for _, idx := range v </span><span class="cov0" title="0">{
                                                        if err := addTaxonomy(singular, plural, idx, weight, p); err != nil </span><span class="cov0" title="0">{
                                                                m.s.Log.ERROR.Printf("Failed to add taxonomy %q for %q: %s", plural, p.Path(), err)
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> if v, ok := vals.(string); ok </span><span class="cov0" title="0">{
                                                if err := addTaxonomy(singular, plural, v, weight, p); err != nil </span><span class="cov0" title="0">{
                                                        m.s.Log.ERROR.Printf("Failed to add taxonomy %q for %q: %s", plural, p.Path(), err)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                m.s.Log.ERROR.Printf("Invalid %s in %q\n", plural, p.Path())
                                        }</span>
                                }

                        }
                }
                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">for _, plural := range s.siteCfg.taxonomiesConfig </span><span class="cov8" title="1">{
                for k := range s.Taxonomies[plural] </span><span class="cov0" title="0">{
                        s.Taxonomies[plural][k].Sort()
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m *pagesMap) cleanKey(key string) string <span class="cov8" title="1">{
        key = filepath.ToSlash(strings.ToLower(key))
        key = strings.Trim(key, "/")
        return "/" + key
}</span>

func (m *pagesMap) mergeCascades(b1, b2 *pagesMapBucket) <span class="cov8" title="1">{
        if b1.cascade == nil </span><span class="cov8" title="1">{
                b1.cascade = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">if b2 != nil &amp;&amp; b2.cascade != nil </span><span class="cov8" title="1">{
                for k, v := range b2.cascade </span><span class="cov0" title="0">{
                        if _, found := b1.cascade[k]; !found </span><span class="cov0" title="0">{
                                b1.cascade[k] = v
                        }</span>
                }
        }
}

func (m *pagesMap) parentBucket(prefix string) *pagesMapBucket <span class="cov8" title="1">{
        if prefix == "/" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">_, parentv, found := m.r.LongestPrefix(path.Dir(prefix))
        if !found </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("[BUG] parent bucket not found for %q", prefix))</span>
        }
        <span class="cov8" title="1">return parentv.(*pagesMapBucket)</span>

}

func (m *pagesMap) withEveryPage(f func(p *pageState)) <span class="cov0" title="0">{
        m.r.Walk(func(k string, v interface{}) bool </span><span class="cov0" title="0">{
                b := v.(*pagesMapBucket)
                f(b.owner)
                if !b.view </span><span class="cov0" title="0">{
                        for _, p := range b.pages </span><span class="cov0" title="0">{
                                f(p.(*pageState))
                        }</span>
                }

                <span class="cov0" title="0">return false</span>
        })
}

type pagesMapBucket struct {
        // Set if the pages in this bucket is also present in another bucket.
        view bool

        // Some additional metatadata attached to this node.
        meta map[string]interface{}

        // Cascading front matter.
        cascade map[string]interface{}

        owner *pageState // The branch node

        // When disableKinds is enabled for this node.
        disabled bool

        // Used to navigate the sections tree
        parent         *pagesMapBucket
        bucketSections []*pagesMapBucket

        pagesInit sync.Once
        pages     page.Pages

        pagesAndSectionsInit sync.Once
        pagesAndSections     page.Pages

        sectionsInit sync.Once
        sections     page.Pages
}

func (b *pagesMapBucket) isEmpty() bool <span class="cov8" title="1">{
        return len(b.pages) == 0 &amp;&amp; len(b.bucketSections) == 0
}</span>

func (b *pagesMapBucket) getPages() page.Pages <span class="cov8" title="1">{
        b.pagesInit.Do(func() </span><span class="cov8" title="1">{
                page.SortByDefault(b.pages)
        }</span>)
        <span class="cov8" title="1">return b.pages</span>
}

func (b *pagesMapBucket) getPagesAndSections() page.Pages <span class="cov0" title="0">{
        b.pagesAndSectionsInit.Do(func() </span><span class="cov0" title="0">{
                var pas page.Pages
                pas = append(pas, b.pages...)
                for _, p := range b.bucketSections </span><span class="cov0" title="0">{
                        pas = append(pas, p.owner)
                }</span>
                <span class="cov0" title="0">b.pagesAndSections = pas
                page.SortByDefault(b.pagesAndSections)</span>
        })
        <span class="cov0" title="0">return b.pagesAndSections</span>
}

func (b *pagesMapBucket) getSections() page.Pages <span class="cov0" title="0">{
        b.sectionsInit.Do(func() </span><span class="cov0" title="0">{
                for _, p := range b.bucketSections </span><span class="cov0" title="0">{
                        b.sections = append(b.sections, p.owner)
                }</span>
                <span class="cov0" title="0">page.SortByDefault(b.sections)</span>
        })

        <span class="cov0" title="0">return b.sections</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package paths

import (
        "fmt"
        "net/url"
        "strings"
)

// A BaseURL in Hugo is normally on the form scheme://path, but the
// form scheme: is also valid (mailto:hugo@rules.com).
type BaseURL struct {
        url    *url.URL
        urlStr string
}

func (b BaseURL) String() string <span class="cov8" title="1">{
        if b.urlStr != "" </span><span class="cov8" title="1">{
                return b.urlStr
        }</span>
        <span class="cov0" title="0">return b.url.String()</span>
}

func (b BaseURL) Path() string <span class="cov8" title="1">{
        return b.url.Path
}</span>

// HostURL returns the URL to the host root without any path elements.
func (b BaseURL) HostURL() string <span class="cov0" title="0">{
        return strings.TrimSuffix(b.String(), b.Path())
}</span>

// WithProtocol returns the BaseURL prefixed with the given protocol.
// The Protocol is normally of the form "scheme://", i.e. "webcal://".
func (b BaseURL) WithProtocol(protocol string) (string, error) <span class="cov0" title="0">{
        u := b.URL()

        scheme := protocol
        isFullProtocol := strings.HasSuffix(scheme, "://")
        isOpaqueProtocol := strings.HasSuffix(scheme, ":")

        if isFullProtocol </span><span class="cov0" title="0">{
                scheme = strings.TrimSuffix(scheme, "://")
        }</span> else<span class="cov0" title="0"> if isOpaqueProtocol </span><span class="cov0" title="0">{
                scheme = strings.TrimSuffix(scheme, ":")
        }</span>

        <span class="cov0" title="0">u.Scheme = scheme

        if isFullProtocol &amp;&amp; u.Opaque != "" </span><span class="cov0" title="0">{
                u.Opaque = "//" + u.Opaque
        }</span> else<span class="cov0" title="0"> if isOpaqueProtocol &amp;&amp; u.Opaque == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("cannot determine BaseURL for protocol %q", protocol)
        }</span>

        <span class="cov0" title="0">return u.String(), nil</span>
}

// URL returns a copy of the internal URL.
// The copy can be safely used and modified.
func (b BaseURL) URL() *url.URL <span class="cov0" title="0">{
        c := *b.url
        return &amp;c
}</span>

func newBaseURLFromString(b string) (BaseURL, error) <span class="cov8" title="1">{
        var result BaseURL

        base, err := url.Parse(b)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov8" title="1">return BaseURL{url: base, urlStr: base.String()}, nil</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package paths

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/modules"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/hugofs"
)

var FilePathSeparator = string(filepath.Separator)

type Paths struct {
        Fs  *hugofs.Fs
        Cfg config.Provider

        BaseURL

        // If the baseURL contains a base path, e.g. https://example.com/docs, then "/docs" will be the BasePath.
        BasePath string

        // Directories
        // TODO(bep) when we have trimmed down mos of the dirs usage outside of this package, make
        // these into an interface.
        ThemesDir  string
        WorkingDir string

        // Directories to store Resource related artifacts.
        AbsResourcesDir string

        AbsPublishDir string

        // pagination path handling
        PaginatePath string

        PublishDir string

        // When in multihost mode, this returns a list of base paths below PublishDir
        // for each language.
        MultihostTargetBasePaths []string

        DisablePathToLower bool
        RemovePathAccents  bool
        UglyURLs           bool
        CanonifyURLs       bool

        Language              *langs.Language
        Languages             langs.Languages
        LanguagesDefaultFirst langs.Languages

        // The PathSpec looks up its config settings in both the current language
        // and then in the global Viper config.
        // Some settings, the settings listed below, does not make sense to be set
        // on per-language-basis. We have no good way of protecting against this
        // other than a "white-list". See language.go.
        defaultContentLanguageInSubdir bool
        DefaultContentLanguage         string
        multilingual                   bool

        AllModules    modules.Modules
        ModulesClient *modules.Client
}

func New(fs *hugofs.Fs, cfg config.Provider) (*Paths, error) <span class="cov8" title="1">{
        baseURLstr := cfg.GetString("baseURL")
        baseURL, err := newBaseURLFromString(baseURLstr)

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "Failed to create baseURL from %q:", baseURLstr)
        }</span>

        <span class="cov8" title="1">contentDir := filepath.Clean(cfg.GetString("contentDir"))
        workingDir := filepath.Clean(cfg.GetString("workingDir"))
        resourceDir := filepath.Clean(cfg.GetString("resourceDir"))
        publishDir := filepath.Clean(cfg.GetString("publishDir"))

        if publishDir == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("publishDir not set")
        }</span>

        <span class="cov8" title="1">defaultContentLanguage := cfg.GetString("defaultContentLanguage")

        var (
                language              *langs.Language
                languages             langs.Languages
                languagesDefaultFirst langs.Languages
        )

        if l, ok := cfg.(*langs.Language); ok </span><span class="cov8" title="1">{
                language = l

        }</span>

        <span class="cov8" title="1">if l, ok := cfg.Get("languagesSorted").(langs.Languages); ok </span><span class="cov8" title="1">{
                languages = l
        }</span>

        <span class="cov8" title="1">if l, ok := cfg.Get("languagesSortedDefaultFirst").(langs.Languages); ok </span><span class="cov8" title="1">{
                languagesDefaultFirst = l
        }</span>

        //

        <span class="cov8" title="1">if len(languages) == 0 </span><span class="cov0" title="0">{
                // We have some old tests that does not test the entire chain, hence
                // they have no languages. So create one so we get the proper filesystem.
                languages = langs.Languages{&amp;langs.Language{Lang: "en", Cfg: cfg, ContentDir: contentDir}}
        }</span>

        <span class="cov8" title="1">absPublishDir := AbsPathify(workingDir, publishDir)
        if !strings.HasSuffix(absPublishDir, FilePathSeparator) </span><span class="cov8" title="1">{
                absPublishDir += FilePathSeparator
        }</span>
        // If root, remove the second '/'
        <span class="cov8" title="1">if absPublishDir == "//" </span><span class="cov0" title="0">{
                absPublishDir = FilePathSeparator
        }</span>
        <span class="cov8" title="1">absResourcesDir := AbsPathify(workingDir, resourceDir)
        if !strings.HasSuffix(absResourcesDir, FilePathSeparator) </span><span class="cov8" title="1">{
                absResourcesDir += FilePathSeparator
        }</span>
        <span class="cov8" title="1">if absResourcesDir == "//" </span><span class="cov0" title="0">{
                absResourcesDir = FilePathSeparator
        }</span>

        <span class="cov8" title="1">var multihostTargetBasePaths []string
        if languages.IsMultihost() </span><span class="cov0" title="0">{
                for _, l := range languages </span><span class="cov0" title="0">{
                        multihostTargetBasePaths = append(multihostTargetBasePaths, l.Lang)
                }</span>
        }

        <span class="cov8" title="1">p := &amp;Paths{
                Fs:      fs,
                Cfg:     cfg,
                BaseURL: baseURL,

                DisablePathToLower: cfg.GetBool("disablePathToLower"),
                RemovePathAccents:  cfg.GetBool("removePathAccents"),
                UglyURLs:           cfg.GetBool("uglyURLs"),
                CanonifyURLs:       cfg.GetBool("canonifyURLs"),

                ThemesDir:  cfg.GetString("themesDir"),
                WorkingDir: workingDir,

                AbsResourcesDir: absResourcesDir,
                AbsPublishDir:   absPublishDir,

                multilingual:                   cfg.GetBool("multilingual"),
                defaultContentLanguageInSubdir: cfg.GetBool("defaultContentLanguageInSubdir"),
                DefaultContentLanguage:         defaultContentLanguage,

                Language:                 language,
                Languages:                languages,
                LanguagesDefaultFirst:    languagesDefaultFirst,
                MultihostTargetBasePaths: multihostTargetBasePaths,

                PaginatePath: cfg.GetString("paginatePath"),
        }

        if cfg.IsSet("allModules") </span><span class="cov8" title="1">{
                p.AllModules = cfg.Get("allModules").(modules.Modules)
        }</span>

        <span class="cov8" title="1">if cfg.IsSet("modulesClient") </span><span class="cov8" title="1">{
                p.ModulesClient = cfg.Get("modulesClient").(*modules.Client)
        }</span>

        // TODO(bep) remove this, eventually
        <span class="cov8" title="1">p.PublishDir = absPublishDir

        return p, nil</span>
}

// GetBasePath returns any path element in baseURL if needed.
func (p *Paths) GetBasePath(isRelativeURL bool) string <span class="cov8" title="1">{
        if isRelativeURL &amp;&amp; p.CanonifyURLs </span><span class="cov0" title="0">{
                // The baseURL will be prepended later.
                return ""
        }</span>
        <span class="cov8" title="1">return p.BasePath</span>
}

func (p *Paths) Lang() string <span class="cov8" title="1">{
        if p == nil || p.Language == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return p.Language.Lang</span>
}

func (p *Paths) GetTargetLanguageBasePath() string <span class="cov0" title="0">{
        if p.Languages.IsMultihost() </span><span class="cov0" title="0">{
                // In a multihost configuration all assets will be published below the language code.
                return p.Lang()
        }</span>
        <span class="cov0" title="0">return p.GetLanguagePrefix()</span>
}

func (p *Paths) GetURLLanguageBasePath() string <span class="cov0" title="0">{
        if p.Languages.IsMultihost() </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return p.GetLanguagePrefix()</span>
}

func (p *Paths) GetLanguagePrefix() string <span class="cov0" title="0">{
        if !p.multilingual </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">defaultLang := p.DefaultContentLanguage
        defaultInSubDir := p.defaultContentLanguageInSubdir

        currentLang := p.Language.Lang
        if currentLang == "" || (currentLang == defaultLang &amp;&amp; !defaultInSubDir) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return currentLang</span>
}

// GetLangSubDir returns the given language's subdir if needed.
func (p *Paths) GetLangSubDir(lang string) string <span class="cov0" title="0">{
        if !p.multilingual </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if p.Languages.IsMultihost() </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if lang == "" || (lang == p.DefaultContentLanguage &amp;&amp; !p.defaultContentLanguageInSubdir) </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return lang</span>
}

// AbsPathify creates an absolute path if given a relative path. If already
// absolute, the path is just cleaned.
func (p *Paths) AbsPathify(inPath string) string <span class="cov0" title="0">{
        return AbsPathify(p.WorkingDir, inPath)
}</span>

// RelPathify trims any WorkingDir prefix from the given filename. If
// the filename is not considered to be absolute, the path is just cleaned.
func (p *Paths) RelPathify(filename string) string <span class="cov0" title="0">{
        filename = filepath.Clean(filename)
        if !filepath.IsAbs(filename) </span><span class="cov0" title="0">{
                return filename
        }</span>

        <span class="cov0" title="0">return strings.TrimPrefix(strings.TrimPrefix(filename, p.WorkingDir), FilePathSeparator)</span>

}

// AbsPathify creates an absolute path if given a working dir and arelative path.
// If already absolute, the path is just cleaned.
func AbsPathify(workingDir, inPath string) string <span class="cov8" title="1">{
        if filepath.IsAbs(inPath) </span><span class="cov0" title="0">{
                return filepath.Clean(inPath)
        }</span>
        <span class="cov8" title="1">return filepath.Join(workingDir, inPath)</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

// GC requires a build first and must run on it's own. It is not thread safe.
func (h *HugoSites) GC() (int, error) <span class="cov0" title="0">{
        return h.Deps.FileCaches.Prune()
}</span>
</pre>
		
		<pre class="file" id="file125" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "bytes"
        "fmt"
        "strconv"

        "html/template"
        "path"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/pkg/errors"

        "reflect"

        "regexp"
        "sort"

        "github.com/gohugoio/hugo/parser/pageparser"
        "github.com/gohugoio/hugo/resources/page"

        _errors "github.com/pkg/errors"

        "strings"
        "sync"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/common/text"
        "github.com/gohugoio/hugo/common/urls"
        "github.com/gohugoio/hugo/output"

        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/tpl"
)

var (
        _ urls.RefLinker  = (*ShortcodeWithPage)(nil)
        _ pageWrapper     = (*ShortcodeWithPage)(nil)
        _ text.Positioner = (*ShortcodeWithPage)(nil)
)

// ShortcodeWithPage is the "." context in a shortcode template.
type ShortcodeWithPage struct {
        Params        interface{}
        Inner         template.HTML
        Page          page.Page
        Parent        *ShortcodeWithPage
        Name          string
        IsNamedParams bool

        // Zero-based ordinal in relation to its parent. If the parent is the page itself,
        // this ordinal will represent the position of this shortcode in the page content.
        Ordinal int

        // pos is the position in bytes in the source file. Used for error logging.
        posInit   sync.Once
        posOffset int
        pos       text.Position

        scratch *maps.Scratch
}

// Position returns this shortcode's detailed position. Note that this information
// may be expensive to calculate, so only use this in error situations.
func (scp *ShortcodeWithPage) Position() text.Position <span class="cov0" title="0">{
        scp.posInit.Do(func() </span><span class="cov0" title="0">{
                if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok </span><span class="cov0" title="0">{
                        scp.pos = p.posOffset(scp.posOffset)
                }</span>
        })
        <span class="cov0" title="0">return scp.pos</span>
}

// Site returns information about the current site.
func (scp *ShortcodeWithPage) Site() page.Site <span class="cov0" title="0">{
        return scp.Page.Site()
}</span>

// Ref is a shortcut to the Ref method on Page. It passes itself as a context
// to get better error messages.
func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) <span class="cov0" title="0">{
        return scp.Page.RefFrom(args, scp)
}</span>

// RelRef is a shortcut to the RelRef method on Page. It passes itself as a context
// to get better error messages.
func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) <span class="cov0" title="0">{
        return scp.Page.RelRefFrom(args, scp)
}</span>

// Scratch returns a scratch-pad scoped for this shortcode. This can be used
// as a temporary storage for variables, counters etc.
func (scp *ShortcodeWithPage) Scratch() *maps.Scratch <span class="cov0" title="0">{
        if scp.scratch == nil </span><span class="cov0" title="0">{
                scp.scratch = maps.NewScratch()
        }</span>
        <span class="cov0" title="0">return scp.scratch</span>
}

// Get is a convenience method to look up shortcode parameters by its key.
func (scp *ShortcodeWithPage) Get(key interface{}) interface{} <span class="cov0" title="0">{
        if scp.Params == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if reflect.ValueOf(scp.Params).Len() == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var x reflect.Value

        switch key.(type) </span>{
        case int64, int32, int16, int8, int:<span class="cov0" title="0">
                if reflect.TypeOf(scp.Params).Kind() == reflect.Map </span><span class="cov0" title="0">{
                        // We treat this as a non error, so people can do similar to
                        // {{ $myParam := .Get "myParam" | default .Get 0 }}
                        // Without having to do additional checks.
                        return nil
                }</span> else<span class="cov0" title="0"> if reflect.TypeOf(scp.Params).Kind() == reflect.Slice </span><span class="cov0" title="0">{
                        idx := int(reflect.ValueOf(key).Int())
                        ln := reflect.ValueOf(scp.Params).Len()
                        if idx &gt; ln-1 </span><span class="cov0" title="0">{
                                return ""
                        }</span>
                        <span class="cov0" title="0">x = reflect.ValueOf(scp.Params).Index(idx)</span>
                }
        case string:<span class="cov0" title="0">
                if reflect.TypeOf(scp.Params).Kind() == reflect.Map </span><span class="cov0" title="0">{
                        x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key))
                        if !x.IsValid() </span><span class="cov0" title="0">{
                                return ""
                        }</span>
                } else<span class="cov0" title="0"> if reflect.TypeOf(scp.Params).Kind() == reflect.Slice </span><span class="cov0" title="0">{
                        // We treat this as a non error, so people can do similar to
                        // {{ $myParam := .Get "myParam" | default .Get 0 }}
                        // Without having to do additional checks.
                        return nil
                }</span>
        }

        <span class="cov0" title="0">switch x.Kind() </span>{
        case reflect.String:<span class="cov0" title="0">
                return x.String()</span>
        case reflect.Int64, reflect.Int32, reflect.Int16, reflect.Int8, reflect.Int:<span class="cov0" title="0">
                return x.Int()</span>
        default:<span class="cov0" title="0">
                return x</span>
        }

}

func (scp *ShortcodeWithPage) page() page.Page <span class="cov0" title="0">{
        return scp.Page
}</span>

// Note - this value must not contain any markup syntax
const shortcodePlaceholderPrefix = "HAHAHUGOSHORTCODE"

func createShortcodePlaceholder(id string, ordinal int) string <span class="cov8" title="1">{
        return shortcodePlaceholderPrefix + "-" + id + strconv.Itoa(ordinal) + "-HBHB"
}</span>

type shortcode struct {
        name      string
        isInline  bool          // inline shortcode. Any inner will be a Go template.
        isClosing bool          // whether a closing tag was provided
        inner     []interface{} // string or nested shortcode
        params    interface{}   // map or array
        ordinal   int
        err       error

        info tpl.Info

        // If set, the rendered shortcode is sent as part of the surrounding content
        // to Blackfriday and similar.
        // Before Hug0 0.55 we didn't send any shortcode output to the markup
        // renderer, and this flag told Hugo to process the {{ .Inner }} content
        // separately.
        // The old behaviour can be had by starting your shortcode template with:
        //    {{ $_hugo_config := `{ "version": 1 }`}}
        doMarkup bool

        // the placeholder in the source when passed to Blackfriday etc.
        // This also identifies the rendered shortcode.
        placeholder string

        pos    int // the position in bytes in the source file
        length int // the length in bytes in the source file
}

func (s shortcode) insertPlaceholder() bool <span class="cov0" title="0">{
        return !s.doMarkup || s.info.Config.Version == 1
}</span>

func (s shortcode) innerString() string <span class="cov0" title="0">{
        var sb strings.Builder

        for _, inner := range s.inner </span><span class="cov0" title="0">{
                sb.WriteString(inner.(string))
        }</span>

        <span class="cov0" title="0">return sb.String()</span>
}

func (sc shortcode) String() string <span class="cov0" title="0">{
        // for testing (mostly), so any change here will break tests!
        var params interface{}
        switch v := sc.params.(type) </span>{
        case map[string]string:<span class="cov0" title="0">
                // sort the keys so test assertions won't fail
                var keys []string
                for k := range v </span><span class="cov0" title="0">{
                        keys = append(keys, k)
                }</span>
                <span class="cov0" title="0">sort.Strings(keys)
                var tmp = make([]string, len(keys))

                for i, k := range keys </span><span class="cov0" title="0">{
                        tmp[i] = k + ":" + v[k]
                }</span>
                <span class="cov0" title="0">params = tmp</span>

        default:<span class="cov0" title="0">
                // use it as is
                params = sc.params</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%s(%q, %t){%s}", sc.name, params, sc.doMarkup, sc.inner)</span>
}

type shortcodeHandler struct {
        p *pageState

        s *Site

        // Ordered list of shortcodes for a page.
        shortcodes []*shortcode

        // All the shortcode names in this set.
        nameSet map[string]bool

        // Configuration
        enableInlineShortcodes bool
}

func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler <span class="cov8" title="1">{

        sh := &amp;shortcodeHandler{
                p:                      p,
                s:                      s,
                enableInlineShortcodes: s.enableInlineShortcodes,
                shortcodes:             make([]*shortcode, 0, 4),
                nameSet:                make(map[string]bool),
        }

        return sh
}</span>

const (
        innerNewlineRegexp = "\n"
        innerCleanupRegexp = `\A&lt;p&gt;(.*)&lt;/p&gt;\n\z`
        innerCleanupExpand = "$1"
)

func renderShortcode(
        level int,
        s *Site,
        tplVariants tpl.TemplateVariants,
        sc *shortcode,
        parent *ShortcodeWithPage,
        p *pageState) (string, bool, error) <span class="cov0" title="0">{

        var tmpl tpl.Template

        // Tracks whether this shortcode or any of its children has template variations
        // in other languages or output formats. We are currently only interested in
        // the output formats, so we may get some false positives -- we
        // should improve on that.
        var hasVariants bool

        if sc.isInline </span><span class="cov0" title="0">{
                if !p.s.enableInlineShortcodes </span><span class="cov0" title="0">{
                        return "", false, nil
                }</span>
                <span class="cov0" title="0">templName := path.Join("_inline_shortcode", p.File().Path(), sc.name)
                if sc.isClosing </span><span class="cov0" title="0">{
                        templStr := sc.innerString()

                        var err error
                        tmpl, err = s.TextTmpl.Parse(templName, templStr)
                        if err != nil </span><span class="cov0" title="0">{
                                fe := herrors.ToFileError("html", err)
                                l1, l2 := p.posOffset(sc.pos).LineNumber, fe.Position().LineNumber
                                fe = herrors.ToFileErrorWithLineNumber(fe, l1+l2-1)
                                return "", false, p.wrapError(fe)
                        }</span>

                } else<span class="cov0" title="0"> {
                        // Re-use of shortcode defined earlier in the same page.
                        var found bool
                        tmpl, found = s.TextTmpl.Lookup(templName)
                        if !found </span><span class="cov0" title="0">{
                                return "", false, _errors.Errorf("no earlier definition of shortcode %q found", sc.name)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                var found, more bool
                tmpl, found, more = s.Tmpl.LookupVariant(sc.name, tplVariants)
                if !found </span><span class="cov0" title="0">{
                        s.Log.ERROR.Printf("Unable to locate template for shortcode %q in page %q", sc.name, p.File().Path())
                        return "", false, nil
                }</span>
                <span class="cov0" title="0">hasVariants = hasVariants || more</span>
        }

        <span class="cov0" title="0">data := &amp;ShortcodeWithPage{Ordinal: sc.ordinal, posOffset: sc.pos, Params: sc.params, Page: newPageForShortcode(p), Parent: parent, Name: sc.name}
        if sc.params != nil </span><span class="cov0" title="0">{
                data.IsNamedParams = reflect.TypeOf(sc.params).Kind() == reflect.Map
        }</span>

        <span class="cov0" title="0">if len(sc.inner) &gt; 0 </span><span class="cov0" title="0">{
                var inner string
                for _, innerData := range sc.inner </span><span class="cov0" title="0">{
                        switch innerData := innerData.(type) </span>{
                        case string:<span class="cov0" title="0">
                                inner += innerData</span>
                        case *shortcode:<span class="cov0" title="0">
                                s, more, err := renderShortcode(level+1, s, tplVariants, innerData, data, p)
                                if err != nil </span><span class="cov0" title="0">{
                                        return "", false, err
                                }</span>
                                <span class="cov0" title="0">hasVariants = hasVariants || more
                                inner += s</span>
                        default:<span class="cov0" title="0">
                                s.Log.ERROR.Printf("Illegal state on shortcode rendering of %q in page %q. Illegal type in inner data: %s ",
                                        sc.name, p.File().Path(), reflect.TypeOf(innerData))
                                return "", false, nil</span>
                        }
                }

                // Pre Hugo 0.55 this was the behaviour even for the outer-most
                // shortcode.
                <span class="cov0" title="0">if sc.doMarkup &amp;&amp; (level &gt; 0 || sc.info.Config.Version == 1) </span><span class="cov0" title="0">{
                        newInner := s.ContentSpec.RenderBytes(&amp;helpers.RenderingContext{
                                Content:      []byte(inner),
                                PageFmt:      p.m.markup,
                                Cfg:          p.Language(),
                                DocumentID:   p.File().UniqueID(),
                                DocumentName: p.File().Path(),
                                Config:       p.getRenderingConfig()})

                        // If the type is  (unknown) or markdown, we assume the markdown
                        // generation has been performed. Given the input: `a line`, markdown
                        // specifies the HTML `&lt;p&gt;a line&lt;/p&gt;\n`. When dealing with documents as a
                        // whole, this is OK. When dealing with an `{{ .Inner }}` block in Hugo,
                        // this is not so good. This code does two things:
                        //
                        // 1.  Check to see if inner has a newline in it. If so, the Inner data is
                        //     unchanged.
                        // 2   If inner does not have a newline, strip the wrapping &lt;p&gt; block and
                        //     the newline.
                        switch p.m.markup </span>{
                        case "", "markdown":<span class="cov0" title="0">
                                if match, _ := regexp.MatchString(innerNewlineRegexp, inner); !match </span><span class="cov0" title="0">{
                                        cleaner, err := regexp.Compile(innerCleanupRegexp)

                                        if err == nil </span><span class="cov0" title="0">{
                                                newInner = cleaner.ReplaceAll(newInner, []byte(innerCleanupExpand))
                                        }</span>
                                }
                        }

                        // TODO(bep) we may have plain text inner templates.
                        <span class="cov0" title="0">data.Inner = template.HTML(newInner)</span>
                } else<span class="cov0" title="0"> {
                        data.Inner = template.HTML(inner)
                }</span>

        }

        <span class="cov0" title="0">result, err := renderShortcodeWithPage(tmpl, data)

        if err != nil &amp;&amp; sc.isInline </span><span class="cov0" title="0">{
                fe := herrors.ToFileError("html", err)
                l1, l2 := p.posFromPage(sc.pos).LineNumber, fe.Position().LineNumber
                fe = herrors.ToFileErrorWithLineNumber(fe, l1+l2-1)
                return "", false, fe
        }</span>

        <span class="cov0" title="0">return result, hasVariants, err</span>
}

func (s *shortcodeHandler) hasShortcodes() bool <span class="cov8" title="1">{
        return len(s.shortcodes) &gt; 0
}</span>

func (s *shortcodeHandler) renderShortcodesForPage(p *pageState, f output.Format) (map[string]string, bool, error) <span class="cov8" title="1">{

        rendered := make(map[string]string)

        tplVariants := tpl.TemplateVariants{
                Language:     p.Language().Lang,
                OutputFormat: f,
        }

        var hasVariants bool

        for _, v := range s.shortcodes </span><span class="cov0" title="0">{
                s, more, err := renderShortcode(0, s.s, tplVariants, v, nil, p)
                if err != nil </span><span class="cov0" title="0">{
                        err = p.parseError(_errors.Wrapf(err, "failed to render shortcode %q", v.name), p.source.parsed.Input(), v.pos)
                        return nil, false, err
                }</span>
                <span class="cov0" title="0">hasVariants = hasVariants || more
                rendered[v.placeholder] = s</span>

        }

        <span class="cov8" title="1">return rendered, hasVariants, nil</span>
}

var errShortCodeIllegalState = errors.New("Illegal shortcode state")

func (s *shortcodeHandler) parseError(err error, input []byte, pos int) error <span class="cov0" title="0">{
        if s.p != nil </span><span class="cov0" title="0">{
                return s.p.parseError(err, input, pos)
        }</span>
        <span class="cov0" title="0">return err</span>
}

// pageTokens state:
// - before: positioned just before the shortcode start
// - after: shortcode(s) consumed (plural when they are nested)
func (s *shortcodeHandler) extractShortcode(ordinal, level int, pt *pageparser.Iterator) (*shortcode, error) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                panic("handler nil")</span>
        }
        <span class="cov0" title="0">sc := &amp;shortcode{ordinal: ordinal}

        var cnt = 0
        var nestedOrdinal = 0
        var nextLevel = level + 1

        fail := func(err error, i pageparser.Item) error </span><span class="cov0" title="0">{
                return s.parseError(err, pt.Input(), i.Pos)
        }</span>

<span class="cov0" title="0">Loop:
        for </span><span class="cov0" title="0">{
                currItem := pt.Next()
                switch </span>{
                case currItem.IsLeftShortcodeDelim():<span class="cov0" title="0">
                        next := pt.Peek()
                        if next.IsShortcodeClose() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if cnt &gt; 0 </span><span class="cov0" title="0">{
                                // nested shortcode; append it to inner content
                                pt.Backup()
                                nested, err := s.extractShortcode(nestedOrdinal, nextLevel, pt)
                                nestedOrdinal++
                                if nested != nil &amp;&amp; nested.name != "" </span><span class="cov0" title="0">{
                                        s.nameSet[nested.name] = true
                                }</span>

                                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                                        sc.inner = append(sc.inner, nested)
                                }</span> else<span class="cov0" title="0"> {
                                        return sc, err
                                }</span>

                        } else<span class="cov0" title="0"> {
                                sc.doMarkup = currItem.IsShortcodeMarkupDelimiter()
                        }</span>

                        <span class="cov0" title="0">cnt++</span>

                case currItem.IsRightShortcodeDelim():<span class="cov0" title="0">
                        // we trust the template on this:
                        // if there's no inner, we're done
                        if !sc.isInline &amp;&amp; !sc.info.IsInner </span><span class="cov0" title="0">{
                                return sc, nil
                        }</span>

                case currItem.IsShortcodeClose():<span class="cov0" title="0">
                        next := pt.Peek()
                        if !sc.isInline &amp;&amp; !sc.info.IsInner </span><span class="cov0" title="0">{
                                if next.IsError() </span><span class="cov0" title="0">{
                                        // return that error, more specific
                                        continue</span>
                                }

                                <span class="cov0" title="0">return sc, fail(_errors.Errorf("shortcode %q has no .Inner, yet a closing tag was provided", next.Val), next)</span>
                        }
                        <span class="cov0" title="0">if next.IsRightShortcodeDelim() </span><span class="cov0" title="0">{
                                // self-closing
                                pt.Consume(1)
                        }</span> else<span class="cov0" title="0"> {
                                sc.isClosing = true
                                pt.Consume(2)
                        }</span>

                        <span class="cov0" title="0">return sc, nil</span>
                case currItem.IsText():<span class="cov0" title="0">
                        sc.inner = append(sc.inner, currItem.ValStr())</span>
                case currItem.IsShortcodeName():<span class="cov0" title="0">

                        sc.name = currItem.ValStr()

                        // Check if the template expects inner content.
                        // We pick the first template for an arbitrary output format
                        // if more than one. It is "all inner or no inner".
                        tmpl, found, _ := s.s.Tmpl.LookupVariant(sc.name, tpl.TemplateVariants{})
                        if !found </span><span class="cov0" title="0">{
                                return nil, _errors.Errorf("template for shortcode %q not found", sc.name)
                        }</span>

                        <span class="cov0" title="0">sc.info = tmpl.(tpl.TemplateInfoProvider).TemplateInfo()</span>
                case currItem.IsInlineShortcodeName():<span class="cov0" title="0">
                        sc.name = currItem.ValStr()
                        sc.isInline = true</span>
                case currItem.IsShortcodeParam():<span class="cov0" title="0">
                        if !pt.IsValueNext() </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov0" title="0"> if pt.Peek().IsShortcodeParamVal() </span><span class="cov0" title="0">{
                                // named params
                                if sc.params == nil </span><span class="cov0" title="0">{
                                        params := make(map[string]string)
                                        params[currItem.ValStr()] = pt.Next().ValStr()
                                        sc.params = params
                                }</span> else<span class="cov0" title="0"> {
                                        if params, ok := sc.params.(map[string]string); ok </span><span class="cov0" title="0">{
                                                params[currItem.ValStr()] = pt.Next().ValStr()
                                        }</span> else<span class="cov0" title="0"> {
                                                return sc, errShortCodeIllegalState
                                        }</span>

                                }
                        } else<span class="cov0" title="0"> {
                                // positional params
                                if sc.params == nil </span><span class="cov0" title="0">{
                                        var params []string
                                        params = append(params, currItem.ValStr())
                                        sc.params = params
                                }</span> else<span class="cov0" title="0"> {
                                        if params, ok := sc.params.([]string); ok </span><span class="cov0" title="0">{
                                                params = append(params, currItem.ValStr())
                                                sc.params = params
                                        }</span> else<span class="cov0" title="0"> {
                                                return sc, errShortCodeIllegalState
                                        }</span>

                                }
                        }
                case currItem.IsDone():<span class="cov0" title="0">
                        // handled by caller
                        pt.Backup()
                        break Loop</span>

                }
        }
        <span class="cov0" title="0">return sc, nil</span>
}

// Replace prefixed shortcode tokens with the real content.
// Note: This function will rewrite the input slice.
func replaceShortcodeTokens(source []byte, replacements map[string]string) ([]byte, error) <span class="cov0" title="0">{

        if len(replacements) == 0 </span><span class="cov0" title="0">{
                return source, nil
        }</span>

        <span class="cov0" title="0">start := 0

        pre := []byte(shortcodePlaceholderPrefix)
        post := []byte("HBHB")
        pStart := []byte("&lt;p&gt;")
        pEnd := []byte("&lt;/p&gt;")

        k := bytes.Index(source[start:], pre)

        for k != -1 </span><span class="cov0" title="0">{
                j := start + k
                postIdx := bytes.Index(source[j:], post)
                if postIdx &lt; 0 </span><span class="cov0" title="0">{
                        // this should never happen, but let the caller decide to panic or not
                        return nil, errors.New("illegal state in content; shortcode token missing end delim")
                }</span>

                <span class="cov0" title="0">end := j + postIdx + 4

                newVal := []byte(replacements[string(source[j:end])])

                // Issue #1148: Check for wrapping p-tags &lt;p&gt;
                if j &gt;= 3 &amp;&amp; bytes.Equal(source[j-3:j], pStart) </span><span class="cov0" title="0">{
                        if (k+4) &lt; len(source) &amp;&amp; bytes.Equal(source[end:end+4], pEnd) </span><span class="cov0" title="0">{
                                j -= 3
                                end += 4
                        }</span>
                }

                // This and other cool slice tricks: https://github.com/golang/go/wiki/SliceTricks
                <span class="cov0" title="0">source = append(source[:j], append(newVal, source[end:]...)...)
                start = j
                k = bytes.Index(source[start:], pre)</span>

        }

        <span class="cov0" title="0">return source, nil</span>
}

func renderShortcodeWithPage(tmpl tpl.Template, data *ShortcodeWithPage) (string, error) <span class="cov0" title="0">{
        buffer := bp.GetBuffer()
        defer bp.PutBuffer(buffer)

        err := tmpl.Execute(buffer, data)
        if err != nil </span><span class="cov0" title="0">{
                return "", _errors.Wrap(err, "failed to process shortcode")
        }</span>
        <span class="cov0" title="0">return buffer.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "html/template"

        "github.com/gohugoio/hugo/resources/page"
)

var tocShortcodePlaceholder = createShortcodePlaceholder("TOC", 0)

// This is sent to the shortcodes. They cannot access the content
// they're a part of. It would cause an infinite regress.
//
// Go doesn't support virtual methods, so this careful dance is currently (I think)
// the best we can do.
type pageForShortcode struct {
        page.PageWithoutContent
        page.ContentProvider

        // We need to replace it after we have rendered it, so provide a
        // temporary placeholder.
        toc template.HTML

        p *pageState
}

func newPageForShortcode(p *pageState) page.Page <span class="cov0" title="0">{
        return &amp;pageForShortcode{
                PageWithoutContent: p,
                ContentProvider:    page.NopPage,
                toc:                template.HTML(tocShortcodePlaceholder),
                p:                  p,
        }
}</span>

func (p *pageForShortcode) page() page.Page <span class="cov0" title="0">{
        return p.PageWithoutContent.(page.Page)
}</span>

func (p *pageForShortcode) TableOfContents() template.HTML <span class="cov0" title="0">{
        p.p.enablePlaceholders()
        return p.toc
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "html/template"
        "io"
        "log"
        "mime"
        "net/url"
        "os"
        "path"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "time"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/text"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/publisher"
        _errors "github.com/pkg/errors"

        "github.com/gohugoio/hugo/langs"

        "github.com/gohugoio/hugo/resources/page"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/lazy"

        "github.com/gohugoio/hugo/media"

        "github.com/fsnotify/fsnotify"
        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/navigation"
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/related"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/page/pagemeta"
        "github.com/gohugoio/hugo/source"
        "github.com/gohugoio/hugo/tpl"

        "github.com/spf13/afero"
        "github.com/spf13/cast"
        "github.com/spf13/viper"
)

// Site contains all the information relevant for constructing a static
// site.  The basic flow of information is as follows:
//
// 1. A list of Files is parsed and then converted into Pages.
//
// 2. Pages contain sections (based on the file they were generated from),
//    aliases and slugs (included in a pages frontmatter) which are the
//    various targets that will get generated.  There will be canonical
//    listing.  The canonical path can be overruled based on a pattern.
//
// 3. Taxonomies are created via configuration and will present some aspect of
//    the final page and typically a perm url.
//
// 4. All Pages are passed through a template based on their desired
//    layout based on numerous different elements.
//
// 5. The entire collection of files is written to disk.
type Site struct {

        // The owning container. When multiple languages, there will be multiple
        // sites.
        h *HugoSites

        *PageCollections

        Taxonomies TaxonomyList

        Sections Taxonomy
        Info     SiteInfo

        layoutHandler *output.LayoutHandler

        language *langs.Language

        siteCfg siteConfigHolder

        disabledKinds map[string]bool

        enableInlineShortcodes bool

        // Output formats defined in site config per Page Kind, or some defaults
        // if not set.
        // Output formats defined in Page front matter will override these.
        outputFormats map[string]output.Formats

        // All the output formats and media types available for this site.
        // These values will be merged from the Hugo defaults, the site config and,
        // finally, the language settings.
        outputFormatsConfig output.Formats
        mediaTypesConfig    media.Types

        siteConfigConfig SiteConfig

        // How to handle page front matter.
        frontmatterHandler pagemeta.FrontMatterHandler

        // We render each site for all the relevant output formats in serial with
        // this rendering context pointing to the current one.
        rc *siteRenderingContext

        // The output formats that we need to render this site in. This slice
        // will be fixed once set.
        // This will be the union of Site.Pages' outputFormats.
        // This slice will be sorted.
        renderFormats output.Formats

        // Logger etc.
        *deps.Deps `json:"-"`

        // The func used to title case titles.
        titleFunc func(s string) string

        relatedDocsHandler *page.RelatedDocsHandler
        siteRefLinker

        publisher publisher.Publisher

        menus navigation.Menus

        // Shortcut to the home page. Note that this may be nil if
        // home page, for some odd reason, is disabled.
        home *pageState

        // The last modification date of this site.
        lastmod time.Time

        // Lazily loaded site dependencies
        init *siteInit
}

type siteConfigHolder struct {
        sitemap          config.Sitemap
        taxonomiesConfig map[string]string
        timeout          time.Duration
        hasCJKLanguage   bool
        enableEmoji      bool
}

// Lazily loaded site dependencies.
type siteInit struct {
        prevNext          *lazy.Init
        prevNextInSection *lazy.Init
        menus             *lazy.Init
}

func (init *siteInit) Reset() <span class="cov0" title="0">{
        init.prevNext.Reset()
        init.prevNextInSection.Reset()
        init.menus.Reset()
}</span>

func (s *Site) initInit(init *lazy.Init, pctx pageContext) <span class="cov8" title="1">{
        _, err := init.Do()
        if err != nil </span><span class="cov0" title="0">{
                s.h.FatalError(pctx.wrapError(err))
        }</span>
}

func (s *Site) prepareInits() <span class="cov8" title="1">{
        s.init = &amp;siteInit{}

        var init lazy.Init

        s.init.prevNext = init.Branch(func() (interface{}, error) </span><span class="cov0" title="0">{
                regularPages := s.findWorkPagesByKind(page.KindPage)
                for i, p := range regularPages </span><span class="cov0" title="0">{
                        if p.posNextPrev == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">p.posNextPrev.nextPage = nil
                        p.posNextPrev.prevPage = nil

                        if i &gt; 0 </span><span class="cov0" title="0">{
                                p.posNextPrev.nextPage = regularPages[i-1]
                        }</span>

                        <span class="cov0" title="0">if i &lt; len(regularPages)-1 </span><span class="cov0" title="0">{
                                p.posNextPrev.prevPage = regularPages[i+1]
                        }</span>
                }
                <span class="cov0" title="0">return nil, nil</span>
        })

        <span class="cov8" title="1">s.init.prevNextInSection = init.Branch(func() (interface{}, error) </span><span class="cov0" title="0">{
                var rootSection []int
                // TODO(bep) cm attach this to the bucket.
                for i, p1 := range s.workAllPages </span><span class="cov0" title="0">{
                        if p1.IsPage() &amp;&amp; p1.Section() == "" </span><span class="cov0" title="0">{
                                rootSection = append(rootSection, i)
                        }</span>
                        <span class="cov0" title="0">if p1.IsSection() </span><span class="cov0" title="0">{
                                sectionPages := p1.RegularPages()
                                for i, p2 := range sectionPages </span><span class="cov0" title="0">{
                                        p2s := p2.(*pageState)
                                        if p2s.posNextPrevSection == nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">p2s.posNextPrevSection.nextPage = nil
                                        p2s.posNextPrevSection.prevPage = nil

                                        if i &gt; 0 </span><span class="cov0" title="0">{
                                                p2s.posNextPrevSection.nextPage = sectionPages[i-1]
                                        }</span>

                                        <span class="cov0" title="0">if i &lt; len(sectionPages)-1 </span><span class="cov0" title="0">{
                                                p2s.posNextPrevSection.prevPage = sectionPages[i+1]
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">for i, j := range rootSection </span><span class="cov0" title="0">{
                        p := s.workAllPages[j]
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                p.posNextPrevSection.nextPage = s.workAllPages[rootSection[i-1]]
                        }</span>

                        <span class="cov0" title="0">if i &lt; len(rootSection)-1 </span><span class="cov0" title="0">{
                                p.posNextPrevSection.prevPage = s.workAllPages[rootSection[i+1]]
                        }</span>
                }

                <span class="cov0" title="0">return nil, nil</span>
        })

        <span class="cov8" title="1">s.init.menus = init.Branch(func() (interface{}, error) </span><span class="cov8" title="1">{
                s.assembleMenus()
                return nil, nil
        }</span>)

}

type siteRenderingContext struct {
        output.Format
}

func (s *Site) Menus() navigation.Menus <span class="cov8" title="1">{
        s.init.menus.Do()
        return s.menus
}</span>

func (s *Site) initRenderFormats() <span class="cov8" title="1">{
        formatSet := make(map[string]bool)
        formats := output.Formats{}
        for _, p := range s.workAllPages </span><span class="cov8" title="1">{
                for _, f := range p.m.configuredOutputFormats </span><span class="cov0" title="0">{
                        if !formatSet[f.Name] </span><span class="cov0" title="0">{
                                formats = append(formats, f)
                                formatSet[f.Name] = true
                        }</span>
                }
        }

        // Add the per kind configured output formats
        <span class="cov8" title="1">for _, kind := range allKindsInPages </span><span class="cov8" title="1">{
                if siteFormats, found := s.outputFormats[kind]; found </span><span class="cov8" title="1">{
                        for _, f := range siteFormats </span><span class="cov8" title="1">{
                                if !formatSet[f.Name] </span><span class="cov8" title="1">{
                                        formats = append(formats, f)
                                        formatSet[f.Name] = true
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">sort.Sort(formats)
        s.renderFormats = formats</span>
}

func (s *Site) GetRelatedDocsHandler() *page.RelatedDocsHandler <span class="cov8" title="1">{
        return s.relatedDocsHandler
}</span>

func (s *Site) Language() *langs.Language <span class="cov8" title="1">{
        return s.language
}</span>

func (s *Site) isEnabled(kind string) bool <span class="cov8" title="1">{
        if kind == kindUnknown </span><span class="cov0" title="0">{
                panic("Unknown kind")</span>
        }
        <span class="cov8" title="1">return !s.disabledKinds[kind]</span>
}

// reset returns a new Site prepared for rebuild.
func (s *Site) reset() *Site <span class="cov0" title="0">{
        return &amp;Site{Deps: s.Deps,
                layoutHandler:          output.NewLayoutHandler(),
                disabledKinds:          s.disabledKinds,
                titleFunc:              s.titleFunc,
                relatedDocsHandler:     s.relatedDocsHandler.Clone(),
                siteRefLinker:          s.siteRefLinker,
                outputFormats:          s.outputFormats,
                rc:                     s.rc,
                outputFormatsConfig:    s.outputFormatsConfig,
                frontmatterHandler:     s.frontmatterHandler,
                mediaTypesConfig:       s.mediaTypesConfig,
                language:               s.language,
                h:                      s.h,
                publisher:              s.publisher,
                siteConfigConfig:       s.siteConfigConfig,
                enableInlineShortcodes: s.enableInlineShortcodes,
                init:                   s.init,
                PageCollections:        s.PageCollections,
                siteCfg:                s.siteCfg,
        }

}</span>

// newSite creates a new site with the given configuration.
func newSite(cfg deps.DepsCfg) (*Site, error) <span class="cov8" title="1">{
        c := newPageCollections()

        if cfg.Language == nil </span><span class="cov0" title="0">{
                cfg.Language = langs.NewDefaultLanguage(cfg.Cfg)
        }</span>

        <span class="cov8" title="1">disabledKinds := make(map[string]bool)
        for _, disabled := range cast.ToStringSlice(cfg.Language.Get("disableKinds")) </span><span class="cov0" title="0">{
                disabledKinds[disabled] = true
        }</span>

        <span class="cov8" title="1">var (
                mediaTypesConfig    []map[string]interface{}
                outputFormatsConfig []map[string]interface{}

                siteOutputFormatsConfig output.Formats
                siteMediaTypesConfig    media.Types
                err                     error
        )

        // Add language last, if set, so it gets precedence.
        for _, cfg := range []config.Provider{cfg.Cfg, cfg.Language} </span><span class="cov8" title="1">{
                if cfg.IsSet("mediaTypes") </span><span class="cov0" title="0">{
                        mediaTypesConfig = append(mediaTypesConfig, cfg.GetStringMap("mediaTypes"))
                }</span>
                <span class="cov8" title="1">if cfg.IsSet("outputFormats") </span><span class="cov0" title="0">{
                        outputFormatsConfig = append(outputFormatsConfig, cfg.GetStringMap("outputFormats"))
                }</span>
        }

        <span class="cov8" title="1">siteMediaTypesConfig, err = media.DecodeTypes(mediaTypesConfig...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">siteOutputFormatsConfig, err = output.DecodeFormats(siteMediaTypesConfig, outputFormatsConfig...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">outputFormats, err := createSiteOutputFormats(siteOutputFormatsConfig, cfg.Language)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">taxonomies := cfg.Language.GetStringMapString("taxonomies")

        var relatedContentConfig related.Config

        if cfg.Language.IsSet("related") </span><span class="cov0" title="0">{
                relatedContentConfig, err = related.DecodeConfig(cfg.Language.Get("related"))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                relatedContentConfig = related.DefaultConfig
                if _, found := taxonomies["tag"]; found </span><span class="cov8" title="1">{
                        relatedContentConfig.Add(related.IndexConfig{Name: "tags", Weight: 80})
                }</span>
        }

        <span class="cov8" title="1">titleFunc := helpers.GetTitleFunc(cfg.Language.GetString("titleCaseStyle"))

        frontMatterHandler, err := pagemeta.NewFrontmatterHandler(cfg.Logger, cfg.Cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">siteConfig := siteConfigHolder{
                sitemap:          config.DecodeSitemap(config.Sitemap{Priority: -1, Filename: "sitemap.xml"}, cfg.Language.GetStringMap("sitemap")),
                taxonomiesConfig: taxonomies,
                timeout:          time.Duration(cfg.Language.GetInt("timeout")) * time.Millisecond,
                hasCJKLanguage:   cfg.Language.GetBool("hasCJKLanguage"),
                enableEmoji:      cfg.Language.Cfg.GetBool("enableEmoji"),
        }

        s := &amp;Site{
                PageCollections:        c,
                layoutHandler:          output.NewLayoutHandler(),
                language:               cfg.Language,
                disabledKinds:          disabledKinds,
                titleFunc:              titleFunc,
                relatedDocsHandler:     page.NewRelatedDocsHandler(relatedContentConfig),
                outputFormats:          outputFormats,
                rc:                     &amp;siteRenderingContext{output.HTMLFormat},
                outputFormatsConfig:    siteOutputFormatsConfig,
                mediaTypesConfig:       siteMediaTypesConfig,
                frontmatterHandler:     frontMatterHandler,
                enableInlineShortcodes: cfg.Language.GetBool("enableInlineShortcodes"),
                siteCfg:                siteConfig,
        }

        s.prepareInits()

        return s, nil</span>

}

// NewSite creates a new site with the given dependency configuration.
// The site will have a template system loaded and ready to use.
// Note: This is mainly used in single site tests.
func NewSite(cfg deps.DepsCfg) (*Site, error) <span class="cov0" title="0">{
        s, err := newSite(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err = applyDeps(cfg, s); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s, nil</span>
}

// NewSiteDefaultLang creates a new site in the default language.
// The site will have a template system loaded and ready to use.
// Note: This is mainly used in single site tests.
// TODO(bep) test refactor -- remove
func NewSiteDefaultLang(withTemplate ...func(templ tpl.TemplateHandler) error) (*Site, error) <span class="cov0" title="0">{
        v := viper.New()
        if err := loadDefaultSettingsFor(v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return newSiteForLang(langs.NewDefaultLanguage(v), withTemplate...)</span>
}

// NewEnglishSite creates a new site in English language.
// The site will have a template system loaded and ready to use.
// Note: This is mainly used in single site tests.
// TODO(bep) test refactor -- remove
func NewEnglishSite(withTemplate ...func(templ tpl.TemplateHandler) error) (*Site, error) <span class="cov0" title="0">{
        v := viper.New()
        if err := loadDefaultSettingsFor(v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return newSiteForLang(langs.NewLanguage("en", v), withTemplate...)</span>
}

// newSiteForLang creates a new site in the given language.
func newSiteForLang(lang *langs.Language, withTemplate ...func(templ tpl.TemplateHandler) error) (*Site, error) <span class="cov0" title="0">{
        withTemplates := func(templ tpl.TemplateHandler) error </span><span class="cov0" title="0">{
                for _, wt := range withTemplate </span><span class="cov0" title="0">{
                        if err := wt(templ); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">cfg := deps.DepsCfg{WithTemplate: withTemplates, Cfg: lang}

        return NewSiteForCfg(cfg)</span>

}

// NewSiteForCfg creates a new site for the given configuration.
// The site will have a template system loaded and ready to use.
// Note: This is mainly used in single site tests.
func NewSiteForCfg(cfg deps.DepsCfg) (*Site, error) <span class="cov0" title="0">{
        h, err := NewHugoSites(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return h.Sites[0], nil</span>

}

type SiteInfo struct {
        Authors page.AuthorList
        Social  SiteSocial

        hugoInfo     hugo.Info
        title        string
        RSSLink      string
        Author       map[string]interface{}
        LanguageCode string
        Copyright    string

        permalinks map[string]string

        LanguagePrefix string
        Languages      langs.Languages

        BuildDrafts bool

        canonifyURLs bool
        relativeURLs bool
        uglyURLs     func(p page.Page) bool

        owner                          *HugoSites
        s                              *Site
        language                       *langs.Language
        defaultContentLanguageInSubdir bool
        sectionPagesMenu               string
}

func (s *SiteInfo) Pages() page.Pages <span class="cov0" title="0">{
        return s.s.Pages()

}</span>

func (s *SiteInfo) RegularPages() page.Pages <span class="cov8" title="1">{
        return s.s.RegularPages()

}</span>

func (s *SiteInfo) AllPages() page.Pages <span class="cov0" title="0">{
        return s.s.AllPages()
}</span>

func (s *SiteInfo) AllRegularPages() page.Pages <span class="cov0" title="0">{
        return s.s.AllRegularPages()
}</span>

func (s *SiteInfo) Permalinks() map[string]string <span class="cov0" title="0">{
        // Remove in 0.57
        helpers.Deprecated("Site", ".Permalinks", "", false)
        return s.permalinks
}</span>

func (s *SiteInfo) LastChange() time.Time <span class="cov0" title="0">{
        return s.s.lastmod
}</span>

func (s *SiteInfo) Title() string <span class="cov8" title="1">{
        return s.title
}</span>

func (s *SiteInfo) Site() page.Site <span class="cov0" title="0">{
        return s
}</span>

func (s *SiteInfo) Menus() navigation.Menus <span class="cov8" title="1">{
        return s.s.Menus()
}</span>

// TODO(bep) type
func (s *SiteInfo) Taxonomies() interface{} <span class="cov8" title="1">{
        return s.s.Taxonomies
}</span>

func (s *SiteInfo) Params() map[string]interface{} <span class="cov8" title="1">{
        return s.s.Language().Params()
}</span>

func (s *SiteInfo) Data() map[string]interface{} <span class="cov8" title="1">{
        return s.s.h.Data()
}</span>

func (s *SiteInfo) Language() *langs.Language <span class="cov0" title="0">{
        return s.language
}</span>

func (s *SiteInfo) Config() SiteConfig <span class="cov8" title="1">{
        return s.s.siteConfigConfig
}</span>

func (s *SiteInfo) Hugo() hugo.Info <span class="cov8" title="1">{
        return s.hugoInfo
}</span>

// Sites is a convenience method to get all the Hugo sites/languages configured.
func (s *SiteInfo) Sites() page.Sites <span class="cov0" title="0">{
        return s.s.h.siteInfos()
}</span>

func (s *SiteInfo) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Site(%q)", s.title)
}</span>

func (s *SiteInfo) BaseURL() template.URL <span class="cov8" title="1">{
        return template.URL(s.s.PathSpec.BaseURL.String())
}</span>

// ServerPort returns the port part of the BaseURL, 0 if none found.
func (s *SiteInfo) ServerPort() int <span class="cov0" title="0">{
        ps := s.s.PathSpec.BaseURL.URL().Port()
        if ps == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">p, err := strconv.Atoi(ps)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return p</span>
}

// GoogleAnalytics is kept here for historic reasons.
func (s *SiteInfo) GoogleAnalytics() string <span class="cov0" title="0">{
        return s.Config().Services.GoogleAnalytics.ID

}</span>

// DisqusShortname is kept here for historic reasons.
func (s *SiteInfo) DisqusShortname() string <span class="cov8" title="1">{
        return s.Config().Services.Disqus.Shortname
}</span>

// SiteSocial is a place to put social details on a site level. These are the
// standard keys that themes will expect to have available, but can be
// expanded to any others on a per site basis
// github
// facebook
// facebook_admin
// twitter
// twitter_domain
// pinterest
// instagram
// youtube
// linkedin
type SiteSocial map[string]string

// Param is a convenience method to do lookups in SiteInfo's Params map.
//
// This method is also implemented on Page and Node.
func (s *SiteInfo) Param(key interface{}) (interface{}, error) <span class="cov0" title="0">{
        keyStr, err := cast.ToStringE(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">keyStr = strings.ToLower(keyStr)
        return s.Params()[keyStr], nil</span>
}

func (s *SiteInfo) IsMultiLingual() bool <span class="cov8" title="1">{
        return len(s.Languages) &gt; 1
}</span>

func (s *SiteInfo) IsServer() bool <span class="cov0" title="0">{
        return s.owner.running
}</span>

type siteRefLinker struct {
        s *Site

        errorLogger *log.Logger
        notFoundURL string
}

func newSiteRefLinker(cfg config.Provider, s *Site) (siteRefLinker, error) <span class="cov8" title="1">{
        logger := s.Log.ERROR

        notFoundURL := cfg.GetString("refLinksNotFoundURL")
        errLevel := cfg.GetString("refLinksErrorLevel")
        if strings.EqualFold(errLevel, "warning") </span><span class="cov0" title="0">{
                logger = s.Log.WARN
        }</span>
        <span class="cov8" title="1">return siteRefLinker{s: s, errorLogger: logger, notFoundURL: notFoundURL}, nil</span>
}

func (s siteRefLinker) logNotFound(ref, what string, p page.Page, position text.Position) <span class="cov0" title="0">{
        if position.IsValid() </span><span class="cov0" title="0">{
                s.errorLogger.Printf("[%s] REF_NOT_FOUND: Ref %q: %s: %s", s.s.Lang(), ref, position.String(), what)
        }</span> else<span class="cov0" title="0"> if p == nil </span><span class="cov0" title="0">{
                s.errorLogger.Printf("[%s] REF_NOT_FOUND: Ref %q: %s", s.s.Lang(), ref, what)
        }</span> else<span class="cov0" title="0"> {
                s.errorLogger.Printf("[%s] REF_NOT_FOUND: Ref %q from page %q: %s", s.s.Lang(), ref, p.Path(), what)
        }</span>
}

func (s *siteRefLinker) refLink(ref string, source interface{}, relative bool, outputFormat string) (string, error) <span class="cov0" title="0">{

        p, err := unwrapPage(source)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var refURL *url.URL

        ref = filepath.ToSlash(ref)

        refURL, err = url.Parse(ref)

        if err != nil </span><span class="cov0" title="0">{
                return s.notFoundURL, err
        }</span>

        <span class="cov0" title="0">var target page.Page
        var link string

        if refURL.Path != "" </span><span class="cov0" title="0">{
                target, err := s.s.getPageNew(p, refURL.Path)
                var pos text.Position
                if err != nil || target == nil </span><span class="cov0" title="0">{
                        if p, ok := source.(text.Positioner); ok </span><span class="cov0" title="0">{
                                pos = p.Position()

                        }</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        s.logNotFound(refURL.Path, err.Error(), p, pos)
                        return s.notFoundURL, nil
                }</span>

                <span class="cov0" title="0">if target == nil </span><span class="cov0" title="0">{
                        s.logNotFound(refURL.Path, "page not found", p, pos)
                        return s.notFoundURL, nil
                }</span>

                <span class="cov0" title="0">var permalinker Permalinker = target

                if outputFormat != "" </span><span class="cov0" title="0">{
                        o := target.OutputFormats().Get(outputFormat)

                        if o == nil </span><span class="cov0" title="0">{
                                s.logNotFound(refURL.Path, fmt.Sprintf("output format %q", outputFormat), p, pos)
                                return s.notFoundURL, nil
                        }</span>
                        <span class="cov0" title="0">permalinker = o</span>
                }

                <span class="cov0" title="0">if relative </span><span class="cov0" title="0">{
                        link = permalinker.RelPermalink()
                }</span> else<span class="cov0" title="0"> {
                        link = permalinker.Permalink()
                }</span>
        }

        <span class="cov0" title="0">if refURL.Fragment != "" </span><span class="cov0" title="0">{
                _ = target
                link = link + "#" + refURL.Fragment
                if pctx, ok := target.(pageContext); ok &amp;&amp; !target.File().IsZero() &amp;&amp; !pctx.getRenderingConfig().PlainIDAnchors </span><span class="cov0" title="0">{
                        if refURL.Path != "" </span><span class="cov0" title="0">{
                                link = link + ":" + target.File().UniqueID()
                        }</span>
                } else<span class="cov0" title="0"> if pctx, ok := p.(pageContext); ok &amp;&amp; !p.File().IsZero() &amp;&amp; !pctx.getRenderingConfig().PlainIDAnchors </span><span class="cov0" title="0">{
                        link = link + ":" + p.File().UniqueID()
                }</span>

        }
        <span class="cov0" title="0">return link, nil</span>
}

// Ref will give an absolute URL to ref in the given Page.
func (s *SiteInfo) Ref(ref string, page page.Page, options ...string) (string, error) <span class="cov0" title="0">{
        // Remove in Hugo 0.54
        helpers.Deprecated("Site", ".Ref", "Use .Site.GetPage", true)
        outputFormat := ""
        if len(options) &gt; 0 </span><span class="cov0" title="0">{
                outputFormat = options[0]
        }</span>

        <span class="cov0" title="0">return s.s.refLink(ref, page, false, outputFormat)</span>
}

// RelRef will give an relative URL to ref in the given Page.
func (s *SiteInfo) RelRef(ref string, page page.Page, options ...string) (string, error) <span class="cov0" title="0">{
        // Remove in Hugo 0.54
        helpers.Deprecated("Site", ".RelRef", "Use .Site.GetPage", true)
        outputFormat := ""
        if len(options) &gt; 0 </span><span class="cov0" title="0">{
                outputFormat = options[0]
        }</span>

        <span class="cov0" title="0">return s.s.refLink(ref, page, true, outputFormat)</span>
}

func (s *Site) running() bool <span class="cov8" title="1">{
        return s.h != nil &amp;&amp; s.h.running
}</span>

func (s *Site) multilingual() *Multilingual <span class="cov0" title="0">{
        return s.h.multilingual
}</span>

type whatChanged struct {
        source bool
        other  bool
        files  map[string]bool
}

// RegisterMediaTypes will register the Site's media types in the mime
// package, so it will behave correctly with Hugo's built-in server.
func (s *Site) RegisterMediaTypes() <span class="cov0" title="0">{
        for _, mt := range s.mediaTypesConfig </span><span class="cov0" title="0">{
                for _, suffix := range mt.Suffixes </span><span class="cov0" title="0">{
                        _ = mime.AddExtensionType(mt.Delimiter+suffix, mt.Type()+"; charset=utf-8")
                }</span>
        }
}

func (s *Site) filterFileEvents(events []fsnotify.Event) []fsnotify.Event <span class="cov0" title="0">{
        var filtered []fsnotify.Event
        seen := make(map[fsnotify.Event]bool)

        for _, ev := range events </span><span class="cov0" title="0">{
                // Avoid processing the same event twice.
                if seen[ev] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seen[ev] = true

                if s.SourceSpec.IgnoreFile(ev.Name) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Throw away any directories
                <span class="cov0" title="0">isRegular, err := s.SourceSpec.IsRegularSourceFile(ev.Name)
                if err != nil &amp;&amp; os.IsNotExist(err) &amp;&amp; (ev.Op&amp;fsnotify.Remove == fsnotify.Remove || ev.Op&amp;fsnotify.Rename == fsnotify.Rename) </span><span class="cov0" title="0">{
                        // Force keep of event
                        isRegular = true
                }</span>
                <span class="cov0" title="0">if !isRegular </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">filtered = append(filtered, ev)</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

func (s *Site) translateFileEvents(events []fsnotify.Event) []fsnotify.Event <span class="cov0" title="0">{
        var filtered []fsnotify.Event

        eventMap := make(map[string][]fsnotify.Event)

        // We often get a Remove etc. followed by a Create, a Create followed by a Write.
        // Remove the superflous events to mage the update logic simpler.
        for _, ev := range events </span><span class="cov0" title="0">{
                eventMap[ev.Name] = append(eventMap[ev.Name], ev)
        }</span>

        <span class="cov0" title="0">for _, ev := range events </span><span class="cov0" title="0">{
                mapped := eventMap[ev.Name]

                // Keep one
                found := false
                var kept fsnotify.Event
                for i, ev2 := range mapped </span><span class="cov0" title="0">{
                        if i == 0 </span><span class="cov0" title="0">{
                                kept = ev2
                        }</span>

                        <span class="cov0" title="0">if ev2.Op&amp;fsnotify.Write == fsnotify.Write </span><span class="cov0" title="0">{
                                kept = ev2
                                found = true
                        }</span>

                        <span class="cov0" title="0">if !found &amp;&amp; ev2.Op&amp;fsnotify.Create == fsnotify.Create </span><span class="cov0" title="0">{
                                kept = ev2
                        }</span>
                }

                <span class="cov0" title="0">filtered = append(filtered, kept)</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

// reBuild partially rebuilds a site given the filesystem events.
// It returns whetever the content source was changed.
// TODO(bep) clean up/rewrite this method.
func (s *Site) processPartial(config *BuildCfg, init func(config *BuildCfg) error, events []fsnotify.Event) error <span class="cov0" title="0">{

        events = s.filterFileEvents(events)
        events = s.translateFileEvents(events)

        s.Log.DEBUG.Printf("Rebuild for events %q", events)

        h := s.h

        // First we need to determine what changed

        var (
                sourceChanged       = []fsnotify.Event{}
                sourceReallyChanged = []fsnotify.Event{}
                contentFilesChanged []string
                tmplChanged         = []fsnotify.Event{}
                dataChanged         = []fsnotify.Event{}
                i18nChanged         = []fsnotify.Event{}
                shortcodesChanged   = make(map[string]bool)
                sourceFilesChanged  = make(map[string]bool)

                // prevent spamming the log on changes
                logger = helpers.NewDistinctFeedbackLogger()
        )

        var cachePartitions []string

        for _, ev := range events </span><span class="cov0" title="0">{
                if assetsFilename := s.BaseFs.Assets.MakePathRelative(ev.Name); assetsFilename != "" </span><span class="cov0" title="0">{
                        cachePartitions = append(cachePartitions, resources.ResourceKeyPartitions(assetsFilename)...)
                }</span>

                <span class="cov0" title="0">if s.isContentDirEvent(ev) </span><span class="cov0" title="0">{
                        logger.Println("Source changed", ev)
                        sourceChanged = append(sourceChanged, ev)
                }</span>
                <span class="cov0" title="0">if s.isLayoutDirEvent(ev) </span><span class="cov0" title="0">{
                        logger.Println("Template changed", ev)
                        tmplChanged = append(tmplChanged, ev)

                        if strings.Contains(ev.Name, "shortcodes") </span><span class="cov0" title="0">{
                                shortcode := filepath.Base(ev.Name)
                                shortcode = strings.TrimSuffix(shortcode, filepath.Ext(shortcode))
                                shortcodesChanged[shortcode] = true
                        }</span>
                }
                <span class="cov0" title="0">if s.isDataDirEvent(ev) </span><span class="cov0" title="0">{
                        logger.Println("Data changed", ev)
                        dataChanged = append(dataChanged, ev)
                }</span>
                <span class="cov0" title="0">if s.isI18nEvent(ev) </span><span class="cov0" title="0">{
                        logger.Println("i18n changed", ev)
                        i18nChanged = append(dataChanged, ev)
                }</span>
        }

        <span class="cov0" title="0">changed := &amp;whatChanged{
                source: len(sourceChanged) &gt; 0 || len(shortcodesChanged) &gt; 0,
                other:  len(tmplChanged) &gt; 0 || len(i18nChanged) &gt; 0 || len(dataChanged) &gt; 0,
                files:  sourceFilesChanged,
        }

        config.whatChanged = changed

        if err := init(config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // These in memory resource caches will be rebuilt on demand.
        <span class="cov0" title="0">for _, s := range s.h.Sites </span><span class="cov0" title="0">{
                s.ResourceSpec.ResourceCache.DeletePartitions(cachePartitions...)
        }</span>

        <span class="cov0" title="0">if len(tmplChanged) &gt; 0 || len(i18nChanged) &gt; 0 </span><span class="cov0" title="0">{
                sites := s.h.Sites
                first := sites[0]

                s.h.init.Reset()

                // TOD(bep) globals clean
                if err := first.Deps.LoadResources(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for i := 1; i &lt; len(sites); i++ </span><span class="cov0" title="0">{
                        site := sites[i]
                        var err error
                        depsCfg := deps.DepsCfg{
                                Language:      site.language,
                                MediaTypes:    site.mediaTypesConfig,
                                OutputFormats: site.outputFormatsConfig,
                        }
                        site.Deps, err = first.Deps.ForLanguage(depsCfg, func(d *deps.Deps) error </span><span class="cov0" title="0">{
                                d.Site = &amp;site.Info
                                return nil
                        }</span>)
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(dataChanged) &gt; 0 </span><span class="cov0" title="0">{
                s.h.init.data.Reset()
        }</span>

        <span class="cov0" title="0">for _, ev := range sourceChanged </span><span class="cov0" title="0">{
                removed := false

                if ev.Op&amp;fsnotify.Remove == fsnotify.Remove </span><span class="cov0" title="0">{
                        removed = true
                }</span>

                // Some editors (Vim) sometimes issue only a Rename operation when writing an existing file
                // Sometimes a rename operation means that file has been renamed other times it means
                // it's been updated
                <span class="cov0" title="0">if ev.Op&amp;fsnotify.Rename == fsnotify.Rename </span><span class="cov0" title="0">{
                        // If the file is still on disk, it's only been updated, if it's not, it's been moved
                        if ex, err := afero.Exists(s.Fs.Source, ev.Name); !ex || err != nil </span><span class="cov0" title="0">{
                                removed = true
                        }</span>
                }

                <span class="cov0" title="0">if removed &amp;&amp; files.IsContentFile(ev.Name) </span><span class="cov0" title="0">{
                        h.removePageByFilename(ev.Name)
                }</span>

                <span class="cov0" title="0">sourceReallyChanged = append(sourceReallyChanged, ev)
                sourceFilesChanged[ev.Name] = true</span>
        }

        <span class="cov0" title="0">for shortcode := range shortcodesChanged </span><span class="cov0" title="0">{
                // There are certain scenarios that, when a shortcode changes,
                // it isn't sufficient to just rerender the already parsed shortcode.
                // One example is if the user adds a new shortcode to the content file first,
                // and then creates the shortcode on the file system.
                // To handle these scenarios, we must do a full reprocessing of the
                // pages that keeps a reference to the changed shortcode.
                pagesWithShortcode := h.findPagesByShortcode(shortcode)
                for _, p := range pagesWithShortcode </span><span class="cov0" title="0">{
                        contentFilesChanged = append(contentFilesChanged, p.File().Filename())
                }</span>
        }

        <span class="cov0" title="0">if len(sourceReallyChanged) &gt; 0 || len(contentFilesChanged) &gt; 0 </span><span class="cov0" title="0">{
                var filenamesChanged []string
                for _, e := range sourceReallyChanged </span><span class="cov0" title="0">{
                        filenamesChanged = append(filenamesChanged, e.Name)
                }</span>
                <span class="cov0" title="0">if len(contentFilesChanged) &gt; 0 </span><span class="cov0" title="0">{
                        filenamesChanged = append(filenamesChanged, contentFilesChanged...)
                }</span>

                <span class="cov0" title="0">filenamesChanged = helpers.UniqueStringsReuse(filenamesChanged)

                if err := s.readAndProcessContent(filenamesChanged...); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }

        <span class="cov0" title="0">return nil</span>

}

func (s *Site) process(config BuildCfg) (err error) <span class="cov8" title="1">{
        if err = s.initialize(); err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, "initialize")
                return
        }</span>
        <span class="cov8" title="1">if err = s.readAndProcessContent(); err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, "readAndProcessContent")
                return
        }</span>
        <span class="cov8" title="1">return err</span>

}

func (s *Site) render(ctx *siteRenderContext) (err error) <span class="cov8" title="1">{

        if err := page.Clear(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if ctx.outIdx == 0 </span><span class="cov8" title="1">{
                // Note that even if disableAliases is set, the aliases themselves are
                // preserved on page. The motivation with this is to be able to generate
                // 301 redirects in a .htacess file and similar using a custom output format.
                if !s.Cfg.GetBool("disableAliases") </span><span class="cov8" title="1">{
                        // Aliases must be rendered before pages.
                        // Some sites, Hugo docs included, have faulty alias definitions that point
                        // to itself or another real page. These will be overwritten in the next
                        // step.
                        if err = s.renderAliases(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

        }

        <span class="cov8" title="1">if err = s.renderPages(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if ctx.outIdx == 0 </span><span class="cov8" title="1">{
                if err = s.renderSitemap(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">if err = s.renderRobotsTXT(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">if err = s.render404(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">if !ctx.renderSingletonPages() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if err = s.renderMainLanguageRedirect(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

func (s *Site) Initialise() (err error) <span class="cov0" title="0">{
        return s.initialize()
}</span>

func (s *Site) initialize() (err error) <span class="cov8" title="1">{
        return s.initializeSiteInfo()
}</span>

// HomeAbsURL is a convenience method giving the absolute URL to the home page.
func (s *SiteInfo) HomeAbsURL() string <span class="cov0" title="0">{
        base := ""
        if s.IsMultiLingual() </span><span class="cov0" title="0">{
                base = s.Language().Lang
        }</span>
        <span class="cov0" title="0">return s.owner.AbsURL(base, false)</span>
}

// SitemapAbsURL is a convenience method giving the absolute URL to the sitemap.
func (s *SiteInfo) SitemapAbsURL() string <span class="cov0" title="0">{
        p := s.HomeAbsURL()
        if !strings.HasSuffix(p, "/") </span><span class="cov0" title="0">{
                p += "/"
        }</span>
        <span class="cov0" title="0">p += s.s.siteCfg.sitemap.Filename
        return p</span>
}

func (s *Site) initializeSiteInfo() error <span class="cov8" title="1">{
        var (
                lang      = s.language
                languages langs.Languages
        )

        if s.h != nil &amp;&amp; s.h.multilingual != nil </span><span class="cov8" title="1">{
                languages = s.h.multilingual.Languages
        }</span>

        <span class="cov8" title="1">permalinks := s.Cfg.GetStringMapString("permalinks")

        defaultContentInSubDir := s.Cfg.GetBool("defaultContentLanguageInSubdir")
        defaultContentLanguage := s.Cfg.GetString("defaultContentLanguage")

        languagePrefix := ""
        if s.multilingualEnabled() &amp;&amp; (defaultContentInSubDir || lang.Lang != defaultContentLanguage) </span><span class="cov0" title="0">{
                languagePrefix = "/" + lang.Lang
        }</span>

        <span class="cov8" title="1">var uglyURLs = func(p page.Page) bool </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">v := s.Cfg.Get("uglyURLs")
        if v != nil </span><span class="cov8" title="1">{
                switch vv := v.(type) </span>{
                case bool:<span class="cov8" title="1">
                        uglyURLs = func(p page.Page) bool </span><span class="cov8" title="1">{
                                return vv
                        }</span>
                case string:<span class="cov0" title="0">
                        // Is what be get from CLI (--uglyURLs)
                        vvv := cast.ToBool(vv)
                        uglyURLs = func(p page.Page) bool </span><span class="cov0" title="0">{
                                return vvv
                        }</span>
                default:<span class="cov0" title="0">
                        m := cast.ToStringMapBool(v)
                        uglyURLs = func(p page.Page) bool </span><span class="cov0" title="0">{
                                return m[p.Section()]
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Info = SiteInfo{
                title:                          lang.GetString("title"),
                Author:                         lang.GetStringMap("author"),
                Social:                         lang.GetStringMapString("social"),
                LanguageCode:                   lang.GetString("languageCode"),
                Copyright:                      lang.GetString("copyright"),
                language:                       lang,
                LanguagePrefix:                 languagePrefix,
                Languages:                      languages,
                defaultContentLanguageInSubdir: defaultContentInSubDir,
                sectionPagesMenu:               lang.GetString("sectionPagesMenu"),
                BuildDrafts:                    s.Cfg.GetBool("buildDrafts"),
                canonifyURLs:                   s.Cfg.GetBool("canonifyURLs"),
                relativeURLs:                   s.Cfg.GetBool("relativeURLs"),
                uglyURLs:                       uglyURLs,
                permalinks:                     permalinks,
                owner:                          s.h,
                s:                              s,
                hugoInfo:                       hugo.NewInfo(s.Cfg.GetString("environment")),
        }

        rssOutputFormat, found := s.outputFormats[page.KindHome].GetByName(output.RSSFormat.Name)

        if found </span><span class="cov8" title="1">{
                s.Info.RSSLink = s.permalink(rssOutputFormat.BaseFilename())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *Site) isI18nEvent(e fsnotify.Event) bool <span class="cov0" title="0">{
        return s.BaseFs.SourceFilesystems.IsI18n(e.Name)
}</span>

func (s *Site) isDataDirEvent(e fsnotify.Event) bool <span class="cov0" title="0">{
        return s.BaseFs.SourceFilesystems.IsData(e.Name)
}</span>

func (s *Site) isLayoutDirEvent(e fsnotify.Event) bool <span class="cov0" title="0">{
        return s.BaseFs.SourceFilesystems.IsLayout(e.Name)
}</span>

func (s *Site) isContentDirEvent(e fsnotify.Event) bool <span class="cov0" title="0">{
        return s.BaseFs.IsContent(e.Name)
}</span>

func (s *Site) readAndProcessContent(filenames ...string) error <span class="cov8" title="1">{
        sourceSpec := source.NewSourceSpec(s.PathSpec, s.BaseFs.Content.Fs)

        proc := newPagesProcessor(s.h, sourceSpec, len(filenames) &gt; 0)

        c := newPagesCollector(sourceSpec, s.Log, s.h.ContentChanges, proc, filenames...)

        return c.Collect()
}</span>

func (s *Site) getMenusFromConfig() navigation.Menus <span class="cov8" title="1">{

        ret := navigation.Menus{}

        if menus := s.language.GetStringMap("menus"); menus != nil </span><span class="cov8" title="1">{
                for name, menu := range menus </span><span class="cov0" title="0">{
                        m, err := cast.ToSliceE(menu)
                        if err != nil </span><span class="cov0" title="0">{
                                s.Log.ERROR.Printf("unable to process menus in site config\n")
                                s.Log.ERROR.Println(err)
                        }</span> else<span class="cov0" title="0"> {
                                for _, entry := range m </span><span class="cov0" title="0">{
                                        s.Log.DEBUG.Printf("found menu: %q, in site config\n", name)

                                        menuEntry := navigation.MenuEntry{Menu: name}
                                        ime, err := cast.ToStringMapE(entry)
                                        if err != nil </span><span class="cov0" title="0">{
                                                s.Log.ERROR.Printf("unable to process menus in site config\n")
                                                s.Log.ERROR.Println(err)
                                        }</span>

                                        <span class="cov0" title="0">menuEntry.MarshallMap(ime)
                                        // TODO(bep) clean up all of this
                                        menuEntry.ConfiguredURL = s.Info.createNodeMenuEntryURL(menuEntry.ConfiguredURL)

                                        if ret[name] == nil </span><span class="cov0" title="0">{
                                                ret[name] = navigation.Menu{}
                                        }</span>
                                        <span class="cov0" title="0">ret[name] = ret[name].Add(&amp;menuEntry)</span>
                                }
                        }
                }
                <span class="cov8" title="1">return ret</span>
        }
        <span class="cov0" title="0">return ret</span>
}

func (s *SiteInfo) createNodeMenuEntryURL(in string) string <span class="cov0" title="0">{

        if !strings.HasPrefix(in, "/") </span><span class="cov0" title="0">{
                return in
        }</span>
        // make it match the nodes
        <span class="cov0" title="0">menuEntryURL := in
        menuEntryURL = helpers.SanitizeURLKeepTrailingSlash(s.s.PathSpec.URLize(menuEntryURL))
        if !s.canonifyURLs </span><span class="cov0" title="0">{
                menuEntryURL = helpers.AddContextRoot(s.s.PathSpec.BaseURL.String(), menuEntryURL)
        }</span>
        <span class="cov0" title="0">return menuEntryURL</span>
}

func (s *Site) assembleMenus() <span class="cov8" title="1">{
        s.menus = make(navigation.Menus)

        type twoD struct {
                MenuName, EntryName string
        }
        flat := map[twoD]*navigation.MenuEntry{}
        children := map[twoD]navigation.Menu{}

        // add menu entries from config to flat hash
        menuConfig := s.getMenusFromConfig()
        for name, menu := range menuConfig </span><span class="cov0" title="0">{
                for _, me := range menu </span><span class="cov0" title="0">{
                        flat[twoD{name, me.KeyName()}] = me
                }</span>
        }

        <span class="cov8" title="1">sectionPagesMenu := s.Info.sectionPagesMenu

        if sectionPagesMenu != "" </span><span class="cov0" title="0">{
                for _, p := range s.workAllPages </span><span class="cov0" title="0">{
                        if p.Kind() == page.KindSection </span><span class="cov0" title="0">{
                                // From Hugo 0.22 we have nested sections, but until we get a
                                // feel of how that would work in this setting, let us keep
                                // this menu for the top level only.
                                id := p.Section()
                                if _, ok := flat[twoD{sectionPagesMenu, id}]; ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">me := navigation.MenuEntry{Identifier: id,
                                        Name:   p.LinkTitle(),
                                        Weight: p.Weight(),
                                        Page:   p}
                                flat[twoD{sectionPagesMenu, me.KeyName()}] = &amp;me</span>
                        }
                }
        }

        // Add menu entries provided by pages
        <span class="cov8" title="1">for _, p := range s.workAllPages </span><span class="cov8" title="1">{
                for name, me := range p.pageMenus.menus() </span><span class="cov0" title="0">{
                        if _, ok := flat[twoD{name, me.KeyName()}]; ok </span><span class="cov0" title="0">{
                                s.SendError(p.wrapError(errors.Errorf("duplicate menu entry with identifier %q in menu %q", me.KeyName(), name)))
                                continue</span>
                        }
                        <span class="cov0" title="0">flat[twoD{name, me.KeyName()}] = me</span>
                }
        }

        // Create Children Menus First
        <span class="cov8" title="1">for _, e := range flat </span><span class="cov0" title="0">{
                if e.Parent != "" </span><span class="cov0" title="0">{
                        children[twoD{e.Menu, e.Parent}] = children[twoD{e.Menu, e.Parent}].Add(e)
                }</span>
        }

        // Placing Children in Parents (in flat)
        <span class="cov8" title="1">for p, childmenu := range children </span><span class="cov0" title="0">{
                _, ok := flat[twoD{p.MenuName, p.EntryName}]
                if !ok </span><span class="cov0" title="0">{
                        // if parent does not exist, create one without a URL
                        flat[twoD{p.MenuName, p.EntryName}] = &amp;navigation.MenuEntry{Name: p.EntryName}
                }</span>
                <span class="cov0" title="0">flat[twoD{p.MenuName, p.EntryName}].Children = childmenu</span>
        }

        // Assembling Top Level of Tree
        <span class="cov8" title="1">for menu, e := range flat </span><span class="cov0" title="0">{
                if e.Parent == "" </span><span class="cov0" title="0">{
                        _, ok := s.menus[menu.MenuName]
                        if !ok </span><span class="cov0" title="0">{
                                s.menus[menu.MenuName] = navigation.Menu{}
                        }</span>
                        <span class="cov0" title="0">s.menus[menu.MenuName] = s.menus[menu.MenuName].Add(e)</span>
                }
        }
}

// get any lanaguagecode to prefix the target file path with.
func (s *Site) getLanguageTargetPathLang(alwaysInSubDir bool) string <span class="cov8" title="1">{
        if s.h.IsMultihost() </span><span class="cov0" title="0">{
                return s.Language().Lang
        }</span>

        <span class="cov8" title="1">return s.getLanguagePermalinkLang(alwaysInSubDir)</span>
}

// get any lanaguagecode to prefix the relative permalink with.
func (s *Site) getLanguagePermalinkLang(alwaysInSubDir bool) string <span class="cov8" title="1">{

        if !s.Info.IsMultiLingual() || s.h.IsMultihost() </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov0" title="0">if alwaysInSubDir </span><span class="cov0" title="0">{
                return s.Language().Lang
        }</span>

        <span class="cov0" title="0">isDefault := s.Language().Lang == s.multilingual().DefaultLang.Lang

        if !isDefault || s.Info.defaultContentLanguageInSubdir </span><span class="cov0" title="0">{
                return s.Language().Lang
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func (s *Site) getTaxonomyKey(key string) string <span class="cov0" title="0">{
        if s.PathSpec.DisablePathToLower </span><span class="cov0" title="0">{
                return s.PathSpec.MakePath(key)
        }</span>
        <span class="cov0" title="0">return strings.ToLower(s.PathSpec.MakePath(key))</span>
}

// Prepare site for a new full build.
func (s *Site) resetBuildState(sourceChanged bool) <span class="cov0" title="0">{
        s.relatedDocsHandler = s.relatedDocsHandler.Clone()
        s.init.Reset()

        if sourceChanged </span><span class="cov0" title="0">{
                s.PageCollections = newPageCollectionsFromPages(s.rawAllPages)
                for _, p := range s.rawAllPages </span><span class="cov0" title="0">{
                        p.pagePages = &amp;pagePages{}
                        p.parent = nil
                        p.Scratcher = maps.NewScratcher()
                }</span>
        } else<span class="cov0" title="0"> {
                s.pagesMap.withEveryPage(func(p *pageState) </span><span class="cov0" title="0">{
                        p.Scratcher = maps.NewScratcher()
                }</span>)
        }
}

func (s *Site) errorCollator(results &lt;-chan error, errs chan&lt;- error) <span class="cov8" title="1">{
        var errors []error
        for e := range results </span><span class="cov0" title="0">{
                errors = append(errors, e)
        }</span>

        <span class="cov8" title="1">errs &lt;- s.h.pickOneAndLogTheRest(errors)

        close(errs)</span>
}

// GetPage looks up a page of a given type for the given ref.
// In Hugo &lt;= 0.44 you had to add Page Kind (section, home) etc. as the first
// argument and then either a unix styled path (with or without a leading slash))
// or path elements separated.
// When we now remove the Kind from this API, we need to make the transition as painless
// as possible for existing sites. Most sites will use {{ .Site.GetPage "section" "my/section" }},
// i.e. 2 arguments, so we test for that.
func (s *SiteInfo) GetPage(ref ...string) (page.Page, error) <span class="cov8" title="1">{
        p, err := s.s.getPageOldVersion(ref...)

        if p == nil </span><span class="cov0" title="0">{
                // The nil struct has meaning in some situations, mostly to avoid breaking
                // existing sites doing $nilpage.IsDescendant($p), which will always return
                // false.
                p = page.NilPage
        }</span>

        <span class="cov8" title="1">return p, err</span>
}

func (s *Site) permalink(link string) string <span class="cov8" title="1">{
        return s.PathSpec.PermalinkForBaseURL(link, s.PathSpec.BaseURL.String())

}</span>

func (s *Site) renderAndWriteXML(statCounter *uint64, name string, targetPath string, d interface{}, layouts ...string) error <span class="cov8" title="1">{
        s.Log.DEBUG.Printf("Render XML for %q to %q", name, targetPath)
        renderBuffer := bp.GetBuffer()
        defer bp.PutBuffer(renderBuffer)

        if err := s.renderForLayouts(name, "", d, renderBuffer, layouts...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var path string
        if s.Info.relativeURLs </span><span class="cov0" title="0">{
                path = helpers.GetDottedRelativePath(targetPath)
        }</span> else<span class="cov8" title="1"> {
                s := s.PathSpec.BaseURL.String()
                if !strings.HasSuffix(s, "/") </span><span class="cov0" title="0">{
                        s += "/"
                }</span>
                <span class="cov8" title="1">path = s</span>
        }

        <span class="cov8" title="1">pd := publisher.Descriptor{
                Src:         renderBuffer,
                TargetPath:  targetPath,
                StatCounter: statCounter,
                // For the minification part of XML,
                // we currently only use the MIME type.
                OutputFormat: output.RSSFormat,
                AbsURLPath:   path,
        }

        return s.publisher.Publish(pd)</span>

}

func (s *Site) renderAndWritePage(statCounter *uint64, name string, targetPath string, p *pageState, layouts ...string) error <span class="cov8" title="1">{
        renderBuffer := bp.GetBuffer()
        defer bp.PutBuffer(renderBuffer)

        of := p.outputFormat()

        if err := s.renderForLayouts(p.Kind(), of.Name, p, renderBuffer, layouts...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if renderBuffer.Len() == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">isHTML := of.IsHTML
        isRSS := of.Name == "RSS"

        var path string

        if s.Info.relativeURLs </span><span class="cov0" title="0">{
                path = helpers.GetDottedRelativePath(targetPath)
        }</span> else<span class="cov8" title="1"> if isRSS || s.Info.canonifyURLs </span><span class="cov8" title="1">{
                url := s.PathSpec.BaseURL.String()
                if !strings.HasSuffix(url, "/") </span><span class="cov0" title="0">{
                        url += "/"
                }</span>
                <span class="cov8" title="1">path = url</span>
        }

        <span class="cov8" title="1">pd := publisher.Descriptor{
                Src:          renderBuffer,
                TargetPath:   targetPath,
                StatCounter:  statCounter,
                OutputFormat: p.outputFormat(),
        }

        if isRSS </span><span class="cov8" title="1">{
                // Always canonify URLs in RSS
                pd.AbsURLPath = path
        }</span> else<span class="cov8" title="1"> if isHTML </span><span class="cov8" title="1">{
                if s.Info.relativeURLs || s.Info.canonifyURLs </span><span class="cov0" title="0">{
                        pd.AbsURLPath = path
                }</span>

                <span class="cov8" title="1">if s.running() &amp;&amp; s.Cfg.GetBool("watch") &amp;&amp; !s.Cfg.GetBool("disableLiveReload") </span><span class="cov0" title="0">{
                        pd.LiveReloadPort = s.Cfg.GetInt("liveReloadPort")
                }</span>

                // For performance reasons we only inject the Hugo generator tag on the home page.
                <span class="cov8" title="1">if p.IsHome() </span><span class="cov8" title="1">{
                        pd.AddHugoGeneratorTag = !s.Cfg.GetBool("disableHugoGeneratorInject")
                }</span>

        }

        <span class="cov8" title="1">return s.publisher.Publish(pd)</span>
}

var infoOnMissingLayout = map[string]bool{
        // The 404 layout is very much optional in Hugo, but we do look for it.
        "404": true,
}

func (s *Site) renderForLayouts(name, outputFormat string, d interface{}, w io.Writer, layouts ...string) (err error) <span class="cov8" title="1">{
        templ := s.findFirstTemplate(layouts...)
        if templ == nil </span><span class="cov0" title="0">{
                log := s.Log.WARN
                if infoOnMissingLayout[name] </span><span class="cov0" title="0">{
                        log = s.Log.INFO
                }</span>

                <span class="cov0" title="0">errMsg := "You should create a template file which matches Hugo Layouts Lookup Rules for this combination."
                var args []interface{}
                msg := "found no layout file for"
                if outputFormat != "" </span><span class="cov0" title="0">{
                        msg += " %q"
                        args = append(args, outputFormat)
                }</span>
                <span class="cov0" title="0">if name != "" </span><span class="cov0" title="0">{
                        msg += " for %q"
                        args = append(args, name)
                }</span>

                <span class="cov0" title="0">msg += ": " + errMsg

                log.Printf(msg, args...)

                return nil</span>
        }

        <span class="cov8" title="1">if err = templ.Execute(w, d); err != nil </span><span class="cov0" title="0">{
                return _errors.Wrapf(err, "render of %q failed", name)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (s *Site) findFirstTemplate(layouts ...string) tpl.Template <span class="cov8" title="1">{
        for _, layout := range layouts </span><span class="cov8" title="1">{
                if templ, found := s.Tmpl.Lookup(layout); found </span><span class="cov8" title="1">{
                        return templ
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *Site) publish(statCounter *uint64, path string, r io.Reader) (err error) <span class="cov0" title="0">{
        s.PathSpec.ProcessingStats.Incr(statCounter)

        return helpers.WriteToDisk(filepath.Clean(path), r, s.BaseFs.PublishFs)
}</span>

func (s *Site) kindFromFileInfoOrSections(fi *fileInfo, sections []string) string <span class="cov8" title="1">{
        if fi.TranslationBaseName() == "_index" </span><span class="cov0" title="0">{
                if fi.Dir() == "" </span><span class="cov0" title="0">{
                        return page.KindHome
                }</span>

                <span class="cov0" title="0">return s.kindFromSections(sections)</span>

        }
        <span class="cov8" title="1">return page.KindPage</span>
}

func (s *Site) kindFromSections(sections []string) string <span class="cov0" title="0">{
        if len(sections) == 0 </span><span class="cov0" title="0">{
                return page.KindHome
        }</span>

        <span class="cov0" title="0">return s.kindFromSectionPath(path.Join(sections...))</span>

}

func (s *Site) kindFromSectionPath(sectionPath string) string <span class="cov8" title="1">{
        for _, plural := range s.siteCfg.taxonomiesConfig </span><span class="cov8" title="1">{
                if plural == sectionPath </span><span class="cov0" title="0">{
                        return page.KindTaxonomyTerm
                }</span>

                <span class="cov8" title="1">if strings.HasPrefix(sectionPath, plural) </span><span class="cov0" title="0">{
                        return page.KindTaxonomy
                }</span>

        }

        <span class="cov8" title="1">return page.KindSection</span>
}

func (s *Site) newTaxonomyPage(title string, sections ...string) *pageState <span class="cov0" title="0">{
        p, err := newPageFromMeta(
                map[string]interface{}{"title": title},
                &amp;pageMeta{
                        s:        s,
                        kind:     page.KindTaxonomy,
                        sections: sections,
                })

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return p</span>

}

func (s *Site) newPage(kind string, sections ...string) *pageState <span class="cov8" title="1">{
        p, err := newPageFromMeta(
                map[string]interface{}{},
                &amp;pageMeta{
                        s:        s,
                        kind:     kind,
                        sections: sections,
                })

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return p</span>
}

func (s *Site) shouldBuild(p page.Page) bool <span class="cov8" title="1">{
        return shouldBuild(s.BuildFuture, s.BuildExpired,
                s.BuildDrafts, p.Draft(), p.PublishDate(), p.ExpiryDate())
}</span>

func shouldBuild(buildFuture bool, buildExpired bool, buildDrafts bool, Draft bool,
        publishDate time.Time, expiryDate time.Time) bool <span class="cov8" title="1">{
        if !(buildDrafts || !Draft) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !buildFuture &amp;&amp; !publishDate.IsZero() &amp;&amp; publishDate.After(time.Now()) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !buildExpired &amp;&amp; !expiryDate.IsZero() &amp;&amp; expiryDate.Before(time.Now()) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/spf13/cast"
)

func createDefaultOutputFormats(allFormats output.Formats, cfg config.Provider) map[string]output.Formats <span class="cov8" title="1">{
        rssOut, _ := allFormats.GetByName(output.RSSFormat.Name)
        htmlOut, _ := allFormats.GetByName(output.HTMLFormat.Name)
        robotsOut, _ := allFormats.GetByName(output.RobotsTxtFormat.Name)
        sitemapOut, _ := allFormats.GetByName(output.SitemapFormat.Name)

        return map[string]output.Formats{
                page.KindPage:         {htmlOut},
                page.KindHome:         {htmlOut, rssOut},
                page.KindSection:      {htmlOut, rssOut},
                page.KindTaxonomy:     {htmlOut, rssOut},
                page.KindTaxonomyTerm: {htmlOut, rssOut},
                // Below are for consistency. They are currently not used during rendering.
                kindRSS:       {rssOut},
                kindSitemap:   {sitemapOut},
                kindRobotsTXT: {robotsOut},
                kind404:       {htmlOut},
        }

}</span>

func createSiteOutputFormats(allFormats output.Formats, cfg config.Provider) (map[string]output.Formats, error) <span class="cov8" title="1">{
        defaultOutputFormats := createDefaultOutputFormats(allFormats, cfg)

        if !cfg.IsSet("outputs") </span><span class="cov8" title="1">{
                return defaultOutputFormats, nil
        }</span>

        <span class="cov0" title="0">outFormats := make(map[string]output.Formats)

        outputs := cfg.GetStringMap("outputs")

        if len(outputs) == 0 </span><span class="cov0" title="0">{
                return outFormats, nil
        }</span>

        <span class="cov0" title="0">seen := make(map[string]bool)

        for k, v := range outputs </span><span class="cov0" title="0">{
                k = getKind(k)
                if k == "" </span><span class="cov0" title="0">{
                        // Invalid kind
                        continue</span>
                }
                <span class="cov0" title="0">var formats output.Formats
                vals := cast.ToStringSlice(v)
                for _, format := range vals </span><span class="cov0" title="0">{
                        f, found := allFormats.GetByName(format)
                        if !found </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to resolve output format %q from site config", format)
                        }</span>
                        <span class="cov0" title="0">formats = append(formats, f)</span>
                }

                // This effectively prevents empty outputs entries for a given Kind.
                // We need at least one.
                <span class="cov0" title="0">if len(formats) &gt; 0 </span><span class="cov0" title="0">{
                        seen[k] = true
                        outFormats[k] = formats
                }</span>
        }

        // Add defaults for the entries not provided by the user.
        <span class="cov0" title="0">for k, v := range defaultOutputFormats </span><span class="cov0" title="0">{
                if !seen[k] </span><span class="cov0" title="0">{
                        outFormats[k] = v
                }</span>
        }

        <span class="cov0" title="0">return outFormats, nil</span>

}
</pre>
		
		<pre class="file" id="file129" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "path"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/config"

        "github.com/gohugoio/hugo/output"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/page/pagemeta"
)

type siteRenderContext struct {
        cfg *BuildCfg

        // Zero based index for all output formats combined.
        sitesOutIdx int

        // Zero based index of the output formats configured within a Site.
        // Note that these outputs are sorted.
        outIdx int

        multihost bool
}

// Whether to render 404.html, robotsTXT.txt which usually is rendered
// once only in the site root.
func (s siteRenderContext) renderSingletonPages() bool <span class="cov8" title="1">{
        if s.multihost </span><span class="cov0" title="0">{
                // 1 per site
                return s.outIdx == 0
        }</span>

        // 1 for all sites
        <span class="cov8" title="1">return s.sitesOutIdx == 0</span>

}

// renderPages renders pages each corresponding to a markdown file.
// TODO(bep np doc
func (s *Site) renderPages(ctx *siteRenderContext) error <span class="cov8" title="1">{

        numWorkers := config.GetNumWorkerMultiplier()

        results := make(chan error)
        pages := make(chan *pageState, numWorkers) // buffered for performance
        errs := make(chan error)

        go s.errorCollator(results, errs)

        wg := &amp;sync.WaitGroup{}

        for i := 0; i &lt; numWorkers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go pageRenderer(ctx, s, pages, results, wg)
        }</span>

        <span class="cov8" title="1">cfg := ctx.cfg

        if !cfg.PartialReRender &amp;&amp; ctx.outIdx == 0 &amp;&amp; len(s.headlessPages) &gt; 0 </span><span class="cov0" title="0">{
                wg.Add(1)
                go headlessPagesPublisher(s, wg)
        }</span>

<span class="cov8" title="1">L:
        for _, page := range s.workAllPages </span><span class="cov8" title="1">{
                if cfg.shouldRender(page) </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-s.h.Done():<span class="cov0" title="0">
                                break L</span>
                        default:<span class="cov8" title="1">
                                pages &lt;- page</span>
                        }
                }
        }

        <span class="cov8" title="1">close(pages)

        wg.Wait()

        close(results)

        err := &lt;-errs
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to render pages")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func headlessPagesPublisher(s *Site, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()
        for _, p := range s.headlessPages </span><span class="cov0" title="0">{
                if err := p.renderResources(); err != nil </span><span class="cov0" title="0">{
                        s.SendError(p.errorf(err, "failed to render page resources"))
                }</span>
        }
}

func pageRenderer(
        ctx *siteRenderContext,
        s *Site,
        pages &lt;-chan *pageState,
        results chan&lt;- error,
        wg *sync.WaitGroup) <span class="cov8" title="1">{

        defer wg.Done()

        for p := range pages </span><span class="cov8" title="1">{
                f := p.outputFormat()

                // TODO(bep) get rid of this odd construct. RSS is an output format.
                if f.Name == "RSS" &amp;&amp; !s.isEnabled(kindRSS) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if err := p.renderResources(); err != nil </span><span class="cov0" title="0">{
                        s.SendError(p.errorf(err, "failed to render page resources"))
                        continue</span>
                }

                <span class="cov8" title="1">layouts, err := p.getLayouts()
                if err != nil </span><span class="cov0" title="0">{
                        s.Log.ERROR.Printf("Failed to resolve layout for output %q for page %q: %s", f.Name, p, err)
                        continue</span>
                }

                <span class="cov8" title="1">targetPath := p.targetPaths().TargetFilename

                if targetPath == "" </span><span class="cov0" title="0">{
                        s.Log.ERROR.Printf("Failed to create target path for output %q for page %q: %s", f.Name, p, err)
                        continue</span>
                }

                <span class="cov8" title="1">if err := s.renderAndWritePage(&amp;s.PathSpec.ProcessingStats.Pages, "page "+p.Title(), targetPath, p, layouts...); err != nil </span><span class="cov0" title="0">{
                        results &lt;- err
                }</span>

                <span class="cov8" title="1">if p.paginator != nil &amp;&amp; p.paginator.current != nil </span><span class="cov8" title="1">{
                        if err := s.renderPaginator(p, layouts); err != nil </span><span class="cov0" title="0">{
                                results &lt;- err
                        }</span>
                }
        }
}

// renderPaginator must be run after the owning Page has been rendered.
func (s *Site) renderPaginator(p *pageState, layouts []string) error <span class="cov8" title="1">{

        paginatePath := s.Cfg.GetString("paginatePath")

        d := p.targetPathDescriptor
        f := p.s.rc.Format
        d.Type = f

        if p.paginator.current == nil || p.paginator.current != p.paginator.current.First() </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("invalid paginator state for %q", p.pathOrTitle()))</span>
        }

        // Write alias for page 1
        <span class="cov8" title="1">d.Addends = fmt.Sprintf("/%s/%d", paginatePath, 1)
        targetPaths := page.CreateTargetPaths(d)

        if err := s.writeDestAlias(targetPaths.TargetFilename, p.Permalink(), f, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Render pages for the rest
        <span class="cov8" title="1">for current := p.paginator.current.Next(); current != nil; current = current.Next() </span><span class="cov0" title="0">{

                p.paginator.current = current
                d.Addends = fmt.Sprintf("/%s/%d", paginatePath, current.PageNumber())
                targetPaths := page.CreateTargetPaths(d)

                if err := s.renderAndWritePage(
                        &amp;s.PathSpec.ProcessingStats.PaginatorPages,
                        p.Title(),
                        targetPaths.TargetFilename, p, layouts...); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }

        <span class="cov8" title="1">return nil</span>
}

func (s *Site) render404() error <span class="cov8" title="1">{
        if !s.isEnabled(kind404) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">p, err := newPageStandalone(&amp;pageMeta{
                s:    s,
                kind: kind404,
                urlPaths: pagemeta.URLPath{
                        URL: "404.html",
                },
        },
                output.HTMLFormat,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nfLayouts := []string{"404.html"}

        targetPath := p.targetPaths().TargetFilename

        if targetPath == "" </span><span class="cov0" title="0">{
                return errors.New("failed to create targetPath for 404 page")
        }</span>

        <span class="cov8" title="1">return s.renderAndWritePage(&amp;s.PathSpec.ProcessingStats.Pages, "404 page", targetPath, p, nfLayouts...)</span>
}

func (s *Site) renderSitemap() error <span class="cov8" title="1">{
        if !s.isEnabled(kindSitemap) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">p, err := newPageStandalone(&amp;pageMeta{
                s:    s,
                kind: kindSitemap,
                urlPaths: pagemeta.URLPath{
                        URL: s.siteCfg.sitemap.Filename,
                }},
                output.HTMLFormat,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">targetPath := p.targetPaths().TargetFilename

        if targetPath == "" </span><span class="cov0" title="0">{
                return errors.New("failed to create targetPath for sitemap")
        }</span>

        <span class="cov8" title="1">smLayouts := []string{"sitemap.xml", "_default/sitemap.xml", "_internal/_default/sitemap.xml"}

        return s.renderAndWriteXML(&amp;s.PathSpec.ProcessingStats.Sitemaps, "sitemap", targetPath, p, smLayouts...)</span>
}

func (s *Site) renderRobotsTXT() error <span class="cov8" title="1">{
        if !s.isEnabled(kindRobotsTXT) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if !s.Cfg.GetBool("enableRobotsTXT") </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">p, err := newPageStandalone(&amp;pageMeta{
                s:    s,
                kind: kindRobotsTXT,
                urlPaths: pagemeta.URLPath{
                        URL: "robots.txt",
                },
        },
                output.RobotsTxtFormat)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rLayouts := []string{"robots.txt", "_default/robots.txt", "_internal/_default/robots.txt"}

        return s.renderAndWritePage(&amp;s.PathSpec.ProcessingStats.Pages, "Robots Txt", p.targetPaths().TargetFilename, p, rLayouts...)</span>

}

// renderAliases renders shell pages that simply have a redirect in the header.
func (s *Site) renderAliases() error <span class="cov8" title="1">{
        for _, p := range s.workAllPages </span><span class="cov8" title="1">{

                if len(p.Aliases()) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, of := range p.OutputFormats() </span><span class="cov0" title="0">{
                        if !of.Format.IsHTML </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">plink := of.Permalink()
                        f := of.Format

                        for _, a := range p.Aliases() </span><span class="cov0" title="0">{
                                isRelative := !strings.HasPrefix(a, "/")

                                if isRelative </span><span class="cov0" title="0">{
                                        // Make alias relative, where "." will be on the
                                        // same directory level as the current page.
                                        // TODO(bep) ugly URLs doesn't seem to be supported in
                                        // aliases, I'm not sure why not.
                                        basePath := of.RelPermalink()
                                        if strings.HasSuffix(basePath, "/") </span><span class="cov0" title="0">{
                                                basePath = path.Join(basePath, "..")
                                        }</span>
                                        <span class="cov0" title="0">a = path.Join(basePath, a)</span>

                                } else<span class="cov0" title="0"> if f.Path != "" </span><span class="cov0" title="0">{
                                        // Make sure AMP and similar doesn't clash with regular aliases.
                                        a = path.Join(f.Path, a)
                                }</span>

                                <span class="cov0" title="0">lang := p.Language().Lang

                                if s.h.multihost &amp;&amp; !strings.HasPrefix(a, "/"+lang) </span><span class="cov0" title="0">{
                                        // These need to be in its language root.
                                        a = path.Join(lang, a)
                                }</span>

                                <span class="cov0" title="0">if err := s.writeDestAlias(a, plink, f, p); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// renderMainLanguageRedirect creates a redirect to the main language home,
// depending on if it lives in sub folder (e.g. /en) or not.
func (s *Site) renderMainLanguageRedirect() error <span class="cov8" title="1">{

        if !s.h.multilingual.enabled() || s.h.IsMultihost() </span><span class="cov8" title="1">{
                // No need for a redirect
                return nil
        }</span>

        <span class="cov0" title="0">html, found := s.outputFormatsConfig.GetByName("HTML")
        if found </span><span class="cov0" title="0">{
                mainLang := s.h.multilingual.DefaultLang
                if s.Info.defaultContentLanguageInSubdir </span><span class="cov0" title="0">{
                        mainLangURL := s.PathSpec.AbsURL(mainLang.Lang, false)
                        s.Log.DEBUG.Printf("Write redirect to main language %s: %s", mainLang, mainLangURL)
                        if err := s.publishDestAlias(true, "/", mainLangURL, html, nil); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        mainLangURL := s.PathSpec.AbsURL("", false)
                        s.Log.DEBUG.Printf("Write redirect to main language %s: %s", mainLang, mainLangURL)
                        if err := s.publishDestAlias(true, mainLang.Lang, mainLangURL, html, nil); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/gohugoio/hugo/resources/page"
)

// Sections returns the top level sections.
func (s *SiteInfo) Sections() page.Pages <span class="cov0" title="0">{
        home, err := s.Home()
        if err == nil </span><span class="cov0" title="0">{
                return home.Sections()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Home is a shortcut to the home page, equivalent to .Site.GetPage "home".
func (s *SiteInfo) Home() (page.Page, error) <span class="cov0" title="0">{
        return s.s.home, nil
}</span>
</pre>
		
		<pre class="file" id="file131" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "sort"

        "github.com/gohugoio/hugo/compare"

        "github.com/gohugoio/hugo/resources/page"
)

// The TaxonomyList is a list of all taxonomies and their values
// e.g. List['tags'] =&gt; TagTaxonomy (from above)
type TaxonomyList map[string]Taxonomy

func (tl TaxonomyList) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("TaxonomyList(%d)", len(tl))
}</span>

// A Taxonomy is a map of keywords to a list of pages.
// For example
//    TagTaxonomy['technology'] = page.WeightedPages
//    TagTaxonomy['go']  =  page.WeightedPages
type Taxonomy map[string]page.WeightedPages

// OrderedTaxonomy is another representation of an Taxonomy using an array rather than a map.
// Important because you can't order a map.
type OrderedTaxonomy []OrderedTaxonomyEntry

// OrderedTaxonomyEntry is similar to an element of a Taxonomy, but with the key embedded (as name)
// e.g:  {Name: Technology, page.WeightedPages: TaxonomyPages}
type OrderedTaxonomyEntry struct {
        Name string
        page.WeightedPages
}

// Get the weighted pages for the given key.
func (i Taxonomy) Get(key string) page.WeightedPages <span class="cov0" title="0">{
        return i[key]
}</span>

// Count the weighted pages for the given key.
func (i Taxonomy) Count(key string) int <span class="cov0" title="0">{ return len(i[key]) }</span>

func (i Taxonomy) add(key string, w page.WeightedPage) <span class="cov0" title="0">{
        i[key] = append(i[key], w)
}</span>

// TaxonomyArray returns an ordered taxonomy with a non defined order.
func (i Taxonomy) TaxonomyArray() OrderedTaxonomy <span class="cov0" title="0">{
        ies := make([]OrderedTaxonomyEntry, len(i))
        count := 0
        for k, v := range i </span><span class="cov0" title="0">{
                ies[count] = OrderedTaxonomyEntry{Name: k, WeightedPages: v}
                count++
        }</span>
        <span class="cov0" title="0">return ies</span>
}

// Alphabetical returns an ordered taxonomy sorted by key name.
func (i Taxonomy) Alphabetical() OrderedTaxonomy <span class="cov0" title="0">{
        name := func(i1, i2 *OrderedTaxonomyEntry) bool </span><span class="cov0" title="0">{
                return compare.LessStrings(i1.Name, i2.Name)
        }</span>

        <span class="cov0" title="0">ia := i.TaxonomyArray()
        oiBy(name).Sort(ia)
        return ia</span>
}

// ByCount returns an ordered taxonomy sorted by # of pages per key.
// If taxonomies have the same # of pages, sort them alphabetical
func (i Taxonomy) ByCount() OrderedTaxonomy <span class="cov0" title="0">{
        count := func(i1, i2 *OrderedTaxonomyEntry) bool </span><span class="cov0" title="0">{
                li1 := len(i1.WeightedPages)
                li2 := len(i2.WeightedPages)

                if li1 == li2 </span><span class="cov0" title="0">{
                        return compare.LessStrings(i1.Name, i2.Name)
                }</span>
                <span class="cov0" title="0">return li1 &gt; li2</span>
        }

        <span class="cov0" title="0">ia := i.TaxonomyArray()
        oiBy(count).Sort(ia)
        return ia</span>
}

// Pages returns the Pages for this taxonomy.
func (ie OrderedTaxonomyEntry) Pages() page.Pages <span class="cov0" title="0">{
        return ie.WeightedPages.Pages()
}</span>

// Count returns the count the pages in this taxonomy.
func (ie OrderedTaxonomyEntry) Count() int <span class="cov0" title="0">{
        return len(ie.WeightedPages)
}</span>

// Term returns the name given to this taxonomy.
func (ie OrderedTaxonomyEntry) Term() string <span class="cov0" title="0">{
        return ie.Name
}</span>

// Reverse reverses the order of the entries in this taxonomy.
func (t OrderedTaxonomy) Reverse() OrderedTaxonomy <span class="cov0" title="0">{
        for i, j := 0, len(t)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                t[i], t[j] = t[j], t[i]
        }</span>

        <span class="cov0" title="0">return t</span>
}

// A type to implement the sort interface for TaxonomyEntries.
type orderedTaxonomySorter struct {
        taxonomy OrderedTaxonomy
        by       oiBy
}

// Closure used in the Sort.Less method.
type oiBy func(i1, i2 *OrderedTaxonomyEntry) bool

func (by oiBy) Sort(taxonomy OrderedTaxonomy) <span class="cov0" title="0">{
        ps := &amp;orderedTaxonomySorter{
                taxonomy: taxonomy,
                by:       by, // The Sort method's receiver is the function (closure) that defines the sort order.
        }
        sort.Stable(ps)
}</span>

// Len is part of sort.Interface.
func (s *orderedTaxonomySorter) Len() int <span class="cov0" title="0">{
        return len(s.taxonomy)
}</span>

// Swap is part of sort.Interface.
func (s *orderedTaxonomySorter) Swap(i, j int) <span class="cov0" title="0">{
        s.taxonomy[i], s.taxonomy[j] = s.taxonomy[j], s.taxonomy[i]
}</span>

// Less is part of sort.Interface. It is implemented by calling the "by" closure in the sorter.
func (s *orderedTaxonomySorter) Less(i, j int) bool <span class="cov0" title="0">{
        return s.by(&amp;s.taxonomy[i], &amp;s.taxonomy[j])
}</span>
</pre>
		
		<pre class="file" id="file132" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/gohugoio/hugo/resources/page"
)

func pagesToTranslationsMap(sites []*Site) map[string]page.Pages <span class="cov0" title="0">{
        out := make(map[string]page.Pages)

        for _, s := range sites </span><span class="cov0" title="0">{
                for _, p := range s.workAllPages </span><span class="cov0" title="0">{
                        // TranslationKey is implemented for all page types.
                        base := p.TranslationKey()

                        pageTranslations, found := out[base]
                        if !found </span><span class="cov0" title="0">{
                                pageTranslations = make(page.Pages, 0)
                        }</span>

                        <span class="cov0" title="0">pageTranslations = append(pageTranslations, p)
                        out[base] = pageTranslations</span>
                }
        }

        <span class="cov0" title="0">return out</span>
}

func assignTranslationsToPages(allTranslations map[string]page.Pages, sites []*Site) <span class="cov0" title="0">{
        for _, s := range sites </span><span class="cov0" title="0">{
                for _, p := range s.workAllPages </span><span class="cov0" title="0">{
                        base := p.TranslationKey()
                        translations, found := allTranslations[base]
                        if !found </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">p.setTranslations(translations)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file133" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package langs

import (
        "fmt"
        "path/filepath"
        "sort"
        "strings"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/spf13/cast"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/config"
)

type LanguagesConfig struct {
        Languages                      Languages
        Multihost                      bool
        DefaultContentLanguageInSubdir bool
}

func LoadLanguageSettings(cfg config.Provider, oldLangs Languages) (c LanguagesConfig, err error) <span class="cov8" title="1">{

        defaultLang := cfg.GetString("defaultContentLanguage")
        if defaultLang == "" </span><span class="cov0" title="0">{
                defaultLang = "en"
                cfg.Set("defaultContentLanguage", defaultLang)
        }</span>

        <span class="cov8" title="1">var languages map[string]interface{}

        languagesFromConfig := cfg.GetStringMap("languages")
        disableLanguages := cfg.GetStringSlice("disableLanguages")

        if len(disableLanguages) == 0 </span><span class="cov8" title="1">{
                languages = languagesFromConfig
        }</span> else<span class="cov0" title="0"> {
                languages = make(map[string]interface{})
                for k, v := range languagesFromConfig </span><span class="cov0" title="0">{
                        for _, disabled := range disableLanguages </span><span class="cov0" title="0">{
                                if disabled == defaultLang </span><span class="cov0" title="0">{
                                        return c, fmt.Errorf("cannot disable default language %q", defaultLang)
                                }</span>

                                <span class="cov0" title="0">if strings.EqualFold(k, disabled) </span><span class="cov0" title="0">{
                                        v.(map[string]interface{})["disabled"] = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">languages[k] = v</span>
                }
        }

        <span class="cov8" title="1">var languages2 Languages

        if len(languages) == 0 </span><span class="cov8" title="1">{
                languages2 = append(languages2, NewDefaultLanguage(cfg))
        }</span> else<span class="cov0" title="0"> {
                languages2, err = toSortedLanguages(cfg, languages)
                if err != nil </span><span class="cov0" title="0">{
                        return c, errors.Wrap(err, "Failed to parse multilingual config")
                }</span>
        }

        <span class="cov8" title="1">if oldLangs != nil </span><span class="cov0" title="0">{
                // When in multihost mode, the languages are mapped to a server, so
                // some structural language changes will need a restart of the dev server.
                // The validation below isn't complete, but should cover the most
                // important cases.
                var invalid bool
                if languages2.IsMultihost() != oldLangs.IsMultihost() </span><span class="cov0" title="0">{
                        invalid = true
                }</span> else<span class="cov0" title="0"> {
                        if languages2.IsMultihost() &amp;&amp; len(languages2) != len(oldLangs) </span><span class="cov0" title="0">{
                                invalid = true
                        }</span>
                }

                <span class="cov0" title="0">if invalid </span><span class="cov0" title="0">{
                        return c, errors.New("language change needing a server restart detected")
                }</span>

                <span class="cov0" title="0">if languages2.IsMultihost() </span><span class="cov0" title="0">{
                        // We need to transfer any server baseURL to the new language
                        for i, ol := range oldLangs </span><span class="cov0" title="0">{
                                nl := languages2[i]
                                nl.Set("baseURL", ol.GetString("baseURL"))
                        }</span>
                }
        }

        // The defaultContentLanguage is something the user has to decide, but it needs
        // to match a language in the language definition list.
        <span class="cov8" title="1">langExists := false
        for _, lang := range languages2 </span><span class="cov8" title="1">{
                if lang.Lang == defaultLang </span><span class="cov8" title="1">{
                        langExists = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !langExists </span><span class="cov0" title="0">{
                return c, fmt.Errorf("site config value %q for defaultContentLanguage does not match any language definition", defaultLang)
        }</span>

        <span class="cov8" title="1">c.Languages = languages2
        c.Multihost = languages2.IsMultihost()
        c.DefaultContentLanguageInSubdir = c.Multihost

        sortedDefaultFirst := make(Languages, len(c.Languages))
        for i, v := range c.Languages </span><span class="cov8" title="1">{
                sortedDefaultFirst[i] = v
        }</span>
        <span class="cov8" title="1">sort.Slice(sortedDefaultFirst, func(i, j int) bool </span><span class="cov0" title="0">{
                li, lj := sortedDefaultFirst[i], sortedDefaultFirst[j]
                if li.Lang == defaultLang </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">if lj.Lang == defaultLang </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">return i &lt; j</span>
        })

        <span class="cov8" title="1">cfg.Set("languagesSorted", c.Languages)
        cfg.Set("languagesSortedDefaultFirst", sortedDefaultFirst)
        cfg.Set("multilingual", len(languages2) &gt; 1)

        multihost := c.Multihost

        if multihost </span><span class="cov0" title="0">{
                cfg.Set("defaultContentLanguageInSubdir", true)
                cfg.Set("multihost", true)
        }</span>

        <span class="cov8" title="1">if multihost </span><span class="cov0" title="0">{
                // The baseURL may be provided at the language level. If that is true,
                // then every language must have a baseURL. In this case we always render
                // to a language sub folder, which is then stripped from all the Permalink URLs etc.
                for _, l := range languages2 </span><span class="cov0" title="0">{
                        burl := l.GetLocal("baseURL")
                        if burl == nil </span><span class="cov0" title="0">{
                                return c, errors.New("baseURL must be set on all or none of the languages")
                        }</span>
                }

        }

        <span class="cov8" title="1">return c, nil</span>
}

func toSortedLanguages(cfg config.Provider, l map[string]interface{}) (Languages, error) <span class="cov0" title="0">{
        languages := make(Languages, len(l))
        i := 0

        for lang, langConf := range l </span><span class="cov0" title="0">{
                langsMap, err := cast.ToStringMapE(langConf)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Language config is not a map: %T", langConf)
                }</span>

                <span class="cov0" title="0">language := NewLanguage(lang, cfg)

                for loki, v := range langsMap </span><span class="cov0" title="0">{
                        switch loki </span>{
                        case "title":<span class="cov0" title="0">
                                language.Title = cast.ToString(v)</span>
                        case "languagename":<span class="cov0" title="0">
                                language.LanguageName = cast.ToString(v)</span>
                        case "weight":<span class="cov0" title="0">
                                language.Weight = cast.ToInt(v)</span>
                        case "contentdir":<span class="cov0" title="0">
                                language.ContentDir = filepath.Clean(cast.ToString(v))</span>
                        case "disabled":<span class="cov0" title="0">
                                language.Disabled = cast.ToBool(v)</span>
                        case "params":<span class="cov0" title="0">
                                m := cast.ToStringMap(v)
                                // Needed for case insensitive fetching of params values
                                maps.ToLower(m)
                                for k, vv := range m </span><span class="cov0" title="0">{
                                        language.SetParam(k, vv)
                                }</span>
                        }

                        // Put all into the Params map
                        <span class="cov0" title="0">language.SetParam(loki, v)

                        // Also set it in the configuration map (for baseURL etc.)
                        language.Set(loki, v)</span>
                }

                <span class="cov0" title="0">languages[i] = language
                i++</span>
        }

        <span class="cov0" title="0">sort.Sort(languages)

        return languages, nil</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package i18n

import (
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/helpers"

        "github.com/nicksnyder/go-i18n/i18n/bundle"
        "github.com/nicksnyder/go-i18n/i18n/translation"
)

var (
        i18nWarningLogger = helpers.NewDistinctFeedbackLogger()
)

// Translator handles i18n translations.
type Translator struct {
        translateFuncs map[string]bundle.TranslateFunc
        cfg            config.Provider
        logger         *loggers.Logger
}

// NewTranslator creates a new Translator for the given language bundle and configuration.
func NewTranslator(b *bundle.Bundle, cfg config.Provider, logger *loggers.Logger) Translator <span class="cov8" title="1">{
        t := Translator{cfg: cfg, logger: logger, translateFuncs: make(map[string]bundle.TranslateFunc)}
        t.initFuncs(b)
        return t
}</span>

// Func gets the translate func for the given language, or for the default
// configured language if not found.
func (t Translator) Func(lang string) bundle.TranslateFunc <span class="cov8" title="1">{
        if f, ok := t.translateFuncs[lang]; ok </span><span class="cov8" title="1">{
                return f
        }</span>
        <span class="cov0" title="0">t.logger.INFO.Printf("Translation func for language %v not found, use default.", lang)
        if f, ok := t.translateFuncs[t.cfg.GetString("defaultContentLanguage")]; ok </span><span class="cov0" title="0">{
                return f
        }</span>
        <span class="cov0" title="0">t.logger.INFO.Println("i18n not initialized; if you need string translations, check that you have a bundle in /i18n that matches the site language or the default language.")
        return func(translationID string, args ...interface{}) string </span><span class="cov0" title="0">{
                return ""
        }</span>

}

func (t Translator) initFuncs(bndl *bundle.Bundle) <span class="cov8" title="1">{
        defaultContentLanguage := t.cfg.GetString("defaultContentLanguage")

        defaultT, err := bndl.Tfunc(defaultContentLanguage)
        if err != nil </span><span class="cov0" title="0">{
                t.logger.INFO.Printf("No translation bundle found for default language %q", defaultContentLanguage)
        }</span>

        <span class="cov8" title="1">translations := bndl.Translations()

        enableMissingTranslationPlaceholders := t.cfg.GetBool("enableMissingTranslationPlaceholders")
        for _, lang := range bndl.LanguageTags() </span><span class="cov8" title="1">{
                currentLang := lang

                t.translateFuncs[currentLang] = func(translationID string, args ...interface{}) string </span><span class="cov8" title="1">{
                        tFunc, err := bndl.Tfunc(currentLang)
                        if err != nil </span><span class="cov0" title="0">{
                                t.logger.WARN.Printf("could not load translations for language %q (%s), will use default content language.\n", lang, err)
                        }</span>

                        <span class="cov8" title="1">translated := tFunc(translationID, args...)
                        if translated != translationID </span><span class="cov8" title="1">{
                                return translated
                        }</span>
                        // If there is no translation for translationID,
                        // then Tfunc returns translationID itself.
                        // But if user set same translationID and translation, we should check
                        // if it really untranslated:
                        <span class="cov0" title="0">if isIDTranslated(translations, currentLang, translationID) </span><span class="cov0" title="0">{
                                return translated
                        }</span>

                        <span class="cov0" title="0">if t.cfg.GetBool("logI18nWarnings") </span><span class="cov0" title="0">{
                                i18nWarningLogger.Printf("i18n|MISSING_TRANSLATION|%s|%s", currentLang, translationID)
                        }</span>
                        <span class="cov0" title="0">if enableMissingTranslationPlaceholders </span><span class="cov0" title="0">{
                                return "[i18n] " + translationID
                        }</span>
                        <span class="cov0" title="0">if defaultT != nil </span><span class="cov0" title="0">{
                                translated := defaultT(translationID, args...)
                                if translated != translationID </span><span class="cov0" title="0">{
                                        return translated
                                }</span>
                                <span class="cov0" title="0">if isIDTranslated(translations, defaultContentLanguage, translationID) </span><span class="cov0" title="0">{
                                        return translated
                                }</span>
                        }
                        <span class="cov0" title="0">return ""</span>
                }
        }
}

// If the translation map contains translationID for specified currentLang,
// then the translationID is actually translated.
func isIDTranslated(translations map[string]map[string]translation.Translation, lang, id string) bool <span class="cov0" title="0">{
        _, contains := translations[lang][id]
        return contains
}</span>
</pre>
		
		<pre class="file" id="file135" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package i18n

import (
        "errors"

        "github.com/gohugoio/hugo/common/herrors"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/source"
        "github.com/nicksnyder/go-i18n/i18n/bundle"
        "github.com/nicksnyder/go-i18n/i18n/language"
        _errors "github.com/pkg/errors"
)

// TranslationProvider provides translation handling, i.e. loading
// of bundles etc.
type TranslationProvider struct {
        t Translator
}

// NewTranslationProvider creates a new translation provider.
func NewTranslationProvider() *TranslationProvider <span class="cov8" title="1">{
        return &amp;TranslationProvider{}
}</span>

// Update updates the i18n func in the provided Deps.
func (tp *TranslationProvider) Update(d *deps.Deps) error <span class="cov8" title="1">{
        spec := source.NewSourceSpec(d.PathSpec, nil)

        i18nBundle := bundle.New()

        en := language.GetPluralSpec("en")
        if en == nil </span><span class="cov0" title="0">{
                return errors.New("the English language has vanished like an old oak table")
        }</span>
        <span class="cov8" title="1">var newLangs []string

        // The source dirs are ordered so the most important comes first. Since this is a
        // last key win situation, we have to reverse the iteration order.
        dirs := d.BaseFs.I18n.Dirs
        for i := len(dirs) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                dir := dirs[i]
                src := spec.NewFilesystemFromFileMetaInfo(dir)

                files, err := src.Files()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">for _, r := range files </span><span class="cov8" title="1">{
                        currentSpec := language.GetPluralSpec(r.BaseFileName())
                        if currentSpec == nil </span><span class="cov0" title="0">{
                                // This may is a language code not supported by go-i18n, it may be
                                // Klingon or ... not even a fake language. Make sure it works.
                                newLangs = append(newLangs, r.BaseFileName())
                        }</span>
                }

                <span class="cov8" title="1">if len(newLangs) &gt; 0 </span><span class="cov0" title="0">{
                        language.RegisterPluralSpec(newLangs, en)
                }</span>

                <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                        if err := addTranslationFile(i18nBundle, file); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">tp.t = NewTranslator(i18nBundle, d.Cfg, d.Log)

        d.Translate = tp.t.Func(d.Language.Lang)

        return nil</span>

}

func addTranslationFile(bundle *bundle.Bundle, r source.File) error <span class="cov8" title="1">{
        f, err := r.FileInfo().Meta().Open()
        if err != nil </span><span class="cov0" title="0">{
                return _errors.Wrapf(err, "failed to open translations file %q:", r.LogicalName())
        }</span>
        <span class="cov8" title="1">err = bundle.ParseTranslationFileBytes(r.LogicalName(), helpers.ReaderToBytes(f))
        f.Close()
        if err != nil </span><span class="cov0" title="0">{
                return errWithFileContext(_errors.Wrapf(err, "failed to load translations"), r)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Clone sets the language func for the new language.
func (tp *TranslationProvider) Clone(d *deps.Deps) error <span class="cov0" title="0">{
        d.Translate = tp.t.Func(d.Language.Lang)

        return nil
}</span>

func errWithFileContext(inerr error, r source.File) error <span class="cov0" title="0">{
        fim, ok := r.FileInfo().(hugofs.FileMetaInfo)
        if !ok </span><span class="cov0" title="0">{
                return inerr
        }</span>

        <span class="cov0" title="0">meta := fim.Meta()
        realFilename := meta.Filename()
        f, err := meta.Open()
        if err != nil </span><span class="cov0" title="0">{
                return inerr
        }</span>
        <span class="cov0" title="0">defer f.Close()

        err, _ = herrors.WithFileContext(
                inerr,
                realFilename,
                f,
                herrors.SimpleLineMatcher)

        return err</span>

}
</pre>
		
		<pre class="file" id="file136" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package langs

import (
        "sort"
        "strings"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/config"
        "github.com/spf13/cast"
)

// These are the settings that should only be looked up in the global Viper
// config and not per language.
// This list may not be complete, but contains only settings that we know
// will be looked up in both.
// This isn't perfect, but it is ultimately the user who shoots him/herself in
// the foot.
// See the pathSpec.
var globalOnlySettings = map[string]bool{
        strings.ToLower("defaultContentLanguageInSubdir"): true,
        strings.ToLower("defaultContentLanguage"):         true,
        strings.ToLower("multilingual"):                   true,
        strings.ToLower("assetDir"):                       true,
        strings.ToLower("resourceDir"):                    true,
}

// Language manages specific-language configuration.
type Language struct {
        Lang         string
        LanguageName string
        Title        string
        Weight       int

        Disabled bool

        // If set per language, this tells Hugo that all content files without any
        // language indicator (e.g. my-page.en.md) is in this language.
        // This is usually a path relative to the working dir, but it can be an
        // absolute directory reference. It is what we get.
        ContentDir string

        Cfg config.Provider

        // These are params declared in the [params] section of the language merged with the
        // site's params, the most specific (language) wins on duplicate keys.
        params map[string]interface{}

        // These are config values, i.e. the settings declared outside of the [params] section of the language.
        // This is the map Hugo looks in when looking for configuration values (baseURL etc.).
        // Values in this map can also be fetched from the params map above.
        settings map[string]interface{}
}

func (l *Language) String() string <span class="cov0" title="0">{
        return l.Lang
}</span>

// NewLanguage creates a new language.
func NewLanguage(lang string, cfg config.Provider) *Language <span class="cov8" title="1">{
        // Note that language specific params will be overridden later.
        // We should improve that, but we need to make a copy:
        params := make(map[string]interface{})
        for k, v := range cfg.GetStringMap("params") </span><span class="cov0" title="0">{
                params[k] = v
        }</span>
        <span class="cov8" title="1">maps.ToLower(params)

        l := &amp;Language{Lang: lang, ContentDir: cfg.GetString("contentDir"), Cfg: cfg, params: params, settings: make(map[string]interface{})}
        return l</span>
}

// NewDefaultLanguage creates the default language for a config.Provider.
// If not otherwise specified the default is "en".
func NewDefaultLanguage(cfg config.Provider) *Language <span class="cov8" title="1">{
        defaultLang := cfg.GetString("defaultContentLanguage")

        if defaultLang == "" </span><span class="cov0" title="0">{
                defaultLang = "en"
        }</span>

        <span class="cov8" title="1">return NewLanguage(defaultLang, cfg)</span>
}

// Languages is a sortable list of languages.
type Languages []*Language

// NewLanguages creates a sorted list of languages.
// NOTE: function is currently unused.
func NewLanguages(l ...*Language) Languages <span class="cov0" title="0">{
        languages := make(Languages, len(l))
        for i := 0; i &lt; len(l); i++ </span><span class="cov0" title="0">{
                languages[i] = l[i]
        }</span>
        <span class="cov0" title="0">sort.Sort(languages)
        return languages</span>
}

func (l Languages) Len() int <span class="cov0" title="0">{ return len(l) }</span>
func (l Languages) Less(i, j int) bool <span class="cov0" title="0">{
        wi, wj := l[i].Weight, l[j].Weight

        if wi == wj </span><span class="cov0" title="0">{
                return l[i].Lang &lt; l[j].Lang
        }</span>

        <span class="cov0" title="0">return wj == 0 || wi &lt; wj</span>

}

func (l Languages) Swap(i, j int) <span class="cov0" title="0">{ l[i], l[j] = l[j], l[i] }</span>

// Params retunrs language-specific params merged with the global params.
func (l *Language) Params() map[string]interface{} <span class="cov8" title="1">{
        return l.params
}</span>

func (l Languages) AsSet() map[string]bool <span class="cov0" title="0">{
        m := make(map[string]bool)
        for _, lang := range l </span><span class="cov0" title="0">{
                m[lang.Lang] = true
        }</span>

        <span class="cov0" title="0">return m</span>
}

func (l Languages) AsOrdinalSet() map[string]int <span class="cov8" title="1">{
        m := make(map[string]int)
        for i, lang := range l </span><span class="cov8" title="1">{
                m[lang.Lang] = i
        }</span>

        <span class="cov8" title="1">return m</span>
}

// IsMultihost returns whether there are more than one language and at least one of
// the languages has baseURL specificed on the language level.
func (l Languages) IsMultihost() bool <span class="cov8" title="1">{
        if len(l) &lt;= 1 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov0" title="0">for _, lang := range l </span><span class="cov0" title="0">{
                if lang.GetLocal("baseURL") != nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// SetParam sets a param with the given key and value.
// SetParam is case-insensitive.
func (l *Language) SetParam(k string, v interface{}) <span class="cov0" title="0">{
        l.params[strings.ToLower(k)] = v
}</span>

// GetBool returns the value associated with the key as a boolean.
func (l *Language) GetBool(key string) bool <span class="cov8" title="1">{ return cast.ToBool(l.Get(key)) }</span>

// GetString returns the value associated with the key as a string.
func (l *Language) GetString(key string) string <span class="cov8" title="1">{ return cast.ToString(l.Get(key)) }</span>

// GetInt returns the value associated with the key as an int.
func (l *Language) GetInt(key string) int <span class="cov8" title="1">{ return cast.ToInt(l.Get(key)) }</span>

// GetStringMap returns the value associated with the key as a map of interfaces.
func (l *Language) GetStringMap(key string) map[string]interface{} <span class="cov8" title="1">{
        return cast.ToStringMap(l.Get(key))
}</span>

// GetStringMapString returns the value associated with the key as a map of strings.
func (l *Language) GetStringMapString(key string) map[string]string <span class="cov8" title="1">{
        return cast.ToStringMapString(l.Get(key))
}</span>

// GetStringSlice returns the value associated with the key as a slice of strings.
func (l *Language) GetStringSlice(key string) []string <span class="cov8" title="1">{
        return cast.ToStringSlice(l.Get(key))
}</span>

// Get returns a value associated with the key relying on specified language.
// Get is case-insensitive for a key.
//
// Get returns an interface. For a specific value use one of the Get____ methods.
func (l *Language) Get(key string) interface{} <span class="cov8" title="1">{
        local := l.GetLocal(key)
        if local != nil </span><span class="cov0" title="0">{
                return local
        }</span>
        <span class="cov8" title="1">return l.Cfg.Get(key)</span>
}

// GetLocal gets a configuration value set on language level. It will
// not fall back to any global value.
// It will return nil if a value with the given key cannot be found.
func (l *Language) GetLocal(key string) interface{} <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                panic("language not set")</span>
        }
        <span class="cov8" title="1">key = strings.ToLower(key)
        if !globalOnlySettings[key] </span><span class="cov8" title="1">{
                if v, ok := l.settings[key]; ok </span><span class="cov0" title="0">{
                        return v
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Set sets the value for the key in the language's params.
func (l *Language) Set(key string, value interface{}) <span class="cov0" title="0">{
        if l == nil </span><span class="cov0" title="0">{
                panic("language not set")</span>
        }
        <span class="cov0" title="0">key = strings.ToLower(key)
        l.settings[key] = value</span>
}

// IsSet checks whether the key is set in the language or the related config store.
func (l *Language) IsSet(key string) bool <span class="cov8" title="1">{
        key = strings.ToLower(key)

        key = strings.ToLower(key)
        if !globalOnlySettings[key] </span><span class="cov8" title="1">{
                if _, ok := l.settings[key]; ok </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return l.Cfg.IsSet(key)</span>

}
</pre>
		
		<pre class="file" id="file137" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lazy

import (
        "context"
        "sync"
        "time"

        "github.com/pkg/errors"
)

// New creates a new empty Init.
func New() *Init <span class="cov8" title="1">{
        return &amp;Init{}
}</span>

// Init holds a graph of lazily initialized dependencies.
type Init struct {
        mu sync.Mutex

        prev     *Init
        children []*Init

        init onceMore
        out  interface{}
        err  error
        f    func() (interface{}, error)
}

// Add adds a func as a new child dependency.
func (ini *Init) Add(initFn func() (interface{}, error)) *Init <span class="cov8" title="1">{
        if ini == nil </span><span class="cov0" title="0">{
                ini = New()
        }</span>
        <span class="cov8" title="1">return ini.add(false, initFn)</span>
}

// AddWithTimeout is same as Add, but with a timeout that aborts initialization.
func (ini *Init) AddWithTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) *Init <span class="cov0" title="0">{
        return ini.Add(func() (interface{}, error) </span><span class="cov0" title="0">{
                return ini.withTimeout(timeout, f)
        }</span>)
}

// Branch creates a new dependency branch based on an existing and adds
// the given dependency as a child.
func (ini *Init) Branch(initFn func() (interface{}, error)) *Init <span class="cov8" title="1">{
        if ini == nil </span><span class="cov0" title="0">{
                ini = New()
        }</span>
        <span class="cov8" title="1">return ini.add(true, initFn)</span>
}

// BranchdWithTimeout is same as Branch, but with a timeout.
func (ini *Init) BranchdWithTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) *Init <span class="cov0" title="0">{
        return ini.Branch(func() (interface{}, error) </span><span class="cov0" title="0">{
                return ini.withTimeout(timeout, f)
        }</span>)
}

// Do initializes the entire dependency graph.
func (ini *Init) Do() (interface{}, error) <span class="cov8" title="1">{
        if ini == nil </span><span class="cov0" title="0">{
                panic("init is nil")</span>
        }

        <span class="cov8" title="1">ini.init.Do(func() </span><span class="cov8" title="1">{
                prev := ini.prev
                if prev != nil </span><span class="cov8" title="1">{
                        // A branch. Initialize the ancestors.
                        if prev.shouldInitialize() </span><span class="cov8" title="1">{
                                _, err := prev.Do()
                                if err != nil </span><span class="cov0" title="0">{
                                        ini.err = err
                                        return
                                }</span>
                        } else<span class="cov8" title="1"> if prev.inProgress() </span><span class="cov0" title="0">{
                                // Concurrent initialization. The following init func
                                // may depend on earlier state, so wait.
                                prev.wait()
                        }</span>
                }

                <span class="cov8" title="1">if ini.f != nil </span><span class="cov8" title="1">{
                        ini.out, ini.err = ini.f()
                }</span>

                <span class="cov8" title="1">for _, child := range ini.children </span><span class="cov8" title="1">{
                        if child.shouldInitialize() </span><span class="cov8" title="1">{
                                _, err := child.Do()
                                if err != nil </span><span class="cov0" title="0">{
                                        ini.err = err
                                        return
                                }</span>
                        }
                }
        })

        <span class="cov8" title="1">ini.wait()

        return ini.out, ini.err</span>

}

// TODO(bep) investigate if we can use sync.Cond for this.
func (ini *Init) wait() <span class="cov8" title="1">{
        var counter time.Duration
        for !ini.init.Done() </span><span class="cov8" title="1">{
                counter += 10
                if counter &gt; 600000000 </span><span class="cov0" title="0">{
                        panic("BUG: timed out in lazy init")</span>
                }
                <span class="cov8" title="1">time.Sleep(counter * time.Microsecond)</span>
        }
}

func (ini *Init) inProgress() bool <span class="cov8" title="1">{
        return ini != nil &amp;&amp; ini.init.InProgress()
}</span>

func (ini *Init) shouldInitialize() bool <span class="cov8" title="1">{
        return !(ini == nil || ini.init.Done() || ini.init.InProgress())
}</span>

// Reset resets the current and all its dependencies.
func (ini *Init) Reset() <span class="cov0" title="0">{
        mu := ini.init.ResetWithLock()
        defer mu.Unlock()
        for _, d := range ini.children </span><span class="cov0" title="0">{
                d.Reset()
        }</span>
}

func (ini *Init) add(branch bool, initFn func() (interface{}, error)) *Init <span class="cov8" title="1">{
        ini.mu.Lock()
        defer ini.mu.Unlock()

        if branch </span><span class="cov8" title="1">{
                return &amp;Init{
                        f:    initFn,
                        prev: ini,
                }
        }</span>

        <span class="cov8" title="1">ini.checkDone()
        ini.children = append(ini.children, &amp;Init{
                f: initFn,
        })

        return ini</span>
}

func (ini *Init) checkDone() <span class="cov8" title="1">{
        if ini.init.Done() </span><span class="cov0" title="0">{
                panic("init cannot be added to after it has run")</span>
        }
}

func (ini *Init) withTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        c := make(chan verr, 1)

        go func() </span><span class="cov0" title="0">{
                v, err := f(ctx)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        c &lt;- verr{v: v, err: err}</span>
                }
        }()

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, errors.New("timed out initializing value. This is most likely a circular loop in a shortcode")</span>
        case ve := &lt;-c:<span class="cov0" title="0">
                return ve.v, ve.err</span>
        }

}

type verr struct {
        v   interface{}
        err error
}
</pre>
		
		<pre class="file" id="file138" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lazy

import (
        "sync"
        "sync/atomic"
)

// onceMore is similar to sync.Once.
//
// Additional features are:
// * it can be reset, so the action can be repeated if needed
// * it has methods to check if it's done or in progress
//
type onceMore struct {
        mu   sync.Mutex
        lock uint32
        done uint32
}

func (t *onceMore) Do(f func()) <span class="cov8" title="1">{
        if atomic.LoadUint32(&amp;t.done) == 1 </span><span class="cov8" title="1">{
                return
        }</span>

        // f may call this Do and we would get a deadlock.
        <span class="cov8" title="1">locked := atomic.CompareAndSwapUint32(&amp;t.lock, 0, 1)
        if !locked </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">defer atomic.StoreUint32(&amp;t.lock, 0)

        t.mu.Lock()
        defer t.mu.Unlock()

        // Double check
        if t.done == 1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">defer atomic.StoreUint32(&amp;t.done, 1)
        f()</span>

}

func (t *onceMore) InProgress() bool <span class="cov8" title="1">{
        return atomic.LoadUint32(&amp;t.lock) == 1
}</span>

func (t *onceMore) Done() bool <span class="cov8" title="1">{
        return atomic.LoadUint32(&amp;t.done) == 1
}</span>

func (t *onceMore) ResetWithLock() *sync.Mutex <span class="cov0" title="0">{
        t.mu.Lock()
        defer atomic.StoreUint32(&amp;t.done, 0)
        return &amp;t.mu
}</span>
</pre>
		
		<pre class="file" id="file139" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package livereload

import (
        "bytes"
        "sync"

        "github.com/gorilla/websocket"
)

type connection struct {
        // The websocket connection.
        ws *websocket.Conn

        // Buffered channel of outbound messages.
        send chan []byte

        // There is a potential data race, especially visible with large files.
        // This is protected by synchronisation of the send channel's close.
        closer sync.Once
}

func (c *connection) close() <span class="cov0" title="0">{
        c.closer.Do(func() </span><span class="cov0" title="0">{
                close(c.send)
        }</span>)
}

func (c *connection) reader() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                _, message, err := c.ws.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if bytes.Contains(message, []byte(`"command":"hello"`)) </span><span class="cov0" title="0">{
                        c.send &lt;- []byte(`{
                                "command": "hello",
                                "protocols": [ "http://livereload.com/protocols/official-7" ],
                                "serverName": "Hugo"
                        }`)
                }</span>
        }
        <span class="cov0" title="0">c.ws.Close()</span>
}

func (c *connection) writer() <span class="cov0" title="0">{
        for message := range c.send </span><span class="cov0" title="0">{
                err := c.ws.WriteMessage(websocket.TextMessage, message)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">c.ws.Close()</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package livereload

type hub struct {
        // Registered connections.
        connections map[*connection]bool

        // Inbound messages from the connections.
        broadcast chan []byte

        // Register requests from the connections.
        register chan *connection

        // Unregister requests from connections.
        unregister chan *connection
}

var wsHub = hub{
        broadcast:   make(chan []byte),
        register:    make(chan *connection),
        unregister:  make(chan *connection),
        connections: make(map[*connection]bool),
}

func (h *hub) run() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case c := &lt;-h.register:<span class="cov0" title="0">
                        h.connections[c] = true</span>
                case c := &lt;-h.unregister:<span class="cov0" title="0">
                        delete(h.connections, c)
                        c.close()</span>
                case m := &lt;-h.broadcast:<span class="cov0" title="0">
                        for c := range h.connections </span><span class="cov0" title="0">{
                                select </span>{
                                case c.send &lt;- m:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0">
                                        delete(h.connections, c)
                                        c.close()</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file141" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Contains an embedded version of livereload.js
//
// Copyright (c) 2010-2015 Andrey Tarantsov
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

package livereload

import (
        "fmt"
        "net"
        "net/http"
        "net/url"
        "path/filepath"

        "github.com/gorilla/websocket"
)

// Prefix to signal to LiveReload that we need to navigate to another path.
const hugoNavigatePrefix = "__hugo_navigate"

var upgrader = &amp;websocket.Upgrader{
        // Hugo may potentially spin up multiple HTTP servers, so we need to exclude the
        // port when checking the origin.
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                origin := r.Header["Origin"]
                if len(origin) == 0 </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">u, err := url.Parse(origin[0])
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">if u.Host == r.Host </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">h1, _, err := net.SplitHostPort(u.Host)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">h2, _, err := net.SplitHostPort(r.Host)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">return h1 == h2</span>
        },
        ReadBufferSize: 1024, WriteBufferSize: 1024}

// Handler is a HandlerFunc handling the livereload
// Websocket interaction.
func Handler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ws, err := upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">c := &amp;connection{send: make(chan []byte, 256), ws: ws}
        wsHub.register &lt;- c
        defer func() </span><span class="cov0" title="0">{ wsHub.unregister &lt;- c }</span>()
        <span class="cov0" title="0">go c.writer()
        c.reader()</span>
}

// Initialize starts the Websocket Hub handling live reloads.
func Initialize() <span class="cov0" title="0">{
        go wsHub.run()
}</span>

// ForceRefresh tells livereload to force a hard refresh.
func ForceRefresh() <span class="cov0" title="0">{
        RefreshPath("/x.js")
}</span>

// NavigateToPath tells livereload to navigate to the given path.
// This translates to `window.location.href = path` in the client.
func NavigateToPath(path string) <span class="cov0" title="0">{
        RefreshPath(hugoNavigatePrefix + path)
}</span>

// NavigateToPathForPort is similar to NavigateToPath but will also
// set window.location.port to the given port value.
func NavigateToPathForPort(path string, port int) <span class="cov0" title="0">{
        refreshPathForPort(hugoNavigatePrefix+path, port)
}</span>

// RefreshPath tells livereload to refresh only the given path.
// If that path points to a CSS stylesheet or an image, only the changes
// will be updated in the browser, not the entire page.
func RefreshPath(s string) <span class="cov0" title="0">{
        refreshPathForPort(s, -1)
}</span>

func refreshPathForPort(s string, port int) <span class="cov0" title="0">{
        // Tell livereload a file has changed - will force a hard refresh if not CSS or an image
        urlPath := filepath.ToSlash(s)
        portStr := ""
        if port &gt; 0 </span><span class="cov0" title="0">{
                portStr = fmt.Sprintf(`, "overrideURL": %d`, port)
        }</span>
        <span class="cov0" title="0">msg := fmt.Sprintf(`{"command":"reload","path":%q,"originalPath":"","liveCSS":true,"liveImg":true%s}`, urlPath, portStr)
        wsHub.broadcast &lt;- []byte(msg)</span>
}

// ServeJS serves the liverreload.js who's reference is injected into the page.
func ServeJS(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/javascript")
        w.Write(liveReloadJS())
}</span>

func liveReloadJS() []byte <span class="cov0" title="0">{
        return []byte(livereloadJS + hugoLiveReloadPlugin)
}</span>

var (
        // This is a patched version, see https://github.com/livereload/livereload-js/pull/84
        livereloadJS         = `!function(){return function e(t,o,n){function r(s,c){if(!o[s]){if(!t[s]){var a="function"==typeof require&amp;&amp;require;if(!c&amp;&amp;a)return a(s,!0);if(i)return i(s,!0);var l=new Error("Cannot find module '"+s+"'");throw l.code="MODULE_NOT_FOUND",l}var h=o[s]={exports:{}};t[s][0].call(h.exports,function(e){return r(t[s][1][e]||e)},h,h.exports,e,t,o,n)}return o[s].exports}for(var i="function"==typeof require&amp;&amp;require,s=0;s&lt;n.length;s++)r(n[s]);return r}}()({1:[function(e,t,o){t.exports=function(e){if("function"!=typeof e)throw TypeError(e+" is not a function!");return e}},{}],2:[function(e,t,o){var n=e("./_wks")("unscopables"),r=Array.prototype;null==r[n]&amp;&amp;e("./_hide")(r,n,{}),t.exports=function(e){r[n][e]=!0}},{"./_hide":17,"./_wks":45}],3:[function(e,t,o){var n=e("./_is-object");t.exports=function(e){if(!n(e))throw TypeError(e+" is not an object!");return e}},{"./_is-object":21}],4:[function(e,t,o){var n=e("./_to-iobject"),r=e("./_to-length"),i=e("./_to-absolute-index");t.exports=function(e){return function(t,o,s){var c,a=n(t),l=r(a.length),h=i(s,l);if(e&amp;&amp;o!=o){for(;l&gt;h;)if((c=a[h++])!=c)return!0}else for(;l&gt;h;h++)if((e||h in a)&amp;&amp;a[h]===o)return e||h||0;return!e&amp;&amp;-1}}},{"./_to-absolute-index":38,"./_to-iobject":40,"./_to-length":41}],5:[function(e,t,o){var n={}.toString;t.exports=function(e){return n.call(e).slice(8,-1)}},{}],6:[function(e,t,o){var n=t.exports={version:"2.6.5"};"number"==typeof __e&amp;&amp;(__e=n)},{}],7:[function(e,t,o){var n=e("./_a-function");t.exports=function(e,t,o){if(n(e),void 0===t)return e;switch(o){case 1:return function(o){return e.call(t,o)};case 2:return function(o,n){return e.call(t,o,n)};case 3:return function(o,n,r){return e.call(t,o,n,r)}}return function(){return e.apply(t,arguments)}}},{"./_a-function":1}],8:[function(e,t,o){t.exports=function(e){if(null==e)throw TypeError("Can't call method on  "+e);return e}},{}],9:[function(e,t,o){t.exports=!e("./_fails")(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},{"./_fails":13}],10:[function(e,t,o){var n=e("./_is-object"),r=e("./_global").document,i=n(r)&amp;&amp;n(r.createElement);t.exports=function(e){return i?r.createElement(e):{}}},{"./_global":15,"./_is-object":21}],11:[function(e,t,o){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},{}],12:[function(e,t,o){var n=e("./_global"),r=e("./_core"),i=e("./_hide"),s=e("./_redefine"),c=e("./_ctx"),a=function(e,t,o){var l,h,u,d,f=e&amp;a.F,p=e&amp;a.G,_=e&amp;a.S,m=e&amp;a.P,g=e&amp;a.B,y=p?n:_?n[t]||(n[t]={}):(n[t]||{}).prototype,v=p?r:r[t]||(r[t]={}),w=v.prototype||(v.prototype={});for(l in p&amp;&amp;(o=t),o)u=((h=!f&amp;&amp;y&amp;&amp;void 0!==y[l])?y:o)[l],d=g&amp;&amp;h?c(u,n):m&amp;&amp;"function"==typeof u?c(Function.call,u):u,y&amp;&amp;s(y,l,u,e&amp;a.U),v[l]!=u&amp;&amp;i(v,l,d),m&amp;&amp;w[l]!=u&amp;&amp;(w[l]=u)};n.core=r,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},{"./_core":6,"./_ctx":7,"./_global":15,"./_hide":17,"./_redefine":34}],13:[function(e,t,o){t.exports=function(e){try{return!!e()}catch(e){return!0}}},{}],14:[function(e,t,o){t.exports=e("./_shared")("native-function-to-string",Function.toString)},{"./_shared":37}],15:[function(e,t,o){var n=t.exports="undefined"!=typeof window&amp;&amp;window.Math==Math?window:"undefined"!=typeof self&amp;&amp;self.Math==Math?self:Function("return this")();"number"==typeof __g&amp;&amp;(__g=n)},{}],16:[function(e,t,o){var n={}.hasOwnProperty;t.exports=function(e,t){return n.call(e,t)}},{}],17:[function(e,t,o){var n=e("./_object-dp"),r=e("./_property-desc");t.exports=e("./_descriptors")?function(e,t,o){return n.f(e,t,r(1,o))}:function(e,t,o){return e[t]=o,e}},{"./_descriptors":9,"./_object-dp":28,"./_property-desc":33}],18:[function(e,t,o){var n=e("./_global").document;t.exports=n&amp;&amp;n.documentElement},{"./_global":15}],19:[function(e,t,o){t.exports=!e("./_descriptors")&amp;&amp;!e("./_fails")(function(){return 7!=Object.defineProperty(e("./_dom-create")("div"),"a",{get:function(){return 7}}).a})},{"./_descriptors":9,"./_dom-create":10,"./_fails":13}],20:[function(e,t,o){var n=e("./_cof");t.exports=Object("z").propertyIsEnumerable(0)?Object:function(e){return"String"==n(e)?e.split(""):Object(e)}},{"./_cof":5}],21:[function(e,t,o){t.exports=function(e){return"object"==typeof e?null!==e:"function"==typeof e}},{}],22:[function(e,t,o){"use strict";var n=e("./_object-create"),r=e("./_property-desc"),i=e("./_set-to-string-tag"),s={};e("./_hide")(s,e("./_wks")("iterator"),function(){return this}),t.exports=function(e,t,o){e.prototype=n(s,{next:r(1,o)}),i(e,t+" Iterator")}},{"./_hide":17,"./_object-create":27,"./_property-desc":33,"./_set-to-string-tag":35,"./_wks":45}],23:[function(e,t,o){"use strict";var n=e("./_library"),r=e("./_export"),i=e("./_redefine"),s=e("./_hide"),c=e("./_iterators"),a=e("./_iter-create"),l=e("./_set-to-string-tag"),h=e("./_object-gpo"),u=e("./_wks")("iterator"),d=!([].keys&amp;&amp;"next"in[].keys()),f=function(){return this};t.exports=function(e,t,o,p,_,m,g){a(o,t,p);var y,v,w,b=function(e){if(!d&amp;&amp;e in L)return L[e];switch(e){case"keys":case"values":return function(){return new o(this,e)}}return function(){return new o(this,e)}},S=t+" Iterator",R="values"==_,k=!1,L=e.prototype,x=L[u]||L["@@iterator"]||_&amp;&amp;L[_],j=x||b(_),C=_?R?b("entries"):j:void 0,O="Array"==t&amp;&amp;L.entries||x;if(O&amp;&amp;(w=h(O.call(new e)))!==Object.prototype&amp;&amp;w.next&amp;&amp;(l(w,S,!0),n||"function"==typeof w[u]||s(w,u,f)),R&amp;&amp;x&amp;&amp;"values"!==x.name&amp;&amp;(k=!0,j=function(){return x.call(this)}),n&amp;&amp;!g||!d&amp;&amp;!k&amp;&amp;L[u]||s(L,u,j),c[t]=j,c[S]=f,_)if(y={values:R?j:b("values"),keys:m?j:b("keys"),entries:C},g)for(v in y)v in L||i(L,v,y[v]);else r(r.P+r.F*(d||k),t,y);return y}},{"./_export":12,"./_hide":17,"./_iter-create":22,"./_iterators":25,"./_library":26,"./_object-gpo":30,"./_redefine":34,"./_set-to-string-tag":35,"./_wks":45}],24:[function(e,t,o){t.exports=function(e,t){return{value:t,done:!!e}}},{}],25:[function(e,t,o){t.exports={}},{}],26:[function(e,t,o){t.exports=!1},{}],27:[function(e,t,o){var n=e("./_an-object"),r=e("./_object-dps"),i=e("./_enum-bug-keys"),s=e("./_shared-key")("IE_PROTO"),c=function(){},a=function(){var t,o=e("./_dom-create")("iframe"),n=i.length;for(o.style.display="none",e("./_html").appendChild(o),o.src="javascript:",(t=o.contentWindow.document).open(),t.write("&lt;script&gt;document.F=Object&lt;\/script&gt;"),t.close(),a=t.F;n--;)delete a.prototype[i[n]];return a()};t.exports=Object.create||function(e,t){var o;return null!==e?(c.prototype=n(e),o=new c,c.prototype=null,o[s]=e):o=a(),void 0===t?o:r(o,t)}},{"./_an-object":3,"./_dom-create":10,"./_enum-bug-keys":11,"./_html":18,"./_object-dps":29,"./_shared-key":36}],28:[function(e,t,o){var n=e("./_an-object"),r=e("./_ie8-dom-define"),i=e("./_to-primitive"),s=Object.defineProperty;o.f=e("./_descriptors")?Object.defineProperty:function(e,t,o){if(n(e),t=i(t,!0),n(o),r)try{return s(e,t,o)}catch(e){}if("get"in o||"set"in o)throw TypeError("Accessors not supported!");return"value"in o&amp;&amp;(e[t]=o.value),e}},{"./_an-object":3,"./_descriptors":9,"./_ie8-dom-define":19,"./_to-primitive":43}],29:[function(e,t,o){var n=e("./_object-dp"),r=e("./_an-object"),i=e("./_object-keys");t.exports=e("./_descriptors")?Object.defineProperties:function(e,t){r(e);for(var o,s=i(t),c=s.length,a=0;c&gt;a;)n.f(e,o=s[a++],t[o]);return e}},{"./_an-object":3,"./_descriptors":9,"./_object-dp":28,"./_object-keys":32}],30:[function(e,t,o){var n=e("./_has"),r=e("./_to-object"),i=e("./_shared-key")("IE_PROTO"),s=Object.prototype;t.exports=Object.getPrototypeOf||function(e){return e=r(e),n(e,i)?e[i]:"function"==typeof e.constructor&amp;&amp;e instanceof e.constructor?e.constructor.prototype:e instanceof Object?s:null}},{"./_has":16,"./_shared-key":36,"./_to-object":42}],31:[function(e,t,o){var n=e("./_has"),r=e("./_to-iobject"),i=e("./_array-includes")(!1),s=e("./_shared-key")("IE_PROTO");t.exports=function(e,t){var o,c=r(e),a=0,l=[];for(o in c)o!=s&amp;&amp;n(c,o)&amp;&amp;l.push(o);for(;t.length&gt;a;)n(c,o=t[a++])&amp;&amp;(~i(l,o)||l.push(o));return l}},{"./_array-includes":4,"./_has":16,"./_shared-key":36,"./_to-iobject":40}],32:[function(e,t,o){var n=e("./_object-keys-internal"),r=e("./_enum-bug-keys");t.exports=Object.keys||function(e){return n(e,r)}},{"./_enum-bug-keys":11,"./_object-keys-internal":31}],33:[function(e,t,o){t.exports=function(e,t){return{enumerable:!(1&amp;e),configurable:!(2&amp;e),writable:!(4&amp;e),value:t}}},{}],34:[function(e,t,o){var n=e("./_global"),r=e("./_hide"),i=e("./_has"),s=e("./_uid")("src"),c=e("./_function-to-string"),a=(""+c).split("toString");e("./_core").inspectSource=function(e){return c.call(e)},(t.exports=function(e,t,o,c){var l="function"==typeof o;l&amp;&amp;(i(o,"name")||r(o,"name",t)),e[t]!==o&amp;&amp;(l&amp;&amp;(i(o,s)||r(o,s,e[t]?""+e[t]:a.join(String(t)))),e===n?e[t]=o:c?e[t]?e[t]=o:r(e,t,o):(delete e[t],r(e,t,o)))})(Function.prototype,"toString",function(){return"function"==typeof this&amp;&amp;this[s]||c.call(this)})},{"./_core":6,"./_function-to-string":14,"./_global":15,"./_has":16,"./_hide":17,"./_uid":44}],35:[function(e,t,o){var n=e("./_object-dp").f,r=e("./_has"),i=e("./_wks")("toStringTag");t.exports=function(e,t,o){e&amp;&amp;!r(e=o?e:e.prototype,i)&amp;&amp;n(e,i,{configurable:!0,value:t})}},{"./_has":16,"./_object-dp":28,"./_wks":45}],36:[function(e,t,o){var n=e("./_shared")("keys"),r=e("./_uid");t.exports=function(e){return n[e]||(n[e]=r(e))}},{"./_shared":37,"./_uid":44}],37:[function(e,t,o){var n=e("./_core"),r=e("./_global"),i=r["__core-js_shared__"]||(r["__core-js_shared__"]={});(t.exports=function(e,t){return i[e]||(i[e]=void 0!==t?t:{})})("versions",[]).push({version:n.version,mode:e("./_library")?"pure":"global",copyright:" 2019 Denis Pushkarev (zloirock.ru)"})},{"./_core":6,"./_global":15,"./_library":26}],38:[function(e,t,o){var n=e("./_to-integer"),r=Math.max,i=Math.min;t.exports=function(e,t){return(e=n(e))&lt;0?r(e+t,0):i(e,t)}},{"./_to-integer":39}],39:[function(e,t,o){var n=Math.ceil,r=Math.floor;t.exports=function(e){return isNaN(e=+e)?0:(e&gt;0?r:n)(e)}},{}],40:[function(e,t,o){var n=e("./_iobject"),r=e("./_defined");t.exports=function(e){return n(r(e))}},{"./_defined":8,"./_iobject":20}],41:[function(e,t,o){var n=e("./_to-integer"),r=Math.min;t.exports=function(e){return e&gt;0?r(n(e),9007199254740991):0}},{"./_to-integer":39}],42:[function(e,t,o){var n=e("./_defined");t.exports=function(e){return Object(n(e))}},{"./_defined":8}],43:[function(e,t,o){var n=e("./_is-object");t.exports=function(e,t){if(!n(e))return e;var o,r;if(t&amp;&amp;"function"==typeof(o=e.toString)&amp;&amp;!n(r=o.call(e)))return r;if("function"==typeof(o=e.valueOf)&amp;&amp;!n(r=o.call(e)))return r;if(!t&amp;&amp;"function"==typeof(o=e.toString)&amp;&amp;!n(r=o.call(e)))return r;throw TypeError("Can't convert object to primitive value")}},{"./_is-object":21}],44:[function(e,t,o){var n=0,r=Math.random();t.exports=function(e){return"Symbol(".concat(void 0===e?"":e,")_",(++n+r).toString(36))}},{}],45:[function(e,t,o){var n=e("./_shared")("wks"),r=e("./_uid"),i=e("./_global").Symbol,s="function"==typeof i;(t.exports=function(e){return n[e]||(n[e]=s&amp;&amp;i[e]||(s?i:r)("Symbol."+e))}).store=n},{"./_global":15,"./_shared":37,"./_uid":44}],46:[function(e,t,o){"use strict";var n=e("./_add-to-unscopables"),r=e("./_iter-step"),i=e("./_iterators"),s=e("./_to-iobject");t.exports=e("./_iter-define")(Array,"Array",function(e,t){this._t=s(e),this._i=0,this._k=t},function(){var e=this._t,t=this._k,o=this._i++;return!e||o&gt;=e.length?(this._t=void 0,r(1)):r(0,"keys"==t?o:"values"==t?e[o]:[o,e[o]])},"values"),i.Arguments=i.Array,n("keys"),n("values"),n("entries")},{"./_add-to-unscopables":2,"./_iter-define":23,"./_iter-step":24,"./_iterators":25,"./_to-iobject":40}],47:[function(e,t,o){for(var n=e("./es6.array.iterator"),r=e("./_object-keys"),i=e("./_redefine"),s=e("./_global"),c=e("./_hide"),a=e("./_iterators"),l=e("./_wks"),h=l("iterator"),u=l("toStringTag"),d=a.Array,f={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},p=r(f),_=0;_&lt;p.length;_++){var m,g=p[_],y=f[g],v=s[g],w=v&amp;&amp;v.prototype;if(w&amp;&amp;(w[h]||c(w,h,d),w[u]||c(w,u,g),a[g]=d,y))for(m in n)w[m]||i(w,m,n[m],!0)}},{"./_global":15,"./_hide":17,"./_iterators":25,"./_object-keys":32,"./_redefine":34,"./_wks":45,"./es6.array.iterator":46}],48:[function(e,t,o){"use strict";const{Parser:n,PROTOCOL_6:r,PROTOCOL_7:i}=e("./protocol"),s="3.0.0";o.Connector=class{constructor(e,t,o,r){this.options=e,this.WebSocket=t,this.Timer=o,this.handlers=r;const i=this.options.path?"".concat(this.options.path):"livereload";this._uri="ws".concat(this.options.https?"s":"","://").concat(this.options.host,":").concat(this.options.port,"/").concat(i),this._nextDelay=this.options.mindelay,this._connectionDesired=!1,this.protocol=0,this.protocolParser=new n({connected:e=&gt;(this.protocol=e,this._handshakeTimeout.stop(),this._nextDelay=this.options.mindelay,this._disconnectionReason="broken",this.handlers.connected(this.protocol)),error:e=&gt;(this.handlers.error(e),this._closeOnError()),message:e=&gt;this.handlers.message(e)}),this._handshakeTimeout=new this.Timer(()=&gt;{if(this._isSocketConnected())return this._disconnectionReason="handshake-timeout",this.socket.close()}),this._reconnectTimer=new this.Timer(()=&gt;{if(this._connectionDesired)return this.connect()}),this.connect()}_isSocketConnected(){return this.socket&amp;&amp;this.socket.readyState===this.WebSocket.OPEN}connect(){this._connectionDesired=!0,this._isSocketConnected()||(this._reconnectTimer.stop(),this._disconnectionReason="cannot-connect",this.protocolParser.reset(),this.handlers.connecting(),this.socket=new this.WebSocket(this._uri),this.socket.onopen=(e=&gt;this._onopen(e)),this.socket.onclose=(e=&gt;this._onclose(e)),this.socket.onmessage=(e=&gt;this._onmessage(e)),this.socket.onerror=(e=&gt;this._onerror(e)))}disconnect(){if(this._connectionDesired=!1,this._reconnectTimer.stop(),this._isSocketConnected())return this._disconnectionReason="manual",this.socket.close()}_scheduleReconnection(){this._connectionDesired&amp;&amp;(this._reconnectTimer.running||(this._reconnectTimer.start(this._nextDelay),this._nextDelay=Math.min(this.options.maxdelay,2*this._nextDelay)))}sendCommand(e){if(this.protocol)return this._sendCommand(e)}_sendCommand(e){return this.socket.send(JSON.stringify(e))}_closeOnError(){return this._handshakeTimeout.stop(),this._disconnectionReason="error",this.socket.close()}_onopen(e){this.handlers.socketConnected(),this._disconnectionReason="handshake-failed";const t={command:"hello",protocols:[r,i]};return t.ver=s,this.options.ext&amp;&amp;(t.ext=this.options.ext),this.options.extver&amp;&amp;(t.extver=this.options.extver),this.options.snipver&amp;&amp;(t.snipver=this.options.snipver),this._sendCommand(t),this._handshakeTimeout.start(this.options.handshake_timeout)}_onclose(e){return this.protocol=0,this.handlers.disconnected(this._disconnectionReason,this._nextDelay),this._scheduleReconnection()}_onerror(e){}_onmessage(e){return this.protocolParser.process(e.data)}}},{"./protocol":53}],49:[function(e,t,o){"use strict";const n={bind(e,t,o){if(e.addEventListener)return e.addEventListener(t,o,!1);if(e.attachEvent)return e[t]=1,e.attachEvent("onpropertychange",function(e){if(e.propertyName===t)return o()});throw new Error("Attempt to attach custom event ".concat(t," to something which isn't a DOMElement"))},fire(e,t){if(e.addEventListener){const e=document.createEvent("HTMLEvents");return e.initEvent(t,!0,!0),document.dispatchEvent(e)}if(!e.attachEvent)throw new Error("Attempt to fire custom event ".concat(t," on something which isn't a DOMElement"));if(e[t])return e[t]++}};o.bind=n.bind,o.fire=n.fire},{}],50:[function(e,t,o){"use strict";class n{constructor(e,t){this.window=e,this.host=t}reload(e,t){if(this.window.less&amp;&amp;this.window.less.refresh){if(e.match(/\.less$/i))return this.reloadLess(e);if(t.originalPath.match(/\.less$/i))return this.reloadLess(t.originalPath)}return!1}reloadLess(e){let t;const o=(()=&gt;{const e=[];for(t of Array.from(document.getElementsByTagName("link")))(t.href&amp;&amp;t.rel.match(/^stylesheet\/less$/i)||t.rel.match(/stylesheet/i)&amp;&amp;t.type.match(/^text\/(x-)?less$/i))&amp;&amp;e.push(t);return e})();if(0===o.length)return!1;for(t of Array.from(o))t.href=this.host.generateCacheBustUrl(t.href);return this.host.console.log("LiveReload is asking LESS to recompile all stylesheets"),this.window.less.refresh(!0),!0}analyze(){return{disable:!(!this.window.less||!this.window.less.refresh)}}}n.identifier="less",n.version="1.0",t.exports=n},{}],51:[function(e,t,o){"use strict";e("core-js/modules/web.dom.iterable");const{Connector:n}=e("./connector"),{Timer:r}=e("./timer"),{Options:i}=e("./options"),{Reloader:s}=e("./reloader"),{ProtocolError:c}=e("./protocol");o.LiveReload=class{constructor(e){if(this.window=e,this.listeners={},this.plugins=[],this.pluginIdentifiers={},this.console=this.window.console&amp;&amp;this.window.console.log&amp;&amp;this.window.console.error?this.window.location.href.match(/LR-verbose/)?this.window.console:{log(){},error:this.window.console.error.bind(this.window.console)}:{log(){},error(){}},this.WebSocket=this.window.WebSocket||this.window.MozWebSocket){if("LiveReloadOptions"in e){this.options=new i;for(let t of Object.keys(e.LiveReloadOptions||{})){const o=e.LiveReloadOptions[t];this.options.set(t,o)}}else if(this.options=i.extract(this.window.document),!this.options)return void this.console.error("LiveReload disabled because it could not find its own &lt;SCRIPT&gt; tag");this.reloader=new s(this.window,this.console,r),this.connector=new n(this.options,this.WebSocket,r,{connecting:()=&gt;{},socketConnected:()=&gt;{},connected:e=&gt;("function"==typeof this.listeners.connect&amp;&amp;this.listeners.connect(),this.log("LiveReload is connected to ".concat(this.options.host,":").concat(this.options.port," (protocol v").concat(e,").")),this.analyze()),error:e=&gt;{if(e instanceof c){if("undefined"!=typeof console&amp;&amp;null!==console)return console.log("".concat(e.message,"."))}else if("undefined"!=typeof console&amp;&amp;null!==console)return console.log("LiveReload internal error: ".concat(e.message))},disconnected:(e,t)=&gt;{switch("function"==typeof this.listeners.disconnect&amp;&amp;this.listeners.disconnect(),e){case"cannot-connect":return this.log("LiveReload cannot connect to ".concat(this.options.host,":").concat(this.options.port,", will retry in ").concat(t," sec."));case"broken":return this.log("LiveReload disconnected from ".concat(this.options.host,":").concat(this.options.port,", reconnecting in ").concat(t," sec."));case"handshake-timeout":return this.log("LiveReload cannot connect to ".concat(this.options.host,":").concat(this.options.port," (handshake timeout), will retry in ").concat(t," sec."));case"handshake-failed":return this.log("LiveReload cannot connect to ".concat(this.options.host,":").concat(this.options.port," (handshake failed), will retry in ").concat(t," sec."));case"manual":case"error":default:return this.log("LiveReload disconnected from ".concat(this.options.host,":").concat(this.options.port," (").concat(e,"), reconnecting in ").concat(t," sec."))}},message:e=&gt;{switch(e.command){case"reload":return this.performReload(e);case"alert":return this.performAlert(e)}}}),this.initialized=!0}else this.console.error("LiveReload disabled because the browser does not seem to support web sockets")}on(e,t){this.listeners[e]=t}log(e){return this.console.log("".concat(e))}performReload(e){return this.log("LiveReload received reload request: ".concat(JSON.stringify(e,null,2))),this.reloader.reload(e.path,{liveCSS:null==e.liveCSS||e.liveCSS,liveImg:null==e.liveImg||e.liveImg,reloadMissingCSS:null==e.reloadMissingCSS||e.reloadMissingCSS,originalPath:e.originalPath||"",overrideURL:e.overrideURL||"",serverURL:"http://".concat(this.options.host,":").concat(this.options.port)})}performAlert(e){return alert(e.message)}shutDown(){if(this.initialized)return this.connector.disconnect(),this.log("LiveReload disconnected."),"function"==typeof this.listeners.shutdown?this.listeners.shutdown():void 0}hasPlugin(e){return!!this.pluginIdentifiers[e]}addPlugin(e){if(!this.initialized)return;if(this.hasPlugin(e.identifier))return;this.pluginIdentifiers[e.identifier]=!0;const t=new e(this.window,{_livereload:this,_reloader:this.reloader,_connector:this.connector,console:this.console,Timer:r,generateCacheBustUrl:e=&gt;this.reloader.generateCacheBustUrl(e)});this.plugins.push(t),this.reloader.addPlugin(t)}analyze(){if(!this.initialized)return;if(!(this.connector.protocol&gt;=7))return;const e={};for(let o of this.plugins){var t=("function"==typeof o.analyze?o.analyze():void 0)||{};e[o.constructor.identifier]=t,t.version=o.constructor.version}this.connector.sendCommand({command:"info",plugins:e,url:this.window.location.href})}}},{"./connector":48,"./options":52,"./protocol":53,"./reloader":54,"./timer":56,"core-js/modules/web.dom.iterable":47}],52:[function(e,t,o){"use strict";class n{constructor(){this.https=!1,this.host=null,this.port=35729,this.snipver=null,this.ext=null,this.extver=null,this.mindelay=1e3,this.maxdelay=6e4,this.handshake_timeout=5e3}set(e,t){void 0!==t&amp;&amp;(isNaN(+t)||(t=+t),this[e]=t)}}n.extract=function(e){for(let s of Array.from(e.getElementsByTagName("script"))){var t,o;if((o=s.src)&amp;&amp;(t=o.match(new RegExp("^[^:]+://(.*)/z?livereload\\.js(?:\\?(.*))?$")))){var r;const e=new n;if(e.https=0===o.indexOf("https"),(r=t[1].match(new RegExp("^([^/:]+)(?::(\\d+))?(\\/+.*)?$")))&amp;&amp;(e.host=r[1],r[2]&amp;&amp;(e.port=parseInt(r[2],10))),t[2])for(let o of t[2].split("&amp;")){var i;(i=o.split("=")).length&gt;1&amp;&amp;e.set(i[0].replace(/-/g,"_"),i.slice(1).join("="))}return e}}return null},o.Options=n},{}],53:[function(e,t,o){"use strict";let n,r;o.PROTOCOL_6=n="http://livereload.com/protocols/official-6",o.PROTOCOL_7=r="http://livereload.com/protocols/official-7";class i{constructor(e,t){this.message="LiveReload protocol error (".concat(e,') after receiving data: "').concat(t,'".')}}o.ProtocolError=i,o.Parser=class{constructor(e){this.handlers=e,this.reset()}reset(){this.protocol=null}process(e){try{let t;if(this.protocol){if(6===this.protocol){if(!(t=JSON.parse(e)).length)throw new i("protocol 6 messages must be arrays");const[o,n]=Array.from(t);if("refresh"!==o)throw new i("unknown protocol 6 command");return this.handlers.message({command:"reload",path:n.path,liveCSS:null==n.apply_css_live||n.apply_css_live})}return t=this._parseMessage(e,["reload","alert"]),this.handlers.message(t)}if(e.match(new RegExp("^!!ver:([\\d.]+)$")))this.protocol=6;else if(t=this._parseMessage(e,["hello"])){if(!t.protocols.length)throw new i("no protocols specified in handshake message");if(Array.from(t.protocols).includes(r))this.protocol=7;else{if(!Array.from(t.protocols).includes(n))throw new i("no supported protocols found");this.protocol=6}}return this.handlers.connected(this.protocol)}catch(e){if(e instanceof i)return this.handlers.error(e);throw e}}_parseMessage(e,t){let o;try{o=JSON.parse(e)}catch(t){throw new i("unparsable JSON",e)}if(!o.command)throw new i('missing "command" key',e);if(!t.includes(o.command))throw new i("invalid command '".concat(o.command,"', only valid commands are: ").concat(t.join(", "),")"),e);return o}}},{}],54:[function(e,t,o){"use strict";const n=function(e){let t,o,n;(o=e.indexOf("#"))&gt;=0?(t=e.slice(o),e=e.slice(0,o)):t="";const r=e.indexOf("??");return r&gt;=0?r+1!==e.lastIndexOf("?")&amp;&amp;(o=e.lastIndexOf("?")):o=e.indexOf("?"),o&gt;=0?(n=e.slice(o),e=e.slice(0,o)):n="",{url:e,params:n,hash:t}},r=function(e){if(!e)return"";let t;return({url:e}=n(e)),t=0===e.indexOf("file://")?e.replace(new RegExp("^file://(localhost)?"),""):e.replace(new RegExp("^([^:]+:)?//([^:/]+)(:\\d*)?/"),"/"),decodeURIComponent(t)},i=function(e,t,o){let n,r={score:0};for(let i of t)(n=s(e,o(i)))&gt;r.score&amp;&amp;(r={object:i,score:n});return 0===r.score?null:r};var s=function(e,t){if((e=e.replace(/^\/+/,"").toLowerCase())===(t=t.replace(/^\/+/,"").toLowerCase()))return 1e4;const o=e.split("/").reverse(),n=t.split("/").reverse(),r=Math.min(o.length,n.length);let i=0;for(;i&lt;r&amp;&amp;o[i]===n[i];)++i;return i};const c=(e,t)=&gt;s(e,t)&gt;0,a=[{selector:"background",styleNames:["backgroundImage"]},{selector:"border",styleNames:["borderImage","webkitBorderImage","MozBorderImage"]}];o.Reloader=class{constructor(e,t,o){this.window=e,this.console=t,this.Timer=o,this.document=this.window.document,this.importCacheWaitPeriod=200,this.plugins=[]}addPlugin(e){return this.plugins.push(e)}analyze(e){}reload(e,t){this.options=t,this.options.stylesheetReloadTimeout||(this.options.stylesheetReloadTimeout=15e3);for(let o of Array.from(this.plugins))if(o.reload&amp;&amp;o.reload(e,t))return;if(!(t.liveCSS&amp;&amp;e.match(/\.css(?:\.map)?$/i)&amp;&amp;this.reloadStylesheet(e)))if(t.liveImg&amp;&amp;e.match(/\.(jpe?g|png|gif)$/i))this.reloadImages(e);else{if(!t.isChromeExtension)return this.reloadPage();this.reloadChromeExtension()}}reloadPage(){return this.window.document.location.reload()}reloadChromeExtension(){return this.window.chrome.runtime.reload()}reloadImages(e){let t;const o=this.generateUniqueString();for(t of Array.from(this.document.images))c(e,r(t.src))&amp;&amp;(t.src=this.generateCacheBustUrl(t.src,o));if(this.document.querySelectorAll)for(let{selector:n,styleNames:r}of a)for(t of Array.from(this.document.querySelectorAll("[style*=".concat(n,"]"))))this.reloadStyleImages(t.style,r,e,o);if(this.document.styleSheets)return Array.from(this.document.styleSheets).map(t=&gt;this.reloadStylesheetImages(t,e,o))}reloadStylesheetImages(e,t,o){let n;try{n=(e||{}).cssRules}catch(e){}if(n)for(let e of Array.from(n))switch(e.type){case CSSRule.IMPORT_RULE:this.reloadStylesheetImages(e.styleSheet,t,o);break;case CSSRule.STYLE_RULE:for(let{styleNames:n}of a)this.reloadStyleImages(e.style,n,t,o);break;case CSSRule.MEDIA_RULE:this.reloadStylesheetImages(e,t,o)}}reloadStyleImages(e,t,o,n){for(let i of t){const t=e[i];if("string"==typeof t){const s=t.replace(new RegExp("\\burl\\s*\\(([^)]*)\\)"),(e,t)=&gt;c(o,r(t))?"url(".concat(this.generateCacheBustUrl(t,n),")"):e);s!==t&amp;&amp;(e[i]=s)}}}reloadStylesheet(e){let t,o;const n=(()=&gt;{const e=[];for(o of Array.from(this.document.getElementsByTagName("link")))o.rel.match(/^stylesheet$/i)&amp;&amp;!o.__LiveReload_pendingRemoval&amp;&amp;e.push(o);return e})(),s=[];for(t of Array.from(this.document.getElementsByTagName("style")))t.sheet&amp;&amp;this.collectImportedStylesheets(t,t.sheet,s);for(o of Array.from(n))this.collectImportedStylesheets(o,o.sheet,s);if(this.window.StyleFix&amp;&amp;this.document.querySelectorAll)for(t of Array.from(this.document.querySelectorAll("style[data-href]")))n.push(t);this.console.log("LiveReload found ".concat(n.length," LINKed stylesheets, ").concat(s.length," @imported stylesheets"));const c=i(e,n.concat(s),e=&gt;r(this.linkHref(e)));if(c)c.object.rule?(this.console.log("LiveReload is reloading imported stylesheet: ".concat(c.object.href)),this.reattachImportedRule(c.object)):(this.console.log("LiveReload is reloading stylesheet: ".concat(this.linkHref(c.object))),this.reattachStylesheetLink(c.object));else if(this.options.reloadMissingCSS)for(o of(this.console.log("LiveReload will reload all stylesheets because path '".concat(e,"' did not match any specific one. To disable this behavior, set 'options.reloadMissingCSS' to 'false'.")),Array.from(n)))this.reattachStylesheetLink(o);else this.console.log("LiveReload will not reload path '".concat(e,"' because the stylesheet was not found on the page and 'options.reloadMissingCSS' was set to 'false'."));return!0}collectImportedStylesheets(e,t,o){let n;try{n=(t||{}).cssRules}catch(e){}if(n&amp;&amp;n.length)for(let t=0;t&lt;n.length;t++){const r=n[t];switch(r.type){case CSSRule.CHARSET_RULE:continue;case CSSRule.IMPORT_RULE:o.push({link:e,rule:r,index:t,href:r.href}),this.collectImportedStylesheets(e,r.styleSheet,o)}}}waitUntilCssLoads(e,t){let o=!1;const n=()=&gt;{if(!o)return o=!0,t()};if(e.onload=(()=&gt;(this.console.log("LiveReload: the new stylesheet has finished loading"),this.knownToSupportCssOnLoad=!0,n())),!this.knownToSupportCssOnLoad){let t;(t=(()=&gt;e.sheet?(this.console.log("LiveReload is polling until the new CSS finishes loading..."),n()):this.Timer.start(50,t)))()}return this.Timer.start(this.options.stylesheetReloadTimeout,n)}linkHref(e){return e.href||e.getAttribute&amp;&amp;e.getAttribute("data-href")}reattachStylesheetLink(e){let t;if(e.__LiveReload_pendingRemoval)return;e.__LiveReload_pendingRemoval=!0,"STYLE"===e.tagName?((t=this.document.createElement("link")).rel="stylesheet",t.media=e.media,t.disabled=e.disabled):t=e.cloneNode(!1),t.href=this.generateCacheBustUrl(this.linkHref(e));const o=e.parentNode;return o.lastChild===e?o.appendChild(t):o.insertBefore(t,e.nextSibling),this.waitUntilCssLoads(t,()=&gt;{let o;return o=/AppleWebKit/.test(navigator.userAgent)?5:200,this.Timer.start(o,()=&gt;{if(e.parentNode)return e.parentNode.removeChild(e),t.onreadystatechange=null,this.window.StyleFix?this.window.StyleFix.link(t):void 0})})}reattachImportedRule({rule:e,index:t,link:o}){const n=e.parentStyleSheet,r=this.generateCacheBustUrl(e.href),i=e.media.length?[].join.call(e.media,", "):"",s='@import url("'.concat(r,'") ').concat(i,";");e.__LiveReload_newHref=r;const c=this.document.createElement("link");return c.rel="stylesheet",c.href=r,c.__LiveReload_pendingRemoval=!0,o.parentNode&amp;&amp;o.parentNode.insertBefore(c,o),this.Timer.start(this.importCacheWaitPeriod,()=&gt;{if(c.parentNode&amp;&amp;c.parentNode.removeChild(c),e.__LiveReload_newHref===r)return n.insertRule(s,t),n.deleteRule(t+1),(e=n.cssRules[t]).__LiveReload_newHref=r,this.Timer.start(this.importCacheWaitPeriod,()=&gt;{if(e.__LiveReload_newHref===r)return n.insertRule(s,t),n.deleteRule(t+1)})})}generateUniqueString(){return"livereload=".concat(Date.now())}generateCacheBustUrl(e,t){let o,r;if(t||(t=this.generateUniqueString()),({url:e,hash:o,params:r}=n(e)),this.options.overrideURL&amp;&amp;e.indexOf(this.options.serverURL)&lt;0){const t=e;e=this.options.serverURL+this.options.overrideURL+"?url="+encodeURIComponent(e),this.console.log("LiveReload is overriding source URL ".concat(t," with ").concat(e))}let i=r.replace(/(\?|&amp;)livereload=(\d+)/,(e,o)=&gt;"".concat(o).concat(t));return i===r&amp;&amp;(i=0===r.length?"?".concat(t):"".concat(r,"&amp;").concat(t)),e+i+o}}},{}],55:[function(e,t,o){"use strict";const n=e("./customevents"),r=window.LiveReload=new(e("./livereload").LiveReload)(window);for(let e in window)e.match(/^LiveReloadPlugin/)&amp;&amp;r.addPlugin(window[e]);r.addPlugin(e("./less")),r.on("shutdown",()=&gt;delete window.LiveReload),r.on("connect",()=&gt;n.fire(document,"LiveReloadConnect")),r.on("disconnect",()=&gt;n.fire(document,"LiveReloadDisconnect")),n.bind(document,"LiveReloadShutDown",()=&gt;r.shutDown())},{"./customevents":49,"./less":50,"./livereload":51}],56:[function(e,t,o){"use strict";class n{constructor(e){this.func=e,this.running=!1,this.id=null,this._handler=(()=&gt;(this.running=!1,this.id=null,this.func()))}start(e){this.running&amp;&amp;clearTimeout(this.id),this.id=setTimeout(this._handler,e),this.running=!0}stop(){this.running&amp;&amp;(clearTimeout(this.id),this.running=!1,this.id=null)}}n.start=((e,t)=&gt;setTimeout(t,e)),o.Timer=n},{}]},{},[55]);`
        hugoLiveReloadPlugin = fmt.Sprintf(`
/*
Hugo adds a specific prefix, "__hugo_navigate", to the path in certain situations to signal
navigation to another content page.
*/

function HugoReload() {}

HugoReload.identifier = 'hugoReloader';
HugoReload.version = '0.9';

HugoReload.prototype.reload = function(path, options) {
        var prefix = %q;

        if (path.lastIndexOf(prefix, 0) !== 0) {
                return false
        }
        
        path = path.substring(prefix.length);

        var portChanged = options.overrideURL &amp;&amp; options.overrideURL != window.location.port
        
        if (!portChanged &amp;&amp; window.location.pathname === path) {
                window.location.reload();
        } else {
                if (portChanged) {
                        window.location = location.protocol + "//" + location.hostname + ":" + options.overrideURL + path;
                } else {
                        window.location.pathname = path;
                }
        }

        return true;
};

LiveReload.addPlugin(HugoReload)
`, hugoNavigatePrefix)
)
</pre>
		
		<pre class="file" id="file142" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
        "fmt"
        "os"

        "github.com/gohugoio/hugo/commands"
)

func main() <span class="cov0" title="0">{
        fmt.Println("Jim args", os.Args[1:])
        resp := commands.Execute(os.Args[1:])

        if resp.Err != nil </span><span class="cov0" title="0">{
                if resp.IsUserError() </span><span class="cov0" title="0">{
                        resp.Cmd.Println("")
                        resp.Cmd.Println(resp.Cmd.UsageString())
                }</span>
                <span class="cov0" title="0">os.Exit(-1)</span>
        }

}
</pre>
		
		<pre class="file" id="file143" style="display: none">package media

import (
        "github.com/gohugoio/hugo/docshelper"
)

// This is is just some helpers used to create some JSON used in the Hugo docs.
func init() <span class="cov8" title="1">{
        docsProvider := func() map[string]interface{} </span><span class="cov0" title="0">{
                docs := make(map[string]interface{})

                docs["types"] = DefaultTypes
                return docs
        }</span>

        <span class="cov8" title="1">docshelper.AddDocProvider("media", docsProvider)</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package media

import (
        "encoding/json"
        "errors"
        "fmt"
        "sort"
        "strings"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/mitchellh/mapstructure"
)

const (
        defaultDelimiter = "."
)

// Type (also known as MIME type and content type) is a two-part identifier for
// file formats and format contents transmitted on the Internet.
// For Hugo's use case, we use the top-level type name / subtype name + suffix.
// One example would be application/svg+xml
// If suffix is not provided, the sub type will be used.
// See // https://en.wikipedia.org/wiki/Media_type
type Type struct {
        MainType string `json:"mainType"` // i.e. text
        SubType  string `json:"subType"`  // i.e. html

        // This is the optional suffix after the "+" in the MIME type,
        //  e.g. "xml" in "applicatiion/rss+xml".
        mimeSuffix string

        Delimiter string `json:"delimiter"` // e.g. "."

        // TODO(bep) make this a string to make it hashable + method
        Suffixes []string `json:"suffixes"`

        // Set when doing lookup by suffix.
        fileSuffix string
}

// FromStringAndExt is same as FromString, but adds the file extension to the type.
func FromStringAndExt(t, ext string) (Type, error) <span class="cov0" title="0">{
        tp, err := fromString(t)
        if err != nil </span><span class="cov0" title="0">{
                return tp, err
        }</span>
        <span class="cov0" title="0">tp.Suffixes = []string{strings.TrimPrefix(ext, ".")}
        return tp, nil</span>
}

// FromString creates a new Type given a type string on the form MainType/SubType and
// an optional suffix, e.g. "text/html" or "text/html+html".
func fromString(t string) (Type, error) <span class="cov0" title="0">{
        t = strings.ToLower(t)
        parts := strings.Split(t, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return Type{}, fmt.Errorf("cannot parse %q as a media type", t)
        }</span>
        <span class="cov0" title="0">mainType := parts[0]
        subParts := strings.Split(parts[1], "+")

        subType := strings.Split(subParts[0], ";")[0]

        var suffix string

        if len(subParts) &gt; 1 </span><span class="cov0" title="0">{
                suffix = subParts[1]
        }</span>

        <span class="cov0" title="0">return Type{MainType: mainType, SubType: subType, mimeSuffix: suffix}, nil</span>
}

// Type returns a string representing the main- and sub-type of a media type, e.g. "text/css".
// A suffix identifier will be appended after a "+" if set, e.g. "image/svg+xml".
// Hugo will register a set of default media types.
// These can be overridden by the user in the configuration,
// by defining a media type with the same Type.
func (m Type) Type() string <span class="cov8" title="1">{
        // Examples are
        // image/svg+xml
        // text/css
        if m.mimeSuffix != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s/%s+%s", m.MainType, m.SubType, m.mimeSuffix)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s/%s", m.MainType, m.SubType)</span>

}

func (m Type) String() string <span class="cov8" title="1">{
        return m.Type()
}</span>

// FullSuffix returns the file suffix with any delimiter prepended.
func (m Type) FullSuffix() string <span class="cov8" title="1">{
        return m.Delimiter + m.Suffix()
}</span>

// Suffix returns the file suffix without any delmiter prepended.
func (m Type) Suffix() string <span class="cov8" title="1">{
        if m.fileSuffix != "" </span><span class="cov0" title="0">{
                return m.fileSuffix
        }</span>
        <span class="cov8" title="1">if len(m.Suffixes) &gt; 0 </span><span class="cov8" title="1">{
                return m.Suffixes[0]
        }</span>
        // There are MIME types without file suffixes.
        <span class="cov0" title="0">return ""</span>
}

// Definitions from https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types etc.
// Note that from Hugo 0.44 we only set Suffix if it is part of the MIME type.
var (
        CalendarType   = Type{MainType: "text", SubType: "calendar", Suffixes: []string{"ics"}, Delimiter: defaultDelimiter}
        CSSType        = Type{MainType: "text", SubType: "css", Suffixes: []string{"css"}, Delimiter: defaultDelimiter}
        SCSSType       = Type{MainType: "text", SubType: "x-scss", Suffixes: []string{"scss"}, Delimiter: defaultDelimiter}
        SASSType       = Type{MainType: "text", SubType: "x-sass", Suffixes: []string{"sass"}, Delimiter: defaultDelimiter}
        CSVType        = Type{MainType: "text", SubType: "csv", Suffixes: []string{"csv"}, Delimiter: defaultDelimiter}
        HTMLType       = Type{MainType: "text", SubType: "html", Suffixes: []string{"html"}, Delimiter: defaultDelimiter}
        JavascriptType = Type{MainType: "application", SubType: "javascript", Suffixes: []string{"js"}, Delimiter: defaultDelimiter}
        JSONType       = Type{MainType: "application", SubType: "json", Suffixes: []string{"json"}, Delimiter: defaultDelimiter}
        RSSType        = Type{MainType: "application", SubType: "rss", mimeSuffix: "xml", Suffixes: []string{"xml"}, Delimiter: defaultDelimiter}
        XMLType        = Type{MainType: "application", SubType: "xml", Suffixes: []string{"xml"}, Delimiter: defaultDelimiter}
        SVGType        = Type{MainType: "image", SubType: "svg", mimeSuffix: "xml", Suffixes: []string{"svg"}, Delimiter: defaultDelimiter}
        TextType       = Type{MainType: "text", SubType: "plain", Suffixes: []string{"txt"}, Delimiter: defaultDelimiter}
        TOMLType       = Type{MainType: "application", SubType: "toml", Suffixes: []string{"toml"}, Delimiter: defaultDelimiter}
        YAMLType       = Type{MainType: "application", SubType: "yaml", Suffixes: []string{"yaml", "yml"}, Delimiter: defaultDelimiter}

        // Common image types
        PNGType = Type{MainType: "image", SubType: "png", Suffixes: []string{"png"}, Delimiter: defaultDelimiter}
        JPGType = Type{MainType: "image", SubType: "jpg", Suffixes: []string{"jpg", "jpeg"}, Delimiter: defaultDelimiter}

        OctetType = Type{MainType: "application", SubType: "octet-stream"}
)

// DefaultTypes is the default media types supported by Hugo.
var DefaultTypes = Types{
        CalendarType,
        CSSType,
        CSVType,
        SCSSType,
        SASSType,
        HTMLType,
        JavascriptType,
        JSONType,
        RSSType,
        XMLType,
        SVGType,
        TextType,
        OctetType,
        YAMLType,
        TOMLType,
        PNGType,
        JPGType,
}

func init() <span class="cov8" title="1">{
        sort.Sort(DefaultTypes)
}</span>

// Types is a slice of media types.
type Types []Type

func (t Types) Len() int           <span class="cov8" title="1">{ return len(t) }</span>
func (t Types) Swap(i, j int)      <span class="cov8" title="1">{ t[i], t[j] = t[j], t[i] }</span>
func (t Types) Less(i, j int) bool <span class="cov8" title="1">{ return t[i].Type() &lt; t[j].Type() }</span>

// GetByType returns a media type for tp.
func (t Types) GetByType(tp string) (Type, bool) <span class="cov0" title="0">{
        for _, tt := range t </span><span class="cov0" title="0">{
                if strings.EqualFold(tt.Type(), tp) </span><span class="cov0" title="0">{
                        return tt, true
                }</span>
        }

        <span class="cov0" title="0">if !strings.Contains(tp, "+") </span><span class="cov0" title="0">{
                // Try with the main and sub type
                parts := strings.Split(tp, "/")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        return t.GetByMainSubType(parts[0], parts[1])
                }</span>
        }

        <span class="cov0" title="0">return Type{}, false</span>
}

// BySuffix will return all media types matching a suffix.
func (t Types) BySuffix(suffix string) []Type <span class="cov8" title="1">{
        var types []Type
        for _, tt := range t </span><span class="cov8" title="1">{
                if match := tt.matchSuffix(suffix); match != "" </span><span class="cov8" title="1">{
                        types = append(types, tt)
                }</span>
        }
        <span class="cov8" title="1">return types</span>
}

// GetFirstBySuffix will return the first media type matching the given suffix.
func (t Types) GetFirstBySuffix(suffix string) (Type, bool) <span class="cov0" title="0">{
        for _, tt := range t </span><span class="cov0" title="0">{
                if match := tt.matchSuffix(suffix); match != "" </span><span class="cov0" title="0">{
                        tt.fileSuffix = match
                        return tt, true
                }</span>
        }
        <span class="cov0" title="0">return Type{}, false</span>
}

// GetBySuffix gets a media type given as suffix, e.g. "html".
// It will return false if no format could be found, or if the suffix given
// is ambiguous.
// The lookup is case insensitive.
func (t Types) GetBySuffix(suffix string) (tp Type, found bool) <span class="cov0" title="0">{
        for _, tt := range t </span><span class="cov0" title="0">{
                if match := tt.matchSuffix(suffix); match != "" </span><span class="cov0" title="0">{
                        if found </span><span class="cov0" title="0">{
                                // ambiguous
                                found = false
                                return
                        }</span>
                        <span class="cov0" title="0">tp = tt
                        tp.fileSuffix = match
                        found = true</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (m Type) matchSuffix(suffix string) string <span class="cov8" title="1">{
        for _, s := range m.Suffixes </span><span class="cov8" title="1">{
                if strings.EqualFold(suffix, s) </span><span class="cov8" title="1">{
                        return s
                }</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// GetByMainSubType gets a media type given a main and a sub type e.g. "text" and "plain".
// It will return false if no format could be found, or if the combination given
// is ambiguous.
// The lookup is case insensitive.
func (t Types) GetByMainSubType(mainType, subType string) (tp Type, found bool) <span class="cov0" title="0">{
        for _, tt := range t </span><span class="cov0" title="0">{
                if strings.EqualFold(mainType, tt.MainType) &amp;&amp; strings.EqualFold(subType, tt.SubType) </span><span class="cov0" title="0">{
                        if found </span><span class="cov0" title="0">{
                                // ambiguous
                                found = false
                                return
                        }</span>

                        <span class="cov0" title="0">tp = tt
                        found = true</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func suffixIsRemoved() error <span class="cov0" title="0">{
        return errors.New(`MediaType.Suffix is removed. Before Hugo 0.44 this was used both to set a custom file suffix and as way
to augment the mediatype definition (what you see after the "+", e.g. "image/svg+xml").

This had its limitations. For one, it was only possible with one file extension per MIME type.

Now you can specify multiple file suffixes using "suffixes", but you need to specify the full MIME type
identifier:

[mediaTypes]
[mediaTypes."image/svg+xml"]
suffixes = ["svg", "abc" ]

In most cases, it will be enough to just change:

[mediaTypes]
[mediaTypes."my/custom-mediatype"]
suffix = "txt"

To:

[mediaTypes]
[mediaTypes."my/custom-mediatype"]
suffixes = ["txt"]

Note that you can still get the Media Type's suffix from a template: {{ $mediaType.Suffix }}. But this will now map to the MIME type filename.
`)
}</span>

// DecodeTypes takes a list of media type configurations and merges those,
// in the order given, with the Hugo defaults as the last resort.
func DecodeTypes(mms ...map[string]interface{}) (Types, error) <span class="cov8" title="1">{
        var m Types

        // Maps type string to Type. Type string is the full application/svg+xml.
        mmm := make(map[string]Type)
        for _, dt := range DefaultTypes </span><span class="cov8" title="1">{
                suffixes := make([]string, len(dt.Suffixes))
                copy(suffixes, dt.Suffixes)
                dt.Suffixes = suffixes
                mmm[dt.Type()] = dt
        }</span>

        <span class="cov8" title="1">for _, mm := range mms </span><span class="cov0" title="0">{
                for k, v := range mm </span><span class="cov0" title="0">{
                        var mediaType Type

                        mediaType, found := mmm[k]
                        if !found </span><span class="cov0" title="0">{
                                var err error
                                mediaType, err = fromString(k)
                                if err != nil </span><span class="cov0" title="0">{
                                        return m, err
                                }</span>
                        }

                        <span class="cov0" title="0">if err := mapstructure.WeakDecode(v, &amp;mediaType); err != nil </span><span class="cov0" title="0">{
                                return m, err
                        }</span>

                        <span class="cov0" title="0">vm := v.(map[string]interface{})
                        maps.ToLower(vm)
                        _, delimiterSet := vm["delimiter"]
                        _, suffixSet := vm["suffix"]

                        if suffixSet </span><span class="cov0" title="0">{
                                return Types{}, suffixIsRemoved()
                        }</span>

                        // The user may set the delimiter as an empty string.
                        <span class="cov0" title="0">if !delimiterSet &amp;&amp; len(mediaType.Suffixes) != 0 </span><span class="cov0" title="0">{
                                mediaType.Delimiter = defaultDelimiter
                        }</span>

                        <span class="cov0" title="0">mmm[k] = mediaType</span>

                }
        }

        <span class="cov8" title="1">for _, v := range mmm </span><span class="cov8" title="1">{
                m = append(m, v)
        }</span>
        <span class="cov8" title="1">sort.Sort(m)

        return m, nil</span>
}

// MarshalJSON returns the JSON encoding of m.
func (m Type) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        type Alias Type
        return json.Marshal(&amp;struct {
                Type   string `json:"type"`
                String string `json:"string"`
                Alias
        }{
                Type:   m.Type(),
                String: m.String(),
                Alias:  (Alias)(m),
        })
}</span>
</pre>
		
		<pre class="file" id="file145" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package metrics provides simple metrics tracking features.
package metrics

import (
        "fmt"
        "io"
        "math"
        "sort"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/gohugoio/hugo/compare"

        "github.com/gohugoio/hugo/common/hreflect"
)

// The Provider interface defines an interface for measuring metrics.
type Provider interface {
        // MeasureSince adds a measurement for key to the metric store.
        // Used with defer and time.Now().
        MeasureSince(key string, start time.Time)

        // WriteMetrics will write a summary of the metrics to w.
        WriteMetrics(w io.Writer)

        // TrackValue tracks the value for diff calculations etc.
        TrackValue(key string, value interface{})

        // Reset clears the metric store.
        Reset()
}

type diff struct {
        baseline interface{}
        count    int
        simSum   int
}

func (d *diff) add(v interface{}) *diff <span class="cov0" title="0">{
        if !hreflect.IsTruthful(v) </span><span class="cov0" title="0">{
                d.baseline = v
                d.count = 1
                d.simSum = 100 // If we get only one it is very cache friendly.
                return d
        }</span>

        <span class="cov0" title="0">d.simSum += howSimilar(v, d.baseline)
        d.count++

        return d</span>
}

// Store provides storage for a set of metrics.
type Store struct {
        calculateHints bool
        metrics        map[string][]time.Duration
        mu             sync.Mutex
        diffs          map[string]*diff
        diffmu         sync.Mutex
}

// NewProvider returns a new instance of a metric store.
func NewProvider(calculateHints bool) Provider <span class="cov0" title="0">{
        return &amp;Store{
                calculateHints: calculateHints,
                metrics:        make(map[string][]time.Duration),
                diffs:          make(map[string]*diff),
        }
}</span>

// Reset clears the metrics store.
func (s *Store) Reset() <span class="cov0" title="0">{
        s.mu.Lock()
        s.metrics = make(map[string][]time.Duration)
        s.mu.Unlock()
        s.diffmu.Lock()
        s.diffs = make(map[string]*diff)
        s.diffmu.Unlock()
}</span>

// TrackValue tracks the value for diff calculations etc.
func (s *Store) TrackValue(key string, value interface{}) <span class="cov0" title="0">{
        if !s.calculateHints </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.diffmu.Lock()
        var (
                d     *diff
                found bool
        )

        d, found = s.diffs[key]

        if !found </span><span class="cov0" title="0">{
                d = &amp;diff{}
                s.diffs[key] = d
        }</span>

        <span class="cov0" title="0">d.add(value)
        s.diffmu.Unlock()</span>
}

// MeasureSince adds a measurement for key to the metric store.
func (s *Store) MeasureSince(key string, start time.Time) <span class="cov0" title="0">{
        s.mu.Lock()
        s.metrics[key] = append(s.metrics[key], time.Since(start))
        s.mu.Unlock()
}</span>

// WriteMetrics writes a summary of the metrics to w.
func (s *Store) WriteMetrics(w io.Writer) <span class="cov0" title="0">{
        s.mu.Lock()

        results := make([]result, len(s.metrics))

        var i int
        for k, v := range s.metrics </span><span class="cov0" title="0">{
                var sum time.Duration
                var max time.Duration

                diff, found := s.diffs[k]
                cacheFactor := 0
                if found </span><span class="cov0" title="0">{
                        cacheFactor = int(math.Floor(float64(diff.simSum) / float64(diff.count)))
                }</span>

                <span class="cov0" title="0">for _, d := range v </span><span class="cov0" title="0">{
                        sum += d
                        if d &gt; max </span><span class="cov0" title="0">{
                                max = d
                        }</span>
                }

                <span class="cov0" title="0">avg := time.Duration(int(sum) / len(v))

                results[i] = result{key: k, count: len(v), max: max, sum: sum, avg: avg, cacheFactor: cacheFactor}
                i++</span>
        }

        <span class="cov0" title="0">s.mu.Unlock()

        if s.calculateHints </span><span class="cov0" title="0">{
                fmt.Fprintf(w, "  %9s  %13s  %12s  %12s  %5s  %s\n", "cache", "cumulative", "average", "maximum", "", "")
                fmt.Fprintf(w, "  %9s  %13s  %12s  %12s  %5s  %s\n", "potential", "duration", "duration", "duration", "count", "template")
                fmt.Fprintf(w, "  %9s  %13s  %12s  %12s  %5s  %s\n", "-----", "----------", "--------", "--------", "-----", "--------")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprintf(w, "  %13s  %12s  %12s  %5s  %s\n", "cumulative", "average", "maximum", "", "")
                fmt.Fprintf(w, "  %13s  %12s  %12s  %5s  %s\n", "duration", "duration", "duration", "count", "template")
                fmt.Fprintf(w, "  %13s  %12s  %12s  %5s  %s\n", "----------", "--------", "--------", "-----", "--------")

        }</span>

        <span class="cov0" title="0">sort.Sort(bySum(results))
        for _, v := range results </span><span class="cov0" title="0">{
                if s.calculateHints </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "  %9d %13s  %12s  %12s  %5d  %s\n", v.cacheFactor, v.sum, v.avg, v.max, v.count, v.key)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(w, "  %13s  %12s  %12s  %5d  %s\n", v.sum, v.avg, v.max, v.count, v.key)
                }</span>
        }

}

// A result represents the calculated results for a given metric.
type result struct {
        key         string
        count       int
        cacheFactor int
        sum         time.Duration
        max         time.Duration
        avg         time.Duration
}

type bySum []result

func (b bySum) Len() int           <span class="cov0" title="0">{ return len(b) }</span>
func (b bySum) Swap(i, j int)      <span class="cov0" title="0">{ b[i], b[j] = b[j], b[i] }</span>
func (b bySum) Less(i, j int) bool <span class="cov0" title="0">{ return b[i].sum &gt; b[j].sum }</span>

// howSimilar is a naive diff implementation that returns
// a number between 0-100 indicating how similar a and b are.
func howSimilar(a, b interface{}) int <span class="cov0" title="0">{
        // TODO(bep) object equality fast path, but remember that
        // we can get anytning in here.

        as, ok1 := a.(string)
        bs, ok2 := b.(string)

        if ok1 &amp;&amp; ok2 </span><span class="cov0" title="0">{
                return howSimilarStrings(as, bs)
        }</span>

        <span class="cov0" title="0">if ok1 != ok2 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">e1, ok1 := a.(compare.Eqer)
        e2, ok2 := b.(compare.Eqer)
        if ok1 &amp;&amp; ok2 &amp;&amp; e1.Eq(e2) </span><span class="cov0" title="0">{
                return 100
        }</span>

        <span class="cov0" title="0">pe1, pok1 := a.(compare.ProbablyEqer)
        pe2, pok2 := b.(compare.ProbablyEqer)
        if pok1 &amp;&amp; pok2 &amp;&amp; pe1.ProbablyEq(pe2) </span><span class="cov0" title="0">{
                return 90
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// howSimilar is a naive diff implementation that returns
// a number between 0-100 indicating how similar a and b are.
// 100 is when all words in a also exists in b.
func howSimilarStrings(a, b string) int <span class="cov0" title="0">{

        // Give some weight to the word positions.
        const partitionSize = 4

        af, bf := strings.Fields(a), strings.Fields(b)
        if len(bf) &gt; len(af) </span><span class="cov0" title="0">{
                af, bf = bf, af
        }</span>

        <span class="cov0" title="0">m1 := make(map[string]bool)
        for i, x := range bf </span><span class="cov0" title="0">{
                partition := partition(i, partitionSize)
                key := x + "/" + strconv.Itoa(partition)
                m1[key] = true
        }</span>

        <span class="cov0" title="0">common := 0
        for i, x := range af </span><span class="cov0" title="0">{
                partition := partition(i, partitionSize)
                key := x + "/" + strconv.Itoa(partition)
                if m1[key] </span><span class="cov0" title="0">{
                        common++
                }</span>
        }

        <span class="cov0" title="0">return int(math.Floor((float64(common) / float64(len(af)) * 100)))</span>
}

func partition(d, scale int) int <span class="cov0" title="0">{
        return int(math.Floor((float64(d) / float64(scale)))) * scale
}</span>
</pre>
		
		<pre class="file" id="file146" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package minifiers contains minifiers mapped to MIME types. This package is used
// in both the resource transformation, i.e. resources.Minify, and in the publishing
// chain.
package minifiers

import (
        "io"
        "regexp"

        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/transform"

        "github.com/gohugoio/hugo/media"
        "github.com/tdewolff/minify/v2"
        "github.com/tdewolff/minify/v2/css"
        "github.com/tdewolff/minify/v2/html"
        "github.com/tdewolff/minify/v2/js"
        "github.com/tdewolff/minify/v2/json"
        "github.com/tdewolff/minify/v2/svg"
        "github.com/tdewolff/minify/v2/xml"
)

// Client wraps a minifier.
type Client struct {
        m *minify.M
}

// Transformer returns a func that can be used in the transformer publishing chain.
// TODO(bep) minify config etc
func (m Client) Transformer(mediatype media.Type) transform.Transformer <span class="cov0" title="0">{
        _, params, min := m.m.Match(mediatype.Type())
        if min == nil </span><span class="cov0" title="0">{
                // No minifier for this MIME type
                return nil
        }</span>

        <span class="cov0" title="0">return func(ft transform.FromTo) error </span><span class="cov0" title="0">{
                // Note that the source io.Reader will already be buffered, but it implements
                // the Bytes() method, which is recognized by the Minify library.
                return min.Minify(m.m, ft.To(), ft.From(), params)
        }</span>
}

// Minify tries to minify the src into dst given a MIME type.
func (m Client) Minify(mediatype media.Type, dst io.Writer, src io.Reader) error <span class="cov0" title="0">{
        return m.m.Minify(mediatype.Type(), dst, src)
}</span>

// New creates a new Client with the provided MIME types as the mapping foundation.
// The HTML minifier is also registered for additional HTML types (AMP etc.) in the
// provided list of output formats.
func New(mediaTypes media.Types, outputFormats output.Formats) Client <span class="cov8" title="1">{
        m := minify.New()
        htmlMin := &amp;html.Minifier{
                KeepDocumentTags:        true,
                KeepConditionalComments: true,
                KeepEndTags:             true,
                KeepDefaultAttrVals:     true,
        }

        cssMin := &amp;css.Minifier{
                Decimals: -1,
                KeepCSS2: true,
        }

        // We use the Type definition of the media types defined in the site if found.
        addMinifier(m, mediaTypes, "css", cssMin)
        addMinifierFunc(m, mediaTypes, "js", js.Minify)
        m.AddFuncRegexp(regexp.MustCompile("^(application|text)/(x-)?(java|ecma)script$"), js.Minify)
        m.AddFuncRegexp(regexp.MustCompile(`^(application|text)/(x-|ld\+)?json$`), json.Minify)
        addMinifierFunc(m, mediaTypes, "json", json.Minify)
        addMinifierFunc(m, mediaTypes, "svg", svg.Minify)
        addMinifierFunc(m, mediaTypes, "xml", xml.Minify)

        // HTML
        addMinifier(m, mediaTypes, "html", htmlMin)
        for _, of := range outputFormats </span><span class="cov8" title="1">{
                if of.IsHTML </span><span class="cov8" title="1">{
                        m.Add(of.MediaType.Type(), htmlMin)
                }</span>
        }

        <span class="cov8" title="1">return Client{m: m}</span>

}

func addMinifier(m *minify.M, mt media.Types, suffix string, min minify.Minifier) <span class="cov8" title="1">{
        types := mt.BySuffix(suffix)
        for _, t := range types </span><span class="cov8" title="1">{
                m.Add(t.Type(), min)
        }</span>
}

func addMinifierFunc(m *minify.M, mt media.Types, suffix string, min minify.MinifierFunc) <span class="cov8" title="1">{
        types := mt.BySuffix(suffix)
        for _, t := range types </span><span class="cov8" title="1">{
                m.AddFunc(t.Type(), min)
        }</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package modules

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "os/exec"
        "path/filepath"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/common/loggers"

        "strings"
        "time"

        "github.com/gohugoio/hugo/config"

        "github.com/rogpeppe/go-internal/module"

        "github.com/gohugoio/hugo/common/hugio"

        "github.com/pkg/errors"
        "github.com/spf13/afero"
)

var (
        fileSeparator = string(os.PathSeparator)
)

const (
        goBinaryStatusOK goBinaryStatus = iota
        goBinaryStatusNotFound
        goBinaryStatusTooOld
)

// The "vendor" dir is reserved for Go Modules.
const vendord = "_vendor"

const (
        goModFilename = "go.mod"
        goSumFilename = "go.sum"
)

// NewClient creates a new Client that can be used to manage the Hugo Components
// in a given workingDir.
// The Client will resolve the dependencies recursively, but needs the top
// level imports to start out.
func NewClient(cfg ClientConfig) *Client <span class="cov8" title="1">{
        fs := cfg.Fs
        n := filepath.Join(cfg.WorkingDir, goModFilename)
        goModEnabled, _ := afero.Exists(fs, n)
        var goModFilename string
        if goModEnabled </span><span class="cov8" title="1">{
                goModFilename = n
        }</span>

        <span class="cov8" title="1">env := os.Environ()
        mcfg := cfg.ModuleConfig

        config.SetEnvVars(&amp;env,
                "PWD", cfg.WorkingDir,
                "GO111MODULE", "on",
                "GOPROXY", mcfg.Proxy,
                "GOPRIVATE", mcfg.Private,
                "GONOPROXY", mcfg.NoProxy)

        if cfg.CacheDir != "" </span><span class="cov8" title="1">{
                // Module cache stored below $GOPATH/pkg
                config.SetEnvVars(&amp;env, "GOPATH", cfg.CacheDir)

        }</span>

        <span class="cov8" title="1">logger := cfg.Logger
        if logger == nil </span><span class="cov8" title="1">{
                logger = loggers.NewWarningLogger()
        }</span>

        <span class="cov8" title="1">return &amp;Client{
                fs:                fs,
                ccfg:              cfg,
                logger:            logger,
                moduleConfig:      mcfg,
                environ:           env,
                GoModulesFilename: goModFilename}</span>
}

// Client contains most of the API provided by this package.
type Client struct {
        fs     afero.Fs
        logger *loggers.Logger

        ccfg ClientConfig

        // The top level module config
        moduleConfig Config

        // Environment variables used in "go get" etc.
        environ []string

        // Set when Go modules are initialized in the current repo, that is:
        // a go.mod file exists.
        GoModulesFilename string

        // Set if we get a exec.ErrNotFound when running Go, which is most likely
        // due to being run on a system without Go installed. We record it here
        // so we can give an instructional error at the end if module/theme
        // resolution fails.
        goBinaryStatus goBinaryStatus
}

// Graph writes a module dependenchy graph to the given writer.
func (c *Client) Graph(w io.Writer) error <span class="cov0" title="0">{
        mc, coll := c.collect(true)
        if coll.err != nil </span><span class="cov0" title="0">{
                return coll.err
        }</span>
        <span class="cov0" title="0">for _, module := range mc.AllModules </span><span class="cov0" title="0">{
                if module.Owner() == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">prefix := ""
                if module.Disabled() </span><span class="cov0" title="0">{
                        prefix = "DISABLED "
                }</span>
                <span class="cov0" title="0">dep := pathVersion(module.Owner()) + " " + pathVersion(module)
                if replace := module.Replace(); replace != nil </span><span class="cov0" title="0">{
                        if replace.Version() != "" </span><span class="cov0" title="0">{
                                dep += " =&gt; " + pathVersion(replace)
                        }</span> else<span class="cov0" title="0"> {
                                // Local dir.
                                dep += " =&gt; " + replace.Dir()
                        }</span>

                }
                <span class="cov0" title="0">fmt.Fprintln(w, prefix+dep)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Tidy can be used to remove unused dependencies from go.mod and go.sum.
func (c *Client) Tidy() error <span class="cov0" title="0">{
        tc, coll := c.collect(false)
        if coll.err != nil </span><span class="cov0" title="0">{
                return coll.err
        }</span>

        <span class="cov0" title="0">if coll.skipTidy </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return c.tidy(tc.AllModules, false)</span>
}

// Vendor writes all the module dependencies to a _vendor folder.
//
// Unlike Go, we support it for any level.
//
// We, by default, use the /_vendor folder first, if found. To disable,
// run with
//    hugo --ignoreVendor
//
// Given a module tree, Hugo will pick the first module for a given path,
// meaning that if the top-level module is vendored, that will be the full
// set of dependencies.
func (c *Client) Vendor() error <span class="cov0" title="0">{
        vendorDir := filepath.Join(c.ccfg.WorkingDir, vendord)
        if err := c.rmVendorDir(vendorDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write the modules list to modules.txt.
        //
        // On the form:
        //
        // # github.com/alecthomas/chroma v0.6.3
        //
        // This is how "go mod vendor" does it. Go also lists
        // the packages below it, but that is currently not applicable to us.
        //
        <span class="cov0" title="0">var modulesContent bytes.Buffer

        tc, coll := c.collect(true)
        if coll.err != nil </span><span class="cov0" title="0">{
                return coll.err
        }</span>

        <span class="cov0" title="0">for _, t := range tc.AllModules </span><span class="cov0" title="0">{
                if t.Owner() == nil </span><span class="cov0" title="0">{
                        // This is the project.
                        continue</span>
                }
                // We respect the --ignoreVendor flag even for the vendor command.
                <span class="cov0" title="0">if !t.IsGoMod() &amp;&amp; !t.Vendor() </span><span class="cov0" title="0">{
                        // We currently do not vendor components living in the
                        // theme directory, see https://github.com/gohugoio/hugo/issues/5993
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Fprintln(&amp;modulesContent, "# "+t.Path()+" "+t.Version())

                dir := t.Dir()

                for _, mount := range t.Mounts() </span><span class="cov0" title="0">{
                        if err := hugio.CopyDir(c.fs, filepath.Join(dir, mount.Source), filepath.Join(vendorDir, t.Path(), mount.Source), nil); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to copy module to vendor dir")
                        }</span>
                }

                // Include the resource cache if present.
                <span class="cov0" title="0">resourcesDir := filepath.Join(dir, files.FolderResources)
                _, err := c.fs.Stat(resourcesDir)
                if err == nil </span><span class="cov0" title="0">{
                        if err := hugio.CopyDir(c.fs, resourcesDir, filepath.Join(vendorDir, t.Path(), files.FolderResources), nil); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to copy resources to vendor dir")
                        }</span>
                }

                // Also include any theme.toml or config.* files in the root.
                <span class="cov0" title="0">configFiles, _ := afero.Glob(c.fs, filepath.Join(dir, "config.*"))
                configFiles = append(configFiles, filepath.Join(dir, "theme.toml"))
                for _, configFile := range configFiles </span><span class="cov0" title="0">{
                        if err := hugio.CopyFile(c.fs, configFile, filepath.Join(vendorDir, t.Path(), filepath.Base(configFile))); err != nil </span><span class="cov0" title="0">{
                                if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if modulesContent.Len() &gt; 0 </span><span class="cov0" title="0">{
                if err := afero.WriteFile(c.fs, filepath.Join(vendorDir, vendorModulesFilename), modulesContent.Bytes(), 0666); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Get runs "go get" with the supplied arguments.
func (c *Client) Get(args ...string) error <span class="cov0" title="0">{
        if err := c.runGo(context.Background(), os.Stdout, append([]string{"get"}, args...)...); err != nil </span><span class="cov0" title="0">{
                errors.Wrapf(err, "failed to get %q", args)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Init initializes this as a Go Module with the given path.
// If path is empty, Go will try to guess.
// If this succeeds, this project will be marked as Go Module.
func (c *Client) Init(path string) error <span class="cov0" title="0">{
        err := c.runGo(context.Background(), os.Stdout, "mod", "init", path)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to init modules")
        }</span>

        <span class="cov0" title="0">c.GoModulesFilename = filepath.Join(c.ccfg.WorkingDir, goModFilename)

        return nil</span>
}

func isProbablyModule(path string) bool <span class="cov8" title="1">{
        return module.CheckPath(path) == nil
}</span>

func (c *Client) listGoMods() (goModules, error) <span class="cov8" title="1">{
        if c.GoModulesFilename == "" || !c.moduleConfig.hasModuleImport() </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">out := ioutil.Discard
        err := c.runGo(context.Background(), out, "mod", "download")
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to download modules")
        }</span>

        <span class="cov0" title="0">b := &amp;bytes.Buffer{}
        err = c.runGo(context.Background(), b, "list", "-m", "-json", "all")
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to list modules")
        }</span>

        <span class="cov0" title="0">var modules goModules

        dec := json.NewDecoder(b)
        for </span><span class="cov0" title="0">{
                m := &amp;goModule{}
                if err := dec.Decode(m); err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return nil, errors.Wrap(err, "failed to decode modules list")</span>
                }

                <span class="cov0" title="0">modules = append(modules, m)</span>
        }

        <span class="cov0" title="0">return modules, err</span>

}

func (c *Client) rewriteGoMod(name string, isGoMod map[string]bool) error <span class="cov0" title="0">{
        data, err := c.rewriteGoModRewrite(name, isGoMod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if data != nil </span><span class="cov0" title="0">{
                if err := afero.WriteFile(c.fs, filepath.Join(c.ccfg.WorkingDir, name), data, 0666); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) rewriteGoModRewrite(name string, isGoMod map[string]bool) ([]byte, error) <span class="cov0" title="0">{
        if name == goModFilename &amp;&amp; c.GoModulesFilename == "" </span><span class="cov0" title="0">{
                // Already checked.
                return nil, nil
        }</span>

        <span class="cov0" title="0">modlineSplitter := getModlineSplitter(name == goModFilename)

        b := &amp;bytes.Buffer{}
        f, err := c.fs.Open(filepath.Join(c.ccfg.WorkingDir, name))
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // It's been deleted.
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">defer f.Close()

        scanner := bufio.NewScanner(f)
        var dirty bool

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                var doWrite bool

                if parts := modlineSplitter(line); parts != nil </span><span class="cov0" title="0">{
                        modname, modver := parts[0], parts[1]
                        modver = strings.TrimSuffix(modver, "/"+goModFilename)
                        modnameVer := modname + " " + modver
                        doWrite = isGoMod[modnameVer]
                }</span> else<span class="cov0" title="0"> {
                        doWrite = true
                }</span>

                <span class="cov0" title="0">if doWrite </span><span class="cov0" title="0">{
                        fmt.Fprintln(b, line)
                }</span> else<span class="cov0" title="0"> {
                        dirty = true
                }</span>
        }

        <span class="cov0" title="0">if !dirty </span><span class="cov0" title="0">{
                // Nothing changed
                return nil, nil
        }</span>

        <span class="cov0" title="0">return b.Bytes(), nil</span>

}

func (c *Client) rmVendorDir(vendorDir string) error <span class="cov0" title="0">{
        modulestxt := filepath.Join(vendorDir, vendorModulesFilename)

        if _, err := c.fs.Stat(vendorDir); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">_, err := c.fs.Stat(modulestxt)
        if err != nil </span><span class="cov0" title="0">{
                // If we have a _vendor dir without modules.txt it sounds like
                // a _vendor dir created by others.
                return errors.New("found _vendor dir without modules.txt, skip delete")
        }</span>

        <span class="cov0" title="0">return c.fs.RemoveAll(vendorDir)</span>
}

func (c *Client) runGo(
        ctx context.Context,
        stdout io.Writer,
        args ...string) error <span class="cov0" title="0">{

        if c.goBinaryStatus != 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">stderr := new(bytes.Buffer)
        cmd := exec.CommandContext(ctx, "go", args...)

        cmd.Env = c.environ
        cmd.Dir = c.ccfg.WorkingDir
        cmd.Stdout = stdout
        cmd.Stderr = io.MultiWriter(stderr, os.Stderr)

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                if ee, ok := err.(*exec.Error); ok &amp;&amp; ee.Err == exec.ErrNotFound </span><span class="cov0" title="0">{
                        c.goBinaryStatus = goBinaryStatusNotFound
                        return nil
                }</span>

                <span class="cov0" title="0">_, ok := err.(*exec.ExitError)
                if !ok </span><span class="cov0" title="0">{
                        return errors.Errorf("failed to execute 'go %v': %s %T", args, err, err)
                }</span>

                // Too old Go version
                <span class="cov0" title="0">if strings.Contains(stderr.String(), "flag provided but not defined") </span><span class="cov0" title="0">{
                        c.goBinaryStatus = goBinaryStatusTooOld
                        return nil
                }</span>

                <span class="cov0" title="0">return errors.Errorf("go command failed: %s", stderr)</span>

        }

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) tidy(mods Modules, goModOnly bool) error <span class="cov0" title="0">{
        isGoMod := make(map[string]bool)
        for _, m := range mods </span><span class="cov0" title="0">{
                if m.Owner() == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if m.IsGoMod() </span><span class="cov0" title="0">{
                        // Matching the format in go.mod
                        pathVer := m.Path() + " " + m.Version()
                        isGoMod[pathVer] = true
                }</span>
        }

        <span class="cov0" title="0">if err := c.rewriteGoMod(goModFilename, isGoMod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if goModOnly </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := c.rewriteGoMod(goSumFilename, isGoMod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ClientConfig configures the module Client.
type ClientConfig struct {
        Fs     afero.Fs
        Logger *loggers.Logger

        // If set, it will be run before we do any duplicate checks for modules
        // etc.
        HookBeforeFinalize func(m *ModulesConfig) error

        // Ignore any _vendor directory.
        IgnoreVendor bool

        // Absolute path to the project dir.
        WorkingDir string

        // Absolute path to the project's themes dir.
        ThemesDir string

        CacheDir     string // Module cache
        ModuleConfig Config
}

type goBinaryStatus int

type goModule struct {
        Path     string         // module path
        Version  string         // module version
        Versions []string       // available module versions (with -versions)
        Replace  *goModule      // replaced by this module
        Time     *time.Time     // time version was created
        Update   *goModule      // available update, if any (with -u)
        Main     bool           // is this the main module?
        Indirect bool           // is this module only an indirect dependency of main module?
        Dir      string         // directory holding files for this module, if any
        GoMod    string         // path to go.mod file for this module, if any
        Error    *goModuleError // error loading module
}

type goModuleError struct {
        Err string // the error itself
}

type goModules []*goModule

func (modules goModules) GetByPath(p string) *goModule <span class="cov8" title="1">{
        if modules == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, m := range modules </span><span class="cov0" title="0">{
                if strings.EqualFold(p, m.Path) </span><span class="cov0" title="0">{
                        return m
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (modules goModules) GetMain() *goModule <span class="cov8" title="1">{
        for _, m := range modules </span><span class="cov0" title="0">{
                if m.Main </span><span class="cov0" title="0">{
                        return m
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func getModlineSplitter(isGoMod bool) func(line string) []string <span class="cov0" title="0">{
        if isGoMod </span><span class="cov0" title="0">{
                return func(line string) []string </span><span class="cov0" title="0">{
                        if strings.HasPrefix(line, "require (") </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">if !strings.HasPrefix(line, "require") &amp;&amp; !strings.HasPrefix(line, "\t") </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">line = strings.TrimPrefix(line, "require")
                        line = strings.TrimSpace(line)
                        line = strings.TrimSuffix(line, "// indirect")

                        return strings.Fields(line)</span>
                }
        }

        <span class="cov0" title="0">return func(line string) []string </span><span class="cov0" title="0">{
                return strings.Fields(line)
        }</span>
}

func pathVersion(m Module) string <span class="cov0" title="0">{
        versionStr := m.Version()
        if m.Vendor() </span><span class="cov0" title="0">{
                versionStr += "+vendor"
        }</span>
        <span class="cov0" title="0">if versionStr == "" </span><span class="cov0" title="0">{
                return m.Path()
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s@%s", m.Path(), versionStr)</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package modules

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/rogpeppe/go-internal/module"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/config"
        "github.com/spf13/afero"
)

var ErrNotExist = errors.New("module does not exist")

const vendorModulesFilename = "modules.txt"

// IsNotExist returns whether an error means that a module could not be found.
func IsNotExist(err error) bool <span class="cov0" title="0">{
        return errors.Cause(err) == ErrNotExist
}</span>

// CreateProjectModule creates modules from the given config.
// This is used in tests only.
func CreateProjectModule(cfg config.Provider) (Module, error) <span class="cov0" title="0">{
        workingDir := cfg.GetString("workingDir")
        var modConfig Config

        mod := createProjectModule(nil, workingDir, modConfig)
        if err := ApplyProjectConfigDefaults(cfg, mod); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return mod, nil</span>
}

func (h *Client) Collect() (ModulesConfig, error) <span class="cov8" title="1">{
        mc, coll := h.collect(true)
        if coll.err != nil </span><span class="cov0" title="0">{
                return mc, coll.err
        }</span>

        <span class="cov8" title="1">if err := (&amp;mc).setActiveMods(h.logger); err != nil </span><span class="cov0" title="0">{
                return mc, err
        }</span>

        <span class="cov8" title="1">if h.ccfg.HookBeforeFinalize != nil </span><span class="cov8" title="1">{
                if err := h.ccfg.HookBeforeFinalize(&amp;mc); err != nil </span><span class="cov0" title="0">{
                        return mc, err
                }</span>
        }

        <span class="cov8" title="1">if err := (&amp;mc).finalize(h.logger); err != nil </span><span class="cov0" title="0">{
                return mc, err
        }</span>

        <span class="cov8" title="1">return mc, nil</span>
}

func (h *Client) collect(tidy bool) (ModulesConfig, *collector) <span class="cov8" title="1">{
        c := &amp;collector{
                Client: h,
        }

        c.collect()
        if c.err != nil </span><span class="cov0" title="0">{
                return ModulesConfig{}, c
        }</span>

        // https://github.com/gohugoio/hugo/issues/6115
        /*if !c.skipTidy &amp;&amp; tidy {
                if err := h.tidy(c.modules, true); err != nil {
                        c.err = err
                        return ModulesConfig{}, c
                }
        }*/

        <span class="cov8" title="1">return ModulesConfig{
                AllModules:        c.modules,
                GoModulesFilename: c.GoModulesFilename,
        }, c</span>

}

type ModulesConfig struct {
        // All modules, including any disabled.
        AllModules Modules

        // All active modules.
        ActiveModules Modules

        // Set if this is a Go modules enabled project.
        GoModulesFilename string
}

func (m *ModulesConfig) setActiveMods(logger *loggers.Logger) error <span class="cov8" title="1">{
        var activeMods Modules
        for _, mod := range m.AllModules </span><span class="cov8" title="1">{
                if !mod.Config().HugoVersion.IsValid() </span><span class="cov0" title="0">{
                        logger.WARN.Printf(`Module %q is not compatible with this Hugo version; run "hugo mod graph" for more information.`, mod.Path())
                }</span>
                <span class="cov8" title="1">if !mod.Disabled() </span><span class="cov8" title="1">{
                        activeMods = append(activeMods, mod)
                }</span>
        }

        <span class="cov8" title="1">m.ActiveModules = activeMods

        return nil</span>
}

func (m *ModulesConfig) finalize(logger *loggers.Logger) error <span class="cov8" title="1">{
        for _, mod := range m.AllModules </span><span class="cov8" title="1">{
                m := mod.(*moduleAdapter)
                m.mounts = filterUnwantedMounts(m.mounts)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func filterUnwantedMounts(mounts []Mount) []Mount <span class="cov8" title="1">{
        // Remove duplicates
        seen := make(map[Mount]bool)
        tmp := mounts[:0]
        for _, m := range mounts </span><span class="cov8" title="1">{
                if !seen[m] </span><span class="cov8" title="1">{
                        tmp = append(tmp, m)
                }</span>
                <span class="cov8" title="1">seen[m] = true</span>
        }
        <span class="cov8" title="1">return tmp</span>
}

type collected struct {
        // Pick the first and prevent circular loops.
        seen map[string]bool

        // Maps module path to a _vendor dir. These values are fetched from
        // _vendor/modules.txt, and the first (top-most) will win.
        vendored map[string]vendoredModule

        // Set if a Go modules enabled project.
        gomods goModules

        // Ordered list of collected modules, including Go Modules and theme
        // components stored below /themes.
        modules Modules
}

// Collects and creates a module tree.
type collector struct {
        *Client

        // Store away any non-fatal error and return at the end.
        err error

        // Set to disable any Tidy operation in the end.
        skipTidy bool

        *collected
}

func (c *collector) initModules() error <span class="cov8" title="1">{
        c.collected = &amp;collected{
                seen:     make(map[string]bool),
                vendored: make(map[string]vendoredModule),
        }

        // We may fail later if we don't find the mods.
        return c.loadModules()
}</span>

func (c *collector) isSeen(path string) bool <span class="cov8" title="1">{
        key := pathKey(path)
        if c.seen[key] </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">c.seen[key] = true
        return false</span>
}

func (c *collector) getVendoredDir(path string) (vendoredModule, bool) <span class="cov8" title="1">{
        v, found := c.vendored[path]
        return v, found
}</span>

func (c *collector) add(owner *moduleAdapter, moduleImport Import, disabled bool) (*moduleAdapter, error) <span class="cov8" title="1">{
        var (
                mod       *goModule
                moduleDir string
                version   string
                vendored  bool
        )

        modulePath := moduleImport.Path
        var realOwner Module = owner

        if !c.ccfg.IgnoreVendor </span><span class="cov8" title="1">{
                if err := c.collectModulesTXT(owner); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Try _vendor first.
                <span class="cov8" title="1">var vm vendoredModule
                vm, vendored = c.getVendoredDir(modulePath)
                if vendored </span><span class="cov0" title="0">{
                        moduleDir = vm.Dir
                        realOwner = vm.Owner
                        version = vm.Version

                        if owner.projectMod </span><span class="cov0" title="0">{
                                // We want to keep the go.mod intact with the versions and all.
                                c.skipTidy = true
                        }</span>

                }
        }

        <span class="cov8" title="1">if moduleDir == "" </span><span class="cov8" title="1">{
                mod = c.gomods.GetByPath(modulePath)
                if mod != nil </span><span class="cov0" title="0">{
                        moduleDir = mod.Dir
                }</span>

                <span class="cov8" title="1">if moduleDir == "" </span><span class="cov8" title="1">{
                        if c.GoModulesFilename != "" &amp;&amp; isProbablyModule(modulePath) </span><span class="cov0" title="0">{
                                // Try to "go get" it and reload the module configuration.
                                if err := c.Get(modulePath); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">if err := c.loadModules(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov0" title="0">mod = c.gomods.GetByPath(modulePath)
                                if mod != nil </span><span class="cov0" title="0">{
                                        moduleDir = mod.Dir
                                }</span>
                        }

                        // Fall back to /themes/&lt;mymodule&gt;
                        <span class="cov8" title="1">if moduleDir == "" </span><span class="cov8" title="1">{
                                moduleDir = filepath.Join(c.ccfg.ThemesDir, modulePath)

                                if found, _ := afero.Exists(c.fs, moduleDir); !found </span><span class="cov0" title="0">{
                                        c.err = c.wrapModuleNotFound(errors.Errorf(`module %q not found; either add it as a Hugo Module or store it in %q.`, modulePath, c.ccfg.ThemesDir))
                                        return nil, nil
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if found, _ := afero.Exists(c.fs, moduleDir); !found </span><span class="cov0" title="0">{
                c.err = c.wrapModuleNotFound(errors.Errorf("%q not found", moduleDir))
                return nil, nil
        }</span>

        <span class="cov8" title="1">if !strings.HasSuffix(moduleDir, fileSeparator) </span><span class="cov8" title="1">{
                moduleDir += fileSeparator
        }</span>

        <span class="cov8" title="1">ma := &amp;moduleAdapter{
                dir:      moduleDir,
                vendor:   vendored,
                disabled: disabled,
                gomod:    mod,
                version:  version,
                // This may be the owner of the _vendor dir
                owner: realOwner,
        }

        if mod == nil </span><span class="cov8" title="1">{
                ma.path = modulePath
        }</span>

        <span class="cov8" title="1">if !moduleImport.IgnoreConfig </span><span class="cov8" title="1">{
                if err := c.applyThemeConfig(ma); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if err := c.applyMounts(moduleImport, ma); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c.modules = append(c.modules, ma)
        return ma, nil</span>

}

func (c *collector) addAndRecurse(owner *moduleAdapter, disabled bool) error <span class="cov8" title="1">{
        moduleConfig := owner.Config()
        if owner.projectMod </span><span class="cov8" title="1">{
                if err := c.applyMounts(Import{}, owner); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">for _, moduleImport := range moduleConfig.Imports </span><span class="cov8" title="1">{
                disabled := disabled || moduleImport.Disable

                if !c.isSeen(moduleImport.Path) </span><span class="cov8" title="1">{
                        tc, err := c.add(owner, moduleImport, disabled)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if tc == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if err := c.addAndRecurse(tc, disabled); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *collector) applyMounts(moduleImport Import, mod *moduleAdapter) error <span class="cov8" title="1">{
        mounts := moduleImport.Mounts

        modConfig := mod.Config()

        if len(mounts) == 0 </span><span class="cov8" title="1">{
                // Mounts not defined by the import.
                mounts = modConfig.Mounts

        }</span>

        <span class="cov8" title="1">if !mod.projectMod &amp;&amp; len(mounts) == 0 </span><span class="cov8" title="1">{
                // Create default mount points for every component folder that
                // exists in the module.
                for _, componentFolder := range files.ComponentFolders </span><span class="cov8" title="1">{
                        sourceDir := filepath.Join(mod.Dir(), componentFolder)
                        _, err := c.fs.Stat(sourceDir)
                        if err == nil </span><span class="cov8" title="1">{
                                mounts = append(mounts, Mount{
                                        Source: componentFolder,
                                        Target: componentFolder,
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">var err error
        mounts, err = c.normalizeMounts(mod, mounts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">mod.mounts = mounts
        return nil</span>
}

func (c *collector) applyThemeConfig(tc *moduleAdapter) error <span class="cov8" title="1">{

        var (
                configFilename string
                cfg            config.Provider
                themeCfg       map[string]interface{}
                hasConfig      bool
                err            error
        )

        // Viper supports more, but this is the sub-set supported by Hugo.
        for _, configFormats := range config.ValidConfigFileExtensions </span><span class="cov8" title="1">{
                configFilename = filepath.Join(tc.Dir(), "config."+configFormats)
                hasConfig, _ = afero.Exists(c.fs, configFilename)
                if hasConfig </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // The old theme information file.
        <span class="cov8" title="1">themeTOML := filepath.Join(tc.Dir(), "theme.toml")

        hasThemeTOML, _ := afero.Exists(c.fs, themeTOML)
        if hasThemeTOML </span><span class="cov8" title="1">{
                data, err := afero.ReadFile(c.fs, themeTOML)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">themeCfg, err = metadecoders.Default.UnmarshalToMap(data, metadecoders.TOML)
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.WARN.Printf("Failed to read module config for %q in %q: %s", tc.Path(), themeTOML, err)
                }</span> else<span class="cov8" title="1"> {
                        maps.ToLower(themeCfg)
                }</span>
        }

        <span class="cov8" title="1">if hasConfig </span><span class="cov0" title="0">{
                if configFilename != "" </span><span class="cov0" title="0">{
                        var err error
                        cfg, err = config.FromFile(c.fs, configFilename)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrapf(err, "failed to read module config for %q in %q", tc.Path(), configFilename)
                        }</span>
                }

                <span class="cov0" title="0">tc.configFilename = configFilename
                tc.cfg = cfg</span>
        }

        <span class="cov8" title="1">config, err := DecodeConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">const oldVersionKey = "min_version"

        if hasThemeTOML </span><span class="cov8" title="1">{

                // Merge old with new
                if minVersion, found := themeCfg[oldVersionKey]; found </span><span class="cov8" title="1">{
                        if config.HugoVersion.Min == "" </span><span class="cov8" title="1">{
                                config.HugoVersion.Min = hugo.VersionString(cast.ToString(minVersion))
                        }</span>
                }

                <span class="cov8" title="1">if config.Params == nil </span><span class="cov8" title="1">{
                        config.Params = make(map[string]interface{})
                }</span>

                <span class="cov8" title="1">for k, v := range themeCfg </span><span class="cov8" title="1">{
                        if k == oldVersionKey </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">config.Params[k] = v</span>
                }

        }

        <span class="cov8" title="1">tc.config = config

        return nil</span>

}

func (c *collector) collect() <span class="cov8" title="1">{
        if err := c.initModules(); err != nil </span><span class="cov0" title="0">{
                c.err = err
                return
        }</span>

        <span class="cov8" title="1">projectMod := createProjectModule(c.gomods.GetMain(), c.ccfg.WorkingDir, c.moduleConfig)

        if err := c.addAndRecurse(projectMod, false); err != nil </span><span class="cov0" title="0">{
                c.err = err
                return
        }</span>

        // Add the project mod on top.
        <span class="cov8" title="1">c.modules = append(Modules{projectMod}, c.modules...)</span>

}

func (c *collector) collectModulesTXT(owner Module) error <span class="cov8" title="1">{
        vendorDir := filepath.Join(owner.Dir(), vendord)
        filename := filepath.Join(vendorDir, vendorModulesFilename)

        f, err := c.fs.Open(filename)

        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">defer f.Close()

        scanner := bufio.NewScanner(f)

        for scanner.Scan() </span><span class="cov0" title="0">{
                // # github.com/alecthomas/chroma v0.6.3
                line := scanner.Text()
                line = strings.Trim(line, "# ")
                line = strings.TrimSpace(line)
                parts := strings.Fields(line)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return errors.Errorf("invalid modules list: %q", filename)
                }</span>
                <span class="cov0" title="0">path := parts[0]
                if _, found := c.vendored[path]; !found </span><span class="cov0" title="0">{
                        c.vendored[path] = vendoredModule{
                                Owner:   owner,
                                Dir:     filepath.Join(vendorDir, path),
                                Version: parts[1],
                        }
                }</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func (c *collector) loadModules() error <span class="cov8" title="1">{
        modules, err := c.listGoMods()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">c.gomods = modules
        return nil</span>
}

func (c *collector) normalizeMounts(owner Module, mounts []Mount) ([]Mount, error) <span class="cov8" title="1">{
        var out []Mount
        dir := owner.Dir()

        for _, mnt := range mounts </span><span class="cov8" title="1">{
                errMsg := fmt.Sprintf("invalid module config for %q", owner.Path())

                if mnt.Source == "" || mnt.Target == "" </span><span class="cov0" title="0">{
                        return nil, errors.New(errMsg + ": both source and target must be set")
                }</span>

                <span class="cov8" title="1">mnt.Source = filepath.Clean(mnt.Source)
                mnt.Target = filepath.Clean(mnt.Target)

                // Verify that Source exists
                sourceDir := filepath.Join(dir, mnt.Source)
                _, err := c.fs.Stat(sourceDir)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Verify that target points to one of the predefined component dirs
                <span class="cov8" title="1">targetBase := mnt.Target
                idxPathSep := strings.Index(mnt.Target, string(os.PathSeparator))
                if idxPathSep != -1 </span><span class="cov0" title="0">{
                        targetBase = mnt.Target[0:idxPathSep]
                }</span>
                <span class="cov8" title="1">if !files.IsComponentFolder(targetBase) </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%s: mount target must be one of: %v", errMsg, files.ComponentFolders)
                }</span>

                <span class="cov8" title="1">out = append(out, mnt)</span>
        }

        <span class="cov8" title="1">return out, nil</span>
}

func (c *collector) wrapModuleNotFound(err error) error <span class="cov0" title="0">{
        err = errors.Wrap(ErrNotExist, err.Error())
        if c.GoModulesFilename == "" </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">baseMsg := "we found a go.mod file in your project, but"

        switch c.goBinaryStatus </span>{
        case goBinaryStatusNotFound:<span class="cov0" title="0">
                return errors.Wrap(err, baseMsg+" you need to install Go to use it. See https://golang.org/dl/.")</span>
        case goBinaryStatusTooOld:<span class="cov0" title="0">
                return errors.Wrap(err, baseMsg+" you need to a newer version of Go to use it. See https://golang.org/dl/.")</span>
        }

        <span class="cov0" title="0">return err</span>

}

type vendoredModule struct {
        Owner   Module
        Dir     string
        Version string
}

func createProjectModule(gomod *goModule, workingDir string, conf Config) *moduleAdapter <span class="cov8" title="1">{
        // Create a pseudo module for the main project.
        var path string
        if gomod == nil </span><span class="cov8" title="1">{
                path = "project"
        }</span>

        <span class="cov8" title="1">return &amp;moduleAdapter{
                path:       path,
                dir:        workingDir,
                gomod:      gomod,
                projectMod: true,
                config:     conf,
        }</span>

}

// In the first iteration of Hugo Modules, we do not support multiple
// major versions running at the same time, so we pick the first (upper most).
// We will investigate namespaces in future versions.
// TODO(bep) add a warning when the above happens.
func pathKey(p string) string <span class="cov8" title="1">{
        prefix, _, _ := module.SplitPathVersion(p)

        return strings.ToLower(prefix)
}</span>
</pre>
		
		<pre class="file" id="file149" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package modules

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/hugo"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/hugofs/files"
        "github.com/gohugoio/hugo/langs"
        "github.com/mitchellh/mapstructure"
)

var DefaultModuleConfig = Config{

        // Default to direct, which means "git clone" and similar. We
        // will investigate proxy settings in more depth later.
        // See https://github.com/golang/go/issues/26334
        Proxy: "direct",

        // Comma separated glob list matching paths that should not use the
        // proxy configured above.
        NoProxy: "none",

        // Comma separated glob list matching paths that should be
        // treated as private.
        Private: "*.*",
}

// ApplyProjectConfigDefaults applies default/missing module configuration for
// the main project.
func ApplyProjectConfigDefaults(cfg config.Provider, mod Module) error <span class="cov8" title="1">{
        moda := mod.(*moduleAdapter)

        // Map legacy directory config into the new module.
        languages := cfg.Get("languagesSortedDefaultFirst").(langs.Languages)
        isMultiHost := languages.IsMultihost()

        // To bridge between old and new configuration format we need
        // a way to make sure all of the core components are configured on
        // the basic level.
        componentsConfigured := make(map[string]bool)
        for _, mnt := range moda.mounts </span><span class="cov0" title="0">{
                componentsConfigured[mnt.Component()] = true
        }</span>

        <span class="cov8" title="1">type dirKeyComponent struct {
                key          string
                component    string
                multilingual bool
        }

        dirKeys := []dirKeyComponent{
                {"contentDir", files.ComponentFolderContent, true},
                {"dataDir", files.ComponentFolderData, false},
                {"layoutDir", files.ComponentFolderLayouts, false},
                {"i18nDir", files.ComponentFolderI18n, false},
                {"archetypeDir", files.ComponentFolderArchetypes, false},
                {"assetDir", files.ComponentFolderAssets, false},
                {"", files.ComponentFolderStatic, isMultiHost},
        }

        createMountsFor := func(d dirKeyComponent, cfg config.Provider) []Mount </span><span class="cov8" title="1">{
                var lang string
                if language, ok := cfg.(*langs.Language); ok </span><span class="cov0" title="0">{
                        lang = language.Lang
                }</span>

                // Static mounts are a little special.
                <span class="cov8" title="1">if d.component == files.ComponentFolderStatic </span><span class="cov8" title="1">{
                        var mounts []Mount
                        staticDirs := getStaticDirs(cfg)
                        if len(staticDirs) &gt; 0 </span><span class="cov0" title="0">{
                                componentsConfigured[d.component] = true
                        }</span>

                        <span class="cov8" title="1">for _, dir := range staticDirs </span><span class="cov0" title="0">{
                                mounts = append(mounts, Mount{Lang: lang, Source: dir, Target: d.component})
                        }</span>

                        <span class="cov8" title="1">return mounts</span>

                }

                <span class="cov8" title="1">if cfg.IsSet(d.key) </span><span class="cov8" title="1">{
                        source := cfg.GetString(d.key)
                        componentsConfigured[d.component] = true

                        return []Mount{Mount{
                                // No lang set for layouts etc.
                                Source: source,
                                Target: d.component}}
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">createMounts := func(d dirKeyComponent) []Mount </span><span class="cov8" title="1">{
                var mounts []Mount
                if d.multilingual </span><span class="cov8" title="1">{
                        if d.component == files.ComponentFolderContent </span><span class="cov8" title="1">{
                                seen := make(map[string]bool)
                                hasContentDir := false
                                for _, language := range languages </span><span class="cov8" title="1">{
                                        if language.ContentDir != "" </span><span class="cov8" title="1">{
                                                hasContentDir = true
                                                break</span>
                                        }
                                }

                                <span class="cov8" title="1">if hasContentDir </span><span class="cov8" title="1">{
                                        for _, language := range languages </span><span class="cov8" title="1">{
                                                contentDir := language.ContentDir
                                                if contentDir == "" </span><span class="cov0" title="0">{
                                                        contentDir = files.ComponentFolderContent
                                                }</span>
                                                <span class="cov8" title="1">if contentDir == "" || seen[contentDir] </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov8" title="1">seen[contentDir] = true
                                                mounts = append(mounts, Mount{Lang: language.Lang, Source: contentDir, Target: d.component})</span>
                                        }
                                }

                                <span class="cov8" title="1">componentsConfigured[d.component] = len(seen) &gt; 0</span>

                        } else<span class="cov0" title="0"> {
                                for _, language := range languages </span><span class="cov0" title="0">{
                                        mounts = append(mounts, createMountsFor(d, language)...)
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        mounts = append(mounts, createMountsFor(d, cfg)...)
                }</span>

                <span class="cov8" title="1">return mounts</span>
        }

        <span class="cov8" title="1">var mounts []Mount
        for _, dirKey := range dirKeys </span><span class="cov8" title="1">{
                if componentsConfigured[dirKey.component] </span><span class="cov0" title="0">{

                        continue</span>
                }

                <span class="cov8" title="1">mounts = append(mounts, createMounts(dirKey)...)</span>

        }

        // Add default configuration
        <span class="cov8" title="1">for _, dirKey := range dirKeys </span><span class="cov8" title="1">{
                if componentsConfigured[dirKey.component] </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">mounts = append(mounts, Mount{Source: dirKey.component, Target: dirKey.component})</span>
        }

        // Prepend the mounts from configuration.
        <span class="cov8" title="1">mounts = append(moda.mounts, mounts...)

        moda.mounts = mounts

        return nil</span>
}

// DecodeConfig creates a modules Config from a given Hugo configuration.
func DecodeConfig(cfg config.Provider) (Config, error) <span class="cov8" title="1">{
        c := DefaultModuleConfig

        if cfg == nil </span><span class="cov8" title="1">{
                return c, nil
        }</span>

        <span class="cov8" title="1">themeSet := cfg.IsSet("theme")
        moduleSet := cfg.IsSet("module")

        if moduleSet </span><span class="cov0" title="0">{
                m := cfg.GetStringMap("module")
                if err := mapstructure.WeakDecode(m, &amp;c); err != nil </span><span class="cov0" title="0">{
                        return c, err
                }</span>

                <span class="cov0" title="0">for i, mnt := range c.Mounts </span><span class="cov0" title="0">{
                        mnt.Source = filepath.Clean(mnt.Source)
                        mnt.Target = filepath.Clean(mnt.Target)
                        c.Mounts[i] = mnt
                }</span>

        }

        <span class="cov8" title="1">if themeSet </span><span class="cov8" title="1">{
                imports := config.GetStringSlicePreserveString(cfg, "theme")
                for _, imp := range imports </span><span class="cov8" title="1">{
                        c.Imports = append(c.Imports, Import{
                                Path: imp,
                        })
                }</span>

        }

        <span class="cov8" title="1">return c, nil</span>
}

// Config holds a module config.
type Config struct {
        Mounts  []Mount
        Imports []Import

        // Meta info about this module (license information etc.).
        Params map[string]interface{}

        // Will be validated against the running Hugo version.
        HugoVersion HugoVersion

        // Configures GOPROXY.
        Proxy string
        // Configures GONOPROXY.
        NoProxy string
        // Configures GOPRIVATE.
        Private string
}

// hasModuleImport reports whether the project config have one or more
// modules imports, e.g. github.com/bep/myshortcodes.
func (c Config) hasModuleImport() bool <span class="cov8" title="1">{
        for _, imp := range c.Imports </span><span class="cov8" title="1">{
                if isProbablyModule(imp.Path) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// HugoVersion holds Hugo binary version requirements for a module.
type HugoVersion struct {
        // The minimum Hugo version that this module works with.
        Min hugo.VersionString

        // The maxium Hugo version that this module works with.
        Max hugo.VersionString

        // Set if the extended version is needed.
        Extended bool
}

func (v HugoVersion) String() string <span class="cov0" title="0">{
        extended := ""
        if v.Extended </span><span class="cov0" title="0">{
                extended = " extended"
        }</span>

        <span class="cov0" title="0">if v.Min != "" &amp;&amp; v.Max != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s/%s%s", v.Min, v.Max, extended)
        }</span>

        <span class="cov0" title="0">if v.Min != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Min %s%s", v.Min, extended)
        }</span>

        <span class="cov0" title="0">if v.Max != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Max %s%s", v.Max, extended)
        }</span>

        <span class="cov0" title="0">return extended</span>
}

// IsValid reports whether this version is valid compared to the running
// Hugo binary.
func (v HugoVersion) IsValid() bool <span class="cov8" title="1">{
        current := hugo.CurrentVersion.Version()
        if v.Extended &amp;&amp; !hugo.IsExtended </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">isValid := true

        if v.Min != "" &amp;&amp; current.Compare(v.Min) &gt; 0 </span><span class="cov0" title="0">{
                isValid = false
        }</span>

        <span class="cov8" title="1">if v.Max != "" &amp;&amp; current.Compare(v.Max) &lt; 0 </span><span class="cov0" title="0">{
                isValid = false
        }</span>

        <span class="cov8" title="1">return isValid</span>
}

type Import struct {
        Path         string // Module path
        IgnoreConfig bool   // Ignore any config.toml found.
        Disable      bool   // Turn off this module.
        Mounts       []Mount
}

type Mount struct {
        Source string // relative path in source repo, e.g. "scss"
        Target string // relative target path, e.g. "assets/bootstrap/scss"

        Lang string // any language code associated with this mount.
}

func (m Mount) Component() string <span class="cov0" title="0">{
        return strings.Split(m.Target, fileSeparator)[0]
}</span>

func getStaticDirs(cfg config.Provider) []string <span class="cov8" title="1">{
        var staticDirs []string
        for i := -1; i &lt;= 10; i++ </span><span class="cov8" title="1">{
                staticDirs = append(staticDirs, getStringOrStringSlice(cfg, "staticDir", i)...)
        }</span>
        <span class="cov8" title="1">return staticDirs</span>
}

func getStringOrStringSlice(cfg config.Provider, key string, id int) []string <span class="cov8" title="1">{

        if id &gt;= 0 </span><span class="cov8" title="1">{
                key = fmt.Sprintf("%s%d", key, id)
        }</span>

        <span class="cov8" title="1">return config.GetStringSlicePreserveString(cfg, key)</span>

}
</pre>
		
		<pre class="file" id="file150" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package modules provides a client that can be used to manage Hugo Components,
// what's referred to as Hugo Modules. Hugo Modules is built on top of Go Modules,
// but also supports vendoring and components stored directly in the themes dir.
package modules

import (
        "github.com/gohugoio/hugo/config"
)

var _ Module = (*moduleAdapter)(nil)

type Module interface {

        // Optional config read from the configFilename above.
        Cfg() config.Provider

        // The decoded module config and mounts.
        Config() Config

        // Optional configuration filename (e.g. "/themes/mytheme/config.json").
        // This will be added to the special configuration watch list when in
        // server mode.
        ConfigFilename() string

        // Directory holding files for this module.
        Dir() string

        // This module is disabled.
        Disabled() bool

        // Returns whether this is a Go Module.
        IsGoMod() bool

        // Any directory remappings.
        Mounts() []Mount

        // In the dependency tree, this is the first module that defines this module
        // as a dependency.
        Owner() Module

        // Returns the path to this module.
        // This will either be the module path, e.g. "github.com/gohugoio/myshortcodes",
        // or the path below your /theme folder, e.g. "mytheme".
        Path() string

        // Replaced by this module.
        Replace() Module

        // Returns whether Dir points below the _vendor dir.
        Vendor() bool

        // The module version.
        Version() string

        // Whether this module's dir is a watch candidate.
        Watch() bool
}

type Modules []Module

type moduleAdapter struct {
        path       string
        dir        string
        version    string
        vendor     bool
        disabled   bool
        projectMod bool
        owner      Module

        mounts []Mount

        configFilename string
        cfg            config.Provider
        config         Config

        // Set if a Go module.
        gomod *goModule
}

func (m *moduleAdapter) Cfg() config.Provider <span class="cov0" title="0">{
        return m.cfg
}</span>

func (m *moduleAdapter) Config() Config <span class="cov8" title="1">{
        return m.config
}</span>

func (m *moduleAdapter) ConfigFilename() string <span class="cov8" title="1">{
        return m.configFilename
}</span>

func (m *moduleAdapter) Dir() string <span class="cov8" title="1">{
        // This may point to the _vendor dir.
        if !m.IsGoMod() || m.dir != "" </span><span class="cov8" title="1">{
                return m.dir
        }</span>
        <span class="cov0" title="0">return m.gomod.Dir</span>
}

func (m *moduleAdapter) Disabled() bool <span class="cov8" title="1">{
        return m.disabled
}</span>

func (m *moduleAdapter) IsGoMod() bool <span class="cov8" title="1">{
        return m.gomod != nil
}</span>

func (m *moduleAdapter) Mounts() []Mount <span class="cov8" title="1">{
        return m.mounts
}</span>

func (m *moduleAdapter) Owner() Module <span class="cov8" title="1">{
        return m.owner
}</span>

func (m *moduleAdapter) Path() string <span class="cov8" title="1">{
        if !m.IsGoMod() || m.path != "" </span><span class="cov8" title="1">{
                return m.path
        }</span>
        <span class="cov0" title="0">return m.gomod.Path</span>
}

func (m *moduleAdapter) Replace() Module <span class="cov0" title="0">{
        if m.IsGoMod() &amp;&amp; !m.Vendor() &amp;&amp; m.gomod.Replace != nil </span><span class="cov0" title="0">{
                return &amp;moduleAdapter{
                        gomod: m.gomod.Replace,
                        owner: m.owner,
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *moduleAdapter) Vendor() bool <span class="cov0" title="0">{
        return m.vendor
}</span>

func (m *moduleAdapter) Version() string <span class="cov0" title="0">{
        if !m.IsGoMod() || m.version != "" </span><span class="cov0" title="0">{
                return m.version
        }</span>
        <span class="cov0" title="0">return m.gomod.Version</span>
}

func (m *moduleAdapter) Watch() bool <span class="cov8" title="1">{
        if m.Owner() == nil </span><span class="cov8" title="1">{
                // Main project
                return true
        }</span>

        <span class="cov8" title="1">if !m.IsGoMod() </span><span class="cov8" title="1">{
                // Module inside /themes
                return true
        }</span>

        <span class="cov0" title="0">if m.Replace() != nil </span><span class="cov0" title="0">{
                // Version is not set when replaced by a local folder.
                return m.Replace().Version() == ""
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package navigation

import (
        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/compare"

        "html/template"
        "sort"
        "strings"

        "github.com/spf13/cast"
)

// MenuEntry represents a menu item defined in either Page front matter
// or in the site config.
type MenuEntry struct {
        ConfiguredURL string // The URL value from front matter / config.
        Page          Page
        Name          string
        Menu          string
        Identifier    string
        title         string
        Pre           template.HTML
        Post          template.HTML
        Weight        int
        Parent        string
        Children      Menu
}

func (m *MenuEntry) URL() string <span class="cov0" title="0">{
        if m.ConfiguredURL != "" </span><span class="cov0" title="0">{
                return m.ConfiguredURL
        }</span>

        <span class="cov0" title="0">if !types.IsNil(m.Page) </span><span class="cov0" title="0">{
                return m.Page.RelPermalink()
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// A narrow version of page.Page.
type Page interface {
        LinkTitle() string
        RelPermalink() string
        Section() string
        Weight() int
        IsPage() bool
        Params() map[string]interface{}
}

// Menu is a collection of menu entries.
type Menu []*MenuEntry

// Menus is a dictionary of menus.
type Menus map[string]Menu

// PageMenus is a dictionary of menus defined in the Pages.
type PageMenus map[string]*MenuEntry

// HasChildren returns whether this menu item has any children.
func (m *MenuEntry) HasChildren() bool <span class="cov0" title="0">{
        return m.Children != nil
}</span>

// KeyName returns the key used to identify this menu entry.
func (m *MenuEntry) KeyName() string <span class="cov0" title="0">{
        if m.Identifier != "" </span><span class="cov0" title="0">{
                return m.Identifier
        }</span>
        <span class="cov0" title="0">return m.Name</span>
}

func (m *MenuEntry) hopefullyUniqueID() string <span class="cov0" title="0">{
        if m.Identifier != "" </span><span class="cov0" title="0">{
                return m.Identifier
        }</span> else<span class="cov0" title="0"> if m.URL() != "" </span><span class="cov0" title="0">{
                return m.URL()
        }</span> else<span class="cov0" title="0"> {
                return m.Name
        }</span>
}

// IsEqual returns whether the two menu entries represents the same menu entry.
func (m *MenuEntry) IsEqual(inme *MenuEntry) bool <span class="cov0" title="0">{
        return m.hopefullyUniqueID() == inme.hopefullyUniqueID() &amp;&amp; m.Parent == inme.Parent
}</span>

// IsSameResource returns whether the two menu entries points to the same
// resource (URL).
func (m *MenuEntry) IsSameResource(inme *MenuEntry) bool <span class="cov0" title="0">{
        murl, inmeurl := m.URL(), inme.URL()
        return murl != "" &amp;&amp; inmeurl != "" &amp;&amp; murl == inmeurl
}</span>

func (m *MenuEntry) MarshallMap(ime map[string]interface{}) <span class="cov0" title="0">{
        for k, v := range ime </span><span class="cov0" title="0">{
                loki := strings.ToLower(k)
                switch loki </span>{
                case "url":<span class="cov0" title="0">
                        m.ConfiguredURL = cast.ToString(v)</span>
                case "weight":<span class="cov0" title="0">
                        m.Weight = cast.ToInt(v)</span>
                case "name":<span class="cov0" title="0">
                        m.Name = cast.ToString(v)</span>
                case "title":<span class="cov0" title="0">
                        m.title = cast.ToString(v)</span>
                case "pre":<span class="cov0" title="0">
                        m.Pre = template.HTML(cast.ToString(v))</span>
                case "post":<span class="cov0" title="0">
                        m.Post = template.HTML(cast.ToString(v))</span>
                case "identifier":<span class="cov0" title="0">
                        m.Identifier = cast.ToString(v)</span>
                case "parent":<span class="cov0" title="0">
                        m.Parent = cast.ToString(v)</span>
                }
        }
}

func (m Menu) Add(me *MenuEntry) Menu <span class="cov0" title="0">{
        m = append(m, me)
        // TODO(bep)
        m.Sort()
        return m
}</span>

/*
 * Implementation of a custom sorter for Menu
 */

// A type to implement the sort interface for Menu
type menuSorter struct {
        menu Menu
        by   menuEntryBy
}

// Closure used in the Sort.Less method.
type menuEntryBy func(m1, m2 *MenuEntry) bool

func (by menuEntryBy) Sort(menu Menu) <span class="cov0" title="0">{
        ms := &amp;menuSorter{
                menu: menu,
                by:   by, // The Sort method's receiver is the function (closure) that defines the sort order.
        }
        sort.Stable(ms)
}</span>

var defaultMenuEntrySort = func(m1, m2 *MenuEntry) bool <span class="cov0" title="0">{
        if m1.Weight == m2.Weight </span><span class="cov0" title="0">{
                c := compare.Strings(m1.Name, m2.Name)
                if c == 0 </span><span class="cov0" title="0">{
                        return m1.Identifier &lt; m2.Identifier
                }</span>
                <span class="cov0" title="0">return c &lt; 0</span>
        }

        <span class="cov0" title="0">if m2.Weight == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if m1.Weight == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return m1.Weight &lt; m2.Weight</span>
}

func (ms *menuSorter) Len() int      <span class="cov0" title="0">{ return len(ms.menu) }</span>
func (ms *menuSorter) Swap(i, j int) <span class="cov0" title="0">{ ms.menu[i], ms.menu[j] = ms.menu[j], ms.menu[i] }</span>

// Less is part of sort.Interface. It is implemented by calling the "by" closure in the sorter.
func (ms *menuSorter) Less(i, j int) bool <span class="cov0" title="0">{ return ms.by(ms.menu[i], ms.menu[j]) }</span>

// Sort sorts the menu by weight, name and then by identifier.
func (m Menu) Sort() Menu <span class="cov0" title="0">{
        menuEntryBy(defaultMenuEntrySort).Sort(m)
        return m
}</span>

// Limit limits the returned menu to n entries.
func (m Menu) Limit(n int) Menu <span class="cov0" title="0">{
        if len(m) &gt; n </span><span class="cov0" title="0">{
                return m[0:n]
        }</span>
        <span class="cov0" title="0">return m</span>
}

// ByWeight sorts the menu by the weight defined in the menu configuration.
func (m Menu) ByWeight() Menu <span class="cov0" title="0">{
        menuEntryBy(defaultMenuEntrySort).Sort(m)
        return m
}</span>

// ByName sorts the menu by the name defined in the menu configuration.
func (m Menu) ByName() Menu <span class="cov0" title="0">{
        title := func(m1, m2 *MenuEntry) bool </span><span class="cov0" title="0">{
                return compare.LessStrings(m1.Name, m2.Name)
        }</span>

        <span class="cov0" title="0">menuEntryBy(title).Sort(m)
        return m</span>
}

// Reverse reverses the order of the menu entries.
func (m Menu) Reverse() Menu <span class="cov0" title="0">{
        for i, j := 0, len(m)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                m[i], m[j] = m[j], m[i]
        }</span>

        <span class="cov0" title="0">return m</span>
}

func (m *MenuEntry) Title() string <span class="cov0" title="0">{
        if m.title != "" </span><span class="cov0" title="0">{
                return m.title
        }</span>

        <span class="cov0" title="0">if m.Page != nil </span><span class="cov0" title="0">{
                return m.Page.LinkTitle()
        }</span>

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package navigation

import (
        "github.com/pkg/errors"
        "github.com/spf13/cast"
)

type PageMenusProvider interface {
        PageMenusGetter
        MenuQueryProvider
}

type PageMenusGetter interface {
        Menus() PageMenus
}

type MenusGetter interface {
        Menus() Menus
}

type MenuQueryProvider interface {
        HasMenuCurrent(menuID string, me *MenuEntry) bool
        IsMenuCurrent(menuID string, inme *MenuEntry) bool
}

func PageMenusFromPage(p Page) (PageMenus, error) <span class="cov8" title="1">{
        params := p.Params()

        ms, ok := params["menus"]
        if !ok </span><span class="cov8" title="1">{
                ms, ok = params["menu"]
        }</span>

        <span class="cov8" title="1">pm := PageMenus{}

        if !ok </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">me := MenuEntry{Page: p, Name: p.LinkTitle(), Weight: p.Weight()}

        // Could be the name of the menu to attach it to
        mname, err := cast.ToStringE(ms)

        if err == nil </span><span class="cov0" title="0">{
                me.Menu = mname
                pm[mname] = &amp;me
                return pm, nil
        }</span>

        // Could be a slice of strings
        <span class="cov0" title="0">mnames, err := cast.ToStringSliceE(ms)

        if err == nil </span><span class="cov0" title="0">{
                for _, mname := range mnames </span><span class="cov0" title="0">{
                        me.Menu = mname
                        pm[mname] = &amp;me
                }</span>
                <span class="cov0" title="0">return pm, nil</span>
        }

        // Could be a structured menu entry
        <span class="cov0" title="0">menus, err := cast.ToStringMapE(ms)
        if err != nil </span><span class="cov0" title="0">{
                return pm, errors.Wrapf(err, "unable to process menus for %q", p.LinkTitle())
        }</span>

        <span class="cov0" title="0">for name, menu := range menus </span><span class="cov0" title="0">{
                menuEntry := MenuEntry{Page: p, Name: p.LinkTitle(), Weight: p.Weight(), Menu: name}
                if menu != nil </span><span class="cov0" title="0">{
                        ime, err := cast.ToStringMapE(menu)
                        if err != nil </span><span class="cov0" title="0">{
                                return pm, errors.Wrapf(err, "unable to process menus for %q", p.LinkTitle())
                        }</span>

                        <span class="cov0" title="0">menuEntry.MarshallMap(ime)</span>
                }
                <span class="cov0" title="0">pm[name] = &amp;menuEntry</span>
        }

        <span class="cov0" title="0">return pm, nil</span>

}

func NewMenuQueryProvider(
        setionPagesMenu string,
        pagem PageMenusGetter,
        sitem MenusGetter,
        p Page) MenuQueryProvider <span class="cov8" title="1">{

        return &amp;pageMenus{
                p:               p,
                pagem:           pagem,
                sitem:           sitem,
                setionPagesMenu: setionPagesMenu,
        }
}</span>

type pageMenus struct {
        pagem           PageMenusGetter
        sitem           MenusGetter
        setionPagesMenu string
        p               Page
}

func (pm *pageMenus) HasMenuCurrent(menuID string, me *MenuEntry) bool <span class="cov0" title="0">{

        // page is labeled as "shadow-member" of the menu with the same identifier as the section
        if pm.setionPagesMenu != "" </span><span class="cov0" title="0">{
                section := pm.p.Section()

                if section != "" &amp;&amp; pm.setionPagesMenu == menuID &amp;&amp; section == me.Identifier </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">if !me.HasChildren() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">menus := pm.pagem.Menus()

        if m, ok := menus[menuID]; ok </span><span class="cov0" title="0">{

                for _, child := range me.Children </span><span class="cov0" title="0">{
                        if child.IsEqual(m) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">if pm.HasMenuCurrent(menuID, child) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">if pm.p == nil || pm.p.IsPage() </span><span class="cov0" title="0">{
                return false
        }</span>

        // The following logic is kept from back when Hugo had both Page and Node types.
        // TODO(bep) consolidate / clean
        <span class="cov0" title="0">nme := MenuEntry{Page: pm.p, Name: pm.p.LinkTitle()}

        for _, child := range me.Children </span><span class="cov0" title="0">{
                if nme.IsSameResource(child) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if pm.HasMenuCurrent(menuID, child) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>

}

func (pm *pageMenus) IsMenuCurrent(menuID string, inme *MenuEntry) bool <span class="cov0" title="0">{
        menus := pm.pagem.Menus()

        if me, ok := menus[menuID]; ok </span><span class="cov0" title="0">{
                if me.IsEqual(inme) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">if pm.p == nil || pm.p.IsPage() </span><span class="cov0" title="0">{
                return false
        }</span>

        // The following logic is kept from back when Hugo had both Page and Node types.
        // TODO(bep) consolidate / clean
        <span class="cov0" title="0">me := MenuEntry{Page: pm.p, Name: pm.p.LinkTitle()}

        if !me.IsSameResource(inme) </span><span class="cov0" title="0">{
                return false
        }</span>

        // this resource may be included in several menus
        // search for it to make sure that it is in the menu with the given menuId
        <span class="cov0" title="0">if menu, ok := pm.sitem.Menus()[menuID]; ok </span><span class="cov0" title="0">{
                for _, menuEntry := range menu </span><span class="cov0" title="0">{
                        if menuEntry.IsSameResource(inme) </span><span class="cov0" title="0">{
                                return true
                        }</span>

                        <span class="cov0" title="0">descendantFound := pm.isSameAsDescendantMenu(inme, menuEntry)
                        if descendantFound </span><span class="cov0" title="0">{
                                return descendantFound
                        }</span>

                }
        }

        <span class="cov0" title="0">return false</span>
}

func (pm *pageMenus) isSameAsDescendantMenu(inme *MenuEntry, parent *MenuEntry) bool <span class="cov0" title="0">{
        if parent.HasChildren() </span><span class="cov0" title="0">{
                for _, child := range parent.Children </span><span class="cov0" title="0">{
                        if child.IsSameResource(inme) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">descendantFound := pm.isSameAsDescendantMenu(inme, child)
                        if descendantFound </span><span class="cov0" title="0">{
                                return descendantFound
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

var NopPageMenus = new(nopPageMenus)

type nopPageMenus int

func (m nopPageMenus) Menus() PageMenus <span class="cov0" title="0">{
        return PageMenus{}
}</span>

func (m nopPageMenus) HasMenuCurrent(menuID string, me *MenuEntry) bool <span class="cov0" title="0">{
        return false
}</span>

func (m nopPageMenus) IsMenuCurrent(menuID string, inme *MenuEntry) bool <span class="cov0" title="0">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file153" style="display: none">package output

import (
        "strings"

        //        "fmt"

        "github.com/gohugoio/hugo/docshelper"
)

// This is is just some helpers used to create some JSON used in the Hugo docs.
func init() <span class="cov8" title="1">{
        docsProvider := func() map[string]interface{} </span><span class="cov0" title="0">{
                docs := make(map[string]interface{})

                docs["formats"] = DefaultFormats
                docs["layouts"] = createLayoutExamples()
                return docs
        }</span>

        <span class="cov8" title="1">docshelper.AddDocProvider("output", docsProvider)</span>
}

func createLayoutExamples() interface{} <span class="cov0" title="0">{

        type Example struct {
                Example      string
                Kind         string
                OutputFormat string
                Suffix       string
                Layouts      []string `json:"Template Lookup Order"`
        }

        var (
                basicExamples []Example
                demoLayout    = "demolayout"
                demoType      = "demotype"
        )

        for _, example := range []struct {
                name string
                d    LayoutDescriptor
                f    Format
        }{
                // Taxonomy output.LayoutDescriptor={categories category taxonomy en  false Type Section
                {"Single page in \"posts\" section", LayoutDescriptor{Kind: "page", Type: "posts"}, HTMLFormat},
                {"Single page in \"posts\" section with layout set", LayoutDescriptor{Kind: "page", Type: "posts", Layout: demoLayout}, HTMLFormat},
                {"AMP single page", LayoutDescriptor{Kind: "page", Type: "posts"}, AMPFormat},
                {"AMP single page, French language", LayoutDescriptor{Kind: "page", Type: "posts", Lang: "fr"}, AMPFormat},
                // All section or typeless pages gets "page" as type
                {"Home page", LayoutDescriptor{Kind: "home", Type: "page"}, HTMLFormat},
                {"Home page with type set", LayoutDescriptor{Kind: "home", Type: demoType}, HTMLFormat},
                {"Home page with layout set", LayoutDescriptor{Kind: "home", Type: "page", Layout: demoLayout}, HTMLFormat},
                {`AMP home, French language"`, LayoutDescriptor{Kind: "home", Type: "page", Lang: "fr"}, AMPFormat},
                {"JSON home", LayoutDescriptor{Kind: "home", Type: "page"}, JSONFormat},
                {"RSS home", LayoutDescriptor{Kind: "home", Type: "page"}, RSSFormat},
                {"RSS section posts", LayoutDescriptor{Kind: "section", Type: "posts"}, RSSFormat},
                {"Taxonomy list in categories", LayoutDescriptor{Kind: "taxonomy", Type: "categories", Section: "category"}, RSSFormat},
                {"Taxonomy terms in categories", LayoutDescriptor{Kind: "taxonomyTerm", Type: "categories", Section: "category"}, RSSFormat},
                {"Section list for \"posts\" section", LayoutDescriptor{Kind: "section", Type: "posts", Section: "posts"}, HTMLFormat},
                {"Section list for \"posts\" section with type set to \"blog\"", LayoutDescriptor{Kind: "section", Type: "blog", Section: "posts"}, HTMLFormat},
                {"Section list for \"posts\" section with layout set to \"demoLayout\"", LayoutDescriptor{Kind: "section", Layout: demoLayout, Section: "posts"}, HTMLFormat},

                {"Taxonomy list in categories", LayoutDescriptor{Kind: "taxonomy", Type: "categories", Section: "category"}, HTMLFormat},
                {"Taxonomy term in categories", LayoutDescriptor{Kind: "taxonomyTerm", Type: "categories", Section: "category"}, HTMLFormat},
        } </span><span class="cov0" title="0">{

                l := NewLayoutHandler()
                layouts, _ := l.For(example.d, example.f)

                basicExamples = append(basicExamples, Example{
                        Example:      example.name,
                        Kind:         example.d.Kind,
                        OutputFormat: example.f.Name,
                        Suffix:       example.f.MediaType.Suffix(),
                        Layouts:      makeLayoutsPresentable(layouts)})
        }</span>

        <span class="cov0" title="0">return basicExamples</span>

}

func makeLayoutsPresentable(l []string) []string <span class="cov0" title="0">{
        var filtered []string
        for _, ll := range l </span><span class="cov0" title="0">{
                if strings.Contains(ll, "page/") </span><span class="cov0" title="0">{
                        // This is a valid lookup, but it's more confusing than useful.
                        continue</span>
                }
                <span class="cov0" title="0">ll = "layouts/" + strings.TrimPrefix(ll, "_text/")

                if !strings.Contains(ll, "indexes") </span><span class="cov0" title="0">{
                        filtered = append(filtered, ll)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package output

import (
        "fmt"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/helpers"
)

// These may be used as content sections with potential conflicts. Avoid that.
var reservedSections = map[string]bool{
        "shortcodes": true,
        "partials":   true,
}

// LayoutDescriptor describes how a layout should be chosen. This is
// typically built from a Page.
type LayoutDescriptor struct {
        Type    string
        Section string
        Kind    string
        Lang    string
        Layout  string
        // LayoutOverride indicates what we should only look for the above layout.
        LayoutOverride bool
}

// LayoutHandler calculates the layout template to use to render a given output type.
type LayoutHandler struct {
        mu    sync.RWMutex
        cache map[layoutCacheKey][]string
}

type layoutCacheKey struct {
        d LayoutDescriptor
        f string
}

// NewLayoutHandler creates a new LayoutHandler.
func NewLayoutHandler() *LayoutHandler <span class="cov8" title="1">{
        return &amp;LayoutHandler{cache: make(map[layoutCacheKey][]string)}
}</span>

// For returns a layout for the given LayoutDescriptor and options.
// Layouts are rendered and cached internally.
func (l *LayoutHandler) For(d LayoutDescriptor, f Format) ([]string, error) <span class="cov8" title="1">{

        // We will get lots of requests for the same layouts, so avoid recalculations.
        key := layoutCacheKey{d, f.Name}
        l.mu.RLock()
        if cacheVal, found := l.cache[key]; found </span><span class="cov0" title="0">{
                l.mu.RUnlock()
                return cacheVal, nil
        }</span>
        <span class="cov8" title="1">l.mu.RUnlock()

        layouts := resolvePageTemplate(d, f)

        layouts = prependTextPrefixIfNeeded(f, layouts...)
        layouts = helpers.UniqueStringsReuse(layouts)

        l.mu.Lock()
        l.cache[key] = layouts
        l.mu.Unlock()

        return layouts, nil</span>
}

type layoutBuilder struct {
        layoutVariations []string
        typeVariations   []string
        d                LayoutDescriptor
        f                Format
}

func (l *layoutBuilder) addLayoutVariations(vars ...string) <span class="cov8" title="1">{
        for _, layoutVar := range vars </span><span class="cov8" title="1">{
                if l.d.LayoutOverride &amp;&amp; layoutVar != l.d.Layout </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">l.layoutVariations = append(l.layoutVariations, layoutVar)</span>
        }
}

func (l *layoutBuilder) addTypeVariations(vars ...string) <span class="cov8" title="1">{
        for _, typeVar := range vars </span><span class="cov8" title="1">{
                if !reservedSections[typeVar] </span><span class="cov8" title="1">{
                        l.typeVariations = append(l.typeVariations, typeVar)
                }</span>
        }
}

func (l *layoutBuilder) addSectionType() <span class="cov8" title="1">{
        if l.d.Section != "" </span><span class="cov8" title="1">{
                l.addTypeVariations(l.d.Section)
        }</span>
}

func (l *layoutBuilder) addKind() <span class="cov8" title="1">{
        l.addLayoutVariations(l.d.Kind)
        l.addTypeVariations(l.d.Kind)
}</span>

func resolvePageTemplate(d LayoutDescriptor, f Format) []string <span class="cov8" title="1">{

        b := &amp;layoutBuilder{d: d, f: f}

        if d.Layout != "" </span><span class="cov0" title="0">{
                b.addLayoutVariations(d.Layout)
        }</span>

        <span class="cov8" title="1">if d.Type != "" </span><span class="cov8" title="1">{
                b.addTypeVariations(d.Type)
        }</span>

        <span class="cov8" title="1">switch d.Kind </span>{
        case "page":<span class="cov8" title="1">
                b.addLayoutVariations("single")
                b.addSectionType()</span>
        case "home":<span class="cov8" title="1">
                b.addLayoutVariations("index", "home")
                // Also look in the root
                b.addTypeVariations("")</span>
        case "section":<span class="cov8" title="1">
                if d.Section != "" </span><span class="cov8" title="1">{
                        b.addLayoutVariations(d.Section)
                }</span>
                <span class="cov8" title="1">b.addSectionType()
                b.addKind()</span>
        case "taxonomy":<span class="cov0" title="0">
                if d.Section != "" </span><span class="cov0" title="0">{
                        b.addLayoutVariations(d.Section)
                }</span>
                <span class="cov0" title="0">b.addKind()
                b.addSectionType()</span>

        case "taxonomyTerm":<span class="cov8" title="1">
                if d.Section != "" </span><span class="cov8" title="1">{
                        b.addLayoutVariations(d.Section + ".terms")
                }</span>
                <span class="cov8" title="1">b.addTypeVariations("taxonomy")
                b.addSectionType()
                b.addLayoutVariations("terms")</span>

        }

        <span class="cov8" title="1">isRSS := f.Name == RSSFormat.Name
        if isRSS </span><span class="cov8" title="1">{
                // The historic and common rss.xml case
                b.addLayoutVariations("")
        }</span>

        // All have _default in their lookup path
        <span class="cov8" title="1">b.addTypeVariations("_default")

        if d.Kind != "page" </span><span class="cov8" title="1">{
                // Add the common list type
                b.addLayoutVariations("list")
        }</span>

        <span class="cov8" title="1">layouts := b.resolveVariations()

        if isRSS </span><span class="cov8" title="1">{
                layouts = append(layouts, "_internal/_default/rss.xml")
        }</span>

        <span class="cov8" title="1">return layouts</span>

}

func (l *layoutBuilder) resolveVariations() []string <span class="cov8" title="1">{

        var layouts []string

        var variations []string
        name := strings.ToLower(l.f.Name)

        if l.d.Lang != "" </span><span class="cov8" title="1">{
                // We prefer the most specific type before language.
                variations = append(variations, []string{fmt.Sprintf("%s.%s", l.d.Lang, name), name, l.d.Lang}...)
        }</span> else<span class="cov0" title="0"> {
                variations = append(variations, name)
        }</span>

        <span class="cov8" title="1">variations = append(variations, "")

        for _, typeVar := range l.typeVariations </span><span class="cov8" title="1">{
                for _, variation := range variations </span><span class="cov8" title="1">{
                        for _, layoutVar := range l.layoutVariations </span><span class="cov8" title="1">{
                                if variation == "" &amp;&amp; layoutVar == "" </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">template := layoutTemplate(typeVar, layoutVar)
                                layouts = append(layouts, replaceKeyValues(template,
                                        "TYPE", typeVar,
                                        "LAYOUT", layoutVar,
                                        "VARIATIONS", variation,
                                        "EXTENSION", l.f.MediaType.Suffix(),
                                ))</span>
                        }
                }

        }

        <span class="cov8" title="1">return filterDotLess(layouts)</span>
}

func layoutTemplate(typeVar, layoutVar string) string <span class="cov8" title="1">{

        var l string

        if typeVar != "" </span><span class="cov8" title="1">{
                l = "TYPE/"
        }</span>

        <span class="cov8" title="1">if layoutVar != "" </span><span class="cov8" title="1">{
                l += "LAYOUT.VARIATIONS.EXTENSION"
        }</span> else<span class="cov8" title="1"> {
                l += "VARIATIONS.EXTENSION"
        }</span>

        <span class="cov8" title="1">return l</span>
}

func filterDotLess(layouts []string) []string <span class="cov8" title="1">{
        var filteredLayouts []string

        for _, l := range layouts </span><span class="cov8" title="1">{
                l = strings.Replace(l, "..", ".", -1)
                l = strings.Trim(l, ".")
                // If media type has no suffix, we have "index" type of layouts in this list, which
                // doesn't make much sense.
                if strings.Contains(l, ".") </span><span class="cov8" title="1">{
                        filteredLayouts = append(filteredLayouts, l)
                }</span>
        }

        <span class="cov8" title="1">return filteredLayouts</span>
}

func prependTextPrefixIfNeeded(f Format, layouts ...string) []string <span class="cov8" title="1">{
        if !f.IsPlainText </span><span class="cov8" title="1">{
                return layouts
        }</span>

        <span class="cov0" title="0">newLayouts := make([]string, len(layouts))

        for i, l := range layouts </span><span class="cov0" title="0">{
                newLayouts[i] = "_text/" + l
        }</span>

        <span class="cov0" title="0">return newLayouts</span>
}

func replaceKeyValues(s string, oldNew ...string) string <span class="cov8" title="1">{
        replacer := strings.NewReplacer(oldNew...)
        return replacer.Replace(s)
}</span>
</pre>
		
		<pre class="file" id="file155" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package output

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/helpers"
)

const (
        baseFileBase = "baseof"
)

var (
        aceTemplateInnerMarkers = [][]byte{[]byte("= content")}
        goTemplateInnerMarkers  = [][]byte{[]byte("{{define"), []byte("{{ define"), []byte("{{- define"), []byte("{{-define")}
)

// TemplateNames represents a template naming scheme.
type TemplateNames struct {
        // The name used as key in the template map. Note that this will be
        // prefixed with "_text/" if it should be parsed with text/template.
        Name string

        OverlayFilename string
        MasterFilename  string
}

// TemplateLookupDescriptor describes the template lookup configuration.
type TemplateLookupDescriptor struct {
        // The full path to the site root.
        WorkingDir string

        // The path to the template relative the the base.
        //  I.e. shortcodes/youtube.html
        RelPath string

        // The template name prefix to look for.
        Prefix string

        // All the output formats in play. This is used to decide if text/template or
        // html/template.
        OutputFormats Formats

        FileExists  func(filename string) (bool, error)
        ContainsAny func(filename string, subslices [][]byte) (bool, error)
}

func isShorthCodeOrPartial(name string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(name, "shortcodes/") || strings.HasPrefix(name, "partials/")
}</span>

// CreateTemplateNames returns a TemplateNames object for a given template.
func CreateTemplateNames(d TemplateLookupDescriptor) (TemplateNames, error) <span class="cov8" title="1">{

        name := filepath.ToSlash(d.RelPath)
        name = strings.TrimPrefix(name, "/")

        if d.Prefix != "" </span><span class="cov0" title="0">{
                name = strings.Trim(d.Prefix, "/") + "/" + name
        }</span>

        <span class="cov8" title="1">var (
                id TemplateNames
        )

        // The filename will have a suffix with an optional type indicator.
        // Examples:
        // index.html
        // index.amp.html
        // index.json
        filename := filepath.Base(d.RelPath)
        isPlainText := false
        outputFormat, found := d.OutputFormats.FromFilename(filename)

        if found &amp;&amp; outputFormat.IsPlainText </span><span class="cov8" title="1">{
                isPlainText = true
        }</span>

        <span class="cov8" title="1">var ext, outFormat string

        parts := strings.Split(filename, ".")
        if len(parts) &gt; 2 </span><span class="cov0" title="0">{
                outFormat = parts[1]
                ext = parts[2]
        }</span> else<span class="cov8" title="1"> if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                ext = parts[1]
        }</span>

        <span class="cov8" title="1">filenameNoSuffix := parts[0]

        id.OverlayFilename = d.RelPath
        id.Name = name

        if isPlainText </span><span class="cov8" title="1">{
                id.Name = "_text/" + id.Name
        }</span>

        // Ace and Go templates may have both a base and inner template.
        <span class="cov8" title="1">if ext == "amber" || isShorthCodeOrPartial(name) </span><span class="cov8" title="1">{
                // No base template support
                return id, nil
        }</span>

        <span class="cov8" title="1">pathDir := filepath.Dir(d.RelPath)

        innerMarkers := goTemplateInnerMarkers

        var baseFilename string

        if outFormat != "" </span><span class="cov0" title="0">{
                baseFilename = fmt.Sprintf("%s.%s.%s", baseFileBase, outFormat, ext)
        }</span> else<span class="cov8" title="1"> {
                baseFilename = fmt.Sprintf("%s.%s", baseFileBase, ext)
        }</span>

        <span class="cov8" title="1">if ext == "ace" </span><span class="cov0" title="0">{
                innerMarkers = aceTemplateInnerMarkers
        }</span>

        // This may be a view that shouldn't have base template
        // Have to look inside it to make sure
        <span class="cov8" title="1">needsBase, err := d.ContainsAny(d.RelPath, innerMarkers)
        if err != nil </span><span class="cov0" title="0">{
                return id, err
        }</span>

        <span class="cov8" title="1">if needsBase </span><span class="cov8" title="1">{
                currBaseFilename := fmt.Sprintf("%s-%s", filenameNoSuffix, baseFilename)

                // Look for base template in the follwing order:
                //   1. &lt;current-path&gt;/&lt;template-name&gt;-baseof.&lt;outputFormat&gt;(optional).&lt;suffix&gt;, e.g. list-baseof.&lt;outputFormat&gt;(optional).&lt;suffix&gt;.
                //   2. &lt;current-path&gt;/baseof.&lt;outputFormat&gt;(optional).&lt;suffix&gt;
                //   3. _default/&lt;template-name&gt;-baseof.&lt;outputFormat&gt;(optional).&lt;suffix&gt;, e.g. list-baseof.&lt;outputFormat&gt;(optional).&lt;suffix&gt;.
                //   4. _default/baseof.&lt;outputFormat&gt;(optional).&lt;suffix&gt;
                //
                // The filesystem it looks in a a composite of the project and potential theme(s).
                pathsToCheck := createPathsToCheck(pathDir, baseFilename, currBaseFilename)

                // We may have language code and/or "terms" in the template name. We want the most specific,
                // but need to fall back to the baseof.html or baseof.ace if needed.
                // E.g. list-baseof.en.html and list-baseof.terms.en.html
                // See #3893, #3856.
                baseBaseFilename, currBaseBaseFilename := helpers.Filename(baseFilename), helpers.Filename(currBaseFilename)
                p1, p2 := strings.Split(baseBaseFilename, "."), strings.Split(currBaseBaseFilename, ".")
                if len(p1) &gt; 0 &amp;&amp; len(p1) == len(p2) </span><span class="cov8" title="1">{
                        for i := len(p1); i &gt; 0; i-- </span><span class="cov8" title="1">{
                                v1, v2 := strings.Join(p1[:i], ".")+"."+ext, strings.Join(p2[:i], ".")+"."+ext
                                pathsToCheck = append(pathsToCheck, createPathsToCheck(pathDir, v1, v2)...)

                        }</span>
                }

                <span class="cov8" title="1">for _, p := range pathsToCheck </span><span class="cov8" title="1">{
                        if ok, err := d.FileExists(p); err == nil &amp;&amp; ok </span><span class="cov8" title="1">{
                                id.MasterFilename = p
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return id, nil</span>

}

func createPathsToCheck(baseTemplatedDir, baseFilename, currBaseFilename string) []string <span class="cov8" title="1">{
        return []string{
                filepath.Join(baseTemplatedDir, currBaseFilename),
                filepath.Join(baseTemplatedDir, baseFilename),
                filepath.Join("_default", currBaseFilename),
                filepath.Join("_default", baseFilename),
        }
}</span>
</pre>
		
		<pre class="file" id="file156" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package output

import (
        "encoding/json"
        "fmt"
        "sort"
        "strings"

        "reflect"

        "github.com/mitchellh/mapstructure"

        "github.com/gohugoio/hugo/media"
)

// Format represents an output representation, usually to a file on disk.
type Format struct {
        // The Name is used as an identifier. Internal output formats (i.e. HTML and RSS)
        // can be overridden by providing a new definition for those types.
        Name string `json:"name"`

        MediaType media.Type `json:"mediaType"`

        // Must be set to a value when there are two or more conflicting mediatype for the same resource.
        Path string `json:"path"`

        // The base output file name used when not using "ugly URLs", defaults to "index".
        BaseName string `json:"baseName"`

        // The value to use for rel links
        //
        // See https://www.w3schools.com/tags/att_link_rel.asp
        //
        // AMP has a special requirement in this department, see:
        // https://www.ampproject.org/docs/guides/deploy/discovery
        // I.e.:
        // &lt;link rel="amphtml" href="https://www.example.com/url/to/amp/document.html"&gt;
        Rel string `json:"rel"`

        // The protocol to use, i.e. "webcal://". Defaults to the protocol of the baseURL.
        Protocol string `json:"protocol"`

        // IsPlainText decides whether to use text/template or html/template
        // as template parser.
        IsPlainText bool `json:"isPlainText"`

        // IsHTML returns whether this format is int the HTML family. This includes
        // HTML, AMP etc. This is used to decide when to create alias redirects etc.
        IsHTML bool `json:"isHTML"`

        // Enable to ignore the global uglyURLs setting.
        NoUgly bool `json:"noUgly"`

        // Enable if it doesn't make sense to include this format in an alternative
        // format listing, CSS being one good example.
        // Note that we use the term "alternative" and not "alternate" here, as it
        // does not necessarily replace the other format, it is an alternative representation.
        NotAlternative bool `json:"notAlternative"`

        // Setting this will make this output format control the value of
        // .Permalink and .RelPermalink for a rendered Page.
        // If not set, these values will point to the main (first) output format
        // configured. That is probably the behaviour you want in most situations,
        // as you probably don't want to link back to the RSS version of a page, as an
        // example. AMP would, however, be a good example of an output format where this
        // behaviour is wanted.
        Permalinkable bool `json:"permalinkable"`

        // Setting this to a non-zero value will be used as the first sort criteria.
        Weight int `json:"weight"`
}

// An ordered list of built-in output formats.
var (
        AMPFormat = Format{
                Name:          "AMP",
                MediaType:     media.HTMLType,
                BaseName:      "index",
                Path:          "amp",
                Rel:           "amphtml",
                IsHTML:        true,
                Permalinkable: true,
                // See https://www.ampproject.org/learn/overview/
        }

        CalendarFormat = Format{
                Name:        "Calendar",
                MediaType:   media.CalendarType,
                IsPlainText: true,
                Protocol:    "webcal://",
                BaseName:    "index",
                Rel:         "alternate",
        }

        CSSFormat = Format{
                Name:           "CSS",
                MediaType:      media.CSSType,
                BaseName:       "styles",
                IsPlainText:    true,
                Rel:            "stylesheet",
                NotAlternative: true,
        }
        CSVFormat = Format{
                Name:        "CSV",
                MediaType:   media.CSVType,
                BaseName:    "index",
                IsPlainText: true,
                Rel:         "alternate",
        }

        HTMLFormat = Format{
                Name:          "HTML",
                MediaType:     media.HTMLType,
                BaseName:      "index",
                Rel:           "canonical",
                IsHTML:        true,
                Permalinkable: true,

                // Weight will be used as first sort criteria. HTML will, by default,
                // be rendered first, but set it to 10 so it's easy to put one above it.
                Weight: 10,
        }

        JSONFormat = Format{
                Name:        "JSON",
                MediaType:   media.JSONType,
                BaseName:    "index",
                IsPlainText: true,
                Rel:         "alternate",
        }

        RobotsTxtFormat = Format{
                Name:        "ROBOTS",
                MediaType:   media.TextType,
                BaseName:    "robots",
                IsPlainText: true,
                Rel:         "alternate",
        }

        RSSFormat = Format{
                Name:      "RSS",
                MediaType: media.RSSType,
                BaseName:  "index",
                NoUgly:    true,
                Rel:       "alternate",
        }

        SitemapFormat = Format{
                Name:      "Sitemap",
                MediaType: media.XMLType,
                BaseName:  "sitemap",
                NoUgly:    true,
                Rel:       "sitemap",
        }
)

// DefaultFormats contains the default output formats supported by Hugo.
var DefaultFormats = Formats{
        AMPFormat,
        CalendarFormat,
        CSSFormat,
        CSVFormat,
        HTMLFormat,
        JSONFormat,
        RobotsTxtFormat,
        RSSFormat,
        SitemapFormat,
}

func init() <span class="cov8" title="1">{
        sort.Sort(DefaultFormats)
}</span>

// Formats is a slice of Format.
type Formats []Format

func (formats Formats) Len() int      <span class="cov8" title="1">{ return len(formats) }</span>
func (formats Formats) Swap(i, j int) <span class="cov8" title="1">{ formats[i], formats[j] = formats[j], formats[i] }</span>
func (formats Formats) Less(i, j int) bool <span class="cov8" title="1">{
        fi, fj := formats[i], formats[j]
        if fi.Weight == fj.Weight </span><span class="cov8" title="1">{
                return fi.Name &lt; fj.Name
        }</span>

        <span class="cov8" title="1">if fj.Weight == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return fi.Weight &gt; 0 &amp;&amp; fi.Weight &lt; fj.Weight</span>

}

// GetBySuffix gets a output format given as suffix, e.g. "html".
// It will return false if no format could be found, or if the suffix given
// is ambiguous.
// The lookup is case insensitive.
func (formats Formats) GetBySuffix(suffix string) (f Format, found bool) <span class="cov8" title="1">{
        for _, ff := range formats </span><span class="cov8" title="1">{
                if strings.EqualFold(suffix, ff.MediaType.Suffix()) </span><span class="cov8" title="1">{
                        if found </span><span class="cov8" title="1">{
                                // ambiguous
                                found = false
                                return
                        }</span>
                        <span class="cov8" title="1">f = ff
                        found = true</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// GetByName gets a format by its identifier name.
func (formats Formats) GetByName(name string) (f Format, found bool) <span class="cov8" title="1">{
        for _, ff := range formats </span><span class="cov8" title="1">{
                if strings.EqualFold(name, ff.Name) </span><span class="cov8" title="1">{
                        f = ff
                        found = true
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// GetByNames gets a list of formats given a list of identifiers.
func (formats Formats) GetByNames(names ...string) (Formats, error) <span class="cov0" title="0">{
        var types []Format

        for _, name := range names </span><span class="cov0" title="0">{
                tpe, ok := formats.GetByName(name)
                if !ok </span><span class="cov0" title="0">{
                        return types, fmt.Errorf("OutputFormat with key %q not found", name)
                }</span>
                <span class="cov0" title="0">types = append(types, tpe)</span>
        }
        <span class="cov0" title="0">return types, nil</span>
}

// FromFilename gets a Format given a filename.
func (formats Formats) FromFilename(filename string) (f Format, found bool) <span class="cov8" title="1">{
        // mytemplate.amp.html
        // mytemplate.html
        // mytemplate
        var ext, outFormat string

        parts := strings.Split(filename, ".")
        if len(parts) &gt; 2 </span><span class="cov0" title="0">{
                outFormat = parts[1]
                ext = parts[2]
        }</span> else<span class="cov8" title="1"> if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                ext = parts[1]
        }</span>

        <span class="cov8" title="1">if outFormat != "" </span><span class="cov0" title="0">{
                return formats.GetByName(outFormat)
        }</span>

        <span class="cov8" title="1">if ext != "" </span><span class="cov8" title="1">{
                f, found = formats.GetBySuffix(ext)
                if !found &amp;&amp; len(parts) == 2 </span><span class="cov8" title="1">{
                        // For extensionless output formats (e.g. Netlify's _redirects)
                        // we must fall back to using the extension as format lookup.
                        f, found = formats.GetByName(ext)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// DecodeFormats takes a list of output format configurations and merges those,
// in the order given, with the Hugo defaults as the last resort.
func DecodeFormats(mediaTypes media.Types, maps ...map[string]interface{}) (Formats, error) <span class="cov8" title="1">{
        f := make(Formats, len(DefaultFormats))
        copy(f, DefaultFormats)

        for _, m := range maps </span><span class="cov0" title="0">{
                for k, v := range m </span><span class="cov0" title="0">{
                        found := false
                        for i, vv := range f </span><span class="cov0" title="0">{
                                if strings.EqualFold(k, vv.Name) </span><span class="cov0" title="0">{
                                        // Merge it with the existing
                                        if err := decode(mediaTypes, v, &amp;f[i]); err != nil </span><span class="cov0" title="0">{
                                                return f, err
                                        }</span>
                                        <span class="cov0" title="0">found = true</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                var newOutFormat Format
                                newOutFormat.Name = k
                                if err := decode(mediaTypes, v, &amp;newOutFormat); err != nil </span><span class="cov0" title="0">{
                                        return f, err
                                }</span>

                                // We need values for these
                                <span class="cov0" title="0">if newOutFormat.BaseName == "" </span><span class="cov0" title="0">{
                                        newOutFormat.BaseName = "index"
                                }</span>
                                <span class="cov0" title="0">if newOutFormat.Rel == "" </span><span class="cov0" title="0">{
                                        newOutFormat.Rel = "alternate"
                                }</span>

                                <span class="cov0" title="0">f = append(f, newOutFormat)</span>
                        }
                }
        }

        <span class="cov8" title="1">sort.Sort(f)

        return f, nil</span>
}

func decode(mediaTypes media.Types, input, output interface{}) error <span class="cov0" title="0">{
        config := &amp;mapstructure.DecoderConfig{
                Metadata:         nil,
                Result:           output,
                WeaklyTypedInput: true,
                DecodeHook: func(a reflect.Type, b reflect.Type, c interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        if a.Kind() == reflect.Map </span><span class="cov0" title="0">{
                                dataVal := reflect.Indirect(reflect.ValueOf(c))
                                for _, key := range dataVal.MapKeys() </span><span class="cov0" title="0">{
                                        keyStr, ok := key.Interface().(string)
                                        if !ok </span><span class="cov0" title="0">{
                                                // Not a string key
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if strings.EqualFold(keyStr, "mediaType") </span><span class="cov0" title="0">{
                                                // If mediaType is a string, look it up and replace it
                                                // in the map.
                                                vv := dataVal.MapIndex(key)
                                                if mediaTypeStr, ok := vv.Interface().(string); ok </span><span class="cov0" title="0">{
                                                        mediaType, found := mediaTypes.GetByType(mediaTypeStr)
                                                        if !found </span><span class="cov0" title="0">{
                                                                return c, fmt.Errorf("media type %q not found", mediaTypeStr)
                                                        }</span>
                                                        <span class="cov0" title="0">dataVal.SetMapIndex(key, reflect.ValueOf(mediaType))</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov0" title="0">return c, nil</span>
                },
        }

        <span class="cov0" title="0">decoder, err := mapstructure.NewDecoder(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return decoder.Decode(input)</span>
}

// BaseFilename returns the base filename of f including an extension (ie.
// "index.xml").
func (f Format) BaseFilename() string <span class="cov8" title="1">{
        return f.BaseName + f.MediaType.FullSuffix()
}</span>

// MarshalJSON returns the JSON encoding of f.
func (f Format) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        type Alias Format
        return json.Marshal(&amp;struct {
                MediaType string
                Alias
        }{
                MediaType: f.MediaType.String(),
                Alias:     (Alias)(f),
        })
}</span>
</pre>
		
		<pre class="file" id="file157" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package parser

import (
        "encoding/json"
        "errors"
        "io"

        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/BurntSushi/toml"

        yaml "gopkg.in/yaml.v2"
)

const (
        yamlDelimLf = "---\n"
        tomlDelimLf = "+++\n"
)

func InterfaceToConfig(in interface{}, format metadecoders.Format, w io.Writer) error <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return errors.New("input was nil")
        }</span>

        <span class="cov0" title="0">switch format </span>{
        case metadecoders.YAML:<span class="cov0" title="0">
                b, err := yaml.Marshal(in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = w.Write(b)
                return err</span>

        case metadecoders.TOML:<span class="cov0" title="0">
                return toml.NewEncoder(w).Encode(in)</span>
        case metadecoders.JSON:<span class="cov0" title="0">
                b, err := json.MarshalIndent(in, "", "   ")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = w.Write(b)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = w.Write([]byte{'\n'})
                return err</span>

        default:<span class="cov0" title="0">
                return errors.New("unsupported Format provided")</span>
        }
}

func InterfaceToFrontMatter(in interface{}, format metadecoders.Format, w io.Writer) error <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return errors.New("input was nil")
        }</span>

        <span class="cov0" title="0">switch format </span>{
        case metadecoders.YAML:<span class="cov0" title="0">
                _, err := w.Write([]byte(yamlDelimLf))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = InterfaceToConfig(in, format, w)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = w.Write([]byte(yamlDelimLf))
                return err</span>

        case metadecoders.TOML:<span class="cov0" title="0">
                _, err := w.Write([]byte(tomlDelimLf))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = InterfaceToConfig(in, format, w)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = w.Write([]byte("\n" + tomlDelimLf))
                return err</span>

        default:<span class="cov0" title="0">
                return InterfaceToConfig(in, format, w)</span>
        }
}
</pre>
		
		<pre class="file" id="file158" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metadecoders

import (
        "bytes"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/niklasfasching/go-org/org"

        "github.com/BurntSushi/toml"
        "github.com/pkg/errors"
        "github.com/spf13/afero"
        "github.com/spf13/cast"
        jww "github.com/spf13/jwalterweatherman"
        yaml "gopkg.in/yaml.v2"
)

// Decoder provides some configuration options for the decoders.
type Decoder struct {
        // Delimiter is the field delimiter used in the CSV decoder. It defaults to ','.
        Delimiter rune

        // Comment, if not 0, is the comment character ued in the CSV decoder. Lines beginning with the
        // Comment character without preceding whitespace are ignored.
        Comment rune
}

// OptionsKey is used in cache keys.
func (d Decoder) OptionsKey() string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteRune(d.Delimiter)
        sb.WriteRune(d.Comment)
        return sb.String()
}</span>

// Default is a Decoder in its default configuration.
var Default = Decoder{
        Delimiter: ',',
}

// UnmarshalToMap will unmarshall data in format f into a new map. This is
// what's needed for Hugo's front matter decoding.
func (d Decoder) UnmarshalToMap(data []byte, f Format) (map[string]interface{}, error) <span class="cov8" title="1">{
        m := make(map[string]interface{})
        if data == nil </span><span class="cov0" title="0">{
                return m, nil
        }</span>

        <span class="cov8" title="1">err := d.unmarshal(data, f, &amp;m)

        return m, err</span>
}

// UnmarshalFileToMap is the same as UnmarshalToMap, but reads the data from
// the given filename.
func (d Decoder) UnmarshalFileToMap(fs afero.Fs, filename string) (map[string]interface{}, error) <span class="cov8" title="1">{
        format := FormatFromString(filename)
        if format == "" </span><span class="cov0" title="0">{
                return nil, errors.Errorf("%q is not a valid configuration format", filename)
        }</span>

        <span class="cov8" title="1">data, err := afero.ReadFile(fs, filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return d.UnmarshalToMap(data, format)</span>
}

// UnmarshalStringTo tries to unmarshal data to a new instance of type typ.
func (d Decoder) UnmarshalStringTo(data string, typ interface{}) (interface{}, error) <span class="cov0" title="0">{
        data = strings.TrimSpace(data)
        // We only check for the possible types in YAML, JSON and TOML.
        switch typ.(type) </span>{
        case string:<span class="cov0" title="0">
                return data, nil</span>
        case map[string]interface{}:<span class="cov0" title="0">
                format := d.FormatFromContentString(data)
                return d.UnmarshalToMap([]byte(data), format)</span>
        case []interface{}:<span class="cov0" title="0">
                // A standalone slice. Let YAML handle it.
                return d.Unmarshal([]byte(data), YAML)</span>
        case bool:<span class="cov0" title="0">
                return cast.ToBoolE(data)</span>
        case int:<span class="cov0" title="0">
                return cast.ToIntE(data)</span>
        case int64:<span class="cov0" title="0">
                return cast.ToInt64E(data)</span>
        case float64:<span class="cov0" title="0">
                return cast.ToFloat64E(data)</span>
        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unmarshal: %T not supportedd", typ)</span>
        }
}

// Unmarshal will unmarshall data in format f into an interface{}.
// This is what's needed for Hugo's /data handling.
func (d Decoder) Unmarshal(data []byte, f Format) (interface{}, error) <span class="cov8" title="1">{
        if data == nil </span><span class="cov0" title="0">{
                switch f </span>{
                case CSV:<span class="cov0" title="0">
                        return make([][]string, 0), nil</span>
                default:<span class="cov0" title="0">
                        return make(map[string]interface{}), nil</span>
                }

        }
        <span class="cov8" title="1">var v interface{}
        err := d.unmarshal(data, f, &amp;v)

        return v, err</span>
}

// unmarshal unmarshals data in format f into v.
func (d Decoder) unmarshal(data []byte, f Format, v interface{}) error <span class="cov8" title="1">{

        var err error

        switch f </span>{
        case ORG:<span class="cov0" title="0">
                err = d.unmarshalORG(data, v)</span>
        case JSON:<span class="cov8" title="1">
                err = json.Unmarshal(data, v)</span>
        case TOML:<span class="cov8" title="1">
                err = toml.Unmarshal(data, v)</span>
        case YAML:<span class="cov8" title="1">
                err = yaml.Unmarshal(data, v)
                if err != nil </span><span class="cov0" title="0">{
                        return toFileError(f, errors.Wrap(err, "failed to unmarshal YAML"))
                }</span>

                // To support boolean keys, the YAML package unmarshals maps to
                // map[interface{}]interface{}. Here we recurse through the result
                // and change all maps to map[string]interface{} like we would've
                // gotten from `json`.
                <span class="cov8" title="1">var ptr interface{}
                switch v.(type) </span>{
                case *map[string]interface{}:<span class="cov8" title="1">
                        ptr = *v.(*map[string]interface{})</span>
                case *interface{}:<span class="cov0" title="0">
                        ptr = *v.(*interface{})</span>
                default:<span class="cov0" title="0">
                        return errors.Errorf("unknown type %T in YAML unmarshal", v)</span>
                }

                <span class="cov8" title="1">if mm, changed := stringifyMapKeys(ptr); changed </span><span class="cov0" title="0">{
                        switch v.(type) </span>{
                        case *map[string]interface{}:<span class="cov0" title="0">
                                *v.(*map[string]interface{}) = mm.(map[string]interface{})</span>
                        case *interface{}:<span class="cov0" title="0">
                                *v.(*interface{}) = mm</span>
                        }
                }
        case CSV:<span class="cov0" title="0">
                return d.unmarshalCSV(data, v)</span>

        default:<span class="cov0" title="0">
                return errors.Errorf("unmarshal of format %q is not supported", f)</span>
        }

        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">return toFileError(f, errors.Wrap(err, "unmarshal failed"))</span>

}

func (d Decoder) unmarshalCSV(data []byte, v interface{}) error <span class="cov0" title="0">{
        r := csv.NewReader(bytes.NewReader(data))
        r.Comma = d.Delimiter
        r.Comment = d.Comment

        records, err := r.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch v.(type) </span>{
        case *interface{}:<span class="cov0" title="0">
                *v.(*interface{}) = records</span>
        default:<span class="cov0" title="0">
                return errors.Errorf("CSV cannot be unmarshaled into %T", v)</span>

        }

        <span class="cov0" title="0">return nil</span>

}

func (d Decoder) unmarshalORG(data []byte, v interface{}) error <span class="cov0" title="0">{
        config := org.New()
        config.Log = jww.WARN
        document := config.Parse(bytes.NewReader(data), "")
        if document.Error != nil </span><span class="cov0" title="0">{
                return document.Error
        }</span>
        <span class="cov0" title="0">frontMatter := make(map[string]interface{}, len(document.BufferSettings))
        for k, v := range document.BufferSettings </span><span class="cov0" title="0">{
                k = strings.ToLower(k)
                if strings.HasSuffix(k, "[]") </span><span class="cov0" title="0">{
                        frontMatter[k[:len(k)-2]] = strings.Fields(v)
                }</span> else<span class="cov0" title="0"> if k == "tags" || k == "categories" || k == "aliases" </span><span class="cov0" title="0">{
                        jww.WARN.Printf("Please use '#+%s[]:' notation, automatic conversion is deprecated.", k)
                        frontMatter[k] = strings.Fields(v)
                }</span> else<span class="cov0" title="0"> {
                        frontMatter[k] = v
                }</span>
        }
        <span class="cov0" title="0">switch v.(type) </span>{
        case *map[string]interface{}:<span class="cov0" title="0">
                *v.(*map[string]interface{}) = frontMatter</span>
        default:<span class="cov0" title="0">
                *v.(*interface{}) = frontMatter</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func toFileError(f Format, err error) error <span class="cov0" title="0">{
        return herrors.ToFileError(string(f), err)
}</span>

// stringifyMapKeys recurses into in and changes all instances of
// map[interface{}]interface{} to map[string]interface{}. This is useful to
// work around the impedance mismatch between JSON and YAML unmarshaling that's
// described here: https://github.com/go-yaml/yaml/issues/139
//
// Inspired by https://github.com/stripe/stripe-mock, MIT licensed
func stringifyMapKeys(in interface{}) (interface{}, bool) <span class="cov8" title="1">{

        switch in := in.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                for i, v := range in </span><span class="cov0" title="0">{
                        if vv, replaced := stringifyMapKeys(v); replaced </span><span class="cov0" title="0">{
                                in[i] = vv
                        }</span>
                }
        case map[string]interface{}:<span class="cov8" title="1">
                for k, v := range in </span><span class="cov8" title="1">{
                        if vv, changed := stringifyMapKeys(v); changed </span><span class="cov0" title="0">{
                                in[k] = vv
                        }</span>
                }
        case map[interface{}]interface{}:<span class="cov0" title="0">
                res := make(map[string]interface{})
                var (
                        ok  bool
                        err error
                )
                for k, v := range in </span><span class="cov0" title="0">{
                        var ks string

                        if ks, ok = k.(string); !ok </span><span class="cov0" title="0">{
                                ks, err = cast.ToStringE(k)
                                if err != nil </span><span class="cov0" title="0">{
                                        ks = fmt.Sprintf("%v", k)
                                }</span>
                        }
                        <span class="cov0" title="0">if vv, replaced := stringifyMapKeys(v); replaced </span><span class="cov0" title="0">{
                                res[ks] = vv
                        }</span> else<span class="cov0" title="0"> {
                                res[ks] = v
                        }</span>
                }
                <span class="cov0" title="0">return res, true</span>
        }

        <span class="cov8" title="1">return nil, false</span>
}
</pre>
		
		<pre class="file" id="file159" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metadecoders

import (
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/media"

        "github.com/gohugoio/hugo/parser/pageparser"
)

type Format string

const (
        // These are the supported metdata  formats in Hugo. Most of these are also
        // supported as /data formats.
        ORG  Format = "org"
        JSON Format = "json"
        TOML Format = "toml"
        YAML Format = "yaml"
        CSV  Format = "csv"
)

// FormatFromString turns formatStr, typically a file extension without any ".",
// into a Format. It returns an empty string for unknown formats.
func FormatFromString(formatStr string) Format <span class="cov8" title="1">{
        formatStr = strings.ToLower(formatStr)
        if strings.Contains(formatStr, ".") </span><span class="cov8" title="1">{
                // Assume a filename
                formatStr = strings.TrimPrefix(filepath.Ext(formatStr), ".")

        }</span>
        <span class="cov8" title="1">switch formatStr </span>{
        case "yaml", "yml":<span class="cov0" title="0">
                return YAML</span>
        case "json":<span class="cov8" title="1">
                return JSON</span>
        case "toml":<span class="cov8" title="1">
                return TOML</span>
        case "org":<span class="cov0" title="0">
                return ORG</span>
        case "csv":<span class="cov0" title="0">
                return CSV</span>
        }

        <span class="cov0" title="0">return ""</span>

}

// FormatFromMediaType gets the Format given a MIME type, empty string
// if unknown.
func FormatFromMediaType(m media.Type) Format <span class="cov0" title="0">{
        for _, suffix := range m.Suffixes </span><span class="cov0" title="0">{
                if f := FormatFromString(suffix); f != "" </span><span class="cov0" title="0">{
                        return f
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// FormatFromFrontMatterType will return empty if not supported.
func FormatFromFrontMatterType(typ pageparser.ItemType) Format <span class="cov8" title="1">{
        switch typ </span>{
        case pageparser.TypeFrontMatterJSON:<span class="cov0" title="0">
                return JSON</span>
        case pageparser.TypeFrontMatterORG:<span class="cov0" title="0">
                return ORG</span>
        case pageparser.TypeFrontMatterTOML:<span class="cov0" title="0">
                return TOML</span>
        case pageparser.TypeFrontMatterYAML:<span class="cov8" title="1">
                return YAML</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// FormatFromContentString tries to detect the format (JSON, YAML or TOML)
// in the given string.
// It return an empty string if no format could be detected.
func (d Decoder) FormatFromContentString(data string) Format <span class="cov0" title="0">{
        csvIdx := strings.IndexRune(data, d.Delimiter)
        jsonIdx := strings.Index(data, "{")
        yamlIdx := strings.Index(data, ":")
        tomlIdx := strings.Index(data, "=")

        if isLowerIndexThan(csvIdx, jsonIdx, yamlIdx, tomlIdx) </span><span class="cov0" title="0">{
                return CSV
        }</span>

        <span class="cov0" title="0">if isLowerIndexThan(jsonIdx, yamlIdx, tomlIdx) </span><span class="cov0" title="0">{
                return JSON
        }</span>

        <span class="cov0" title="0">if isLowerIndexThan(yamlIdx, tomlIdx) </span><span class="cov0" title="0">{
                return YAML
        }</span>

        <span class="cov0" title="0">if tomlIdx != -1 </span><span class="cov0" title="0">{
                return TOML
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func isLowerIndexThan(first int, others ...int) bool <span class="cov0" title="0">{
        if first == -1 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, other := range others </span><span class="cov0" title="0">{
                if other != -1 &amp;&amp; other &lt; first </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pageparser

import (
        "bytes"
        "fmt"
)

type Item struct {
        Type ItemType
        Pos  int
        Val  []byte
}

type Items []Item

func (i Item) ValStr() string <span class="cov0" title="0">{
        return string(i.Val)
}</span>

func (i Item) IsText() bool <span class="cov0" title="0">{
        return i.Type == tText
}</span>

func (i Item) IsNonWhitespace() bool <span class="cov0" title="0">{
        return len(bytes.TrimSpace(i.Val)) &gt; 0
}</span>

func (i Item) IsShortcodeName() bool <span class="cov0" title="0">{
        return i.Type == tScName
}</span>

func (i Item) IsInlineShortcodeName() bool <span class="cov0" title="0">{
        return i.Type == tScNameInline
}</span>

func (i Item) IsLeftShortcodeDelim() bool <span class="cov8" title="1">{
        return i.Type == tLeftDelimScWithMarkup || i.Type == tLeftDelimScNoMarkup
}</span>

func (i Item) IsRightShortcodeDelim() bool <span class="cov0" title="0">{
        return i.Type == tRightDelimScWithMarkup || i.Type == tRightDelimScNoMarkup
}</span>

func (i Item) IsShortcodeClose() bool <span class="cov0" title="0">{
        return i.Type == tScClose
}</span>

func (i Item) IsShortcodeParam() bool <span class="cov0" title="0">{
        return i.Type == tScParam
}</span>

func (i Item) IsShortcodeParamVal() bool <span class="cov0" title="0">{
        return i.Type == tScParamVal
}</span>

func (i Item) IsShortcodeMarkupDelimiter() bool <span class="cov0" title="0">{
        return i.Type == tLeftDelimScWithMarkup || i.Type == tRightDelimScWithMarkup
}</span>

func (i Item) IsFrontMatter() bool <span class="cov8" title="1">{
        return i.Type &gt;= TypeFrontMatterYAML &amp;&amp; i.Type &lt;= TypeFrontMatterORG
}</span>

func (i Item) IsDone() bool <span class="cov8" title="1">{
        return i.Type == tError || i.Type == tEOF
}</span>

func (i Item) IsEOF() bool <span class="cov8" title="1">{
        return i.Type == tEOF
}</span>

func (i Item) IsError() bool <span class="cov8" title="1">{
        return i.Type == tError
}</span>

func (i Item) String() string <span class="cov0" title="0">{
        switch </span>{
        case i.Type == tEOF:<span class="cov0" title="0">
                return "EOF"</span>
        case i.Type == tError:<span class="cov0" title="0">
                return string(i.Val)</span>
        case i.Type &gt; tKeywordMarker:<span class="cov0" title="0">
                return fmt.Sprintf("&lt;%s&gt;", i.Val)</span>
        case len(i.Val) &gt; 50:<span class="cov0" title="0">
                return fmt.Sprintf("%v:%.20q...", i.Type, i.Val)</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%v:[%s]", i.Type, i.Val)</span>
}

type ItemType int

const (
        tError ItemType = iota
        tEOF

        // page items
        TypeHTMLStart          // document starting with &lt; as first non-whitespace
        TypeLeadSummaryDivider // &lt;!--more--&gt;,  # more
        TypeFrontMatterYAML
        TypeFrontMatterTOML
        TypeFrontMatterJSON
        TypeFrontMatterORG
        TypeEmoji
        TypeIgnore // // The BOM Unicode byte order marker and possibly others

        // shortcode items
        tLeftDelimScNoMarkup
        tRightDelimScNoMarkup
        tLeftDelimScWithMarkup
        tRightDelimScWithMarkup
        tScClose
        tScName
        tScNameInline
        tScParam
        tScParamVal

        tText // plain text

        // preserved for later - keywords come after this
        tKeywordMarker
)
</pre>
		
		<pre class="file" id="file161" style="display: none">// Code generated by "stringer -type ItemType"; DO NOT EDIT.

package pageparser

import "strconv"

const _ItemType_name = "tErrortEOFTypeHTMLStartTypeLeadSummaryDividerTypeFrontMatterYAMLTypeFrontMatterTOMLTypeFrontMatterJSONTypeFrontMatterORGTypeEmojiTypeIgnoretLeftDelimScNoMarkuptRightDelimScNoMarkuptLeftDelimScWithMarkuptRightDelimScWithMarkuptScClosetScNametScNameInlinetScParamtScParamValtTexttKeywordMarker"

var _ItemType_index = [...]uint16{0, 6, 10, 23, 45, 64, 83, 102, 120, 129, 139, 159, 180, 202, 225, 233, 240, 253, 261, 272, 277, 291}

func (i ItemType) String() string <span class="cov0" title="0">{
        if i &lt; 0 || i &gt;= ItemType(len(_ItemType_index)-1) </span><span class="cov0" title="0">{
                return "ItemType(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov0" title="0">return _ItemType_name[_ItemType_index[i]:_ItemType_index[i+1]]</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package pageparser provides a parser for Hugo content files (Markdown, HTML etc.) in Hugo.
// This implementation is highly inspired by the great talk given by Rob Pike called "Lexical Scanning in Go"
// It's on YouTube, Google it!.
// See slides here: http://cuddle.googlecode.com/hg/talk/lex.html
package pageparser

import (
        "bytes"
        "fmt"
        "unicode"
        "unicode/utf8"
)

const eof = -1

// returns the next state in scanner.
type stateFunc func(*pageLexer) stateFunc

type pageLexer struct {
        input      []byte
        stateStart stateFunc
        state      stateFunc
        pos        int // input position
        start      int // item start position
        width      int // width of last element

        // Contains lexers for shortcodes and other main section
        // elements.
        sectionHandlers *sectionHandlers

        cfg Config

        // The summary divider to look for.
        summaryDivider []byte
        // Set when we have parsed any summary divider
        summaryDividerChecked bool
        // Whether we're in a HTML comment.
        isInHTMLComment bool

        lexerShortcodeState

        // items delivered to client
        items Items
}

// Implement the Result interface
func (l *pageLexer) Iterator() *Iterator <span class="cov8" title="1">{
        return l.newIterator()
}</span>

func (l *pageLexer) Input() []byte <span class="cov8" title="1">{
        return l.input

}</span>

type Config struct {
        EnableEmoji bool
}

// note: the input position here is normally 0 (start), but
// can be set if position of first shortcode is known
func newPageLexer(input []byte, stateStart stateFunc, cfg Config) *pageLexer <span class="cov8" title="1">{
        lexer := &amp;pageLexer{
                input:      input,
                stateStart: stateStart,
                cfg:        cfg,
                lexerShortcodeState: lexerShortcodeState{
                        currLeftDelimItem:  tLeftDelimScNoMarkup,
                        currRightDelimItem: tRightDelimScNoMarkup,
                        openShortcodes:     make(map[string]bool),
                },
                items: make([]Item, 0, 5),
        }

        lexer.sectionHandlers = createSectionHandlers(lexer)

        return lexer
}</span>

func (l *pageLexer) newIterator() *Iterator <span class="cov8" title="1">{
        return &amp;Iterator{l: l, lastPos: -1}
}</span>

// main loop
func (l *pageLexer) run() *pageLexer <span class="cov8" title="1">{
        for l.state = l.stateStart; l.state != nil; </span><span class="cov8" title="1">{
                l.state = l.state(l)
        }</span>
        <span class="cov8" title="1">return l</span>
}

// Page syntax
var (
        byteOrderMark     = '\ufeff'
        summaryDivider    = []byte("&lt;!--more--&gt;")
        summaryDividerOrg = []byte("# more")
        delimTOML         = []byte("+++")
        delimYAML         = []byte("---")
        delimOrg          = []byte("#+")
        htmlCommentStart  = []byte("&lt;!--")
        htmlCommentEnd    = []byte("--&gt;")

        emojiDelim = byte(':')
)

func (l *pageLexer) next() rune <span class="cov8" title="1">{
        if l.pos &gt;= len(l.input) </span><span class="cov0" title="0">{
                l.width = 0
                return eof
        }</span>

        <span class="cov8" title="1">runeValue, runeWidth := utf8.DecodeRune(l.input[l.pos:])
        l.width = runeWidth
        l.pos += l.width
        return runeValue</span>
}

// peek, but no consume
func (l *pageLexer) peek() rune <span class="cov0" title="0">{
        r := l.next()
        l.backup()
        return r
}</span>

// steps back one
func (l *pageLexer) backup() <span class="cov8" title="1">{
        l.pos -= l.width
}</span>

// sends an item back to the client.
func (l *pageLexer) emit(t ItemType) <span class="cov8" title="1">{
        l.items = append(l.items, Item{t, l.start, l.input[l.start:l.pos]})
        l.start = l.pos
}</span>

func (l *pageLexer) isEOF() bool <span class="cov8" title="1">{
        return l.pos &gt;= len(l.input)
}</span>

// special case, do not send '\\' back to client
func (l *pageLexer) ignoreEscapesAndEmit(t ItemType) <span class="cov0" title="0">{
        val := bytes.Map(func(r rune) rune </span><span class="cov0" title="0">{
                if r == '\\' </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">return r</span>
        }, l.input[l.start:l.pos])
        <span class="cov0" title="0">l.items = append(l.items, Item{t, l.start, val})
        l.start = l.pos</span>
}

// gets the current value (for debugging and error handling)
func (l *pageLexer) current() []byte <span class="cov0" title="0">{
        return l.input[l.start:l.pos]
}</span>

// ignore current element
func (l *pageLexer) ignore() <span class="cov8" title="1">{
        l.start = l.pos
}</span>

var lf = []byte("\n")

// nil terminates the parser
func (l *pageLexer) errorf(format string, args ...interface{}) stateFunc <span class="cov0" title="0">{
        l.items = append(l.items, Item{tError, l.start, []byte(fmt.Sprintf(format, args...))})
        return nil
}</span>

func (l *pageLexer) consumeCRLF() bool <span class="cov8" title="1">{
        var consumed bool
        for _, r := range crLf </span><span class="cov8" title="1">{
                if l.next() != r </span><span class="cov8" title="1">{
                        l.backup()
                }</span> else<span class="cov8" title="1"> {
                        consumed = true
                }</span>
        }
        <span class="cov8" title="1">return consumed</span>
}

func (l *pageLexer) consumeToNextLine() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                r := l.next()
                if r == eof || isEndOfLine(r) </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

func (l *pageLexer) consumeSpace() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                r := l.next()
                if r == eof || !unicode.IsSpace(r) </span><span class="cov0" title="0">{
                        l.backup()
                        return
                }</span>
        }
}

// lex a string starting at ":"
func lexEmoji(l *pageLexer) stateFunc <span class="cov0" title="0">{
        pos := l.pos + 1
        valid := false

        for i := pos; i &lt; len(l.input); i++ </span><span class="cov0" title="0">{
                if i &gt; pos &amp;&amp; l.input[i] == emojiDelim </span><span class="cov0" title="0">{
                        pos = i + 1
                        valid = true
                        break</span>
                }
                <span class="cov0" title="0">r, _ := utf8.DecodeRune(l.input[i:])
                if !(isAlphaNumericOrHyphen(r) || r == '+') </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if valid </span><span class="cov0" title="0">{
                l.pos = pos
                l.emit(TypeEmoji)
        }</span> else<span class="cov0" title="0"> {
                l.pos++
                l.emit(tText)
        }</span>

        <span class="cov0" title="0">return lexMainSection</span>
}

type sectionHandlers struct {
        l *pageLexer

        // Set when none of the sections are found so we
        // can safely stop looking and skip to the end.
        skipAll bool

        handlers    []*sectionHandler
        skipIndexes []int
}

func (s *sectionHandlers) skip() int <span class="cov8" title="1">{
        if s.skipAll </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov8" title="1">s.skipIndexes = s.skipIndexes[:0]
        var shouldSkip bool
        for _, skipper := range s.handlers </span><span class="cov8" title="1">{
                idx := skipper.skip()
                if idx != -1 </span><span class="cov0" title="0">{
                        shouldSkip = true
                        s.skipIndexes = append(s.skipIndexes, idx)
                }</span>
        }

        <span class="cov8" title="1">if !shouldSkip </span><span class="cov8" title="1">{
                s.skipAll = true
                return -1
        }</span>

        <span class="cov0" title="0">return minIndex(s.skipIndexes...)</span>
}

func createSectionHandlers(l *pageLexer) *sectionHandlers <span class="cov8" title="1">{

        shortCodeHandler := &amp;sectionHandler{
                l: l,
                skipFunc: func(l *pageLexer) int </span><span class="cov8" title="1">{
                        return l.index(leftDelimSc)
                }</span>,
                lexFunc: func(origin stateFunc, l *pageLexer) (stateFunc, bool) <span class="cov0" title="0">{
                        if !l.isShortCodeStart() </span><span class="cov0" title="0">{
                                return origin, false
                        }</span>

                        <span class="cov0" title="0">if l.isInline </span><span class="cov0" title="0">{
                                // If we're inside an inline shortcode, the only valid shortcode markup is
                                // the markup which closes it.
                                b := l.input[l.pos+3:]
                                end := indexNonWhiteSpace(b, '/')
                                if end != len(l.input)-1 </span><span class="cov0" title="0">{
                                        b = bytes.TrimSpace(b[end+1:])
                                        if end == -1 || !bytes.HasPrefix(b, []byte(l.currShortcodeName+" ")) </span><span class="cov0" title="0">{
                                                return l.errorf("inline shortcodes do not support nesting"), true
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">if l.hasPrefix(leftDelimScWithMarkup) </span><span class="cov0" title="0">{
                                l.currLeftDelimItem = tLeftDelimScWithMarkup
                                l.currRightDelimItem = tRightDelimScWithMarkup
                        }</span> else<span class="cov0" title="0"> {
                                l.currLeftDelimItem = tLeftDelimScNoMarkup
                                l.currRightDelimItem = tRightDelimScNoMarkup
                        }</span>

                        <span class="cov0" title="0">return lexShortcodeLeftDelim, true</span>
                },
        }

        <span class="cov8" title="1">summaryDividerHandler := &amp;sectionHandler{
                l: l,
                skipFunc: func(l *pageLexer) int </span><span class="cov8" title="1">{
                        if l.summaryDividerChecked || l.summaryDivider == nil </span><span class="cov0" title="0">{
                                return -1

                        }</span>
                        <span class="cov8" title="1">return l.index(l.summaryDivider)</span>
                },
                lexFunc: func(origin stateFunc, l *pageLexer) (stateFunc, bool) <span class="cov0" title="0">{
                        if !l.hasPrefix(l.summaryDivider) </span><span class="cov0" title="0">{
                                return origin, false
                        }</span>

                        <span class="cov0" title="0">l.summaryDividerChecked = true
                        l.pos += len(l.summaryDivider)
                        // This makes it a little easier to reason about later.
                        l.consumeSpace()
                        l.emit(TypeLeadSummaryDivider)

                        return origin, true</span>

                },
        }

        <span class="cov8" title="1">handlers := []*sectionHandler{shortCodeHandler, summaryDividerHandler}

        if l.cfg.EnableEmoji </span><span class="cov0" title="0">{
                emojiHandler := &amp;sectionHandler{
                        l: l,
                        skipFunc: func(l *pageLexer) int </span><span class="cov0" title="0">{
                                return l.indexByte(emojiDelim)
                        }</span>,
                        lexFunc: func(origin stateFunc, l *pageLexer) (stateFunc, bool) <span class="cov0" title="0">{
                                return lexEmoji, true
                        }</span>,
                }

                <span class="cov0" title="0">handlers = append(handlers, emojiHandler)</span>
        }

        <span class="cov8" title="1">return &amp;sectionHandlers{
                l:           l,
                handlers:    handlers,
                skipIndexes: make([]int, len(handlers)),
        }</span>
}

func (s *sectionHandlers) lex(origin stateFunc) stateFunc <span class="cov0" title="0">{
        if s.skipAll </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if s.l.pos &gt; s.l.start </span><span class="cov0" title="0">{
                s.l.emit(tText)
        }</span>

        <span class="cov0" title="0">for _, handler := range s.handlers </span><span class="cov0" title="0">{
                if handler.skipAll </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">next, handled := handler.lexFunc(origin, handler.l)
                if next == nil || handled </span><span class="cov0" title="0">{
                        return next
                }</span>
        }

        // Not handled by the above.
        <span class="cov0" title="0">s.l.pos++

        return origin</span>
}

type sectionHandler struct {
        l *pageLexer

        // No more sections of this type.
        skipAll bool

        // Returns the index of the next match, -1 if none found.
        skipFunc func(l *pageLexer) int

        // Lex lexes the current section and returns the next state func and
        // a bool telling if this section was handled.
        // Note that returning nil as the next state will terminate the
        // lexer.
        lexFunc func(origin stateFunc, l *pageLexer) (stateFunc, bool)
}

func (s *sectionHandler) skip() int <span class="cov8" title="1">{
        if s.skipAll </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov8" title="1">idx := s.skipFunc(s.l)
        if idx == -1 </span><span class="cov8" title="1">{
                s.skipAll = true
        }</span>
        <span class="cov8" title="1">return idx</span>
}

func lexMainSection(l *pageLexer) stateFunc <span class="cov8" title="1">{

        if l.isEOF() </span><span class="cov0" title="0">{
                return lexDone
        }</span>

        <span class="cov8" title="1">if l.isInHTMLComment </span><span class="cov0" title="0">{
                return lexEndFromtMatterHTMLComment
        }</span>

        // Fast forward as far as possible.
        <span class="cov8" title="1">skip := l.sectionHandlers.skip()

        if skip == -1 </span><span class="cov8" title="1">{
                l.pos = len(l.input)
                return lexDone
        }</span> else<span class="cov0" title="0"> if skip &gt; 0 </span><span class="cov0" title="0">{
                l.pos += skip
        }</span>

        <span class="cov0" title="0">next := l.sectionHandlers.lex(lexMainSection)
        if next != nil </span><span class="cov0" title="0">{
                return next
        }</span>

        <span class="cov0" title="0">l.pos = len(l.input)
        return lexDone</span>

}

func lexDone(l *pageLexer) stateFunc <span class="cov8" title="1">{

        // Done!
        if l.pos &gt; l.start </span><span class="cov8" title="1">{
                l.emit(tText)
        }</span>
        <span class="cov8" title="1">l.emit(tEOF)
        return nil</span>
}

func (l *pageLexer) printCurrentInput() <span class="cov0" title="0">{
        fmt.Printf("input[%d:]: %q", l.pos, string(l.input[l.pos:]))
}</span>

// state helpers

func (l *pageLexer) index(sep []byte) int <span class="cov8" title="1">{
        return bytes.Index(l.input[l.pos:], sep)
}</span>

func (l *pageLexer) indexByte(sep byte) int <span class="cov0" title="0">{
        return bytes.IndexByte(l.input[l.pos:], sep)
}</span>

func (l *pageLexer) hasPrefix(prefix []byte) bool <span class="cov8" title="1">{
        return bytes.HasPrefix(l.input[l.pos:], prefix)
}</span>

// helper functions

// returns the min index &gt;= 0
func minIndex(indices ...int) int <span class="cov0" title="0">{
        min := -1

        for _, j := range indices </span><span class="cov0" title="0">{
                if j &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if min == -1 </span><span class="cov0" title="0">{
                        min = j
                }</span> else<span class="cov0" title="0"> if j &lt; min </span><span class="cov0" title="0">{
                        min = j
                }</span>
        }
        <span class="cov0" title="0">return min</span>
}

func indexNonWhiteSpace(s []byte, in rune) int <span class="cov0" title="0">{
        idx := bytes.IndexFunc(s, func(r rune) bool </span><span class="cov0" title="0">{
                return !unicode.IsSpace(r)
        }</span>)

        <span class="cov0" title="0">if idx == -1 </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">r, _ := utf8.DecodeRune(s[idx:])
        if r == in </span><span class="cov0" title="0">{
                return idx
        }</span>
        <span class="cov0" title="0">return -1</span>
}

func isSpace(r rune) bool <span class="cov0" title="0">{
        return r == ' ' || r == '\t'
}</span>

func isAlphaNumericOrHyphen(r rune) bool <span class="cov0" title="0">{
        // let unquoted YouTube ids as positional params slip through (they contain hyphens)
        return isAlphaNumeric(r) || r == '-'
}</span>

var crLf = []rune{'\r', '\n'}

func isEndOfLine(r rune) bool <span class="cov8" title="1">{
        return r == '\r' || r == '\n'
}</span>

func isAlphaNumeric(r rune) bool <span class="cov0" title="0">{
        return r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r)
}</span>
</pre>
		
		<pre class="file" id="file163" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package pageparser provides a parser for Hugo content files (Markdown, HTML etc.) in Hugo.
// This implementation is highly inspired by the great talk given by Rob Pike called "Lexical Scanning in Go"
// It's on YouTube, Google it!.
// See slides here: http://cuddle.googlecode.com/hg/talk/lex.html
package pageparser

func lexIntroSection(l *pageLexer) stateFunc <span class="cov8" title="1">{
        l.summaryDivider = summaryDivider

LOOP:
        for </span><span class="cov8" title="1">{
                r := l.next()
                if r == eof </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">switch </span>{
                case r == '+':<span class="cov0" title="0">
                        return l.lexFrontMatterSection(TypeFrontMatterTOML, r, "TOML", delimTOML)</span>
                case r == '-':<span class="cov8" title="1">
                        return l.lexFrontMatterSection(TypeFrontMatterYAML, r, "YAML", delimYAML)</span>
                case r == '{':<span class="cov0" title="0">
                        return lexFrontMatterJSON</span>
                case r == '#':<span class="cov0" title="0">
                        return lexFrontMatterOrgMode</span>
                case r == byteOrderMark:<span class="cov0" title="0">
                        l.emit(TypeIgnore)</span>
                case !isSpace(r) &amp;&amp; !isEndOfLine(r):<span class="cov0" title="0">
                        if r == '&lt;' </span><span class="cov0" title="0">{
                                l.backup()
                                if l.hasPrefix(htmlCommentStart) </span><span class="cov0" title="0">{
                                        // This may be commented out front mattter, which should
                                        // still be read.
                                        l.consumeToNextLine()
                                        l.isInHTMLComment = true
                                        l.emit(TypeIgnore)
                                        continue LOOP</span>
                                } else<span class="cov0" title="0"> {
                                        if l.pos &gt; l.start </span><span class="cov0" title="0">{
                                                l.emit(tText)
                                        }</span>
                                        <span class="cov0" title="0">l.next()
                                        // This is the start of a plain HTML document with no
                                        // front matter. I still can contain shortcodes, so we
                                        // have to keep looking.
                                        l.emit(TypeHTMLStart)</span>
                                }
                        }
                        <span class="cov0" title="0">break LOOP</span>
                }
        }

        // Now move on to the shortcodes.
        <span class="cov0" title="0">return lexMainSection</span>
}

func lexEndFromtMatterHTMLComment(l *pageLexer) stateFunc <span class="cov0" title="0">{
        l.isInHTMLComment = false
        right := l.index(htmlCommentEnd)
        if right == -1 </span><span class="cov0" title="0">{
                return l.errorf("starting HTML comment with no end")
        }</span>
        <span class="cov0" title="0">l.pos += right + len(htmlCommentEnd)
        l.emit(TypeIgnore)

        // Now move on to the shortcodes.
        return lexMainSection</span>
}

func lexFrontMatterJSON(l *pageLexer) stateFunc <span class="cov0" title="0">{
        // Include the left delimiter
        l.backup()

        var (
                inQuote bool
                level   int
        )

        for </span><span class="cov0" title="0">{

                r := l.next()

                switch </span>{
                case r == eof:<span class="cov0" title="0">
                        return l.errorf("unexpected EOF parsing JSON front matter")</span>
                case r == '{':<span class="cov0" title="0">
                        if !inQuote </span><span class="cov0" title="0">{
                                level++
                        }</span>
                case r == '}':<span class="cov0" title="0">
                        if !inQuote </span><span class="cov0" title="0">{
                                level--
                        }</span>
                case r == '"':<span class="cov0" title="0">
                        inQuote = !inQuote</span>
                case r == '\\':<span class="cov0" title="0">
                        // This may be an escaped quote. Make sure it's not marked as a
                        // real one.
                        l.next()</span>
                }

                <span class="cov0" title="0">if level == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">l.consumeCRLF()
        l.emit(TypeFrontMatterJSON)

        return lexMainSection</span>
}

func lexFrontMatterOrgMode(l *pageLexer) stateFunc <span class="cov0" title="0">{
        /*
                #+TITLE: Test File For chaseadamsio/goorgeous
                #+AUTHOR: Chase Adams
                #+DESCRIPTION: Just another golang parser for org content!
        */

        l.summaryDivider = summaryDividerOrg

        l.backup()

        if !l.hasPrefix(delimOrg) </span><span class="cov0" title="0">{
                return lexMainSection
        }</span>

        // Read lines until we no longer see a #+ prefix
<span class="cov0" title="0">LOOP:
        for </span><span class="cov0" title="0">{

                r := l.next()

                switch </span>{
                case r == '\n':<span class="cov0" title="0">
                        if !l.hasPrefix(delimOrg) </span><span class="cov0" title="0">{
                                break LOOP</span>
                        }
                case r == eof:<span class="cov0" title="0">
                        break LOOP</span>

                }
        }

        <span class="cov0" title="0">l.emit(TypeFrontMatterORG)

        return lexMainSection</span>

}

// Handle YAML or TOML front matter.
func (l *pageLexer) lexFrontMatterSection(tp ItemType, delimr rune, name string, delim []byte) stateFunc <span class="cov8" title="1">{

        for i := 0; i &lt; 2; i++ </span><span class="cov8" title="1">{
                if r := l.next(); r != delimr </span><span class="cov0" title="0">{
                        return l.errorf("invalid %s delimiter", name)
                }</span>
        }

        // Let front matter start at line 1
        <span class="cov8" title="1">wasEndOfLine := l.consumeCRLF()
        // We don't care about the delimiters.
        l.ignore()

        var r rune

        for </span><span class="cov8" title="1">{
                if !wasEndOfLine </span><span class="cov8" title="1">{
                        r = l.next()
                        if r == eof </span><span class="cov0" title="0">{
                                return l.errorf("EOF looking for end %s front matter delimiter", name)
                        }</span>
                }

                <span class="cov8" title="1">if wasEndOfLine || isEndOfLine(r) </span><span class="cov8" title="1">{
                        if l.hasPrefix(delim) </span><span class="cov8" title="1">{
                                l.emit(tp)
                                l.pos += 3
                                l.consumeCRLF()
                                l.ignore()
                                break</span>
                        }
                }

                <span class="cov8" title="1">wasEndOfLine = false</span>
        }

        <span class="cov8" title="1">return lexMainSection</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package pageparser provides a parser for Hugo content files (Markdown, HTML etc.) in Hugo.
// This implementation is highly inspired by the great talk given by Rob Pike called "Lexical Scanning in Go"
// It's on YouTube, Google it!.
// See slides here: http://cuddle.googlecode.com/hg/talk/lex.html
package pageparser

type lexerShortcodeState struct {
        currLeftDelimItem  ItemType
        currRightDelimItem ItemType
        isInline           bool
        currShortcodeName  string          // is only set when a shortcode is in opened state
        closingState       int             // &gt; 0 = on its way to be closed
        elementStepNum     int             // step number in element
        paramElements      int             // number of elements (name + value = 2) found first
        openShortcodes     map[string]bool // set of shortcodes in open state

}

// Shortcode syntax
var (
        leftDelimSc            = []byte("{{")
        leftDelimScNoMarkup    = []byte("{{&lt;")
        rightDelimScNoMarkup   = []byte("&gt;}}")
        leftDelimScWithMarkup  = []byte("{{%")
        rightDelimScWithMarkup = []byte("%}}")
        leftComment            = []byte("/*") // comments in this context us used to to mark shortcodes as "not really a shortcode"
        rightComment           = []byte("*/")
)

func (l *pageLexer) isShortCodeStart() bool <span class="cov0" title="0">{
        return l.hasPrefix(leftDelimScWithMarkup) || l.hasPrefix(leftDelimScNoMarkup)
}</span>

func lexShortcodeLeftDelim(l *pageLexer) stateFunc <span class="cov0" title="0">{
        l.pos += len(l.currentLeftShortcodeDelim())
        if l.hasPrefix(leftComment) </span><span class="cov0" title="0">{
                return lexShortcodeComment
        }</span>
        <span class="cov0" title="0">l.emit(l.currentLeftShortcodeDelimItem())
        l.elementStepNum = 0
        l.paramElements = 0
        return lexInsideShortcode</span>
}

func lexShortcodeComment(l *pageLexer) stateFunc <span class="cov0" title="0">{
        posRightComment := l.index(append(rightComment, l.currentRightShortcodeDelim()...))
        if posRightComment &lt;= 1 </span><span class="cov0" title="0">{
                return l.errorf("comment must be closed")
        }</span>
        // we emit all as text, except the comment markers
        <span class="cov0" title="0">l.emit(tText)
        l.pos += len(leftComment)
        l.ignore()
        l.pos += posRightComment - len(leftComment)
        l.emit(tText)
        l.pos += len(rightComment)
        l.ignore()
        l.pos += len(l.currentRightShortcodeDelim())
        l.emit(tText)
        return lexMainSection</span>
}

func lexShortcodeRightDelim(l *pageLexer) stateFunc <span class="cov0" title="0">{
        l.closingState = 0
        l.pos += len(l.currentRightShortcodeDelim())
        l.emit(l.currentRightShortcodeDelimItem())
        return lexMainSection
}</span>

// either:
// 1. param
// 2. "param" or "param\"
// 3. param="123" or param="123\"
// 4. param="Some \"escaped\" text"
func lexShortcodeParam(l *pageLexer, escapedQuoteStart bool) stateFunc <span class="cov0" title="0">{

        first := true
        nextEq := false

        var r rune

        for </span><span class="cov0" title="0">{
                r = l.next()
                if first </span><span class="cov0" title="0">{
                        if r == '"' </span><span class="cov0" title="0">{
                                // a positional param with quotes
                                if l.paramElements == 2 </span><span class="cov0" title="0">{
                                        return l.errorf("got quoted positional parameter. Cannot mix named and positional parameters")
                                }</span>
                                <span class="cov0" title="0">l.paramElements = 1
                                l.backup()
                                return lexShortcodeQuotedParamVal(l, !escapedQuoteStart, tScParam)</span>
                        }
                        <span class="cov0" title="0">first = false</span>
                } else<span class="cov0" title="0"> if r == '=' </span><span class="cov0" title="0">{
                        // a named param
                        l.backup()
                        nextEq = true
                        break</span>
                }

                <span class="cov0" title="0">if !isAlphaNumericOrHyphen(r) </span><span class="cov0" title="0">{
                        l.backup()
                        break</span>
                }
        }

        <span class="cov0" title="0">if l.paramElements == 0 </span><span class="cov0" title="0">{
                l.paramElements++

                if nextEq </span><span class="cov0" title="0">{
                        l.paramElements++
                }</span>
        } else<span class="cov0" title="0"> {
                if nextEq &amp;&amp; l.paramElements == 1 </span><span class="cov0" title="0">{
                        return l.errorf("got named parameter '%s'. Cannot mix named and positional parameters", l.current())
                }</span> else<span class="cov0" title="0"> if !nextEq &amp;&amp; l.paramElements == 2 </span><span class="cov0" title="0">{
                        return l.errorf("got positional parameter '%s'. Cannot mix named and positional parameters", l.current())
                }</span>
        }

        <span class="cov0" title="0">l.emit(tScParam)
        return lexInsideShortcode</span>

}

func lexShortcodeQuotedParamVal(l *pageLexer, escapedQuotedValuesAllowed bool, typ ItemType) stateFunc <span class="cov0" title="0">{
        openQuoteFound := false
        escapedInnerQuoteFound := false
        escapedQuoteState := 0

Loop:
        for </span><span class="cov0" title="0">{
                switch r := l.next(); </span>{
                case r == '\\':<span class="cov0" title="0">
                        if l.peek() == '"' </span><span class="cov0" title="0">{
                                if openQuoteFound &amp;&amp; !escapedQuotedValuesAllowed </span><span class="cov0" title="0">{
                                        l.backup()
                                        break Loop</span>
                                } else<span class="cov0" title="0"> if openQuoteFound </span><span class="cov0" title="0">{
                                        // the coming quoute is inside
                                        escapedInnerQuoteFound = true
                                        escapedQuoteState = 1
                                }</span>
                        }
                case r == eof, r == '\n':<span class="cov0" title="0">
                        return l.errorf("unterminated quoted string in shortcode parameter-argument: '%s'", l.current())</span>
                case r == '"':<span class="cov0" title="0">
                        if escapedQuoteState == 0 </span><span class="cov0" title="0">{
                                if openQuoteFound </span><span class="cov0" title="0">{
                                        l.backup()
                                        break Loop</span>

                                } else<span class="cov0" title="0"> {
                                        openQuoteFound = true
                                        l.ignore()
                                }</span>
                        } else<span class="cov0" title="0"> {
                                escapedQuoteState = 0
                        }</span>

                }
        }

        <span class="cov0" title="0">if escapedInnerQuoteFound </span><span class="cov0" title="0">{
                l.ignoreEscapesAndEmit(typ)
        }</span> else<span class="cov0" title="0"> {
                l.emit(typ)
        }</span>

        <span class="cov0" title="0">r := l.next()

        if r == '\\' </span><span class="cov0" title="0">{
                if l.peek() == '"' </span><span class="cov0" title="0">{
                        // ignore the escaped closing quote
                        l.ignore()
                        l.next()
                        l.ignore()
                }</span>
        } else<span class="cov0" title="0"> if r == '"' </span><span class="cov0" title="0">{
                // ignore closing quote
                l.ignore()
        }</span> else<span class="cov0" title="0"> {
                // handled by next state
                l.backup()
        }</span>

        <span class="cov0" title="0">return lexInsideShortcode</span>
}

// Inline shortcodes has the form {{&lt; myshortcode.inline &gt;}}
var inlineIdentifier = []byte("inline ")

// scans an alphanumeric inside shortcode
func lexIdentifierInShortcode(l *pageLexer) stateFunc <span class="cov0" title="0">{
        lookForEnd := false
Loop:
        for </span><span class="cov0" title="0">{
                switch r := l.next(); </span>{
                case isAlphaNumericOrHyphen(r):<span class="cov0" title="0"></span>
                // Allow forward slash inside names to make it possible to create namespaces.
                case r == '/':<span class="cov0" title="0"></span>
                case r == '.':<span class="cov0" title="0">
                        l.isInline = l.hasPrefix(inlineIdentifier)
                        if !l.isInline </span><span class="cov0" title="0">{
                                return l.errorf("period in shortcode name only allowed for inline identifiers")
                        }</span>
                default:<span class="cov0" title="0">
                        l.backup()
                        word := string(l.input[l.start:l.pos])
                        if l.closingState &gt; 0 &amp;&amp; !l.openShortcodes[word] </span><span class="cov0" title="0">{
                                return l.errorf("closing tag for shortcode '%s' does not match start tag", word)
                        }</span> else<span class="cov0" title="0"> if l.closingState &gt; 0 </span><span class="cov0" title="0">{
                                l.openShortcodes[word] = false
                                lookForEnd = true
                        }</span>

                        <span class="cov0" title="0">l.closingState = 0
                        l.currShortcodeName = word
                        l.openShortcodes[word] = true
                        l.elementStepNum++
                        if l.isInline </span><span class="cov0" title="0">{
                                l.emit(tScNameInline)
                        }</span> else<span class="cov0" title="0"> {
                                l.emit(tScName)
                        }</span>
                        <span class="cov0" title="0">break Loop</span>
                }
        }

        <span class="cov0" title="0">if lookForEnd </span><span class="cov0" title="0">{
                return lexEndOfShortcode
        }</span>
        <span class="cov0" title="0">return lexInsideShortcode</span>
}

func lexEndOfShortcode(l *pageLexer) stateFunc <span class="cov0" title="0">{
        l.isInline = false
        if l.hasPrefix(l.currentRightShortcodeDelim()) </span><span class="cov0" title="0">{
                return lexShortcodeRightDelim
        }</span>
        <span class="cov0" title="0">switch r := l.next(); </span>{
        case isSpace(r):<span class="cov0" title="0">
                l.ignore()</span>
        default:<span class="cov0" title="0">
                return l.errorf("unclosed shortcode")</span>
        }
        <span class="cov0" title="0">return lexEndOfShortcode</span>
}

// scans the elements inside shortcode tags
func lexInsideShortcode(l *pageLexer) stateFunc <span class="cov0" title="0">{
        if l.hasPrefix(l.currentRightShortcodeDelim()) </span><span class="cov0" title="0">{
                return lexShortcodeRightDelim
        }</span>
        <span class="cov0" title="0">switch r := l.next(); </span>{
        case r == eof:<span class="cov0" title="0">
                // eol is allowed inside shortcodes; this may go to end of document before it fails
                return l.errorf("unclosed shortcode action")</span>
        case isSpace(r), isEndOfLine(r):<span class="cov0" title="0">
                l.ignore()</span>
        case r == '=':<span class="cov0" title="0">
                l.ignore()
                return lexShortcodeQuotedParamVal(l, l.peek() != '\\', tScParamVal)</span>
        case r == '/':<span class="cov0" title="0">
                if l.currShortcodeName == "" </span><span class="cov0" title="0">{
                        return l.errorf("got closing shortcode, but none is open")
                }</span>
                <span class="cov0" title="0">l.closingState++
                l.isInline = false
                l.emit(tScClose)</span>
        case r == '\\':<span class="cov0" title="0">
                l.ignore()
                if l.peek() == '"' </span><span class="cov0" title="0">{
                        return lexShortcodeParam(l, true)
                }</span>
        case l.elementStepNum &gt; 0 &amp;&amp; (isAlphaNumericOrHyphen(r) || r == '"'):<span class="cov0" title="0"> // positional params can have quotes
                l.backup()
                return lexShortcodeParam(l, false)</span>
        case isAlphaNumeric(r):<span class="cov0" title="0">
                l.backup()
                return lexIdentifierInShortcode</span>
        default:<span class="cov0" title="0">
                return l.errorf("unrecognized character in shortcode action: %#U. Note: Parameters with non-alphanumeric args must be quoted", r)</span>
        }
        <span class="cov0" title="0">return lexInsideShortcode</span>
}

func (l *pageLexer) currentLeftShortcodeDelimItem() ItemType <span class="cov0" title="0">{
        return l.currLeftDelimItem
}</span>

func (l *pageLexer) currentRightShortcodeDelimItem() ItemType <span class="cov0" title="0">{
        return l.currRightDelimItem
}</span>

func (l *pageLexer) currentLeftShortcodeDelim() []byte <span class="cov0" title="0">{
        if l.currLeftDelimItem == tLeftDelimScWithMarkup </span><span class="cov0" title="0">{
                return leftDelimScWithMarkup
        }</span>
        <span class="cov0" title="0">return leftDelimScNoMarkup</span>

}

func (l *pageLexer) currentRightShortcodeDelim() []byte <span class="cov0" title="0">{
        if l.currRightDelimItem == tRightDelimScWithMarkup </span><span class="cov0" title="0">{
                return rightDelimScWithMarkup
        }</span>
        <span class="cov0" title="0">return rightDelimScNoMarkup</span>
}
</pre>
		
		<pre class="file" id="file165" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package pageparser provides a parser for Hugo content files (Markdown, HTML etc.) in Hugo.
// This implementation is highly inspired by the great talk given by Rob Pike called "Lexical Scanning in Go"
// It's on YouTube, Google it!.
// See slides here: http://cuddle.googlecode.com/hg/talk/lex.html
package pageparser

import (
        "bytes"
        "io"
        "io/ioutil"

        "github.com/pkg/errors"
)

// Result holds the parse result.
type Result interface {
        // Iterator returns a new Iterator positioned at the beginning of the parse tree.
        Iterator() *Iterator
        // Input returns the input to Parse.
        Input() []byte
}

var _ Result = (*pageLexer)(nil)

// Parse parses the page in the given reader according to the given Config.
// TODO(bep) now that we have improved the "lazy order" init, it *may* be
// some potential saving in doing a buffered approach where the first pass does
// the frontmatter only.
func Parse(r io.Reader, cfg Config) (Result, error) <span class="cov8" title="1">{
        return parseSection(r, cfg, lexIntroSection)
}</span>

// ParseMain parses starting with the main section. Used in tests.
func ParseMain(r io.Reader, cfg Config) (Result, error) <span class="cov0" title="0">{
        return parseSection(r, cfg, lexMainSection)
}</span>

func parseSection(r io.Reader, cfg Config, start stateFunc) (Result, error) <span class="cov8" title="1">{
        b, err := ioutil.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to read page content")
        }</span>
        <span class="cov8" title="1">return parseBytes(b, cfg, start)</span>
}

func parseBytes(b []byte, cfg Config, start stateFunc) (Result, error) <span class="cov8" title="1">{
        lexer := newPageLexer(b, start, cfg)
        lexer.run()
        return lexer, nil
}</span>

// An Iterator has methods to iterate a parsed page with support going back
// if needed.
type Iterator struct {
        l       *pageLexer
        lastPos int // position of the last item returned by nextItem
}

// consumes and returns the next item
func (t *Iterator) Next() Item <span class="cov8" title="1">{
        t.lastPos++
        return t.Current()
}</span>

// Input returns the input source.
func (t *Iterator) Input() []byte <span class="cov0" title="0">{
        return t.l.Input()
}</span>

var errIndexOutOfBounds = Item{tError, 0, []byte("no more tokens")}

// Current will repeatably return the current item.
func (t *Iterator) Current() Item <span class="cov8" title="1">{
        if t.lastPos &gt;= len(t.l.items) </span><span class="cov0" title="0">{
                return errIndexOutOfBounds
        }</span>
        <span class="cov8" title="1">return t.l.items[t.lastPos]</span>
}

// backs up one token.
func (t *Iterator) Backup() <span class="cov0" title="0">{
        if t.lastPos &lt; 0 </span><span class="cov0" title="0">{
                panic("need to go forward before going back")</span>
        }
        <span class="cov0" title="0">t.lastPos--</span>
}

// check for non-error and non-EOF types coming next
func (t *Iterator) IsValueNext() bool <span class="cov0" title="0">{
        i := t.Peek()
        return i.Type != tError &amp;&amp; i.Type != tEOF
}</span>

// look at, but do not consume, the next item
// repeated, sequential calls will return the same item
func (t *Iterator) Peek() Item <span class="cov8" title="1">{
        return t.l.items[t.lastPos+1]
}</span>

// PeekWalk will feed the next items in the iterator to walkFn
// until it returns false.
func (t *Iterator) PeekWalk(walkFn func(item Item) bool) <span class="cov0" title="0">{
        for i := t.lastPos + 1; i &lt; len(t.l.items); i++ </span><span class="cov0" title="0">{
                item := t.l.items[i]
                if !walkFn(item) </span><span class="cov0" title="0">{
                        break</span>
                }
        }
}

// Consume is a convencience method to consume the next n tokens,
// but back off Errors and EOF.
func (t *Iterator) Consume(cnt int) <span class="cov0" title="0">{
        for i := 0; i &lt; cnt; i++ </span><span class="cov0" title="0">{
                token := t.Next()
                if token.Type == tError || token.Type == tEOF </span><span class="cov0" title="0">{
                        t.Backup()
                        break</span>
                }
        }
}

// LineNumber returns the current line number. Used for logging.
func (t *Iterator) LineNumber() int <span class="cov0" title="0">{
        return bytes.Count(t.l.input[:t.Current().Pos], lf) + 1
}</span>
</pre>
		
		<pre class="file" id="file166" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package publisher

import (
        "errors"
        "io"
        "sync/atomic"

        "github.com/gohugoio/hugo/media"

        "github.com/gohugoio/hugo/minifiers"

        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/helpers"

        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/transform"
        "github.com/gohugoio/hugo/transform/livereloadinject"
        "github.com/gohugoio/hugo/transform/metainject"
        "github.com/gohugoio/hugo/transform/urlreplacers"
)

// Descriptor describes the needed publishing chain for an item.
type Descriptor struct {
        // The content to publish.
        Src io.Reader

        // The OutputFormat of the this content.
        OutputFormat output.Format

        // Where to publish this content. This is a filesystem-relative path.
        TargetPath string

        // Counter for the end build summary.
        StatCounter *uint64

        // Configuration that trigger pre-processing.
        // LiveReload script will be injected if this is &gt; 0
        LiveReloadPort int

        // Enable to inject the Hugo generated tag in the header. Is currently only
        // injected on the home page for HTML type of output formats.
        AddHugoGeneratorTag bool

        // If set, will replace all relative URLs with this one.
        AbsURLPath string

        // Enable to minify the output using the OutputFormat defined above to
        // pick the correct minifier configuration.
        Minify bool
}

// DestinationPublisher is the default and currently only publisher in Hugo. This
// publisher prepares and publishes an item to the defined destination, e.g. /public.
type DestinationPublisher struct {
        fs     afero.Fs
        minify bool
        min    minifiers.Client
}

// NewDestinationPublisher creates a new DestinationPublisher.
func NewDestinationPublisher(fs afero.Fs, outputFormats output.Formats, mediaTypes media.Types, minify bool) DestinationPublisher <span class="cov8" title="1">{
        pub := DestinationPublisher{fs: fs}
        if minify </span><span class="cov0" title="0">{
                pub.min = minifiers.New(mediaTypes, outputFormats)
                pub.minify = true
        }</span>
        <span class="cov8" title="1">return pub</span>
}

// Publish applies any relevant transformations and writes the file
// to its destination, e.g. /public.
func (p DestinationPublisher) Publish(d Descriptor) error <span class="cov8" title="1">{
        if d.TargetPath == "" </span><span class="cov0" title="0">{
                return errors.New("Publish: must provide a TargetPath")
        }</span>

        <span class="cov8" title="1">src := d.Src

        transformers := p.createTransformerChain(d)

        if len(transformers) != 0 </span><span class="cov8" title="1">{
                b := bp.GetBuffer()
                defer bp.PutBuffer(b)

                if err := transformers.Apply(b, d.Src); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // This is now what we write to disk.
                <span class="cov8" title="1">src = b</span>
        }

        <span class="cov8" title="1">f, err := helpers.OpenFileForWriting(p.fs, d.TargetPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        _, err = io.Copy(f, src)
        if err == nil &amp;&amp; d.StatCounter != nil </span><span class="cov8" title="1">{
                atomic.AddUint64(d.StatCounter, uint64(1))
        }</span>
        <span class="cov8" title="1">return err</span>
}

// Publisher publishes a result file.
type Publisher interface {
        Publish(d Descriptor) error
}

// XML transformer := transform.New(urlreplacers.NewAbsURLInXMLTransformer(path))
func (p DestinationPublisher) createTransformerChain(f Descriptor) transform.Chain <span class="cov8" title="1">{
        transformers := transform.NewEmpty()

        isHTML := f.OutputFormat.IsHTML

        if f.AbsURLPath != "" </span><span class="cov8" title="1">{
                if isHTML </span><span class="cov0" title="0">{
                        transformers = append(transformers, urlreplacers.NewAbsURLTransformer(f.AbsURLPath))
                }</span> else<span class="cov8" title="1"> {
                        // Assume XML.
                        transformers = append(transformers, urlreplacers.NewAbsURLInXMLTransformer(f.AbsURLPath))
                }</span>
        }

        <span class="cov8" title="1">if isHTML </span><span class="cov8" title="1">{
                if f.LiveReloadPort &gt; 0 </span><span class="cov0" title="0">{
                        transformers = append(transformers, livereloadinject.New(f.LiveReloadPort))
                }</span>

                // This is only injected on the home page.
                <span class="cov8" title="1">if f.AddHugoGeneratorTag </span><span class="cov8" title="1">{
                        transformers = append(transformers, metainject.HugoGenerator)
                }</span>

        }

        <span class="cov8" title="1">if p.minify </span><span class="cov0" title="0">{
                minifyTransformer := p.min.Transformer(f.OutputFormat.MediaType)
                if minifyTransformer != nil </span><span class="cov0" title="0">{
                        transformers = append(transformers, minifyTransformer)
                }</span>
        }

        <span class="cov8" title="1">return transformers</span>

}
</pre>
		
		<pre class="file" id="file167" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package related holds code to help finding related content.
package related

import (
        "errors"
        "fmt"
        "math"
        "sort"
        "strings"
        "time"

        "github.com/gohugoio/hugo/common/types"
        "github.com/mitchellh/mapstructure"
)

var (
        _        Keyword = (*StringKeyword)(nil)
        zeroDate         = time.Time{}

        // DefaultConfig is the default related config.
        DefaultConfig = Config{
                Threshold: 80,
                Indices: IndexConfigs{
                        IndexConfig{Name: "keywords", Weight: 100},
                        IndexConfig{Name: "date", Weight: 10},
                },
        }
)

/*
Config is the top level configuration element used to configure how to retrieve
related content in Hugo.

An example site config.toml:

        [related]
        threshold = 1
        [[related.indices]]
        name = "keywords"
        weight = 200
        [[related.indices]]
        name  = "tags"
        weight = 100
        [[related.indices]]
        name  = "date"
        weight = 1
        pattern = "2006"
*/
type Config struct {
        // Only include matches &gt;= threshold, a normalized rank between 0 and 100.
        Threshold int

        // To get stable "See also" sections we, by default, exclude newer related pages.
        IncludeNewer bool

        // Will lower case all string values and queries to the indices.
        // May get better results, but at a slight performance cost.
        ToLower bool

        Indices IndexConfigs
}

// Add adds a given index.
func (c *Config) Add(index IndexConfig) <span class="cov8" title="1">{
        if c.ToLower </span><span class="cov0" title="0">{
                index.ToLower = true
        }</span>
        <span class="cov8" title="1">c.Indices = append(c.Indices, index)</span>
}

// IndexConfigs holds a set of index configurations.
type IndexConfigs []IndexConfig

// IndexConfig configures an index.
type IndexConfig struct {
        // The index name. This directly maps to a field or Param name.
        Name string

        // Contextual pattern used to convert the Param value into a string.
        // Currently only used for dates. Can be used to, say, bump posts in the same
        // time frame when searching for related documents.
        // For dates it follows Go's time.Format patterns, i.e.
        // "2006" for YYYY and "200601" for YYYYMM.
        Pattern string

        // This field's weight when doing multi-index searches. Higher is "better".
        Weight int

        // Will lower case all string values in and queries tothis index.
        // May get better accurate results, but at a slight performance cost.
        ToLower bool
}

// Document is the interface an indexable document in Hugo must fulfill.
type Document interface {
        // RelatedKeywords returns a list of keywords for the given index config.
        RelatedKeywords(cfg IndexConfig) ([]Keyword, error)

        // When this document was or will be published.
        PublishDate() time.Time

        // Name is used as an tiebreaker if both Weight and PublishDate are
        // the same.
        Name() string
}

// InvertedIndex holds an inverted index, also sometimes named posting list, which
// lists, for every possible search term, the documents that contain that term.
type InvertedIndex struct {
        cfg   Config
        index map[string]map[Keyword][]Document

        minWeight int
        maxWeight int
}

func (idx *InvertedIndex) getIndexCfg(name string) (IndexConfig, bool) <span class="cov8" title="1">{
        for _, conf := range idx.cfg.Indices </span><span class="cov8" title="1">{
                if conf.Name == name </span><span class="cov8" title="1">{
                        return conf, true
                }</span>
        }

        <span class="cov0" title="0">return IndexConfig{}, false</span>
}

// NewInvertedIndex creates a new InvertedIndex.
// Documents to index must be added in Add.
func NewInvertedIndex(cfg Config) *InvertedIndex <span class="cov8" title="1">{
        idx := &amp;InvertedIndex{index: make(map[string]map[Keyword][]Document), cfg: cfg}
        for _, conf := range cfg.Indices </span><span class="cov8" title="1">{
                idx.index[conf.Name] = make(map[Keyword][]Document)
                if conf.Weight &lt; idx.minWeight </span><span class="cov0" title="0">{
                        // By default, the weight scale starts at 0, but we allow
                        // negative weights.
                        idx.minWeight = conf.Weight
                }</span>
                <span class="cov8" title="1">if conf.Weight &gt; idx.maxWeight </span><span class="cov8" title="1">{
                        idx.maxWeight = conf.Weight
                }</span>
        }
        <span class="cov8" title="1">return idx</span>
}

// Add documents to the inverted index.
// The value must support == and !=.
func (idx *InvertedIndex) Add(docs ...Document) error <span class="cov8" title="1">{
        var err error
        for _, config := range idx.cfg.Indices </span><span class="cov8" title="1">{
                if config.Weight == 0 </span><span class="cov0" title="0">{
                        // Disabled
                        continue</span>
                }
                <span class="cov8" title="1">setm := idx.index[config.Name]

                for _, doc := range docs </span><span class="cov8" title="1">{
                        var words []Keyword
                        words, err = doc.RelatedKeywords(config)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">for _, keyword := range words </span><span class="cov8" title="1">{
                                setm[keyword] = append(setm[keyword], doc)
                        }</span>
                }
        }

        <span class="cov8" title="1">return err</span>

}

// queryElement holds the index name and keywords that can be used to compose a
// search for related content.
type queryElement struct {
        Index    string
        Keywords []Keyword
}

func newQueryElement(index string, keywords ...Keyword) queryElement <span class="cov8" title="1">{
        return queryElement{Index: index, Keywords: keywords}
}</span>

type ranks []*rank

type rank struct {
        Doc     Document
        Weight  int
        Matches int
}

func (r *rank) addWeight(w int) <span class="cov0" title="0">{
        r.Weight += w
        r.Matches++
}</span>

func newRank(doc Document, weight int) *rank <span class="cov8" title="1">{
        return &amp;rank{Doc: doc, Weight: weight, Matches: 1}
}</span>

func (r ranks) Len() int      <span class="cov8" title="1">{ return len(r) }</span>
func (r ranks) Swap(i, j int) <span class="cov0" title="0">{ r[i], r[j] = r[j], r[i] }</span>
func (r ranks) Less(i, j int) bool <span class="cov0" title="0">{
        if r[i].Weight == r[j].Weight </span><span class="cov0" title="0">{
                if r[i].Doc.PublishDate() == r[j].Doc.PublishDate() </span><span class="cov0" title="0">{
                        return r[i].Doc.Name() &lt; r[j].Doc.Name()
                }</span>
                <span class="cov0" title="0">return r[i].Doc.PublishDate().After(r[j].Doc.PublishDate())</span>
        }
        <span class="cov0" title="0">return r[i].Weight &gt; r[j].Weight</span>
}

// SearchDoc finds the documents matching any of the keywords in the given indices
// against the given document.
// The resulting document set will be sorted according to number of matches
// and the index weights, and any matches with a rank below the configured
// threshold (normalize to 0..100) will be removed.
// If an index name is provided, only that index will be queried.
func (idx *InvertedIndex) SearchDoc(doc Document, indices ...string) ([]Document, error) <span class="cov8" title="1">{
        var q []queryElement

        var configs IndexConfigs

        if len(indices) == 0 </span><span class="cov8" title="1">{
                configs = idx.cfg.Indices
        }</span> else<span class="cov0" title="0"> {
                configs = make(IndexConfigs, len(indices))
                for i, indexName := range indices </span><span class="cov0" title="0">{
                        cfg, found := idx.getIndexCfg(indexName)
                        if !found </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("index %q not found", indexName)
                        }</span>
                        <span class="cov0" title="0">configs[i] = cfg</span>
                }
        }

        <span class="cov8" title="1">for _, cfg := range configs </span><span class="cov8" title="1">{
                keywords, err := doc.RelatedKeywords(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">q = append(q, newQueryElement(cfg.Name, keywords...))</span>

        }

        <span class="cov8" title="1">return idx.searchDate(doc.PublishDate(), q...)</span>
}

// ToKeywords returns a Keyword slice of the given input.
func (cfg IndexConfig) ToKeywords(v interface{}) ([]Keyword, error) <span class="cov8" title="1">{
        var (
                keywords []Keyword
                toLower  = cfg.ToLower
        )
        switch vv := v.(type) </span>{
        case string:<span class="cov0" title="0">
                if toLower </span><span class="cov0" title="0">{
                        vv = strings.ToLower(vv)
                }</span>
                <span class="cov0" title="0">keywords = append(keywords, StringKeyword(vv))</span>
        case []string:<span class="cov0" title="0">
                if toLower </span><span class="cov0" title="0">{
                        for i := 0; i &lt; len(vv); i++ </span><span class="cov0" title="0">{
                                vv[i] = strings.ToLower(vv[i])
                        }</span>
                }
                <span class="cov0" title="0">keywords = append(keywords, StringsToKeywords(vv...)...)</span>
        case time.Time:<span class="cov8" title="1">
                layout := "2006"
                if cfg.Pattern != "" </span><span class="cov0" title="0">{
                        layout = cfg.Pattern
                }</span>
                <span class="cov8" title="1">keywords = append(keywords, StringKeyword(vv.Format(layout)))</span>
        case nil:<span class="cov8" title="1">
                return keywords, nil</span>
        default:<span class="cov0" title="0">
                return keywords, fmt.Errorf("indexing currently not supported for index %q and type %T", cfg.Name, vv)</span>
        }

        <span class="cov8" title="1">return keywords, nil</span>
}

// SearchKeyValues finds the documents matching any of the keywords in the given indices.
// The resulting document set will be sorted according to number of matches
// and the index weights, and any matches with a rank below the configured
// threshold (normalize to 0..100) will be removed.
func (idx *InvertedIndex) SearchKeyValues(args ...types.KeyValues) ([]Document, error) <span class="cov0" title="0">{
        q := make([]queryElement, len(args))

        for i, arg := range args </span><span class="cov0" title="0">{
                var keywords []Keyword
                key := arg.KeyString()
                if key == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("index %q not valid", arg.Key)
                }</span>
                <span class="cov0" title="0">conf, found := idx.getIndexCfg(key)
                if !found </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("index %q not found", key)
                }</span>

                <span class="cov0" title="0">for _, val := range arg.Values </span><span class="cov0" title="0">{
                        k, err := conf.ToKeywords(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">keywords = append(keywords, k...)</span>
                }

                <span class="cov0" title="0">q[i] = newQueryElement(conf.Name, keywords...)</span>

        }

        <span class="cov0" title="0">return idx.search(q...)</span>
}

func (idx *InvertedIndex) search(query ...queryElement) ([]Document, error) <span class="cov0" title="0">{
        return idx.searchDate(zeroDate, query...)
}</span>

func (idx *InvertedIndex) searchDate(upperDate time.Time, query ...queryElement) ([]Document, error) <span class="cov8" title="1">{
        matchm := make(map[Document]*rank, 200)
        applyDateFilter := !idx.cfg.IncludeNewer &amp;&amp; !upperDate.IsZero()

        for _, el := range query </span><span class="cov8" title="1">{
                setm, found := idx.index[el.Index]
                if !found </span><span class="cov0" title="0">{
                        return []Document{}, fmt.Errorf("index for %q not found", el.Index)
                }</span>

                <span class="cov8" title="1">config, found := idx.getIndexCfg(el.Index)
                if !found </span><span class="cov0" title="0">{
                        return []Document{}, fmt.Errorf("index config for %q not found", el.Index)
                }</span>

                <span class="cov8" title="1">for _, kw := range el.Keywords </span><span class="cov8" title="1">{
                        if docs, found := setm[kw]; found </span><span class="cov8" title="1">{
                                for _, doc := range docs </span><span class="cov8" title="1">{
                                        if applyDateFilter </span><span class="cov8" title="1">{
                                                // Exclude newer than the limit given
                                                if doc.PublishDate().After(upperDate) </span><span class="cov8" title="1">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov8" title="1">r, found := matchm[doc]
                                        if !found </span><span class="cov8" title="1">{
                                                matchm[doc] = newRank(doc, config.Weight)
                                        }</span> else<span class="cov0" title="0"> {
                                                r.addWeight(config.Weight)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">if len(matchm) == 0 </span><span class="cov0" title="0">{
                return []Document{}, nil
        }</span>

        <span class="cov8" title="1">matches := make(ranks, 0, 100)

        for _, v := range matchm </span><span class="cov8" title="1">{
                avgWeight := v.Weight / v.Matches
                weight := norm(avgWeight, idx.minWeight, idx.maxWeight)
                threshold := idx.cfg.Threshold / v.Matches

                if weight &gt;= threshold </span><span class="cov0" title="0">{
                        matches = append(matches, v)
                }</span>
        }

        <span class="cov8" title="1">sort.Stable(matches)

        result := make([]Document, len(matches))

        for i, m := range matches </span><span class="cov0" title="0">{
                result[i] = m.Doc
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// normalizes num to a number between 0 and 100.
func norm(num, min, max int) int <span class="cov8" title="1">{
        if min &gt; max </span><span class="cov0" title="0">{
                panic("min &gt; max")</span>
        }
        <span class="cov8" title="1">return int(math.Floor((float64(num-min) / float64(max-min) * 100) + 0.5))</span>
}

// DecodeConfig decodes a slice of map into Config.
func DecodeConfig(in interface{}) (Config, error) <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return Config{}, errors.New("no related config provided")
        }</span>

        <span class="cov0" title="0">m, ok := in.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return Config{}, fmt.Errorf("expected map[string]interface {} got %T", in)
        }</span>

        <span class="cov0" title="0">if len(m) == 0 </span><span class="cov0" title="0">{
                return Config{}, errors.New("empty related config provided")
        }</span>

        <span class="cov0" title="0">var c Config

        if err := mapstructure.WeakDecode(m, &amp;c); err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>

        <span class="cov0" title="0">if c.Threshold &lt; 0 || c.Threshold &gt; 100 </span><span class="cov0" title="0">{
                return Config{}, errors.New("related threshold must be between 0 and 100")
        }</span>

        <span class="cov0" title="0">if c.ToLower </span><span class="cov0" title="0">{
                for i := range c.Indices </span><span class="cov0" title="0">{
                        c.Indices[i].ToLower = true
                }</span>
        }

        <span class="cov0" title="0">return c, nil</span>
}

// StringKeyword is a string search keyword.
type StringKeyword string

func (s StringKeyword) String() string <span class="cov0" title="0">{
        return string(s)
}</span>

// Keyword is the interface a keyword in the search index must implement.
type Keyword interface {
        String() string
}

// StringsToKeywords converts the given slice of strings to a slice of Keyword.
func StringsToKeywords(s ...string) []Keyword <span class="cov0" title="0">{
        kw := make([]Keyword, len(s))

        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                kw[i] = StringKeyword(s[i])
        }</span>

        <span class="cov0" title="0">return kw</span>
}
</pre>
		
		<pre class="file" id="file168" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "encoding/json"
        "fmt"
        "image"
        "image/draw"
        _ "image/gif"
        _ "image/png"
        "io"
        "io/ioutil"
        "os"
        "path"
        "path/filepath"
        "strings"
        "sync"

        "github.com/disintegration/gift"

        "github.com/gohugoio/hugo/cache/filecache"
        "github.com/gohugoio/hugo/resources/images/exif"

        "github.com/gohugoio/hugo/resources/internal"

        "github.com/gohugoio/hugo/resources/resource"

        _errors "github.com/pkg/errors"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/resources/images"

        // Blind import for image.Decode

        // Blind import for image.Decode
        _ "golang.org/x/image/webp"
)

var (
        _ resource.Image  = (*imageResource)(nil)
        _ resource.Source = (*imageResource)(nil)
        _ resource.Cloner = (*imageResource)(nil)
)

// ImageResource represents an image resource.
type imageResource struct {
        *images.Image

        // When a image is processed in a chain, this holds the reference to the
        // original (first).
        root *imageResource

        metaInit    sync.Once
        metaInitErr error
        meta        *imageMeta

        baseResource
}

type imageMeta struct {
        Exif *exif.Exif
}

func (i *imageResource) Exif() (*exif.Exif, error) <span class="cov0" title="0">{
        return i.root.getExif()
}</span>

func (i *imageResource) getExif() (*exif.Exif, error) <span class="cov0" title="0">{

        i.metaInit.Do(func() </span><span class="cov0" title="0">{

                supportsExif := i.Format == images.JPEG || i.Format == images.TIFF
                if !supportsExif </span><span class="cov0" title="0">{
                        return

                }</span>

                <span class="cov0" title="0">key := i.getImageMetaCacheTargetPath()

                read := func(info filecache.ItemInfo, r io.Reader) error </span><span class="cov0" title="0">{
                        meta := &amp;imageMeta{}
                        data, err := ioutil.ReadAll(r)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if err = json.Unmarshal(data, &amp;meta); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">i.meta = meta

                        return nil</span>
                }

                <span class="cov0" title="0">create := func(info filecache.ItemInfo, w io.WriteCloser) (err error) </span><span class="cov0" title="0">{

                        f, err := i.root.ReadSeekCloser()
                        if err != nil </span><span class="cov0" title="0">{
                                i.metaInitErr = err
                                return
                        }</span>
                        <span class="cov0" title="0">defer f.Close()

                        x, err := i.getSpec().imaging.DecodeExif(f)
                        if err != nil </span><span class="cov0" title="0">{
                                i.metaInitErr = err
                                return
                        }</span>

                        <span class="cov0" title="0">i.meta = &amp;imageMeta{Exif: x}

                        // Also write it to cache
                        enc := json.NewEncoder(w)
                        return enc.Encode(i.meta)</span>

                }

                <span class="cov0" title="0">_, i.metaInitErr = i.getSpec().imageCache.fileCache.ReadOrCreate(key, read, create)</span>

        })

        <span class="cov0" title="0">if i.metaInitErr != nil </span><span class="cov0" title="0">{
                return nil, i.metaInitErr
        }</span>

        <span class="cov0" title="0">return i.meta.Exif, nil</span>
}

func (i *imageResource) Clone() resource.Resource <span class="cov0" title="0">{
        gr := i.baseResource.Clone().(baseResource)
        return &amp;imageResource{
                root:         i.root,
                Image:        i.WithSpec(gr),
                baseResource: gr,
        }
}</span>

func (i *imageResource) cloneWithUpdates(u *transformationUpdate) (baseResource, error) <span class="cov0" title="0">{
        base, err := i.baseResource.cloneWithUpdates(u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var img *images.Image

        if u.isContenChanged() </span><span class="cov0" title="0">{
                img = i.WithSpec(base)
        }</span> else<span class="cov0" title="0"> {
                img = i.Image
        }</span>

        <span class="cov0" title="0">return &amp;imageResource{
                root:         i.root,
                Image:        img,
                baseResource: base,
        }, nil</span>
}

// Resize resizes the image to the specified width and height using the specified resampling
// filter and returns the transformed image. If one of width or height is 0, the image aspect
// ratio is preserved.
func (i *imageResource) Resize(spec string) (resource.Image, error) <span class="cov0" title="0">{
        conf, err := i.decodeImageConfig("resize", spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return i.doWithImageConfig(conf, func(src image.Image) (image.Image, error) </span><span class="cov0" title="0">{
                return i.Proc.ApplyFiltersFromConfig(src, conf)
        }</span>)
}

// Fit scales down the image using the specified resample filter to fit the specified
// maximum width and height.
func (i *imageResource) Fit(spec string) (resource.Image, error) <span class="cov0" title="0">{
        conf, err := i.decodeImageConfig("fit", spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return i.doWithImageConfig(conf, func(src image.Image) (image.Image, error) </span><span class="cov0" title="0">{
                return i.Proc.ApplyFiltersFromConfig(src, conf)
        }</span>)
}

// Fill scales the image to the smallest possible size that will cover the specified dimensions,
// crops the resized image to the specified dimensions using the given anchor point.
// Space delimited config: 200x300 TopLeft
func (i *imageResource) Fill(spec string) (resource.Image, error) <span class="cov0" title="0">{
        conf, err := i.decodeImageConfig("fill", spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return i.doWithImageConfig(conf, func(src image.Image) (image.Image, error) </span><span class="cov0" title="0">{
                return i.Proc.ApplyFiltersFromConfig(src, conf)
        }</span>)
}

func (i *imageResource) Filter(filters ...interface{}) (resource.Image, error) <span class="cov0" title="0">{
        conf := i.Proc.GetDefaultImageConfig("filter")

        var gfilters []gift.Filter

        for _, f := range filters </span><span class="cov0" title="0">{
                gfilters = append(gfilters, images.ToFilters(f)...)
        }</span>

        <span class="cov0" title="0">conf.Key = internal.HashString(gfilters)

        return i.doWithImageConfig(conf, func(src image.Image) (image.Image, error) </span><span class="cov0" title="0">{
                return i.Proc.Filter(src, gfilters...)
        }</span>)
}

func (i *imageResource) isJPEG() bool <span class="cov0" title="0">{
        name := strings.ToLower(i.getResourcePaths().relTargetDirFile.file)
        return strings.HasSuffix(name, ".jpg") || strings.HasSuffix(name, ".jpeg")
}</span>

// Serialize image processing. The imaging library spins up its own set of Go routines,
// so there is not much to gain from adding more load to the mix. That
// can even have negative effect in low resource scenarios.
// Note that this only effects the non-cached scenario. Once the processed
// image is written to disk, everything is fast, fast fast.
const imageProcWorkers = 1

var imageProcSem = make(chan bool, imageProcWorkers)

func (i *imageResource) doWithImageConfig(conf images.ImageConfig, f func(src image.Image) (image.Image, error)) (resource.Image, error) <span class="cov0" title="0">{
        return i.getSpec().imageCache.getOrCreate(i, conf, func() (*imageResource, image.Image, error) </span><span class="cov0" title="0">{
                imageProcSem &lt;- true
                defer func() </span><span class="cov0" title="0">{
                        &lt;-imageProcSem
                }</span>()

                <span class="cov0" title="0">errOp := conf.Action
                errPath := i.getSourceFilename()

                src, err := i.decodeSource()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, &amp;os.PathError{Op: errOp, Path: errPath, Err: err}
                }</span>

                <span class="cov0" title="0">converted, err := f(src)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, &amp;os.PathError{Op: errOp, Path: errPath, Err: err}
                }</span>

                <span class="cov0" title="0">if i.Format == images.PNG </span><span class="cov0" title="0">{
                        // Apply the colour palette from the source
                        if paletted, ok := src.(*image.Paletted); ok </span><span class="cov0" title="0">{
                                tmp := image.NewPaletted(converted.Bounds(), paletted.Palette)
                                draw.FloydSteinberg.Draw(tmp, tmp.Bounds(), converted, converted.Bounds().Min)
                                converted = tmp
                        }</span>
                }

                <span class="cov0" title="0">ci := i.clone(converted)
                ci.setBasePath(conf)

                return ci, converted, nil</span>
        })
}

func (i *imageResource) decodeImageConfig(action, spec string) (images.ImageConfig, error) <span class="cov0" title="0">{
        conf, err := images.DecodeImageConfig(action, spec, i.Proc.Cfg)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        <span class="cov0" title="0">iconf := i.Proc.Cfg

        if conf.Quality &lt;= 0 &amp;&amp; i.isJPEG() </span><span class="cov0" title="0">{
                // We need a quality setting for all JPEGs
                conf.Quality = iconf.Quality
        }</span>

        <span class="cov0" title="0">return conf, nil</span>
}

func (i *imageResource) decodeSource() (image.Image, error) <span class="cov0" title="0">{
        f, err := i.ReadSeekCloser()
        if err != nil </span><span class="cov0" title="0">{
                return nil, _errors.Wrap(err, "failed to open image for decode")
        }</span>
        <span class="cov0" title="0">defer f.Close()
        img, _, err := image.Decode(f)
        return img, err</span>
}

func (i *imageResource) clone(img image.Image) *imageResource <span class="cov0" title="0">{
        spec := i.baseResource.Clone().(baseResource)

        var image *images.Image
        if img != nil </span><span class="cov0" title="0">{
                image = i.WithImage(img)
        }</span> else<span class="cov0" title="0"> {
                image = i.WithSpec(spec)
        }</span>

        <span class="cov0" title="0">return &amp;imageResource{
                Image:        image,
                root:         i.root,
                baseResource: spec,
        }</span>
}

func (i *imageResource) setBasePath(conf images.ImageConfig) <span class="cov0" title="0">{
        i.getResourcePaths().relTargetDirFile = i.relTargetPathFromConfig(conf)
}</span>

func (i *imageResource) getImageMetaCacheTargetPath() string <span class="cov0" title="0">{
        const imageMetaVersionNumber = 1 // Increment to invalidate the meta cache

        cfg := i.getSpec().imaging.Cfg
        df := i.getResourcePaths().relTargetDirFile
        if fi := i.getFileInfo(); fi != nil </span><span class="cov0" title="0">{
                df.dir = filepath.Dir(fi.Meta().Path())
        }</span>
        <span class="cov0" title="0">p1, _ := helpers.FileAndExt(df.file)
        h, _ := i.hash()
        idStr := internal.HashString(h, i.size(), imageMetaVersionNumber, cfg)
        return path.Join(df.dir, fmt.Sprintf("%s_%s.json", p1, idStr))</span>
}

func (i *imageResource) relTargetPathFromConfig(conf images.ImageConfig) dirFile <span class="cov0" title="0">{
        p1, p2 := helpers.FileAndExt(i.getResourcePaths().relTargetDirFile.file)

        h, _ := i.hash()
        idStr := fmt.Sprintf("_hu%s_%d", h, i.size())

        // Do not change for no good reason.
        const md5Threshold = 100

        key := conf.GetKey(i.Format)

        // It is useful to have the key in clear text, but when nesting transforms, it
        // can easily be too long to read, and maybe even too long
        // for the different OSes to handle.
        if len(p1)+len(idStr)+len(p2) &gt; md5Threshold </span><span class="cov0" title="0">{
                key = helpers.MD5String(p1 + key + p2)
                huIdx := strings.Index(p1, "_hu")
                if huIdx != -1 </span><span class="cov0" title="0">{
                        p1 = p1[:huIdx]
                }</span> else<span class="cov0" title="0"> {
                        // This started out as a very long file name. Making it even longer
                        // could melt ice in the Arctic.
                        p1 = ""
                }</span>
        } else<span class="cov0" title="0"> if strings.Contains(p1, idStr) </span><span class="cov0" title="0">{
                // On scaling an already scaled image, we get the file info from the original.
                // Repeating the same info in the filename makes it stuttery for no good reason.
                idStr = ""
        }</span>

        <span class="cov0" title="0">return dirFile{
                dir:  i.getResourcePaths().relTargetDirFile.dir,
                file: fmt.Sprintf("%s%s_%s%s", p1, idStr, key, p2),
        }</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "image"
        "io"
        "path/filepath"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/resources/images"

        "github.com/gohugoio/hugo/cache/filecache"
        "github.com/gohugoio/hugo/helpers"
)

type imageCache struct {
        pathSpec *helpers.PathSpec

        fileCache *filecache.Cache

        mu    sync.RWMutex
        store map[string]*resourceAdapter
}

func (c *imageCache) isInCache(key string) bool <span class="cov0" title="0">{
        c.mu.RLock()
        _, found := c.store[c.normalizeKey(key)]
        c.mu.RUnlock()
        return found
}</span>

func (c *imageCache) deleteByPrefix(prefix string) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        prefix = c.normalizeKey(prefix)
        for k := range c.store </span><span class="cov0" title="0">{
                if strings.HasPrefix(k, prefix) </span><span class="cov0" title="0">{
                        delete(c.store, k)
                }</span>
        }
}

func (c *imageCache) normalizeKey(key string) string <span class="cov0" title="0">{
        // It is a path with Unix style slashes and it always starts with a leading slash.
        key = filepath.ToSlash(key)
        if !strings.HasPrefix(key, "/") </span><span class="cov0" title="0">{
                key = "/" + key
        }</span>

        <span class="cov0" title="0">return key</span>
}

func (c *imageCache) clear() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.store = make(map[string]*resourceAdapter)
}</span>

func (c *imageCache) getOrCreate(
        parent *imageResource, conf images.ImageConfig,
        createImage func() (*imageResource, image.Image, error)) (*resourceAdapter, error) <span class="cov0" title="0">{
        relTarget := parent.relTargetPathFromConfig(conf)
        memKey := parent.relTargetPathForRel(relTarget.path(), false, false, false)

        // For the file cache we want to generate and store it once if possible.
        fileKeyPath := relTarget
        if fi := parent.root.getFileInfo(); fi != nil </span><span class="cov0" title="0">{
                fileKeyPath.dir = filepath.ToSlash(filepath.Dir(fi.Meta().Path()))
        }</span>
        <span class="cov0" title="0">fileKey := fileKeyPath.path()

        // First check the in-memory store, then the disk.
        c.mu.RLock()
        cachedImage, found := c.store[memKey]
        c.mu.RUnlock()

        if found </span><span class="cov0" title="0">{
                return cachedImage, nil
        }</span>

        <span class="cov0" title="0">var img *imageResource

        // These funcs are protected by a named lock.
        // read clones the parent to its new name and copies
        // the content to the destinations.
        read := func(info filecache.ItemInfo, r io.Reader) error </span><span class="cov0" title="0">{
                img = parent.clone(nil)
                rp := img.getResourcePaths()
                rp.relTargetDirFile.file = relTarget.file
                img.setSourceFilename(info.Name)

                w, err := img.openDestinationsForWriting()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if w == nil </span><span class="cov0" title="0">{
                        // Nothing to write.
                        return nil
                }</span>

                <span class="cov0" title="0">defer w.Close()
                _, err = io.Copy(w, r)
                return err</span>
        }

        // create creates the image and encodes it to the cache (w).
        <span class="cov0" title="0">create := func(info filecache.ItemInfo, w io.WriteCloser) (err error) </span><span class="cov0" title="0">{
                defer w.Close()

                var conv image.Image
                img, conv, err = createImage()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">rp := img.getResourcePaths()
                rp.relTargetDirFile.file = relTarget.file
                img.setSourceFilename(info.Name)

                return img.EncodeTo(conf, conv, w)</span>
        }

        // Now look in the file cache.

        // The definition of this counter is not that we have processed that amount
        // (e.g. resized etc.), it can be fetched from file cache,
        //  but the count of processed image variations for this site.
        <span class="cov0" title="0">c.pathSpec.ProcessingStats.Incr(&amp;c.pathSpec.ProcessingStats.ProcessedImages)

        _, err := c.fileCache.ReadOrCreate(fileKey, read, create)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The file is now stored in this cache.
        <span class="cov0" title="0">img.setSourceFs(c.fileCache.Fs)

        c.mu.Lock()
        if cachedImage, found = c.store[memKey]; found </span><span class="cov0" title="0">{
                c.mu.Unlock()
                return cachedImage, nil
        }</span>

        <span class="cov0" title="0">imgAdapter := newResourceAdapter(parent.getSpec(), true, img)
        c.store[memKey] = imgAdapter
        c.mu.Unlock()

        return imgAdapter, nil</span>
}

func newImageCache(fileCache *filecache.Cache, ps *helpers.PathSpec) *imageCache <span class="cov8" title="1">{
        return &amp;imageCache{fileCache: fileCache, pathSpec: ps, store: make(map[string]*resourceAdapter)}
}</span>
</pre>
		
		<pre class="file" id="file170" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import (
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/disintegration/gift"

        "github.com/mitchellh/mapstructure"
)

const (
        defaultJPEGQuality    = 75
        defaultResampleFilter = "box"
)

var (
        imageFormats = map[string]Format{
                ".jpg":  JPEG,
                ".jpeg": JPEG,
                ".png":  PNG,
                ".tif":  TIFF,
                ".tiff": TIFF,
                ".bmp":  BMP,
                ".gif":  GIF,
        }

        // Add or increment if changes to an image format's processing requires
        // re-generation.
        imageFormatsVersions = map[Format]int{
                PNG: 2, // Floyd Steinberg dithering
        }

        // Increment to mark all processed images as stale. Only use when absolutely needed.
        // See the finer grained smartCropVersionNumber and imageFormatsVersions.
        mainImageVersionNumber = 0
)

var anchorPositions = map[string]gift.Anchor{
        strings.ToLower("Center"):      gift.CenterAnchor,
        strings.ToLower("TopLeft"):     gift.TopLeftAnchor,
        strings.ToLower("Top"):         gift.TopAnchor,
        strings.ToLower("TopRight"):    gift.TopRightAnchor,
        strings.ToLower("Left"):        gift.LeftAnchor,
        strings.ToLower("Right"):       gift.RightAnchor,
        strings.ToLower("BottomLeft"):  gift.BottomLeftAnchor,
        strings.ToLower("Bottom"):      gift.BottomAnchor,
        strings.ToLower("BottomRight"): gift.BottomRightAnchor,
}

var imageFilters = map[string]gift.Resampling{

        strings.ToLower("NearestNeighbor"):   gift.NearestNeighborResampling,
        strings.ToLower("Box"):               gift.BoxResampling,
        strings.ToLower("Linear"):            gift.LinearResampling,
        strings.ToLower("Hermite"):           hermiteResampling,
        strings.ToLower("MitchellNetravali"): mitchellNetravaliResampling,
        strings.ToLower("CatmullRom"):        catmullRomResampling,
        strings.ToLower("BSpline"):           bSplineResampling,
        strings.ToLower("Gaussian"):          gaussianResampling,
        strings.ToLower("Lanczos"):           gift.LanczosResampling,
        strings.ToLower("Hann"):              hannResampling,
        strings.ToLower("Hamming"):           hammingResampling,
        strings.ToLower("Blackman"):          blackmanResampling,
        strings.ToLower("Bartlett"):          bartlettResampling,
        strings.ToLower("Welch"):             welchResampling,
        strings.ToLower("Cosine"):            cosineResampling,
}

func ImageFormatFromExt(ext string) (Format, bool) <span class="cov0" title="0">{
        f, found := imageFormats[ext]
        return f, found
}</span>

func DecodeConfig(m map[string]interface{}) (Imaging, error) <span class="cov8" title="1">{
        var i Imaging
        if err := mapstructure.WeakDecode(m, &amp;i); err != nil </span><span class="cov0" title="0">{
                return i, err
        }</span>

        <span class="cov8" title="1">if i.Quality == 0 </span><span class="cov8" title="1">{
                i.Quality = defaultJPEGQuality
        }</span> else<span class="cov0" title="0"> if i.Quality &lt; 0 || i.Quality &gt; 100 </span><span class="cov0" title="0">{
                return i, errors.New("JPEG quality must be a number between 1 and 100")
        }</span>

        <span class="cov8" title="1">if i.Anchor == "" || strings.EqualFold(i.Anchor, smartCropIdentifier) </span><span class="cov8" title="1">{
                i.Anchor = smartCropIdentifier
        }</span> else<span class="cov0" title="0"> {
                i.Anchor = strings.ToLower(i.Anchor)
                if _, found := anchorPositions[i.Anchor]; !found </span><span class="cov0" title="0">{
                        return i, errors.New("invalid anchor value in imaging config")
                }</span>
        }

        <span class="cov8" title="1">if i.ResampleFilter == "" </span><span class="cov8" title="1">{
                i.ResampleFilter = defaultResampleFilter
        }</span> else<span class="cov0" title="0"> {
                filter := strings.ToLower(i.ResampleFilter)
                _, found := imageFilters[filter]
                if !found </span><span class="cov0" title="0">{
                        return i, fmt.Errorf("%q is not a valid resample filter", filter)
                }</span>
                <span class="cov0" title="0">i.ResampleFilter = filter</span>
        }

        <span class="cov8" title="1">if strings.TrimSpace(i.Exif.IncludeFields) == "" &amp;&amp; strings.TrimSpace(i.Exif.ExcludeFields) == "" </span><span class="cov8" title="1">{
                // Don't change this for no good reason. Please don't.
                i.Exif.ExcludeFields = "GPS|Exif|Exposure[M|P|B]|Contrast|Resolution|Sharp|JPEG|Metering|Sensing|Saturation|ColorSpace|Flash|WhiteBalance"
        }</span>

        <span class="cov8" title="1">return i, nil</span>
}

func DecodeImageConfig(action, config string, defaults Imaging) (ImageConfig, error) <span class="cov0" title="0">{
        var (
                c   ImageConfig
                err error
        )

        c.Action = action

        if config == "" </span><span class="cov0" title="0">{
                return c, errors.New("image config cannot be empty")
        }</span>

        <span class="cov0" title="0">parts := strings.Fields(config)
        for _, part := range parts </span><span class="cov0" title="0">{
                part = strings.ToLower(part)

                if part == smartCropIdentifier </span><span class="cov0" title="0">{
                        c.AnchorStr = smartCropIdentifier
                }</span> else<span class="cov0" title="0"> if pos, ok := anchorPositions[part]; ok </span><span class="cov0" title="0">{
                        c.Anchor = pos
                        c.AnchorStr = part
                }</span> else<span class="cov0" title="0"> if filter, ok := imageFilters[part]; ok </span><span class="cov0" title="0">{
                        c.Filter = filter
                        c.FilterStr = part
                }</span> else<span class="cov0" title="0"> if part[0] == 'q' </span><span class="cov0" title="0">{
                        c.Quality, err = strconv.Atoi(part[1:])
                        if err != nil </span><span class="cov0" title="0">{
                                return c, err
                        }</span>
                        <span class="cov0" title="0">if c.Quality &lt; 1 || c.Quality &gt; 100 </span><span class="cov0" title="0">{
                                return c, errors.New("quality ranges from 1 to 100 inclusive")
                        }</span>
                } else<span class="cov0" title="0"> if part[0] == 'r' </span><span class="cov0" title="0">{
                        c.Rotate, err = strconv.Atoi(part[1:])
                        if err != nil </span><span class="cov0" title="0">{
                                return c, err
                        }</span>
                } else<span class="cov0" title="0"> if strings.Contains(part, "x") </span><span class="cov0" title="0">{
                        widthHeight := strings.Split(part, "x")
                        if len(widthHeight) &lt;= 2 </span><span class="cov0" title="0">{
                                first := widthHeight[0]
                                if first != "" </span><span class="cov0" title="0">{
                                        c.Width, err = strconv.Atoi(first)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return c, err
                                        }</span>
                                }

                                <span class="cov0" title="0">if len(widthHeight) == 2 </span><span class="cov0" title="0">{
                                        second := widthHeight[1]
                                        if second != "" </span><span class="cov0" title="0">{
                                                c.Height, err = strconv.Atoi(second)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return c, err
                                                }</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                return c, errors.New("invalid image dimensions")
                        }</span>

                }
        }

        <span class="cov0" title="0">if c.Width == 0 &amp;&amp; c.Height == 0 </span><span class="cov0" title="0">{
                return c, errors.New("must provide Width or Height")
        }</span>

        <span class="cov0" title="0">if c.FilterStr == "" </span><span class="cov0" title="0">{
                c.FilterStr = defaults.ResampleFilter
                c.Filter = imageFilters[c.FilterStr]
        }</span>

        <span class="cov0" title="0">if c.AnchorStr == "" </span><span class="cov0" title="0">{
                c.AnchorStr = defaults.Anchor
                if !strings.EqualFold(c.AnchorStr, smartCropIdentifier) </span><span class="cov0" title="0">{
                        c.Anchor = anchorPositions[c.AnchorStr]
                }</span>
        }

        <span class="cov0" title="0">return c, nil</span>
}

// ImageConfig holds configuration to create a new image from an existing one, resize etc.
type ImageConfig struct {
        Action string

        // If set, this will be used as the key in filenames etc.
        Key string

        // Quality ranges from 1 to 100 inclusive, higher is better.
        // This is only relevant for JPEG images.
        // Default is 75.
        Quality int

        // Rotate rotates an image by the given angle counter-clockwise.
        // The rotation will be performed first.
        Rotate int

        Width  int
        Height int

        Filter    gift.Resampling
        FilterStr string

        Anchor    gift.Anchor
        AnchorStr string
}

func (i ImageConfig) GetKey(format Format) string <span class="cov0" title="0">{
        if i.Key != "" </span><span class="cov0" title="0">{
                return i.Action + "_" + i.Key
        }</span>

        <span class="cov0" title="0">k := strconv.Itoa(i.Width) + "x" + strconv.Itoa(i.Height)
        if i.Action != "" </span><span class="cov0" title="0">{
                k += "_" + i.Action
        }</span>
        <span class="cov0" title="0">if i.Quality &gt; 0 </span><span class="cov0" title="0">{
                k += "_q" + strconv.Itoa(i.Quality)
        }</span>
        <span class="cov0" title="0">if i.Rotate != 0 </span><span class="cov0" title="0">{
                k += "_r" + strconv.Itoa(i.Rotate)
        }</span>
        <span class="cov0" title="0">anchor := i.AnchorStr
        if anchor == smartCropIdentifier </span><span class="cov0" title="0">{
                anchor = anchor + strconv.Itoa(smartCropVersionNumber)
        }</span>

        <span class="cov0" title="0">k += "_" + i.FilterStr

        if strings.EqualFold(i.Action, "fill") </span><span class="cov0" title="0">{
                k += "_" + anchor
        }</span>

        <span class="cov0" title="0">if v, ok := imageFormatsVersions[format]; ok </span><span class="cov0" title="0">{
                k += "_" + strconv.Itoa(v)
        }</span>

        <span class="cov0" title="0">if mainImageVersionNumber &gt; 0 </span><span class="cov0" title="0">{
                k += "_" + strconv.Itoa(mainImageVersionNumber)
        }</span>

        <span class="cov0" title="0">return k</span>
}

// Imaging contains default image processing configuration. This will be fetched
// from site (or language) config.
type Imaging struct {
        // Default image quality setting (1-100). Only used for JPEG images.
        Quality int

        // Resample filter to use in resize operations..
        ResampleFilter string

        // The anchor to use in Fill. Default is "smart", i.e. Smart Crop.
        Anchor string

        Exif ExifConfig
}

type ExifConfig struct {

        // Regexp matching the Exif fields you want from the (massive) set of Exif info
        // available. As we cache this info to disk, this is for performance and
        // disk space reasons more than anything.
        // If you want it all, put ".*" in this config setting.
        // Note that if neither this or ExcludeFields is set, Hugo will return a small
        // default set.
        IncludeFields string

        // Regexp matching the Exif fields you want to exclude. This may be easier to use
        // than IncludeFields above, depending on what you want.
        ExcludeFields string

        // Hugo extracts the "photo taken" date/time into .Date by default.
        // Set this to true to turn it off.
        DisableDate bool

        // Hugo extracts the "photo taken where" (GPS latitude and longitude) into
        // .Long and .Lat. Set this to true to turn it off.
        DisableLatLong bool
}
</pre>
		
		<pre class="file" id="file171" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package exif

import (
        "bytes"
        "fmt"
        "io"
        "math/big"
        "regexp"
        "strings"
        "time"
        "unicode"
        "unicode/utf8"

        "github.com/bep/tmc"

        _exif "github.com/rwcarlsen/goexif/exif"
        "github.com/rwcarlsen/goexif/tiff"
)

const exifTimeLayout = "2006:01:02 15:04:05"

type Exif struct {
        Lat  float64
        Long float64
        Date time.Time
        Tags Tags
}

type Decoder struct {
        includeFieldsRe  *regexp.Regexp
        excludeFieldsrRe *regexp.Regexp
        noDate           bool
        noLatLong        bool
}

func IncludeFields(expression string) func(*Decoder) error <span class="cov8" title="1">{
        return func(d *Decoder) error </span><span class="cov8" title="1">{
                re, err := compileRegexp(expression)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">d.includeFieldsRe = re
                return nil</span>
        }
}

func ExcludeFields(expression string) func(*Decoder) error <span class="cov8" title="1">{
        return func(d *Decoder) error </span><span class="cov8" title="1">{
                re, err := compileRegexp(expression)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">d.excludeFieldsrRe = re
                return nil</span>
        }
}

func WithLatLongDisabled(disabled bool) func(*Decoder) error <span class="cov8" title="1">{
        return func(d *Decoder) error </span><span class="cov8" title="1">{
                d.noLatLong = disabled
                return nil
        }</span>
}

func WithDateDisabled(disabled bool) func(*Decoder) error <span class="cov8" title="1">{
        return func(d *Decoder) error </span><span class="cov8" title="1">{
                d.noDate = disabled
                return nil
        }</span>
}

func compileRegexp(expression string) (*regexp.Regexp, error) <span class="cov8" title="1">{
        expression = strings.TrimSpace(expression)
        if expression == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if !strings.HasPrefix(expression, "(") </span><span class="cov8" title="1">{
                // Make it case insensitive
                expression = "(?i)" + expression
        }</span>

        <span class="cov8" title="1">return regexp.Compile(expression)</span>

}

func NewDecoder(options ...func(*Decoder) error) (*Decoder, error) <span class="cov8" title="1">{
        d := &amp;Decoder{}
        for _, opt := range options </span><span class="cov8" title="1">{
                if err := opt(d); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return d, nil</span>
}

func (d *Decoder) Decode(r io.Reader) (ex *Exif, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("Exif failed: %v", r)
                }</span>
        }()

        <span class="cov0" title="0">var x *_exif.Exif
        x, err = _exif.Decode(r)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "EOF" </span><span class="cov0" title="0">{

                        // Found no Exif
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">var tm time.Time
        var lat, long float64

        if !d.noDate </span><span class="cov0" title="0">{
                tm, _ = x.DateTime()
        }</span>

        <span class="cov0" title="0">if !d.noLatLong </span><span class="cov0" title="0">{
                lat, long, _ = x.LatLong()
        }</span>

        <span class="cov0" title="0">walker := &amp;exifWalker{x: x, vals: make(map[string]interface{}), includeMatcher: d.includeFieldsRe, excludeMatcher: d.excludeFieldsrRe}
        if err = x.Walk(walker); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ex = &amp;Exif{Lat: lat, Long: long, Date: tm, Tags: walker.vals}

        return</span>
}

func decodeTag(x *_exif.Exif, f _exif.FieldName, t *tiff.Tag) (interface{}, error) <span class="cov0" title="0">{
        switch t.Format() </span>{
        case tiff.StringVal, tiff.UndefVal:<span class="cov0" title="0">
                s := nullString(t.Val)
                if strings.Contains(string(f), "DateTime") </span><span class="cov0" title="0">{
                        if d, err := tryParseDate(x, s); err == nil </span><span class="cov0" title="0">{
                                return d, nil
                        }</span>
                }
                <span class="cov0" title="0">return s, nil</span>
        case tiff.OtherVal:<span class="cov0" title="0">
                return "unknown", nil</span>
        }

        <span class="cov0" title="0">var rv []interface{}

        for i := 0; i &lt; int(t.Count); i++ </span><span class="cov0" title="0">{
                switch t.Format() </span>{
                case tiff.RatVal:<span class="cov0" title="0">
                        n, d, _ := t.Rat2(i)
                        rat := big.NewRat(n, d)
                        if n == 1 </span><span class="cov0" title="0">{
                                rv = append(rv, rat)
                        }</span> else<span class="cov0" title="0"> {
                                f, _ := rat.Float64()
                                rv = append(rv, f)
                        }</span>

                case tiff.FloatVal:<span class="cov0" title="0">
                        v, _ := t.Float(i)
                        rv = append(rv, v)</span>
                case tiff.IntVal:<span class="cov0" title="0">
                        v, _ := t.Int(i)
                        rv = append(rv, v)</span>
                }
        }

        <span class="cov0" title="0">if t.Count == 1 </span><span class="cov0" title="0">{
                if len(rv) == 1 </span><span class="cov0" title="0">{
                        return rv[0], nil
                }</span>
        }

        <span class="cov0" title="0">return rv, nil</span>

}

// Code borrowed from exif.DateTime and adjusted.
func tryParseDate(x *_exif.Exif, s string) (time.Time, error) <span class="cov0" title="0">{
        dateStr := strings.TrimRight(s, "\x00")
        // TODO(bep): look for timezone offset, GPS time, etc.
        timeZone := time.Local
        if tz, _ := x.TimeZone(); tz != nil </span><span class="cov0" title="0">{
                timeZone = tz
        }</span>
        <span class="cov0" title="0">return time.ParseInLocation(exifTimeLayout, dateStr, timeZone)</span>

}

type exifWalker struct {
        x              *_exif.Exif
        vals           map[string]interface{}
        includeMatcher *regexp.Regexp
        excludeMatcher *regexp.Regexp
}

func (e *exifWalker) Walk(f _exif.FieldName, tag *tiff.Tag) error <span class="cov0" title="0">{
        name := string(f)
        if e.excludeMatcher != nil &amp;&amp; e.excludeMatcher.MatchString(name) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if e.includeMatcher != nil &amp;&amp; !e.includeMatcher.MatchString(name) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val, err := decodeTag(e.x, f, tag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">e.vals[name] = val
        return nil</span>
}

func nullString(in []byte) string <span class="cov0" title="0">{
        var rv bytes.Buffer
        for _, b := range in </span><span class="cov0" title="0">{
                if unicode.IsPrint(rune(b)) </span><span class="cov0" title="0">{
                        rv.WriteByte(b)
                }</span>
        }
        <span class="cov0" title="0">rvs := rv.String()
        if utf8.ValidString(rvs) </span><span class="cov0" title="0">{
                return rvs
        }</span>

        <span class="cov0" title="0">return ""</span>
}

var tcodec *tmc.Codec

func init() <span class="cov8" title="1">{
        var err error
        tcodec, err = tmc.New()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

type Tags map[string]interface{}

func (v *Tags) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        vv := make(map[string]interface{})
        if err := tcodec.Unmarshal(b, &amp;vv); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*v = vv

        return nil</span>
}

func (v Tags) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return tcodec.Marshal(v)
}</span>
</pre>
		
		<pre class="file" id="file172" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package images provides template functions for manipulating images.
package images

import (
        "github.com/disintegration/gift"
        "github.com/spf13/cast"
)

// Increment for re-generation of images using these filters.
const filterAPIVersion = 0

type Filters struct {
}

// Brightness creates a filter that changes the brightness of an image.
// The percentage parameter must be in range (-100, 100).
func (*Filters) Brightness(percentage interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(percentage),
                Filter:  gift.Brightness(cast.ToFloat32(percentage)),
        }
}</span>

// ColorBalance creates a filter that changes the color balance of an image.
// The percentage parameters for each color channel (red, green, blue) must be in range (-100, 500).
func (*Filters) ColorBalance(percentageRed, percentageGreen, percentageBlue interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(percentageRed, percentageGreen, percentageBlue),
                Filter:  gift.ColorBalance(cast.ToFloat32(percentageRed), cast.ToFloat32(percentageGreen), cast.ToFloat32(percentageBlue)),
        }
}</span>

// Colorize creates a filter that produces a colorized version of an image.
// The hue parameter is the angle on the color wheel, typically in range (0, 360).
// The saturation parameter must be in range (0, 100).
// The percentage parameter specifies the strength of the effect, it must be in range (0, 100).
func (*Filters) Colorize(hue, saturation, percentage interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(hue, saturation, percentage),
                Filter:  gift.Colorize(cast.ToFloat32(hue), cast.ToFloat32(saturation), cast.ToFloat32(percentage)),
        }
}</span>

// Contrast creates a filter that changes the contrast of an image.
// The percentage parameter must be in range (-100, 100).
func (*Filters) Contrast(percentage interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(percentage),
                Filter:  gift.Contrast(cast.ToFloat32(percentage)),
        }
}</span>

// Gamma creates a filter that performs a gamma correction on an image.
// The gamma parameter must be positive. Gamma = 1 gives the original image.
// Gamma less than 1 darkens the image and gamma greater than 1 lightens it.
func (*Filters) Gamma(gamma interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(gamma),
                Filter:  gift.Gamma(cast.ToFloat32(gamma)),
        }
}</span>

// GaussianBlur creates a filter that applies a gaussian blur to an image.
func (*Filters) GaussianBlur(sigma interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(sigma),
                Filter:  gift.GaussianBlur(cast.ToFloat32(sigma)),
        }
}</span>

// Grayscale creates a filter that produces a grayscale version of an image.
func (*Filters) Grayscale() gift.Filter <span class="cov0" title="0">{
        return filter{
                Filter: gift.Grayscale(),
        }
}</span>

// Hue creates a filter that rotates the hue of an image.
// The hue angle shift is typically in range -180 to 180.
func (*Filters) Hue(shift interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(shift),
                Filter:  gift.Hue(cast.ToFloat32(shift)),
        }
}</span>

// Invert creates a filter that negates the colors of an image.
func (*Filters) Invert() gift.Filter <span class="cov0" title="0">{
        return filter{
                Filter: gift.Invert(),
        }
}</span>

// Pixelate creates a filter that applies a pixelation effect to an image.
func (*Filters) Pixelate(size interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(size),
                Filter:  gift.Pixelate(cast.ToInt(size)),
        }
}</span>

// Saturation creates a filter that changes the saturation of an image.
func (*Filters) Saturation(percentage interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(percentage),
                Filter:  gift.Saturation(cast.ToFloat32(percentage)),
        }
}</span>

// Sepia creates a filter that produces a sepia-toned version of an image.
func (*Filters) Sepia(percentage interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(percentage),
                Filter:  gift.Sepia(cast.ToFloat32(percentage)),
        }
}</span>

// Sigmoid creates a filter that changes the contrast of an image using a sigmoidal function and returns the adjusted image.
// It's a non-linear contrast change useful for photo adjustments as it preserves highlight and shadow detail.
func (*Filters) Sigmoid(midpoint, factor interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(midpoint, factor),
                Filter:  gift.Sigmoid(cast.ToFloat32(midpoint), cast.ToFloat32(factor)),
        }
}</span>

// UnsharpMask creates a filter that sharpens an image.
// The sigma parameter is used in a gaussian function and affects the radius of effect.
// Sigma must be positive. Sharpen radius roughly equals 3 * sigma.
// The amount parameter controls how much darker and how much lighter the edge borders become. Typically between 0.5 and 1.5.
// The threshold parameter controls the minimum brightness change that will be sharpened. Typically between 0 and 0.05.
func (*Filters) UnsharpMask(sigma, amount, threshold interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(sigma, amount, threshold),
                Filter:  gift.UnsharpMask(cast.ToFloat32(sigma), cast.ToFloat32(amount), cast.ToFloat32(threshold)),
        }
}</span>

type filter struct {
        Options filterOpts
        gift.Filter
}

// For cache-busting.
type filterOpts struct {
        Version int
        Vals    interface{}
}

func newFilterOpts(vals ...interface{}) filterOpts <span class="cov0" title="0">{
        return filterOpts{
                Version: filterAPIVersion,
                Vals:    vals,
        }
}</span>
</pre>
		
		<pre class="file" id="file173" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import (
        "fmt"
        "image"
        "image/color"
        "image/gif"
        "image/jpeg"
        "image/png"
        "io"
        "sync"

        "github.com/gohugoio/hugo/resources/images/exif"

        "github.com/disintegration/gift"
        "golang.org/x/image/bmp"
        "golang.org/x/image/tiff"

        "github.com/gohugoio/hugo/common/hugio"
        "github.com/pkg/errors"
)

func NewImage(f Format, proc *ImageProcessor, img image.Image, s Spec) *Image <span class="cov0" title="0">{
        if img != nil </span><span class="cov0" title="0">{
                return &amp;Image{
                        Format: f,
                        Proc:   proc,
                        Spec:   s,
                        imageConfig: &amp;imageConfig{
                                config:       imageConfigFromImage(img),
                                configLoaded: true,
                        },
                }
        }</span>
        <span class="cov0" title="0">return &amp;Image{Format: f, Proc: proc, Spec: s, imageConfig: &amp;imageConfig{}}</span>
}

type Image struct {
        Format Format

        Proc *ImageProcessor

        Spec Spec

        *imageConfig
}

func (i *Image) EncodeTo(conf ImageConfig, img image.Image, w io.Writer) error <span class="cov0" title="0">{
        switch i.Format </span>{
        case JPEG:<span class="cov0" title="0">

                var rgba *image.RGBA
                quality := conf.Quality

                if nrgba, ok := img.(*image.NRGBA); ok </span><span class="cov0" title="0">{
                        if nrgba.Opaque() </span><span class="cov0" title="0">{
                                rgba = &amp;image.RGBA{
                                        Pix:    nrgba.Pix,
                                        Stride: nrgba.Stride,
                                        Rect:   nrgba.Rect,
                                }
                        }</span>
                }
                <span class="cov0" title="0">if rgba != nil </span><span class="cov0" title="0">{
                        return jpeg.Encode(w, rgba, &amp;jpeg.Options{Quality: quality})
                }</span>
                <span class="cov0" title="0">return jpeg.Encode(w, img, &amp;jpeg.Options{Quality: quality})</span>
        case PNG:<span class="cov0" title="0">
                encoder := png.Encoder{CompressionLevel: png.DefaultCompression}
                return encoder.Encode(w, img)</span>

        case GIF:<span class="cov0" title="0">
                return gif.Encode(w, img, &amp;gif.Options{
                        NumColors: 256,
                })</span>
        case TIFF:<span class="cov0" title="0">
                return tiff.Encode(w, img, &amp;tiff.Options{Compression: tiff.Deflate, Predictor: true})</span>

        case BMP:<span class="cov0" title="0">
                return bmp.Encode(w, img)</span>
        default:<span class="cov0" title="0">
                return errors.New("format not supported")</span>
        }

}

// Height returns i's height.
func (i *Image) Height() int <span class="cov0" title="0">{
        i.initConfig()
        return i.config.Height
}</span>

// Width returns i's width.
func (i *Image) Width() int <span class="cov0" title="0">{
        i.initConfig()
        return i.config.Width
}</span>

func (i Image) WithImage(img image.Image) *Image <span class="cov0" title="0">{
        i.Spec = nil
        i.imageConfig = &amp;imageConfig{
                config:       imageConfigFromImage(img),
                configLoaded: true,
        }

        return &amp;i
}</span>

func (i Image) WithSpec(s Spec) *Image <span class="cov0" title="0">{
        i.Spec = s
        i.imageConfig = &amp;imageConfig{}
        return &amp;i
}</span>

func (i *Image) initConfig() error <span class="cov0" title="0">{
        var err error
        i.configInit.Do(func() </span><span class="cov0" title="0">{
                if i.configLoaded </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">var (
                        f      hugio.ReadSeekCloser
                        config image.Config
                )

                f, err = i.Spec.ReadSeekCloser()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">defer f.Close()

                config, _, err = image.DecodeConfig(f)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">i.config = config</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to load image config")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func NewImageProcessor(cfg Imaging) (*ImageProcessor, error) <span class="cov8" title="1">{
        e := cfg.Exif
        exifDecoder, err := exif.NewDecoder(
                exif.WithDateDisabled(e.DisableDate),
                exif.WithLatLongDisabled(e.DisableLatLong),
                exif.ExcludeFields(e.ExcludeFields),
                exif.IncludeFields(e.IncludeFields),
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;ImageProcessor{
                Cfg:         cfg,
                exifDecoder: exifDecoder,
        }, nil</span>

}

type ImageProcessor struct {
        Cfg         Imaging
        exifDecoder *exif.Decoder
}

func (p *ImageProcessor) DecodeExif(r io.Reader) (*exif.Exif, error) <span class="cov0" title="0">{
        return p.exifDecoder.Decode(r)
}</span>

func (p *ImageProcessor) ApplyFiltersFromConfig(src image.Image, conf ImageConfig) (image.Image, error) <span class="cov0" title="0">{
        var filters []gift.Filter

        if conf.Rotate != 0 </span><span class="cov0" title="0">{
                // Apply any rotation before any resize.
                filters = append(filters, gift.Rotate(float32(conf.Rotate), color.Transparent, gift.NearestNeighborInterpolation))
        }</span>

        <span class="cov0" title="0">switch conf.Action </span>{
        case "resize":<span class="cov0" title="0">
                filters = append(filters, gift.Resize(conf.Width, conf.Height, conf.Filter))</span>
        case "fill":<span class="cov0" title="0">
                if conf.AnchorStr == smartCropIdentifier </span><span class="cov0" title="0">{
                        bounds, err := p.smartCrop(src, conf.Width, conf.Height, conf.Filter)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // First crop it, then resize it.
                        <span class="cov0" title="0">filters = append(filters, gift.Crop(bounds))
                        filters = append(filters, gift.Resize(conf.Width, conf.Height, conf.Filter))</span>

                } else<span class="cov0" title="0"> {
                        filters = append(filters, gift.ResizeToFill(conf.Width, conf.Height, conf.Filter, conf.Anchor))
                }</span>
        case "fit":<span class="cov0" title="0">
                filters = append(filters, gift.ResizeToFit(conf.Width, conf.Height, conf.Filter))</span>
        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unsupported action: %q", conf.Action)</span>
        }

        <span class="cov0" title="0">return p.Filter(src, filters...)</span>
}

func (p *ImageProcessor) Filter(src image.Image, filters ...gift.Filter) (image.Image, error) <span class="cov0" title="0">{
        g := gift.New(filters...)
        dst := image.NewRGBA(g.Bounds(src.Bounds()))
        g.Draw(dst, src)
        return dst, nil
}</span>

func (p *ImageProcessor) GetDefaultImageConfig(action string) ImageConfig <span class="cov0" title="0">{
        return ImageConfig{
                Action:  action,
                Quality: p.Cfg.Quality,
        }
}</span>

type Spec interface {
        // Loads the image source.
        ReadSeekCloser() (hugio.ReadSeekCloser, error)
}

// Format is an image file format.
type Format int

const (
        JPEG Format = iota + 1
        PNG
        GIF
        TIFF
        BMP
)

type imageConfig struct {
        config       image.Config
        configInit   sync.Once
        configLoaded bool
}

func imageConfigFromImage(img image.Image) image.Config <span class="cov0" title="0">{
        b := img.Bounds()
        return image.Config{Width: b.Max.X, Height: b.Max.Y}
}</span>

func ToFilters(in interface{}) []gift.Filter <span class="cov0" title="0">{
        switch v := in.(type) </span>{
        case []gift.Filter:<span class="cov0" title="0">
                return v</span>
        case []filter:<span class="cov0" title="0">
                vv := make([]gift.Filter, len(v))
                for i, f := range v </span><span class="cov0" title="0">{
                        vv[i] = f
                }</span>
                <span class="cov0" title="0">return vv</span>
        case gift.Filter:<span class="cov0" title="0">
                return []gift.Filter{v}</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("%T is not an image filter", in))</span>
        }
}
</pre>
		
		<pre class="file" id="file174" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import "math"

// We moved from imaging to the gift package for image processing at some point.
// That package had more, but also less resampling filters. So we add the missing
// ones here. They are fairly exotic, but someone may use them, so keep them here
// for now.
//
// The filters below are ported from https://github.com/disintegration/imaging/blob/9aab30e6aa535fe3337b489b76759ef97dfaf362/resize.go#L369
// MIT License.

var (
        // Hermite cubic spline filter (BC-spline; B=0; C=0).
        hermiteResampling = resamp{
                name:    "Hermite",
                support: 1.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 1.0 </span><span class="cov0" title="0">{
                                return bcspline(x, 0.0, 0.0)
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // Mitchell-Netravali cubic filter (BC-spline; B=1/3; C=1/3).
        mitchellNetravaliResampling = resamp{
                name:    "MitchellNetravali",
                support: 2.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 2.0 </span><span class="cov0" title="0">{
                                return bcspline(x, 1.0/3.0, 1.0/3.0)
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // Catmull-Rom - sharp cubic filter (BC-spline; B=0; C=0.5).
        catmullRomResampling = resamp{
                name:    "CatmullRomResampling",
                support: 2.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 2.0 </span><span class="cov0" title="0">{
                                return bcspline(x, 0.0, 0.5)
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // BSpline is a smooth cubic filter (BC-spline; B=1; C=0).
        bSplineResampling = resamp{
                name:    "BSplineResampling",
                support: 2.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 2.0 </span><span class="cov0" title="0">{
                                return bcspline(x, 1.0, 0.0)
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // Gaussian blurring filter.
        gaussianResampling = resamp{
                name:    "GaussianResampling",
                support: 2.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 2.0 </span><span class="cov0" title="0">{
                                return float32(math.Exp(float64(-2 * x * x)))
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        //  Hann-windowed sinc filter (3 lobes).
        hannResampling = resamp{
                name:    "HannResampling",
                support: 3.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 3.0 </span><span class="cov0" title="0">{
                                return sinc(x) * float32(0.5+0.5*math.Cos(math.Pi*float64(x)/3.0))
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        hammingResampling = resamp{
                name:    "HammingResampling",
                support: 3.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 3.0 </span><span class="cov0" title="0">{
                                return sinc(x) * float32(0.54+0.46*math.Cos(math.Pi*float64(x)/3.0))
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // Blackman-windowed sinc filter (3 lobes).
        blackmanResampling = resamp{
                name:    "BlackmanResampling",
                support: 3.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 3.0 </span><span class="cov0" title="0">{
                                return sinc(x) * float32(0.42-0.5*math.Cos(math.Pi*float64(x)/3.0+math.Pi)+0.08*math.Cos(2.0*math.Pi*float64(x)/3.0))
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        bartlettResampling = resamp{
                name:    "BartlettResampling",
                support: 3.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 3.0 </span><span class="cov0" title="0">{
                                return sinc(x) * (3.0 - x) / 3.0
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // Welch-windowed sinc filter (parabolic window, 3 lobes).
        welchResampling = resamp{
                name:    "WelchResampling",
                support: 3.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 3.0 </span><span class="cov0" title="0">{
                                return sinc(x) * (1.0 - (x * x / 9.0))
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // Cosine-windowed sinc filter (3 lobes).
        cosineResampling = resamp{
                name:    "CosineResampling",
                support: 3.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 3.0 </span><span class="cov0" title="0">{
                                return sinc(x) * float32(math.Cos((math.Pi/2.0)*(float64(x)/3.0)))
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }
)

// The following code is borrowed from https://raw.githubusercontent.com/disintegration/gift/master/resize.go
// MIT licensed.
type resamp struct {
        name    string
        support float32
        kernel  func(float32) float32
}

func (r resamp) String() string <span class="cov0" title="0">{
        return r.name
}</span>

func (r resamp) Support() float32 <span class="cov0" title="0">{
        return r.support
}</span>

func (r resamp) Kernel(x float32) float32 <span class="cov0" title="0">{
        return r.kernel(x)
}</span>

func bcspline(x, b, c float32) float32 <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                x = -x
        }</span>
        <span class="cov0" title="0">if x &lt; 1 </span><span class="cov0" title="0">{
                return ((12-9*b-6*c)*x*x*x + (-18+12*b+6*c)*x*x + (6 - 2*b)) / 6
        }</span>
        <span class="cov0" title="0">if x &lt; 2 </span><span class="cov0" title="0">{
                return ((-b-6*c)*x*x*x + (6*b+30*c)*x*x + (-12*b-48*c)*x + (8*b + 24*c)) / 6
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func absf32(x float32) float32 <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                return -x
        }</span>
        <span class="cov0" title="0">return x</span>
}

func sinc(x float32) float32 <span class="cov0" title="0">{
        if x == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return float32(math.Sin(math.Pi*float64(x)) / (math.Pi * float64(x)))</span>
}
</pre>
		
		<pre class="file" id="file175" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import (
        "image"

        "github.com/disintegration/gift"

        "github.com/muesli/smartcrop"
)

const (
        // Do not change.
        smartCropIdentifier = "smart"

        // This is just a increment, starting on 1. If Smart Crop improves its cropping, we
        // need a way to trigger a re-generation of the crops in the wild, so increment this.
        smartCropVersionNumber = 1
)

func (p *ImageProcessor) newSmartCropAnalyzer(filter gift.Resampling) smartcrop.Analyzer <span class="cov0" title="0">{
        return smartcrop.NewAnalyzer(imagingResizer{p: p, filter: filter})
}</span>

// Needed by smartcrop
type imagingResizer struct {
        p      *ImageProcessor
        filter gift.Resampling
}

func (r imagingResizer) Resize(img image.Image, width, height uint) image.Image <span class="cov0" title="0">{
        result, _ := r.p.Filter(img, gift.Resize(int(width), int(height), r.filter))
        return result
}</span>

func (p *ImageProcessor) smartCrop(img image.Image, width, height int, filter gift.Resampling) (image.Rectangle, error) <span class="cov0" title="0">{
        if width &lt;= 0 || height &lt;= 0 </span><span class="cov0" title="0">{
                return image.Rectangle{}, nil
        }</span>

        <span class="cov0" title="0">srcBounds := img.Bounds()
        srcW := srcBounds.Dx()
        srcH := srcBounds.Dy()

        if srcW &lt;= 0 || srcH &lt;= 0 </span><span class="cov0" title="0">{
                return image.Rectangle{}, nil
        }</span>

        <span class="cov0" title="0">if srcW == width &amp;&amp; srcH == height </span><span class="cov0" title="0">{
                return srcBounds, nil
        }</span>

        <span class="cov0" title="0">smart := p.newSmartCropAnalyzer(filter)

        rect, err := smart.FindBestCrop(img, width, height)
        if err != nil </span><span class="cov0" title="0">{
                return image.Rectangle{}, err
        }</span>

        <span class="cov0" title="0">return img.Bounds().Intersect(rect), nil</span>

}
</pre>
		
		<pre class="file" id="file176" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package internal

import (
        "strconv"

        "github.com/mitchellh/hashstructure"
)

// ResourceTransformationKey are provided by the different transformation implementations.
// It identifies the transformation (name) and its configuration (elements).
// We combine this in a chain with the rest of the transformations
// with the target filename and a content hash of the origin to use as cache key.
type ResourceTransformationKey struct {
        Name     string
        elements []interface{}
}

// NewResourceTransformationKey creates a new ResourceTransformationKey from the transformation
// name and elements. We will create a 64 bit FNV hash from the elements, which when combined
// with the other key elements should be unique for all practical applications.
func NewResourceTransformationKey(name string, elements ...interface{}) ResourceTransformationKey <span class="cov0" title="0">{
        return ResourceTransformationKey{Name: name, elements: elements}
}</span>

// Value returns the Key as a string.
// Do not change this without good reasons.
func (k ResourceTransformationKey) Value() string <span class="cov0" title="0">{
        if len(k.elements) == 0 </span><span class="cov0" title="0">{
                return k.Name
        }</span>

        <span class="cov0" title="0">return k.Name + "_" + HashString(k.elements...)</span>

}

// HashString returns a hash from the given elements.
// It will panic if the hash cannot be calculated.
func HashString(elements ...interface{}) string <span class="cov0" title="0">{
        var o interface{}
        if len(elements) == 1 </span><span class="cov0" title="0">{
                o = elements[0]
        }</span> else<span class="cov0" title="0"> {
                o = elements
        }</span>

        <span class="cov0" title="0">hash, err := hashstructure.Hash(o, nil)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return strconv.FormatUint(hash, 10)</span>
}
</pre>
		
		<pre class="file" id="file177" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package page contains the core interfaces and types for the Page resource,
// a core component in Hugo.
package page

import (
        "html/template"

        "github.com/bep/gitmap"
        "github.com/gohugoio/hugo/config"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/compare"

        "github.com/gohugoio/hugo/navigation"
        "github.com/gohugoio/hugo/related"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/gohugoio/hugo/source"
)

// Clear clears any global package state.
func Clear() error <span class="cov8" title="1">{
        spc.clear()
        return nil
}</span>

// AlternativeOutputFormatsProvider provides alternative output formats for a
// Page.
type AlternativeOutputFormatsProvider interface {
        // AlternativeOutputFormats gives the alternative output formats for the
        // current output.
        // Note that we use the term "alternative" and not "alternate" here, as it
        // does not necessarily replace the other format, it is an alternative representation.
        AlternativeOutputFormats() OutputFormats
}

// AuthorProvider provides author information.
type AuthorProvider interface {
        Author() Author
        Authors() AuthorList
}

// ChildCareProvider provides accessors to child resources.
type ChildCareProvider interface {
        Pages() Pages

        // RegularPages returns a list of pages of kind 'Page'.
        // In Hugo 0.57 we changed the Pages method so it returns all page
        // kinds, even sections. If you want the old behaviour, you can
        // use RegularPages.
        RegularPages() Pages

        Resources() resource.Resources
}

// ContentProvider provides the content related values for a Page.
type ContentProvider interface {
        Content() (interface{}, error)
        Plain() string
        PlainWords() []string
        Summary() template.HTML
        Truncated() bool
        FuzzyWordCount() int
        WordCount() int
        ReadingTime() int
        Len() int
}

// FileProvider provides the source file.
type FileProvider interface {
        File() source.File
}

// GetPageProvider provides the GetPage method.
type GetPageProvider interface {
        // GetPage looks up a page for the given ref.
        //    {{ with .GetPage "blog" }}{{ .Title }}{{ end }}
        //
        // This will return nil when no page could be found, and will return
        // an error if the ref is ambiguous.
        GetPage(ref string) (Page, error)
}

// GitInfoProvider provides Git info.
type GitInfoProvider interface {
        GitInfo() *gitmap.GitInfo
}

// InSectionPositioner provides section navigation.
type InSectionPositioner interface {
        NextInSection() Page
        PrevInSection() Page
}

// InternalDependencies is considered an internal interface.
type InternalDependencies interface {
        GetRelatedDocsHandler() *RelatedDocsHandler
}

// OutputFormatsProvider provides the OutputFormats of a Page.
type OutputFormatsProvider interface {
        OutputFormats() OutputFormats
}

// Page is the core interface in Hugo.
type Page interface {
        ContentProvider
        TableOfContentsProvider
        PageWithoutContent
}

// PageMetaProvider provides page metadata, typically provided via front matter.
type PageMetaProvider interface {
        // The 4 page dates
        resource.Dated

        // Aliases forms the base for redirects generation.
        Aliases() []string

        // BundleType returns the bundle type: "leaf", "branch" or an empty string if it is none.
        // See https://gohugo.io/content-management/page-bundles/
        BundleType() string

        // A configured description.
        Description() string

        // Whether this is a draft. Will only be true if run with the --buildDrafts (-D) flag.
        Draft() bool

        // IsHome returns whether this is the home page.
        IsHome() bool

        // Configured keywords.
        Keywords() []string

        // The Page Kind. One of page, home, section, taxonomy, taxonomyTerm.
        Kind() string

        // The configured layout to use to render this page. Typically set in front matter.
        Layout() string

        // The title used for links.
        LinkTitle() string

        // IsNode returns whether this is an item of one of the list types in Hugo,
        // i.e. not a regular content
        IsNode() bool

        // IsPage returns whether this is a regular content
        IsPage() bool

        // Param looks for a param in Page and then in Site config.
        Param(key interface{}) (interface{}, error)

        // Path gets the relative path, including file name and extension if relevant,
        // to the source of this Page. It will be relative to any content root.
        Path() string

        // The slug, typically defined in front matter.
        Slug() string

        // This page's language code. Will be the same as the site's.
        Lang() string

        // IsSection returns whether this is a section
        IsSection() bool

        // Section returns the first path element below the content root.
        Section() string

        // Returns a slice of sections (directories if it's a file) to this
        // Page.
        SectionsEntries() []string

        // SectionsPath is SectionsEntries joined with a /.
        SectionsPath() string

        // Sitemap returns the sitemap configuration for this page.
        Sitemap() config.Sitemap

        // Type is a discriminator used to select layouts etc. It is typically set
        // in front matter, but will fall back to the root section.
        Type() string

        // The configured weight, used as the first sort value in the default
        // page sort if non-zero.
        Weight() int
}

// PageRenderProvider provides a way for a Page to render itself.
type PageRenderProvider interface {
        Render(layout ...string) template.HTML
}

// PageWithoutContent is the Page without any of the content methods.
type PageWithoutContent interface {
        RawContentProvider
        resource.Resource
        PageMetaProvider
        resource.LanguageProvider

        // For pages backed by a file.
        FileProvider

        GitInfoProvider

        // Output formats
        OutputFormatsProvider
        AlternativeOutputFormatsProvider

        // Tree navigation
        ChildCareProvider
        TreeProvider

        // Horizontal navigation
        InSectionPositioner
        PageRenderProvider
        PaginatorProvider
        Positioner
        navigation.PageMenusProvider

        // TODO(bep)
        AuthorProvider

        // Page lookups/refs
        GetPageProvider
        RefProvider

        resource.TranslationKeyProvider
        TranslationsProvider

        SitesProvider

        // Helper methods
        ShortcodeInfoProvider
        compare.Eqer
        maps.Scratcher
        RelatedKeywordsProvider

        DeprecatedWarningPageMethods
}

// Positioner provides next/prev navigation.
type Positioner interface {
        Next() Page
        Prev() Page

        // Deprecated: Use Prev. Will be removed in Hugo 0.57
        PrevPage() Page

        // Deprecated: Use Next. Will be removed in Hugo 0.57
        NextPage() Page
}

// RawContentProvider provides the raw, unprocessed content of the page.
type RawContentProvider interface {
        RawContent() string
}

// RefProvider provides the methods needed to create reflinks to pages.
type RefProvider interface {
        Ref(argsm map[string]interface{}) (string, error)
        RefFrom(argsm map[string]interface{}, source interface{}) (string, error)
        RelRef(argsm map[string]interface{}) (string, error)
        RelRefFrom(argsm map[string]interface{}, source interface{}) (string, error)
}

// RelatedKeywordsProvider allows a Page to be indexed.
type RelatedKeywordsProvider interface {
        // Make it indexable as a related.Document
        RelatedKeywords(cfg related.IndexConfig) ([]related.Keyword, error)
}

// ShortcodeInfoProvider provides info about the shortcodes in a Page.
type ShortcodeInfoProvider interface {
        // HasShortcode return whether the page has a shortcode with the given name.
        // This method is mainly motivated with the Hugo Docs site's need for a list
        // of pages with the `todo` shortcode in it.
        HasShortcode(name string) bool
}

// SitesProvider provide accessors to get sites.
type SitesProvider interface {
        Site() Site
        Sites() Sites
}

// TableOfContentsProvider provides the table of contents for a Page.
type TableOfContentsProvider interface {
        TableOfContents() template.HTML
}

// TranslationsProvider provides access to any translations.
type TranslationsProvider interface {

        // IsTranslated returns whether this content file is translated to
        // other language(s).
        IsTranslated() bool

        // AllTranslations returns all translations, including the current Page.
        AllTranslations() Pages

        // Translations returns the translations excluding the current Page.
        Translations() Pages
}

// TreeProvider provides section tree navigation.
type TreeProvider interface {

        // IsAncestor returns whether the current page is an ancestor of the given
        // Note that this method is not relevant for taxonomy lists and taxonomy terms pages.
        IsAncestor(other interface{}) (bool, error)

        // CurrentSection returns the page's current section or the page itself if home or a section.
        // Note that this will return nil for pages that is not regular, home or section pages.
        CurrentSection() Page

        // IsDescendant returns whether the current page is a descendant of the given
        // Note that this method is not relevant for taxonomy lists and taxonomy terms pages.
        IsDescendant(other interface{}) (bool, error)

        // FirstSection returns the section on level 1 below home, e.g. "/docs".
        // For the home page, this will return itself.
        FirstSection() Page

        // InSection returns whether the given page is in the current section.
        // Note that this will always return false for pages that are
        // not either regular, home or section pages.
        InSection(other interface{}) (bool, error)

        // Parent returns a section's parent section or a page's section.
        // To get a section's subsections, see Page's Sections method.
        Parent() Page

        // Sections returns this section's subsections, if any.
        // Note that for non-sections, this method will always return an empty list.
        Sections() Pages

        // Page returns a reference to the Page itself, kept here mostly
        // for legacy reasons.
        Page() Page
}

// DeprecatedWarningPageMethods lists deprecated Page methods that will trigger
// a WARNING if invoked.
// This was added in Hugo 0.55.
type DeprecatedWarningPageMethods interface {
        source.FileWithoutOverlap
        DeprecatedWarningPageMethods1
}

type DeprecatedWarningPageMethods1 interface {
        IsDraft() bool
        Hugo() hugo.Info
        LanguagePrefix() string
        GetParam(key string) interface{}
        RSSLink() template.URL
        URL() string
}

// Move here to trigger ERROR instead of WARNING.
// TODO(bep) create wrappers and put into the Page once it has some methods.
type DeprecatedErrorPageMethods interface {
}
</pre>
		
		<pre class="file" id="file178" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package page contains the core interfaces and types for the Page resource,
// a core component in Hugo.
package page

import (
        "fmt"
)

// Data represents the .Data element in a Page in Hugo. We make this
// a type so we can do lazy loading of .Data.Pages
type Data map[string]interface{}

// Pages returns the pages stored with key "pages". If this is a func,
// it will be invoked.
func (d Data) Pages() Pages <span class="cov8" title="1">{
        v, found := d["pages"]
        if !found </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch vv := v.(type) </span>{
        case Pages:<span class="cov0" title="0">
                return vv</span>
        case func() Pages:<span class="cov8" title="1">
                return vv()</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("%T is not Pages", v))</span>
        }
}
</pre>
		
		<pre class="file" id="file179" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import "strings"

const (
        KindPage = "page"

        // The rest are node types; home page, sections etc.

        KindHome         = "home"
        KindSection      = "section"
        KindTaxonomy     = "taxonomy"
        KindTaxonomyTerm = "taxonomyTerm"
)

var kindMap = map[string]string{
        strings.ToLower(KindPage):         KindPage,
        strings.ToLower(KindHome):         KindHome,
        strings.ToLower(KindSection):      KindSection,
        strings.ToLower(KindTaxonomy):     KindTaxonomy,
        strings.ToLower(KindTaxonomyTerm): KindTaxonomyTerm,
}

// GetKind gets the page kind given a string, empty if not found.
func GetKind(s string) string <span class="cov0" title="0">{
        return kindMap[strings.ToLower(s)]
}</span>
</pre>
		
		<pre class="file" id="file180" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is autogenerated.

package page

import (
        "encoding/json"
        "github.com/bep/gitmap"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/navigation"
        "github.com/gohugoio/hugo/source"
        "html/template"
        "time"
)

func MarshalPageToJSON(p Page) ([]byte, error) <span class="cov0" title="0">{
        content, err := p.Content()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">plain := p.Plain()
        plainWords := p.PlainWords()
        summary := p.Summary()
        truncated := p.Truncated()
        fuzzyWordCount := p.FuzzyWordCount()
        wordCount := p.WordCount()
        readingTime := p.ReadingTime()
        length := p.Len()
        tableOfContents := p.TableOfContents()
        rawContent := p.RawContent()
        mediaType := p.MediaType()
        resourceType := p.ResourceType()
        permalink := p.Permalink()
        relPermalink := p.RelPermalink()
        name := p.Name()
        title := p.Title()
        params := p.Params()
        data := p.Data()
        date := p.Date()
        lastmod := p.Lastmod()
        publishDate := p.PublishDate()
        expiryDate := p.ExpiryDate()
        aliases := p.Aliases()
        bundleType := p.BundleType()
        description := p.Description()
        draft := p.Draft()
        isHome := p.IsHome()
        keywords := p.Keywords()
        kind := p.Kind()
        layout := p.Layout()
        linkTitle := p.LinkTitle()
        isNode := p.IsNode()
        isPage := p.IsPage()
        path := p.Path()
        slug := p.Slug()
        lang := p.Lang()
        isSection := p.IsSection()
        section := p.Section()
        sectionsEntries := p.SectionsEntries()
        sectionsPath := p.SectionsPath()
        sitemap := p.Sitemap()
        typ := p.Type()
        weight := p.Weight()
        language := p.Language()
        file := p.File()
        gitInfo := p.GitInfo()
        outputFormats := p.OutputFormats()
        alternativeOutputFormats := p.AlternativeOutputFormats()
        menus := p.Menus()
        translationKey := p.TranslationKey()
        isTranslated := p.IsTranslated()
        allTranslations := p.AllTranslations()
        translations := p.Translations()

        s := struct {
                Content                  interface{}
                Plain                    string
                PlainWords               []string
                Summary                  template.HTML
                Truncated                bool
                FuzzyWordCount           int
                WordCount                int
                ReadingTime              int
                Len                      int
                TableOfContents          template.HTML
                RawContent               string
                MediaType                media.Type
                ResourceType             string
                Permalink                string
                RelPermalink             string
                Name                     string
                Title                    string
                Params                   map[string]interface{}
                Data                     interface{}
                Date                     time.Time
                Lastmod                  time.Time
                PublishDate              time.Time
                ExpiryDate               time.Time
                Aliases                  []string
                BundleType               string
                Description              string
                Draft                    bool
                IsHome                   bool
                Keywords                 []string
                Kind                     string
                Layout                   string
                LinkTitle                string
                IsNode                   bool
                IsPage                   bool
                Path                     string
                Slug                     string
                Lang                     string
                IsSection                bool
                Section                  string
                SectionsEntries          []string
                SectionsPath             string
                Sitemap                  config.Sitemap
                Type                     string
                Weight                   int
                Language                 *langs.Language
                File                     source.File
                GitInfo                  *gitmap.GitInfo
                OutputFormats            OutputFormats
                AlternativeOutputFormats OutputFormats
                Menus                    navigation.PageMenus
                TranslationKey           string
                IsTranslated             bool
                AllTranslations          Pages
                Translations             Pages
        }{
                Content:                  content,
                Plain:                    plain,
                PlainWords:               plainWords,
                Summary:                  summary,
                Truncated:                truncated,
                FuzzyWordCount:           fuzzyWordCount,
                WordCount:                wordCount,
                ReadingTime:              readingTime,
                Len:                      length,
                TableOfContents:          tableOfContents,
                RawContent:               rawContent,
                MediaType:                mediaType,
                ResourceType:             resourceType,
                Permalink:                permalink,
                RelPermalink:             relPermalink,
                Name:                     name,
                Title:                    title,
                Params:                   params,
                Data:                     data,
                Date:                     date,
                Lastmod:                  lastmod,
                PublishDate:              publishDate,
                ExpiryDate:               expiryDate,
                Aliases:                  aliases,
                BundleType:               bundleType,
                Description:              description,
                Draft:                    draft,
                IsHome:                   isHome,
                Keywords:                 keywords,
                Kind:                     kind,
                Layout:                   layout,
                LinkTitle:                linkTitle,
                IsNode:                   isNode,
                IsPage:                   isPage,
                Path:                     path,
                Slug:                     slug,
                Lang:                     lang,
                IsSection:                isSection,
                Section:                  section,
                SectionsEntries:          sectionsEntries,
                SectionsPath:             sectionsPath,
                Sitemap:                  sitemap,
                Type:                     typ,
                Weight:                   weight,
                Language:                 language,
                File:                     file,
                GitInfo:                  gitInfo,
                OutputFormats:            outputFormats,
                AlternativeOutputFormats: alternativeOutputFormats,
                Menus:                    menus,
                TranslationKey:           translationKey,
                IsTranslated:             isTranslated,
                AllTranslations:          allTranslations,
                Translations:             translations,
        }

        return json.Marshal(&amp;s)</span>
}
</pre>
		
		<pre class="file" id="file181" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package page contains the core interfaces and types for the Page resource,
// a core component in Hugo.
package page

import (
        "html/template"
        "time"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/bep/gitmap"
        "github.com/gohugoio/hugo/navigation"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/source"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/related"
        "github.com/gohugoio/hugo/resources/resource"
)

var (
        NopPage Page = new(nopPage)
        NilPage *nopPage
)

// PageNop implements Page, but does nothing.
type nopPage int

func (p *nopPage) Aliases() []string <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Sitemap() config.Sitemap <span class="cov0" title="0">{
        return config.Sitemap{}
}</span>

func (p *nopPage) Layout() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) RSSLink() template.URL <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Author() Author <span class="cov0" title="0">{
        return Author{}

}</span>
func (p *nopPage) Authors() AuthorList <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) AllTranslations() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) LanguagePrefix() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) AlternativeOutputFormats() OutputFormats <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) BaseFileName() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) BundleType() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Content() (interface{}, error) <span class="cov8" title="1">{
        return "", nil
}</span>

func (p *nopPage) ContentBaseName() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) CurrentSection() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Data() interface{} <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Date() (t time.Time) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) Description() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) RefFrom(argsm map[string]interface{}, source interface{}) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>
func (p *nopPage) RelRefFrom(argsm map[string]interface{}, source interface{}) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (p *nopPage) Dir() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Draft() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) Eq(other interface{}) bool <span class="cov0" title="0">{
        return p == other
}</span>

func (p *nopPage) ExpiryDate() (t time.Time) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) Ext() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Extension() string <span class="cov0" title="0">{
        return ""
}</span>

var nilFile *source.FileInfo

func (p *nopPage) File() source.File <span class="cov0" title="0">{
        return nilFile
}</span>

func (p *nopPage) FileInfo() hugofs.FileMetaInfo <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Filename() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) FirstSection() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) FuzzyWordCount() int <span class="cov0" title="0">{
        return 0
}</span>

func (p *nopPage) GetPage(ref string) (Page, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *nopPage) GetParam(key string) interface{} <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) GitInfo() *gitmap.GitInfo <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) HasMenuCurrent(menuID string, me *navigation.MenuEntry) bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) HasShortcode(name string) bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) Hugo() (h hugo.Info) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) InSection(other interface{}) (bool, error) <span class="cov0" title="0">{
        return false, nil
}</span>

func (p *nopPage) IsAncestor(other interface{}) (bool, error) <span class="cov0" title="0">{
        return false, nil
}</span>

func (p *nopPage) IsDescendant(other interface{}) (bool, error) <span class="cov0" title="0">{
        return false, nil
}</span>

func (p *nopPage) IsDraft() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) IsHome() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) IsMenuCurrent(menuID string, inme *navigation.MenuEntry) bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) IsNode() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) IsPage() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) IsSection() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) IsTranslated() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) Keywords() []string <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Kind() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Lang() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Language() *langs.Language <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Lastmod() (t time.Time) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) Len() int <span class="cov0" title="0">{
        return 0
}</span>

func (p *nopPage) LinkTitle() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) LogicalName() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) MediaType() (m media.Type) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) Menus() (m navigation.PageMenus) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) Name() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Next() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) OutputFormats() OutputFormats <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Pages() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) RegularPages() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Paginate(seq interface{}, options ...interface{}) (*Pager, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *nopPage) Paginator(options ...interface{}) (*Pager, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *nopPage) Param(key interface{}) (interface{}, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *nopPage) Params() map[string]interface{} <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Page() Page <span class="cov0" title="0">{
        return p
}</span>

func (p *nopPage) Parent() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Path() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Permalink() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Plain() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) PlainWords() []string <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Prev() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) PublishDate() (t time.Time) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) PrevInSection() Page <span class="cov0" title="0">{
        return nil
}</span>
func (p *nopPage) NextInSection() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) PrevPage() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) NextPage() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) RawContent() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) ReadingTime() int <span class="cov0" title="0">{
        return 0
}</span>

func (p *nopPage) Ref(argsm map[string]interface{}) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (p *nopPage) RelPermalink() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) RelRef(argsm map[string]interface{}) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (p *nopPage) Render(layout ...string) template.HTML <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) ResourceType() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Resources() resource.Resources <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Scratch() *maps.Scratch <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) RelatedKeywords(cfg related.IndexConfig) ([]related.Keyword, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *nopPage) Section() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Sections() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) SectionsEntries() []string <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) SectionsPath() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Site() Site <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Sites() Sites <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Slug() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) String() string <span class="cov0" title="0">{
        return "nopPage"
}</span>

func (p *nopPage) Summary() template.HTML <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) TableOfContents() template.HTML <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Title() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) TranslationBaseName() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) TranslationKey() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Translations() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Truncated() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) Type() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) URL() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) UniqueID() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Weight() int <span class="cov0" title="0">{
        return 0
}</span>

func (p *nopPage) WordCount() int <span class="cov0" title="0">{
        return 0
}</span>
</pre>
		
		<pre class="file" id="file182" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package page contains the core interfaces and types for the Page resource,
// a core component in Hugo.
package page

import (
        "strings"

        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/output"
)

// OutputFormats holds a list of the relevant output formats for a given page.
type OutputFormats []OutputFormat

// OutputFormat links to a representation of a resource.
type OutputFormat struct {
        // Rel constains a value that can be used to construct a rel link.
        // This is value is fetched from the output format definition.
        // Note that for pages with only one output format,
        // this method will always return "canonical".
        // As an example, the AMP output format will, by default, return "amphtml".
        //
        // See:
        // https://www.ampproject.org/docs/guides/deploy/discovery
        //
        // Most other output formats will have "alternate" as value for this.
        Rel string

        Format output.Format

        relPermalink string
        permalink    string
}

// Name returns this OutputFormat's name, i.e. HTML, AMP, JSON etc.
func (o OutputFormat) Name() string <span class="cov0" title="0">{
        return o.Format.Name
}</span>

// MediaType returns this OutputFormat's MediaType (MIME type).
func (o OutputFormat) MediaType() media.Type <span class="cov8" title="1">{
        return o.Format.MediaType
}</span>

// Permalink returns the absolute permalink to this output format.
func (o OutputFormat) Permalink() string <span class="cov8" title="1">{
        return o.permalink
}</span>

// RelPermalink returns the relative permalink to this output format.
func (o OutputFormat) RelPermalink() string <span class="cov8" title="1">{
        return o.relPermalink
}</span>

func NewOutputFormat(relPermalink, permalink string, isCanonical bool, f output.Format) OutputFormat <span class="cov8" title="1">{
        rel := f.Rel
        if isCanonical </span><span class="cov8" title="1">{
                rel = "canonical"
        }</span>
        <span class="cov8" title="1">return OutputFormat{Rel: rel, Format: f, relPermalink: relPermalink, permalink: permalink}</span>
}

// Get gets a OutputFormat given its name, i.e. json, html etc.
// It returns nil if none found.
func (o OutputFormats) Get(name string) *OutputFormat <span class="cov8" title="1">{
        for _, f := range o </span><span class="cov8" title="1">{
                if strings.EqualFold(f.Format.Name, name) </span><span class="cov8" title="1">{
                        return &amp;f
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file183" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "path"
        "path/filepath"

        "strings"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/output"
)

const slash = "/"

// TargetPathDescriptor describes how a file path for a given resource
// should look like on the file system. The same descriptor is then later used to
// create both the permalinks and the relative links, paginator URLs etc.
//
// The big motivating behind this is to have only one source of truth for URLs,
// and by that also get rid of most of the fragile string parsing/encoding etc.
//
//
type TargetPathDescriptor struct {
        PathSpec *helpers.PathSpec

        Type output.Format
        Kind string

        Sections []string

        // For regular content pages this is either
        // 1) the Slug, if set,
        // 2) the file base name (TranslationBaseName).
        BaseName string

        // Source directory.
        Dir string

        // Typically a language prefix added to file paths.
        PrefixFilePath string

        // Typically a language prefix added to links.
        PrefixLink string

        // If in multihost mode etc., every link/path needs to be prefixed, even
        // if set in URL.
        ForcePrefix bool

        // URL from front matter if set. Will override any Slug etc.
        URL string

        // Used to create paginator links.
        Addends string

        // The expanded permalink if defined for the section, ready to use.
        ExpandedPermalink string

        // Some types cannot have uglyURLs, even if globally enabled, RSS being one example.
        UglyURLs bool
}

// TODO(bep) move this type.
type TargetPaths struct {

        // Where to store the file on disk relative to the publish dir. OS slashes.
        TargetFilename string

        // The directory to write sub-resources of the above.
        SubResourceBaseTarget string

        // The base for creating links to sub-resources of the above.
        SubResourceBaseLink string

        // The relative permalink to this resources. Unix slashes.
        Link string
}

func (p TargetPaths) RelPermalink(s *helpers.PathSpec) string <span class="cov8" title="1">{
        return s.PrependBasePath(p.Link, false)
}</span>

func (p TargetPaths) PermalinkForOutputFormat(s *helpers.PathSpec, f output.Format) string <span class="cov8" title="1">{
        var baseURL string
        var err error
        if f.Protocol != "" </span><span class="cov0" title="0">{
                baseURL, err = s.BaseURL.WithProtocol(f.Protocol)
                if err != nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
        } else<span class="cov8" title="1"> {
                baseURL = s.BaseURL.String()
        }</span>

        <span class="cov8" title="1">return s.PermalinkForBaseURL(p.Link, baseURL)</span>
}

func isHtmlIndex(s string) bool <span class="cov8" title="1">{
        return strings.HasSuffix(s, "/index.html")
}</span>

func CreateTargetPaths(d TargetPathDescriptor) (tp TargetPaths) <span class="cov8" title="1">{

        if d.Type.Name == "" </span><span class="cov0" title="0">{
                panic("CreateTargetPath: missing type")</span>
        }

        // Normalize all file Windows paths to simplify what's next.
        <span class="cov8" title="1">if helpers.FilePathSeparator != slash </span><span class="cov0" title="0">{
                d.Dir = filepath.ToSlash(d.Dir)
                d.PrefixFilePath = filepath.ToSlash(d.PrefixFilePath)

        }</span>

        <span class="cov8" title="1">if d.URL != "" &amp;&amp; !strings.HasPrefix(d.URL, "/") </span><span class="cov8" title="1">{
                // Treat this as a context relative URL
                d.ForcePrefix = true
        }</span>

        <span class="cov8" title="1">pagePath := slash

        var (
                pagePathDir string
                link        string
                linkDir     string
        )

        // The top level index files, i.e. the home page etc., needs
        // the index base even when uglyURLs is enabled.
        needsBase := true

        isUgly := d.UglyURLs &amp;&amp; !d.Type.NoUgly
        baseNameSameAsType := d.BaseName != "" &amp;&amp; d.BaseName == d.Type.BaseName

        if d.ExpandedPermalink == "" &amp;&amp; baseNameSameAsType </span><span class="cov0" title="0">{
                isUgly = true
        }</span>

        <span class="cov8" title="1">if d.Kind != KindPage &amp;&amp; d.URL == "" &amp;&amp; len(d.Sections) &gt; 0 </span><span class="cov8" title="1">{
                if d.ExpandedPermalink != "" </span><span class="cov0" title="0">{
                        pagePath = pjoin(pagePath, d.ExpandedPermalink)
                }</span> else<span class="cov8" title="1"> {
                        pagePath = pjoin(d.Sections...)
                }</span>
                <span class="cov8" title="1">needsBase = false</span>
        }

        <span class="cov8" title="1">if d.Type.Path != "" </span><span class="cov0" title="0">{
                pagePath = pjoin(pagePath, d.Type.Path)
        }</span>

        <span class="cov8" title="1">if d.Kind != KindHome &amp;&amp; d.URL != "" </span><span class="cov8" title="1">{
                pagePath = pjoin(pagePath, d.URL)

                if d.Addends != "" </span><span class="cov0" title="0">{
                        pagePath = pjoin(pagePath, d.Addends)
                }</span>

                <span class="cov8" title="1">pagePathDir = pagePath
                link = pagePath
                hasDot := strings.Contains(d.URL, ".")
                hasSlash := strings.HasSuffix(d.URL, slash)

                if hasSlash || !hasDot </span><span class="cov0" title="0">{
                        pagePath = pjoin(pagePath, d.Type.BaseName+d.Type.MediaType.FullSuffix())
                }</span> else<span class="cov8" title="1"> if hasDot </span><span class="cov8" title="1">{
                        pagePathDir = path.Dir(pagePathDir)
                }</span>

                <span class="cov8" title="1">if !isHtmlIndex(pagePath) </span><span class="cov8" title="1">{
                        link = pagePath
                }</span> else<span class="cov0" title="0"> if !hasSlash </span><span class="cov0" title="0">{
                        link += slash
                }</span>

                <span class="cov8" title="1">linkDir = pagePathDir

                if d.ForcePrefix </span><span class="cov8" title="1">{

                        // Prepend language prefix if not already set in URL
                        if d.PrefixFilePath != "" &amp;&amp; !strings.HasPrefix(d.URL, slash+d.PrefixFilePath) </span><span class="cov0" title="0">{
                                pagePath = pjoin(d.PrefixFilePath, pagePath)
                                pagePathDir = pjoin(d.PrefixFilePath, pagePathDir)
                        }</span>

                        <span class="cov8" title="1">if d.PrefixLink != "" &amp;&amp; !strings.HasPrefix(d.URL, slash+d.PrefixLink) </span><span class="cov0" title="0">{
                                link = pjoin(d.PrefixLink, link)
                                linkDir = pjoin(d.PrefixLink, linkDir)
                        }</span>
                }

        } else<span class="cov8" title="1"> if d.Kind == KindPage </span><span class="cov8" title="1">{

                if d.ExpandedPermalink != "" </span><span class="cov0" title="0">{
                        pagePath = pjoin(pagePath, d.ExpandedPermalink)

                }</span> else<span class="cov8" title="1"> {
                        if d.Dir != "" </span><span class="cov8" title="1">{
                                pagePath = pjoin(pagePath, d.Dir)
                        }</span>
                        <span class="cov8" title="1">if d.BaseName != "" </span><span class="cov8" title="1">{
                                pagePath = pjoin(pagePath, d.BaseName)
                        }</span>
                }

                <span class="cov8" title="1">if d.Addends != "" </span><span class="cov0" title="0">{
                        pagePath = pjoin(pagePath, d.Addends)
                }</span>

                <span class="cov8" title="1">link = pagePath

                // TODO(bep) this should not happen after the fix in https://github.com/gohugoio/hugo/issues/4870
                // but we may need some more testing before we can remove it.
                if baseNameSameAsType </span><span class="cov0" title="0">{
                        link = strings.TrimSuffix(link, d.BaseName)
                }</span>

                <span class="cov8" title="1">pagePathDir = link
                link = link + slash
                linkDir = pagePathDir

                if isUgly </span><span class="cov0" title="0">{
                        pagePath = addSuffix(pagePath, d.Type.MediaType.FullSuffix())
                }</span> else<span class="cov8" title="1"> {
                        pagePath = pjoin(pagePath, d.Type.BaseName+d.Type.MediaType.FullSuffix())
                }</span>

                <span class="cov8" title="1">if !isHtmlIndex(pagePath) </span><span class="cov0" title="0">{
                        link = pagePath
                }</span>

                <span class="cov8" title="1">if d.PrefixFilePath != "" </span><span class="cov0" title="0">{
                        pagePath = pjoin(d.PrefixFilePath, pagePath)
                        pagePathDir = pjoin(d.PrefixFilePath, pagePathDir)
                }</span>

                <span class="cov8" title="1">if d.PrefixLink != "" </span><span class="cov0" title="0">{
                        link = pjoin(d.PrefixLink, link)
                        linkDir = pjoin(d.PrefixLink, linkDir)
                }</span>

        } else<span class="cov8" title="1"> {
                if d.Addends != "" </span><span class="cov8" title="1">{
                        pagePath = pjoin(pagePath, d.Addends)
                }</span>

                <span class="cov8" title="1">needsBase = needsBase &amp;&amp; d.Addends == ""

                // No permalink expansion etc. for node type pages (for now)
                base := ""

                if needsBase || !isUgly </span><span class="cov8" title="1">{
                        base = d.Type.BaseName
                }</span>

                <span class="cov8" title="1">pagePathDir = pagePath
                link = pagePath
                linkDir = pagePathDir

                if base != "" </span><span class="cov8" title="1">{
                        pagePath = path.Join(pagePath, addSuffix(base, d.Type.MediaType.FullSuffix()))
                }</span> else<span class="cov0" title="0"> {
                        pagePath = addSuffix(pagePath, d.Type.MediaType.FullSuffix())

                }</span>

                <span class="cov8" title="1">if !isHtmlIndex(pagePath) </span><span class="cov8" title="1">{
                        link = pagePath
                }</span> else<span class="cov8" title="1"> {
                        link += slash
                }</span>

                <span class="cov8" title="1">if d.PrefixFilePath != "" </span><span class="cov0" title="0">{
                        pagePath = pjoin(d.PrefixFilePath, pagePath)
                        pagePathDir = pjoin(d.PrefixFilePath, pagePathDir)
                }</span>

                <span class="cov8" title="1">if d.PrefixLink != "" </span><span class="cov0" title="0">{
                        link = pjoin(d.PrefixLink, link)
                        linkDir = pjoin(d.PrefixLink, linkDir)
                }</span>
        }

        <span class="cov8" title="1">pagePath = pjoin(slash, pagePath)
        pagePathDir = strings.TrimSuffix(path.Join(slash, pagePathDir), slash)

        hadSlash := strings.HasSuffix(link, slash)
        link = strings.Trim(link, slash)
        if hadSlash </span><span class="cov8" title="1">{
                link += slash
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(link, slash) </span><span class="cov8" title="1">{
                link = slash + link
        }</span>

        <span class="cov8" title="1">linkDir = strings.TrimSuffix(path.Join(slash, linkDir), slash)

        // Note: MakePathSanitized will lower case the path if
        // disablePathToLower isn't set.
        pagePath = d.PathSpec.MakePathSanitized(pagePath)
        pagePathDir = d.PathSpec.MakePathSanitized(pagePathDir)
        link = d.PathSpec.MakePathSanitized(link)
        linkDir = d.PathSpec.MakePathSanitized(linkDir)

        tp.TargetFilename = filepath.FromSlash(pagePath)
        tp.SubResourceBaseTarget = filepath.FromSlash(pagePathDir)
        tp.SubResourceBaseLink = linkDir
        tp.Link = d.PathSpec.URLizeFilename(link)
        if tp.Link == "" </span><span class="cov0" title="0">{
                tp.Link = slash
        }</span>

        <span class="cov8" title="1">return</span>
}

func addSuffix(s, suffix string) string <span class="cov8" title="1">{
        return strings.Trim(s, slash) + suffix
}</span>

// Like path.Join, but preserves one trailing slash if present.
func pjoin(elem ...string) string <span class="cov8" title="1">{
        hadSlash := strings.HasSuffix(elem[len(elem)-1], slash)
        joined := path.Join(elem...)
        if hadSlash &amp;&amp; !strings.HasSuffix(joined, slash) </span><span class="cov8" title="1">{
                return joined + slash
        }</span>
        <span class="cov8" title="1">return joined</span>
}
</pre>
		
		<pre class="file" id="file184" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is autogenerated.

package page

import (
        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "html/template"
)

// NewDeprecatedWarningPage adds deprecation warnings to the given implementation.
func NewDeprecatedWarningPage(p DeprecatedWarningPageMethods) DeprecatedWarningPageMethods <span class="cov8" title="1">{
        return &amp;pageDeprecated{p: p}
}</span>

type pageDeprecated struct {
        p DeprecatedWarningPageMethods
}

func (p *pageDeprecated) Filename() string <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".Filename", "Use .File.Filename", false)
        return p.p.Filename()
}</span>
func (p *pageDeprecated) Dir() string <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".Dir", "Use .File.Dir", false)
        return p.p.Dir()
}</span>
func (p *pageDeprecated) IsDraft() bool <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".IsDraft", "Use .Draft.", false)
        return p.p.IsDraft()
}</span>
func (p *pageDeprecated) Extension() string <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".Extension", "Use .File.Extension", false)
        return p.p.Extension()
}</span>
func (p *pageDeprecated) Hugo() hugo.Info <span class="cov8" title="1">{
        helpers.Deprecated("Page", ".Hugo", "Use the global hugo function.", false)
        return p.p.Hugo()
}</span>
func (p *pageDeprecated) Ext() string <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".Ext", "Use .File.Ext", false)
        return p.p.Ext()
}</span>
func (p *pageDeprecated) LanguagePrefix() string <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".LanguagePrefix", "Use .Site.LanguagePrefix.", false)
        return p.p.LanguagePrefix()
}</span>
func (p *pageDeprecated) GetParam(arg0 string) interface{} <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".GetParam", "Use .Param or .Params.myParam.", false)
        return p.p.GetParam(arg0)
}</span>
func (p *pageDeprecated) LogicalName() string <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".LogicalName", "Use .File.LogicalName", false)
        return p.p.LogicalName()
}</span>
func (p *pageDeprecated) BaseFileName() string <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".BaseFileName", "Use .File.BaseFileName", false)
        return p.p.BaseFileName()
}</span>
func (p *pageDeprecated) RSSLink() template.URL <span class="cov8" title="1">{
        helpers.Deprecated("Page", ".RSSLink", "Use the Output Format's link, e.g. something like: \n    {{ with .OutputFormats.Get \"RSS\" }}{{ .RelPermalink }}{{ end }}", false)
        return p.p.RSSLink()
}</span>
func (p *pageDeprecated) TranslationBaseName() string <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".TranslationBaseName", "Use .File.TranslationBaseName", false)
        return p.p.TranslationBaseName()
}</span>
func (p *pageDeprecated) URL() string <span class="cov8" title="1">{
        helpers.Deprecated("Page", ".URL", "Use .Permalink or .RelPermalink. If what you want is the front matter URL value, use .Params.url", false)
        return p.p.URL()
}</span>
func (p *pageDeprecated) ContentBaseName() string <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".ContentBaseName", "Use .File.ContentBaseName", false)
        return p.p.ContentBaseName()
}</span>
func (p *pageDeprecated) UniqueID() string <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".UniqueID", "Use .File.UniqueID", false)
        return p.p.UniqueID()
}</span>
func (p *pageDeprecated) FileInfo() hugofs.FileMetaInfo <span class="cov0" title="0">{
        helpers.Deprecated("Page", ".FileInfo", "Use .File.FileInfo", false)
        return p.p.FileInfo()
}</span>
</pre>
		
		<pre class="file" id="file185" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "errors"
        "fmt"
        "reflect"
        "sort"
        "strings"
        "time"

        "github.com/gohugoio/hugo/common/collections"
        "github.com/gohugoio/hugo/compare"

        "github.com/gohugoio/hugo/resources/resource"
)

var (
        _ collections.Slicer   = PageGroup{}
        _ compare.ProbablyEqer = PageGroup{}
        _ compare.ProbablyEqer = PagesGroup{}
)

// PageGroup represents a group of pages, grouped by the key.
// The key is typically a year or similar.
type PageGroup struct {
        Key interface{}
        Pages
}

type mapKeyValues []reflect.Value

func (v mapKeyValues) Len() int      <span class="cov0" title="0">{ return len(v) }</span>
func (v mapKeyValues) Swap(i, j int) <span class="cov0" title="0">{ v[i], v[j] = v[j], v[i] }</span>

type mapKeyByInt struct{ mapKeyValues }

func (s mapKeyByInt) Less(i, j int) bool <span class="cov0" title="0">{ return s.mapKeyValues[i].Int() &lt; s.mapKeyValues[j].Int() }</span>

type mapKeyByStr struct{ mapKeyValues }

func (s mapKeyByStr) Less(i, j int) bool <span class="cov0" title="0">{
        return compare.LessStrings(s.mapKeyValues[i].String(), s.mapKeyValues[j].String())
}</span>

func sortKeys(v []reflect.Value, order string) []reflect.Value <span class="cov0" title="0">{
        if len(v) &lt;= 1 </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">switch v[0].Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                if order == "desc" </span><span class="cov0" title="0">{
                        sort.Sort(sort.Reverse(mapKeyByInt{v}))
                }</span> else<span class="cov0" title="0"> {
                        sort.Sort(mapKeyByInt{v})
                }</span>
        case reflect.String:<span class="cov0" title="0">
                if order == "desc" </span><span class="cov0" title="0">{
                        sort.Sort(sort.Reverse(mapKeyByStr{v}))
                }</span> else<span class="cov0" title="0"> {
                        sort.Sort(mapKeyByStr{v})
                }</span>
        }
        <span class="cov0" title="0">return v</span>
}

// PagesGroup represents a list of page groups.
// This is what you get when doing page grouping in the templates.
type PagesGroup []PageGroup

// Reverse reverses the order of this list of page groups.
func (p PagesGroup) Reverse() PagesGroup <span class="cov0" title="0">{
        for i, j := 0, len(p)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                p[i], p[j] = p[j], p[i]
        }</span>

        <span class="cov0" title="0">return p</span>
}

var (
        errorType   = reflect.TypeOf((*error)(nil)).Elem()
        pagePtrType = reflect.TypeOf((*Page)(nil)).Elem()
        pagesType   = reflect.TypeOf(Pages{})
)

// GroupBy groups by the value in the given field or method name and with the given order.
// Valid values for order is asc, desc, rev and reverse.
func (p Pages) GroupBy(key string, order ...string) (PagesGroup, error) <span class="cov0" title="0">{
        if len(p) &lt; 1 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">direction := "asc"

        if len(order) &gt; 0 &amp;&amp; (strings.ToLower(order[0]) == "desc" || strings.ToLower(order[0]) == "rev" || strings.ToLower(order[0]) == "reverse") </span><span class="cov0" title="0">{
                direction = "desc"
        }</span>

        <span class="cov0" title="0">var ft interface{}
        m, ok := pagePtrType.MethodByName(key)
        if ok </span><span class="cov0" title="0">{
                if m.Type.NumOut() == 0 || m.Type.NumOut() &gt; 2 </span><span class="cov0" title="0">{
                        return nil, errors.New(key + " is a Page method but you can't use it with GroupBy")
                }</span>
                <span class="cov0" title="0">if m.Type.NumOut() == 1 &amp;&amp; m.Type.Out(0).Implements(errorType) </span><span class="cov0" title="0">{
                        return nil, errors.New(key + " is a Page method but you can't use it with GroupBy")
                }</span>
                <span class="cov0" title="0">if m.Type.NumOut() == 2 &amp;&amp; !m.Type.Out(1).Implements(errorType) </span><span class="cov0" title="0">{
                        return nil, errors.New(key + " is a Page method but you can't use it with GroupBy")
                }</span>
                <span class="cov0" title="0">ft = m</span>
        } else<span class="cov0" title="0"> {
                ft, ok = pagePtrType.Elem().FieldByName(key)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New(key + " is neither a field nor a method of Page")
                }</span>
        }

        <span class="cov0" title="0">var tmp reflect.Value
        switch e := ft.(type) </span>{
        case reflect.StructField:<span class="cov0" title="0">
                tmp = reflect.MakeMap(reflect.MapOf(e.Type, pagesType))</span>
        case reflect.Method:<span class="cov0" title="0">
                tmp = reflect.MakeMap(reflect.MapOf(e.Type.Out(0), pagesType))</span>
        }

        <span class="cov0" title="0">for _, e := range p </span><span class="cov0" title="0">{
                ppv := reflect.ValueOf(e)
                var fv reflect.Value
                switch ft.(type) </span>{
                case reflect.StructField:<span class="cov0" title="0">
                        fv = ppv.Elem().FieldByName(key)</span>
                case reflect.Method:<span class="cov0" title="0">
                        fv = ppv.MethodByName(key).Call([]reflect.Value{})[0]</span>
                }
                <span class="cov0" title="0">if !fv.IsValid() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if !tmp.MapIndex(fv).IsValid() </span><span class="cov0" title="0">{
                        tmp.SetMapIndex(fv, reflect.MakeSlice(pagesType, 0, 0))
                }</span>
                <span class="cov0" title="0">tmp.SetMapIndex(fv, reflect.Append(tmp.MapIndex(fv), ppv))</span>
        }

        <span class="cov0" title="0">sortedKeys := sortKeys(tmp.MapKeys(), direction)
        r := make([]PageGroup, len(sortedKeys))
        for i, k := range sortedKeys </span><span class="cov0" title="0">{
                r[i] = PageGroup{Key: k.Interface(), Pages: tmp.MapIndex(k).Interface().(Pages)}
        }</span>

        <span class="cov0" title="0">return r, nil</span>
}

// GroupByParam groups by the given page parameter key's value and with the given order.
// Valid values for order is asc, desc, rev and reverse.
func (p Pages) GroupByParam(key string, order ...string) (PagesGroup, error) <span class="cov0" title="0">{
        if len(p) &lt; 1 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">direction := "asc"

        if len(order) &gt; 0 &amp;&amp; (strings.ToLower(order[0]) == "desc" || strings.ToLower(order[0]) == "rev" || strings.ToLower(order[0]) == "reverse") </span><span class="cov0" title="0">{
                direction = "desc"
        }</span>

        <span class="cov0" title="0">var tmp reflect.Value
        var keyt reflect.Type
        for _, e := range p </span><span class="cov0" title="0">{
                param := resource.GetParamToLower(e, key)
                if param != nil </span><span class="cov0" title="0">{
                        if _, ok := param.([]string); !ok </span><span class="cov0" title="0">{
                                keyt = reflect.TypeOf(param)
                                tmp = reflect.MakeMap(reflect.MapOf(keyt, pagesType))
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">if !tmp.IsValid() </span><span class="cov0" title="0">{
                return nil, errors.New("there is no such a param")
        }</span>

        <span class="cov0" title="0">for _, e := range p </span><span class="cov0" title="0">{
                param := resource.GetParam(e, key)

                if param == nil || reflect.TypeOf(param) != keyt </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">v := reflect.ValueOf(param)
                if !tmp.MapIndex(v).IsValid() </span><span class="cov0" title="0">{
                        tmp.SetMapIndex(v, reflect.MakeSlice(pagesType, 0, 0))
                }</span>
                <span class="cov0" title="0">tmp.SetMapIndex(v, reflect.Append(tmp.MapIndex(v), reflect.ValueOf(e)))</span>
        }

        <span class="cov0" title="0">var r []PageGroup
        for _, k := range sortKeys(tmp.MapKeys(), direction) </span><span class="cov0" title="0">{
                r = append(r, PageGroup{Key: k.Interface(), Pages: tmp.MapIndex(k).Interface().(Pages)})
        }</span>

        <span class="cov0" title="0">return r, nil</span>
}

func (p Pages) groupByDateField(sorter func(p Pages) Pages, formatter func(p Page) string, order ...string) (PagesGroup, error) <span class="cov0" title="0">{
        if len(p) &lt; 1 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">sp := sorter(p)

        if !(len(order) &gt; 0 &amp;&amp; (strings.ToLower(order[0]) == "asc" || strings.ToLower(order[0]) == "rev" || strings.ToLower(order[0]) == "reverse")) </span><span class="cov0" title="0">{
                sp = sp.Reverse()
        }</span>

        <span class="cov0" title="0">date := formatter(sp[0].(Page))
        var r []PageGroup
        r = append(r, PageGroup{Key: date, Pages: make(Pages, 0)})
        r[0].Pages = append(r[0].Pages, sp[0])

        i := 0
        for _, e := range sp[1:] </span><span class="cov0" title="0">{
                date = formatter(e.(Page))
                if r[i].Key.(string) != date </span><span class="cov0" title="0">{
                        r = append(r, PageGroup{Key: date})
                        i++
                }</span>
                <span class="cov0" title="0">r[i].Pages = append(r[i].Pages, e)</span>
        }
        <span class="cov0" title="0">return r, nil</span>
}

// GroupByDate groups by the given page's Date value in
// the given format and with the given order.
// Valid values for order is asc, desc, rev and reverse.
// For valid format strings, see https://golang.org/pkg/time/#Time.Format
func (p Pages) GroupByDate(format string, order ...string) (PagesGroup, error) <span class="cov0" title="0">{
        sorter := func(p Pages) Pages </span><span class="cov0" title="0">{
                return p.ByDate()
        }</span>
        <span class="cov0" title="0">formatter := func(p Page) string </span><span class="cov0" title="0">{
                return p.Date().Format(format)
        }</span>
        <span class="cov0" title="0">return p.groupByDateField(sorter, formatter, order...)</span>
}

// GroupByPublishDate groups by the given page's PublishDate value in
// the given format and with the given order.
// Valid values for order is asc, desc, rev and reverse.
// For valid format strings, see https://golang.org/pkg/time/#Time.Format
func (p Pages) GroupByPublishDate(format string, order ...string) (PagesGroup, error) <span class="cov0" title="0">{
        sorter := func(p Pages) Pages </span><span class="cov0" title="0">{
                return p.ByPublishDate()
        }</span>
        <span class="cov0" title="0">formatter := func(p Page) string </span><span class="cov0" title="0">{
                return p.PublishDate().Format(format)
        }</span>
        <span class="cov0" title="0">return p.groupByDateField(sorter, formatter, order...)</span>
}

// GroupByExpiryDate groups by the given page's ExpireDate value in
// the given format and with the given order.
// Valid values for order is asc, desc, rev and reverse.
// For valid format strings, see https://golang.org/pkg/time/#Time.Format
func (p Pages) GroupByExpiryDate(format string, order ...string) (PagesGroup, error) <span class="cov0" title="0">{
        sorter := func(p Pages) Pages </span><span class="cov0" title="0">{
                return p.ByExpiryDate()
        }</span>
        <span class="cov0" title="0">formatter := func(p Page) string </span><span class="cov0" title="0">{
                return p.ExpiryDate().Format(format)
        }</span>
        <span class="cov0" title="0">return p.groupByDateField(sorter, formatter, order...)</span>
}

// GroupByParamDate groups by a date set as a param on the page in
// the given format and with the given order.
// Valid values for order is asc, desc, rev and reverse.
// For valid format strings, see https://golang.org/pkg/time/#Time.Format
func (p Pages) GroupByParamDate(key string, format string, order ...string) (PagesGroup, error) <span class="cov0" title="0">{
        sorter := func(p Pages) Pages </span><span class="cov0" title="0">{
                var r Pages
                for _, e := range p </span><span class="cov0" title="0">{
                        param := resource.GetParamToLower(e, key)
                        if _, ok := param.(time.Time); ok </span><span class="cov0" title="0">{
                                r = append(r, e)
                        }</span>
                }
                <span class="cov0" title="0">pdate := func(p1, p2 Page) bool </span><span class="cov0" title="0">{
                        p1p, p2p := p1.(Page), p2.(Page)
                        return resource.GetParamToLower(p1p, key).(time.Time).Unix() &lt; resource.GetParamToLower(p2p, key).(time.Time).Unix()
                }</span>
                <span class="cov0" title="0">pageBy(pdate).Sort(r)
                return r</span>
        }
        <span class="cov0" title="0">formatter := func(p Page) string </span><span class="cov0" title="0">{
                return resource.GetParamToLower(p, key).(time.Time).Format(format)
        }</span>
        <span class="cov0" title="0">return p.groupByDateField(sorter, formatter, order...)</span>
}

// ProbablyEq wraps comare.ProbablyEqer
func (p PageGroup) ProbablyEq(other interface{}) bool <span class="cov0" title="0">{
        otherP, ok := other.(PageGroup)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if p.Key != otherP.Key </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return p.Pages.ProbablyEq(otherP.Pages)</span>

}

// Slice is not meant to be used externally. It's a bridge function
// for the template functions. See collections.Slice.
func (p PageGroup) Slice(in interface{}) (interface{}, error) <span class="cov0" title="0">{
        switch items := in.(type) </span>{
        case PageGroup:<span class="cov0" title="0">
                return items, nil</span>
        case []interface{}:<span class="cov0" title="0">
                groups := make(PagesGroup, len(items))
                for i, v := range items </span><span class="cov0" title="0">{
                        g, ok := v.(PageGroup)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("type %T is not a PageGroup", v)
                        }</span>
                        <span class="cov0" title="0">groups[i] = g</span>
                }
                <span class="cov0" title="0">return groups, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid slice type %T", items)</span>
        }
}

// Len returns the number of pages in the page group.
func (psg PagesGroup) Len() int <span class="cov0" title="0">{
        l := 0
        for _, pg := range psg </span><span class="cov0" title="0">{
                l += len(pg.Pages)
        }</span>
        <span class="cov0" title="0">return l</span>
}

// ProbablyEq wraps comare.ProbablyEqer
func (psg PagesGroup) ProbablyEq(other interface{}) bool <span class="cov0" title="0">{
        otherPsg, ok := other.(PagesGroup)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if len(psg) != len(otherPsg) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for i := range psg </span><span class="cov0" title="0">{
                if !psg[i].ProbablyEq(otherPsg[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>

}

// ToPagesGroup tries to convert seq into a PagesGroup.
func ToPagesGroup(seq interface{}) (PagesGroup, error) <span class="cov8" title="1">{
        switch v := seq.(type) </span>{
        case nil:<span class="cov0" title="0">
                return nil, nil</span>
        case PagesGroup:<span class="cov0" title="0">
                return v, nil</span>
        case []PageGroup:<span class="cov0" title="0">
                return PagesGroup(v), nil</span>
        case []interface{}:<span class="cov0" title="0">
                l := len(v)
                if l == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">switch v[0].(type) </span>{
                case PageGroup:<span class="cov0" title="0">
                        pagesGroup := make(PagesGroup, l)
                        for i, ipg := range v </span><span class="cov0" title="0">{
                                if pg, ok := ipg.(PageGroup); ok </span><span class="cov0" title="0">{
                                        pagesGroup[i] = pg
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, fmt.Errorf("unsupported type in paginate from slice, got %T instead of PageGroup", ipg)
                                }</span>
                        }
                        <span class="cov0" title="0">return pagesGroup, nil</span>
                }
        }

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file186" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pagemeta

import (
        "strings"
        "time"

        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/resources/resource"

        "github.com/gohugoio/hugo/config"
        "github.com/spf13/cast"
)

// FrontMatterHandler maps front matter into Page fields and .Params.
// Note that we currently have only extracted the date logic.
type FrontMatterHandler struct {
        fmConfig frontmatterConfig

        dateHandler        frontMatterFieldHandler
        lastModHandler     frontMatterFieldHandler
        publishDateHandler frontMatterFieldHandler
        expiryDateHandler  frontMatterFieldHandler

        // A map of all date keys configured, including any custom.
        allDateKeys map[string]bool

        logger *loggers.Logger
}

// FrontMatterDescriptor describes how to handle front matter for a given Page.
// It has pointers to values in the receiving page which gets updated.
type FrontMatterDescriptor struct {

        // This the Page's front matter.
        Frontmatter map[string]interface{}

        // This is the Page's base filename (BaseFilename), e.g. page.md., or
        // if page is a leaf bundle, the bundle folder name (ContentBaseName).
        BaseFilename string

        // The content file's mod time.
        ModTime time.Time

        // May be set from the author date in Git.
        GitAuthorDate time.Time

        // The below are pointers to values on Page and will be modified.

        // This is the Page's params.
        Params map[string]interface{}

        // This is the Page's dates.
        Dates *resource.Dates

        // This is the Page's Slug etc.
        PageURLs *URLPath
}

var (
        dateFieldAliases = map[string][]string{
                fmDate:       {},
                fmLastmod:    {"modified"},
                fmPubDate:    {"pubdate", "published"},
                fmExpiryDate: {"unpublishdate"},
        }
)

// HandleDates updates all the dates given the current configuration and the
// supplied front matter params. Note that this requires all lower-case keys
// in the params map.
func (f FrontMatterHandler) HandleDates(d *FrontMatterDescriptor) error <span class="cov8" title="1">{
        if d.Dates == nil </span><span class="cov0" title="0">{
                panic("missing dates")</span>
        }

        <span class="cov8" title="1">if f.dateHandler == nil </span><span class="cov0" title="0">{
                panic("missing date handler")</span>
        }

        <span class="cov8" title="1">if _, err := f.dateHandler(d); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := f.lastModHandler(d); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := f.publishDateHandler(d); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := f.expiryDateHandler(d); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsDateKey returns whether the given front matter key is considered a date by the current
// configuration.
func (f FrontMatterHandler) IsDateKey(key string) bool <span class="cov8" title="1">{
        return f.allDateKeys[key]
}</span>

// A Zero date is a signal that the name can not be parsed.
// This follows the format as outlined in Jekyll, https://jekyllrb.com/docs/posts/:
// "Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers"
func dateAndSlugFromBaseFilename(name string) (time.Time, string) <span class="cov0" title="0">{
        withoutExt, _ := helpers.FileAndExt(name)

        if len(withoutExt) &lt; 10 </span><span class="cov0" title="0">{
                // This can not be a date.
                return time.Time{}, ""
        }</span>

        // Note: Hugo currently have no custom timezone support.
        // We will have to revisit this when that is in place.
        <span class="cov0" title="0">d, err := time.Parse("2006-01-02", withoutExt[:10])
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, ""
        }</span>

        // Be a little lenient with the format here.
        <span class="cov0" title="0">slug := strings.Trim(withoutExt[10:], " -_")

        return d, slug</span>
}

type frontMatterFieldHandler func(d *FrontMatterDescriptor) (bool, error)

func (f FrontMatterHandler) newChainedFrontMatterFieldHandler(handlers ...frontMatterFieldHandler) frontMatterFieldHandler <span class="cov8" title="1">{
        return func(d *FrontMatterDescriptor) (bool, error) </span><span class="cov8" title="1">{
                for _, h := range handlers </span><span class="cov8" title="1">{
                        // First successful handler wins.
                        success, err := h(d)
                        if err != nil </span><span class="cov0" title="0">{
                                f.logger.ERROR.Println(err)
                        }</span> else<span class="cov8" title="1"> if success </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                }
                <span class="cov8" title="1">return false, nil</span>
        }
}

type frontmatterConfig struct {
        date        []string
        lastmod     []string
        publishDate []string
        expiryDate  []string
}

const (
        // These are all the date handler identifiers
        // All identifiers not starting with a ":" maps to a front matter parameter.
        fmDate       = "date"
        fmPubDate    = "publishdate"
        fmLastmod    = "lastmod"
        fmExpiryDate = "expirydate"

        // Gets date from filename, e.g 218-02-22-mypage.md
        fmFilename = ":filename"

        // Gets date from file OS mod time.
        fmModTime = ":filemodtime"

        // Gets date from Git
        fmGitAuthorDate = ":git"
)

// This is the config you get when doing nothing.
func newDefaultFrontmatterConfig() frontmatterConfig <span class="cov8" title="1">{
        return frontmatterConfig{
                date:        []string{fmDate, fmPubDate, fmLastmod},
                lastmod:     []string{fmGitAuthorDate, fmLastmod, fmDate, fmPubDate},
                publishDate: []string{fmPubDate, fmDate},
                expiryDate:  []string{fmExpiryDate},
        }
}</span>

func newFrontmatterConfig(cfg config.Provider) (frontmatterConfig, error) <span class="cov8" title="1">{
        c := newDefaultFrontmatterConfig()
        defaultConfig := c

        if cfg.IsSet("frontmatter") </span><span class="cov0" title="0">{
                fm := cfg.GetStringMap("frontmatter")
                for k, v := range fm </span><span class="cov0" title="0">{
                        loki := strings.ToLower(k)
                        switch loki </span>{
                        case fmDate:<span class="cov0" title="0">
                                c.date = toLowerSlice(v)</span>
                        case fmPubDate:<span class="cov0" title="0">
                                c.publishDate = toLowerSlice(v)</span>
                        case fmLastmod:<span class="cov0" title="0">
                                c.lastmod = toLowerSlice(v)</span>
                        case fmExpiryDate:<span class="cov0" title="0">
                                c.expiryDate = toLowerSlice(v)</span>
                        }
                }
        }

        <span class="cov8" title="1">expander := func(c, d []string) []string </span><span class="cov8" title="1">{
                out := expandDefaultValues(c, d)
                out = addDateFieldAliases(out)
                return out
        }</span>

        <span class="cov8" title="1">c.date = expander(c.date, defaultConfig.date)
        c.publishDate = expander(c.publishDate, defaultConfig.publishDate)
        c.lastmod = expander(c.lastmod, defaultConfig.lastmod)
        c.expiryDate = expander(c.expiryDate, defaultConfig.expiryDate)

        return c, nil</span>
}

func addDateFieldAliases(values []string) []string <span class="cov8" title="1">{
        var complete []string

        for _, v := range values </span><span class="cov8" title="1">{
                complete = append(complete, v)
                if aliases, found := dateFieldAliases[v]; found </span><span class="cov8" title="1">{
                        complete = append(complete, aliases...)
                }</span>
        }
        <span class="cov8" title="1">return helpers.UniqueStringsReuse(complete)</span>
}

func expandDefaultValues(values []string, defaults []string) []string <span class="cov8" title="1">{
        var out []string
        for _, v := range values </span><span class="cov8" title="1">{
                if v == ":default" </span><span class="cov0" title="0">{
                        out = append(out, defaults...)
                }</span> else<span class="cov8" title="1"> {
                        out = append(out, v)
                }</span>
        }
        <span class="cov8" title="1">return out</span>
}

func toLowerSlice(in interface{}) []string <span class="cov0" title="0">{
        out := cast.ToStringSlice(in)
        for i := 0; i &lt; len(out); i++ </span><span class="cov0" title="0">{
                out[i] = strings.ToLower(out[i])
        }</span>

        <span class="cov0" title="0">return out</span>
}

// NewFrontmatterHandler creates a new FrontMatterHandler with the given logger and configuration.
// If no logger is provided, one will be created.
func NewFrontmatterHandler(logger *loggers.Logger, cfg config.Provider) (FrontMatterHandler, error) <span class="cov8" title="1">{

        if logger == nil </span><span class="cov0" title="0">{
                logger = loggers.NewErrorLogger()
        }</span>

        <span class="cov8" title="1">frontMatterConfig, err := newFrontmatterConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return FrontMatterHandler{}, err
        }</span>

        <span class="cov8" title="1">allDateKeys := make(map[string]bool)
        addKeys := func(vals []string) </span><span class="cov8" title="1">{
                for _, k := range vals </span><span class="cov8" title="1">{
                        if !strings.HasPrefix(k, ":") </span><span class="cov8" title="1">{
                                allDateKeys[k] = true
                        }</span>
                }
        }

        <span class="cov8" title="1">addKeys(frontMatterConfig.date)
        addKeys(frontMatterConfig.expiryDate)
        addKeys(frontMatterConfig.lastmod)
        addKeys(frontMatterConfig.publishDate)

        f := FrontMatterHandler{logger: logger, fmConfig: frontMatterConfig, allDateKeys: allDateKeys}

        if err := f.createHandlers(); err != nil </span><span class="cov0" title="0">{
                return f, err
        }</span>

        <span class="cov8" title="1">return f, nil</span>
}

func (f *FrontMatterHandler) createHandlers() error <span class="cov8" title="1">{
        var err error

        if f.dateHandler, err = f.createDateHandler(f.fmConfig.date,
                func(d *FrontMatterDescriptor, t time.Time) </span><span class="cov8" title="1">{
                        d.Dates.FDate = t
                        setParamIfNotSet(fmDate, t, d)
                }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.lastModHandler, err = f.createDateHandler(f.fmConfig.lastmod,
                func(d *FrontMatterDescriptor, t time.Time) </span><span class="cov8" title="1">{
                        setParamIfNotSet(fmLastmod, t, d)
                        d.Dates.FLastmod = t
                }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.publishDateHandler, err = f.createDateHandler(f.fmConfig.publishDate,
                func(d *FrontMatterDescriptor, t time.Time) </span><span class="cov8" title="1">{
                        setParamIfNotSet(fmPubDate, t, d)
                        d.Dates.FPublishDate = t
                }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.expiryDateHandler, err = f.createDateHandler(f.fmConfig.expiryDate,
                func(d *FrontMatterDescriptor, t time.Time) </span><span class="cov0" title="0">{
                        setParamIfNotSet(fmExpiryDate, t, d)
                        d.Dates.FExpiryDate = t
                }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func setParamIfNotSet(key string, value interface{}, d *FrontMatterDescriptor) <span class="cov8" title="1">{
        if _, found := d.Params[key]; found </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">d.Params[key] = value</span>
}

func (f FrontMatterHandler) createDateHandler(identifiers []string, setter func(d *FrontMatterDescriptor, t time.Time)) (frontMatterFieldHandler, error) <span class="cov8" title="1">{
        var h *frontmatterFieldHandlers
        var handlers []frontMatterFieldHandler

        for _, identifier := range identifiers </span><span class="cov8" title="1">{
                switch identifier </span>{
                case fmFilename:<span class="cov0" title="0">
                        handlers = append(handlers, h.newDateFilenameHandler(setter))</span>
                case fmModTime:<span class="cov0" title="0">
                        handlers = append(handlers, h.newDateModTimeHandler(setter))</span>
                case fmGitAuthorDate:<span class="cov8" title="1">
                        handlers = append(handlers, h.newDateGitAuthorDateHandler(setter))</span>
                default:<span class="cov8" title="1">
                        handlers = append(handlers, h.newDateFieldHandler(identifier, setter))</span>
                }
        }

        <span class="cov8" title="1">return f.newChainedFrontMatterFieldHandler(handlers...), nil</span>

}

type frontmatterFieldHandlers int

func (f *frontmatterFieldHandlers) newDateFieldHandler(key string, setter func(d *FrontMatterDescriptor, t time.Time)) frontMatterFieldHandler <span class="cov8" title="1">{
        return func(d *FrontMatterDescriptor) (bool, error) </span><span class="cov8" title="1">{
                v, found := d.Frontmatter[key]

                if !found </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">date, err := cast.ToTimeE(v)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                // We map several date keys to one, so, for example,
                // "expirydate", "unpublishdate" will all set .ExpiryDate (first found).
                <span class="cov8" title="1">setter(d, date)

                // This is the params key as set in front matter.
                d.Params[key] = date

                return true, nil</span>
        }
}

func (f *frontmatterFieldHandlers) newDateFilenameHandler(setter func(d *FrontMatterDescriptor, t time.Time)) frontMatterFieldHandler <span class="cov0" title="0">{
        return func(d *FrontMatterDescriptor) (bool, error) </span><span class="cov0" title="0">{
                date, slug := dateAndSlugFromBaseFilename(d.BaseFilename)
                if date.IsZero() </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                <span class="cov0" title="0">setter(d, date)

                if _, found := d.Frontmatter["slug"]; !found </span><span class="cov0" title="0">{
                        // Use slug from filename
                        d.PageURLs.Slug = slug
                }</span>

                <span class="cov0" title="0">return true, nil</span>
        }
}

func (f *frontmatterFieldHandlers) newDateModTimeHandler(setter func(d *FrontMatterDescriptor, t time.Time)) frontMatterFieldHandler <span class="cov0" title="0">{
        return func(d *FrontMatterDescriptor) (bool, error) </span><span class="cov0" title="0">{
                if d.ModTime.IsZero() </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">setter(d, d.ModTime)
                return true, nil</span>
        }
}

func (f *frontmatterFieldHandlers) newDateGitAuthorDateHandler(setter func(d *FrontMatterDescriptor, t time.Time)) frontMatterFieldHandler <span class="cov8" title="1">{
        return func(d *FrontMatterDescriptor) (bool, error) </span><span class="cov8" title="1">{
                if d.GitAuthorDate.IsZero() </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">setter(d, d.GitAuthorDate)
                return true, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file187" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "fmt"
        "math/rand"

        "github.com/gohugoio/hugo/compare"

        "github.com/gohugoio/hugo/resources/resource"
)

var (
        _ resource.ResourcesConverter = Pages{}
        _ compare.ProbablyEqer        = Pages{}
)

// Pages is a slice of pages. This is the most common list type in Hugo.
type Pages []Page

func (ps Pages) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Pages(%d)", len(ps))
}</span>

// Used in tests.
func (ps Pages) shuffle() <span class="cov0" title="0">{
        for i := range ps </span><span class="cov0" title="0">{
                j := rand.Intn(i + 1)
                ps[i], ps[j] = ps[j], ps[i]
        }</span>
}

// ToResources wraps resource.ResourcesConverter
func (pages Pages) ToResources() resource.Resources <span class="cov0" title="0">{
        r := make(resource.Resources, len(pages))
        for i, p := range pages </span><span class="cov0" title="0">{
                r[i] = p
        }</span>
        <span class="cov0" title="0">return r</span>
}

// ToPages tries to convert seq into Pages.
func ToPages(seq interface{}) (Pages, error) <span class="cov8" title="1">{
        if seq == nil </span><span class="cov0" title="0">{
                return Pages{}, nil
        }</span>

        <span class="cov8" title="1">switch v := seq.(type) </span>{
        case Pages:<span class="cov8" title="1">
                return v, nil</span>
        case *Pages:<span class="cov0" title="0">
                return *(v), nil</span>
        case WeightedPages:<span class="cov0" title="0">
                return v.Pages(), nil</span>
        case PageGroup:<span class="cov0" title="0">
                return v.Pages, nil</span>
        case []Page:<span class="cov0" title="0">
                pages := make(Pages, len(v))
                for i, vv := range v </span><span class="cov0" title="0">{
                        pages[i] = vv
                }</span>
                <span class="cov0" title="0">return pages, nil</span>
        case []interface{}:<span class="cov0" title="0">
                pages := make(Pages, len(v))
                success := true
                for i, vv := range v </span><span class="cov0" title="0">{
                        p, ok := vv.(Page)
                        if !ok </span><span class="cov0" title="0">{
                                success = false
                                break</span>
                        }
                        <span class="cov0" title="0">pages[i] = p</span>
                }
                <span class="cov0" title="0">if success </span><span class="cov0" title="0">{
                        return pages, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("cannot convert type %T to Pages", seq)</span>
}

func (p Pages) Group(key interface{}, in interface{}) (interface{}, error) <span class="cov0" title="0">{
        pages, err := ToPages(in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return PageGroup{Key: key, Pages: pages}, nil</span>
}

// Len returns the number of pages in the list.
func (p Pages) Len() int <span class="cov8" title="1">{
        return len(p)
}</span>

// ProbablyEq wraps comare.ProbablyEqer
func (pages Pages) ProbablyEq(other interface{}) bool <span class="cov0" title="0">{
        otherPages, ok := other.(Pages)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if len(pages) != len(otherPages) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">step := 1

        for i := 0; i &lt; len(pages); i += step </span><span class="cov0" title="0">{
                if !pages[i].Eq(otherPages[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">if i &gt; 50 </span><span class="cov0" title="0">{
                        // This is most likely the same.
                        step = 50
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (ps Pages) removeFirstIfFound(p Page) Pages <span class="cov8" title="1">{
        ii := -1
        for i, pp := range ps </span><span class="cov0" title="0">{
                if p.Eq(pp) </span><span class="cov0" title="0">{
                        ii = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if ii != -1 </span><span class="cov0" title="0">{
                ps = append(ps[:ii], ps[ii+1:]...)
        }</span>
        <span class="cov8" title="1">return ps</span>
}

// PagesFactory somehow creates some Pages.
// We do a lot of lazy Pages initialization in Hugo, so we need a type.
type PagesFactory func() Pages
</pre>
		
		<pre class="file" id="file188" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "sync"
)

type pageCacheEntry struct {
        in  []Pages
        out Pages
}

func (entry pageCacheEntry) matches(pageLists []Pages) bool <span class="cov0" title="0">{
        if len(entry.in) != len(pageLists) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for i, p := range pageLists </span><span class="cov0" title="0">{
                if !pagesEqual(p, entry.in[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

type pageCache struct {
        sync.RWMutex
        m map[string][]pageCacheEntry
}

func newPageCache() *pageCache <span class="cov8" title="1">{
        return &amp;pageCache{m: make(map[string][]pageCacheEntry)}
}</span>

func (c *pageCache) clear() <span class="cov8" title="1">{
        c.Lock()
        defer c.Unlock()
        c.m = make(map[string][]pageCacheEntry)
}</span>

// get/getP gets a Pages slice from the cache matching the given key and
// all the provided Pages slices.
// If none found in cache, a copy of the first slice is created.
//
// If an apply func is provided, that func is applied to the newly created copy.
//
// The getP variant' apply func takes a pointer to Pages.
//
// The cache and the execution of the apply func is protected by a RWMutex.
func (c *pageCache) get(key string, apply func(p Pages), pageLists ...Pages) (Pages, bool) <span class="cov0" title="0">{
        return c.getP(key, func(p *Pages) </span><span class="cov0" title="0">{
                if apply != nil </span><span class="cov0" title="0">{
                        apply(*p)
                }</span>
        }, pageLists...)
}

func (c *pageCache) getP(key string, apply func(p *Pages), pageLists ...Pages) (Pages, bool) <span class="cov0" title="0">{
        c.RLock()
        if cached, ok := c.m[key]; ok </span><span class="cov0" title="0">{
                for _, entry := range cached </span><span class="cov0" title="0">{
                        if entry.matches(pageLists) </span><span class="cov0" title="0">{
                                c.RUnlock()
                                return entry.out, true
                        }</span>
                }
        }
        <span class="cov0" title="0">c.RUnlock()

        c.Lock()
        defer c.Unlock()

        // double-check
        if cached, ok := c.m[key]; ok </span><span class="cov0" title="0">{
                for _, entry := range cached </span><span class="cov0" title="0">{
                        if entry.matches(pageLists) </span><span class="cov0" title="0">{
                                return entry.out, true
                        }</span>
                }
        }

        <span class="cov0" title="0">p := pageLists[0]
        pagesCopy := append(Pages(nil), p...)

        if apply != nil </span><span class="cov0" title="0">{
                apply(&amp;pagesCopy)
        }</span>

        <span class="cov0" title="0">entry := pageCacheEntry{in: pageLists, out: pagesCopy}
        if v, ok := c.m[key]; ok </span><span class="cov0" title="0">{
                c.m[key] = append(v, entry)
        }</span> else<span class="cov0" title="0"> {
                c.m[key] = []pageCacheEntry{entry}
        }</span>

        <span class="cov0" title="0">return pagesCopy, false</span>

}

// pagesEqual returns whether p1 and p2 are equal.
func pagesEqual(p1, p2 Pages) bool <span class="cov8" title="1">{
        if p1 == nil &amp;&amp; p2 == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if p1 == nil || p2 == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if p1.Len() != p2.Len() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if p1.Len() == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(p1); i++ </span><span class="cov8" title="1">{
                if p1[i] != p2[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file189" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "fmt"
)

var (
        _ pagesLanguageMerger = (*Pages)(nil)
)

type pagesLanguageMerger interface {
        MergeByLanguage(other Pages) Pages
        // Needed for integration with the tpl package.
        MergeByLanguageInterface(other interface{}) (interface{}, error)
}

// MergeByLanguage supplies missing translations in p1 with values from p2.
// The result is sorted by the default sort order for pages.
func (p1 Pages) MergeByLanguage(p2 Pages) Pages <span class="cov0" title="0">{
        merge := func(pages *Pages) </span><span class="cov0" title="0">{
                m := make(map[string]bool)
                for _, p := range *pages </span><span class="cov0" title="0">{
                        m[p.TranslationKey()] = true
                }</span>

                <span class="cov0" title="0">for _, p := range p2 </span><span class="cov0" title="0">{
                        if _, found := m[p.TranslationKey()]; !found </span><span class="cov0" title="0">{
                                *pages = append(*pages, p)
                        }</span>
                }

                <span class="cov0" title="0">SortByDefault(*pages)</span>
        }

        <span class="cov0" title="0">out, _ := spc.getP("pages.MergeByLanguage", merge, p1, p2)

        return out</span>
}

// MergeByLanguageInterface is the generic version of MergeByLanguage. It
// is here just so it can be called from the tpl package.
func (p1 Pages) MergeByLanguageInterface(in interface{}) (interface{}, error) <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return p1, nil
        }</span>
        <span class="cov0" title="0">p2, ok := in.(Pages)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%T cannot be merged by language", in)
        }</span>
        <span class="cov0" title="0">return p1.MergeByLanguage(p2), nil</span>
}
</pre>
		
		<pre class="file" id="file190" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

// Prev returns the previous page reletive to the given
func (p Pages) Prev(cur Page) Page <span class="cov0" title="0">{
        for x, c := range p </span><span class="cov0" title="0">{
                if c.Eq(cur) </span><span class="cov0" title="0">{
                        if x == 0 </span><span class="cov0" title="0">{
                                // TODO(bep) consider return nil here to get it line with the other Prevs
                                return p[len(p)-1]
                        }</span>
                        <span class="cov0" title="0">return p[x-1]</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Next returns the next page reletive to the given
func (p Pages) Next(cur Page) Page <span class="cov0" title="0">{
        for x, c := range p </span><span class="cov0" title="0">{
                if c.Eq(cur) </span><span class="cov0" title="0">{
                        if x &lt; len(p)-1 </span><span class="cov0" title="0">{
                                return p[x+1]
                        }</span>
                        // TODO(bep) consider return nil here to get it line with the other Nexts
                        <span class="cov0" title="0">return p[0]</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file191" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "sync"

        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/related"
        "github.com/pkg/errors"
        "github.com/spf13/cast"
)

var (
        // Assert that Pages and PageGroup implements the PageGenealogist interface.
        _ PageGenealogist = (Pages)(nil)
        _ PageGenealogist = PageGroup{}
)

// A PageGenealogist finds related pages in a page collection. This interface is implemented
// by Pages and PageGroup, which makes it available as `{{ .RegularRelated . }}` etc.
type PageGenealogist interface {

        // Template example:
        // {{ $related := .RegularPages.Related . }}
        Related(doc related.Document) (Pages, error)

        // Template example:
        // {{ $related := .RegularPages.RelatedIndices . "tags" "date" }}
        RelatedIndices(doc related.Document, indices ...interface{}) (Pages, error)

        // Template example:
        // {{ $related := .RegularPages.RelatedTo ( keyVals "tags" "hugo", "rocks")  ( keyVals "date" .Date ) }}
        RelatedTo(args ...types.KeyValues) (Pages, error)
}

// Related searches all the configured indices with the search keywords from the
// supplied document.
func (p Pages) Related(doc related.Document) (Pages, error) <span class="cov8" title="1">{
        result, err := p.searchDoc(doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if page, ok := doc.(Page); ok </span><span class="cov8" title="1">{
                return result.removeFirstIfFound(page), nil
        }</span>

        <span class="cov0" title="0">return result, nil</span>

}

// RelatedIndices searches the given indices with the search keywords from the
// supplied document.
func (p Pages) RelatedIndices(doc related.Document, indices ...interface{}) (Pages, error) <span class="cov0" title="0">{
        indicesStr, err := cast.ToStringSliceE(indices)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result, err := p.searchDoc(doc, indicesStr...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if page, ok := doc.(Page); ok </span><span class="cov0" title="0">{
                return result.removeFirstIfFound(page), nil
        }</span>

        <span class="cov0" title="0">return result, nil</span>

}

// RelatedTo searches the given indices with the corresponding values.
func (p Pages) RelatedTo(args ...types.KeyValues) (Pages, error) <span class="cov0" title="0">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return p.search(args...)</span>

}

func (p Pages) search(args ...types.KeyValues) (Pages, error) <span class="cov0" title="0">{
        return p.withInvertedIndex(func(idx *related.InvertedIndex) ([]related.Document, error) </span><span class="cov0" title="0">{
                return idx.SearchKeyValues(args...)
        }</span>)

}

func (p Pages) searchDoc(doc related.Document, indices ...string) (Pages, error) <span class="cov8" title="1">{
        return p.withInvertedIndex(func(idx *related.InvertedIndex) ([]related.Document, error) </span><span class="cov8" title="1">{
                return idx.SearchDoc(doc, indices...)
        }</span>)
}

func (p Pages) withInvertedIndex(search func(idx *related.InvertedIndex) ([]related.Document, error)) (Pages, error) <span class="cov8" title="1">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">d, ok := p[0].(InternalDependencies)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.Errorf("invalid type %T in related serch", p[0])
        }</span>

        <span class="cov8" title="1">cache := d.GetRelatedDocsHandler()

        searchIndex, err := cache.getOrCreateIndex(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result, err := search(searchIndex)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(result) &gt; 0 </span><span class="cov0" title="0">{
                mp := make(Pages, len(result))
                for i, match := range result </span><span class="cov0" title="0">{
                        mp[i] = match.(Page)
                }</span>
                <span class="cov0" title="0">return mp, nil</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

type cachedPostingList struct {
        p Pages

        postingList *related.InvertedIndex
}

type RelatedDocsHandler struct {
        cfg related.Config

        postingLists []*cachedPostingList
        mu           sync.RWMutex
}

func NewRelatedDocsHandler(cfg related.Config) *RelatedDocsHandler <span class="cov8" title="1">{
        return &amp;RelatedDocsHandler{cfg: cfg}
}</span>

func (s *RelatedDocsHandler) Clone() *RelatedDocsHandler <span class="cov0" title="0">{
        return NewRelatedDocsHandler(s.cfg)
}</span>

// This assumes that a lock has been acquired.
func (s *RelatedDocsHandler) getIndex(p Pages) *related.InvertedIndex <span class="cov8" title="1">{
        for _, ci := range s.postingLists </span><span class="cov8" title="1">{
                if pagesEqual(p, ci.p) </span><span class="cov8" title="1">{
                        return ci.postingList
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *RelatedDocsHandler) getOrCreateIndex(p Pages) (*related.InvertedIndex, error) <span class="cov8" title="1">{
        s.mu.RLock()
        cachedIndex := s.getIndex(p)
        if cachedIndex != nil </span><span class="cov8" title="1">{
                s.mu.RUnlock()
                return cachedIndex, nil
        }</span>
        <span class="cov8" title="1">s.mu.RUnlock()

        s.mu.Lock()
        defer s.mu.Unlock()

        if cachedIndex := s.getIndex(p); cachedIndex != nil </span><span class="cov0" title="0">{
                return cachedIndex, nil
        }</span>

        <span class="cov8" title="1">searchIndex := related.NewInvertedIndex(s.cfg)

        for _, page := range p </span><span class="cov8" title="1">{
                if err := searchIndex.Add(page); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">s.postingLists = append(s.postingLists, &amp;cachedPostingList{p: p, postingList: searchIndex})

        return searchIndex, nil</span>
}
</pre>
		
		<pre class="file" id="file192" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "sort"

        "github.com/gohugoio/hugo/resources/resource"

        "github.com/gohugoio/hugo/compare"
        "github.com/spf13/cast"
)

var spc = newPageCache()

/*
 * Implementation of a custom sorter for Pages
 */

// A pageSorter implements the sort interface for Pages
type pageSorter struct {
        pages Pages
        by    pageBy
}

// pageBy is a closure used in the Sort.Less method.
type pageBy func(p1, p2 Page) bool

// Sort stable sorts the pages given the receiver's sort order.
func (by pageBy) Sort(pages Pages) <span class="cov8" title="1">{
        ps := &amp;pageSorter{
                pages: pages,
                by:    by, // The Sort method's receiver is the function (closure) that defines the sort order.
        }
        sort.Stable(ps)
}</span>

// DefaultPageSort is the default sort func for pages in Hugo:
// Order by Weight, Date, LinkTitle and then full file path.
var DefaultPageSort = func(p1, p2 Page) bool <span class="cov8" title="1">{
        if p1.Weight() == p2.Weight() </span><span class="cov8" title="1">{
                if p1.Date().Unix() == p2.Date().Unix() </span><span class="cov8" title="1">{
                        c := compare.Strings(p1.LinkTitle(), p2.LinkTitle())
                        if c == 0 </span><span class="cov0" title="0">{
                                if p1.File().IsZero() || p2.File().IsZero() </span><span class="cov0" title="0">{
                                        return p1.File().IsZero()
                                }</span>
                                <span class="cov0" title="0">return compare.LessStrings(p1.File().Filename(), p2.File().Filename())</span>
                        }
                        <span class="cov8" title="1">return c &lt; 0</span>
                }
                <span class="cov8" title="1">return p1.Date().Unix() &gt; p2.Date().Unix()</span>
        }

        <span class="cov0" title="0">if p2.Weight() == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if p1.Weight() == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return p1.Weight() &lt; p2.Weight()</span>
}

var languagePageSort = func(p1, p2 Page) bool <span class="cov0" title="0">{

        if p1.Language().Weight == p2.Language().Weight </span><span class="cov0" title="0">{
                if p1.Date().Unix() == p2.Date().Unix() </span><span class="cov0" title="0">{
                        c := compare.Strings(p1.LinkTitle(), p2.LinkTitle())
                        if c == 0 </span><span class="cov0" title="0">{
                                if !p1.File().IsZero() &amp;&amp; !p2.File().IsZero() </span><span class="cov0" title="0">{
                                        return compare.LessStrings(p1.File().Filename(), p2.File().Filename())
                                }</span>
                        }
                        <span class="cov0" title="0">return c &lt; 0</span>
                }
                <span class="cov0" title="0">return p1.Date().Unix() &gt; p2.Date().Unix()</span>
        }

        <span class="cov0" title="0">if p2.Language().Weight == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if p1.Language().Weight == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return p1.Language().Weight &lt; p2.Language().Weight</span>
}

func (ps *pageSorter) Len() int      <span class="cov8" title="1">{ return len(ps.pages) }</span>
func (ps *pageSorter) Swap(i, j int) <span class="cov0" title="0">{ ps.pages[i], ps.pages[j] = ps.pages[j], ps.pages[i] }</span>

// Less is part of sort.Interface. It is implemented by calling the "by" closure in the sorter.
func (ps *pageSorter) Less(i, j int) bool <span class="cov8" title="1">{ return ps.by(ps.pages[i], ps.pages[j]) }</span>

// Limit limits the number of pages returned to n.
func (p Pages) Limit(n int) Pages <span class="cov0" title="0">{
        if len(p) &gt; n </span><span class="cov0" title="0">{
                return p[0:n]
        }</span>
        <span class="cov0" title="0">return p</span>
}

// ByWeight sorts the Pages by weight and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByWeight() Pages <span class="cov0" title="0">{
        const key = "pageSort.ByWeight"
        pages, _ := spc.get(key, pageBy(DefaultPageSort).Sort, p)
        return pages
}</span>

// SortByDefault sorts pages by the default sort.
func SortByDefault(pages Pages) <span class="cov8" title="1">{
        pageBy(DefaultPageSort).Sort(pages)
}</span>

// ByTitle sorts the Pages by title and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByTitle() Pages <span class="cov0" title="0">{

        const key = "pageSort.ByTitle"

        title := func(p1, p2 Page) bool </span><span class="cov0" title="0">{
                return compare.LessStrings(p1.Title(), p2.Title())
        }</span>

        <span class="cov0" title="0">pages, _ := spc.get(key, pageBy(title).Sort, p)
        return pages</span>
}

// ByLinkTitle sorts the Pages by link title and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByLinkTitle() Pages <span class="cov0" title="0">{

        const key = "pageSort.ByLinkTitle"

        linkTitle := func(p1, p2 Page) bool </span><span class="cov0" title="0">{
                return compare.LessStrings(p1.LinkTitle(), p2.LinkTitle())
        }</span>

        <span class="cov0" title="0">pages, _ := spc.get(key, pageBy(linkTitle).Sort, p)

        return pages</span>
}

// ByDate sorts the Pages by date and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByDate() Pages <span class="cov0" title="0">{

        const key = "pageSort.ByDate"

        date := func(p1, p2 Page) bool </span><span class="cov0" title="0">{
                return p1.Date().Unix() &lt; p2.Date().Unix()
        }</span>

        <span class="cov0" title="0">pages, _ := spc.get(key, pageBy(date).Sort, p)

        return pages</span>
}

// ByPublishDate sorts the Pages by publish date and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByPublishDate() Pages <span class="cov0" title="0">{

        const key = "pageSort.ByPublishDate"

        pubDate := func(p1, p2 Page) bool </span><span class="cov0" title="0">{
                return p1.PublishDate().Unix() &lt; p2.PublishDate().Unix()
        }</span>

        <span class="cov0" title="0">pages, _ := spc.get(key, pageBy(pubDate).Sort, p)

        return pages</span>
}

// ByExpiryDate sorts the Pages by publish date and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByExpiryDate() Pages <span class="cov0" title="0">{

        const key = "pageSort.ByExpiryDate"

        expDate := func(p1, p2 Page) bool </span><span class="cov0" title="0">{
                return p1.ExpiryDate().Unix() &lt; p2.ExpiryDate().Unix()
        }</span>

        <span class="cov0" title="0">pages, _ := spc.get(key, pageBy(expDate).Sort, p)

        return pages</span>
}

// ByLastmod sorts the Pages by the last modification date and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByLastmod() Pages <span class="cov0" title="0">{

        const key = "pageSort.ByLastmod"

        date := func(p1, p2 Page) bool </span><span class="cov0" title="0">{
                return p1.Lastmod().Unix() &lt; p2.Lastmod().Unix()
        }</span>

        <span class="cov0" title="0">pages, _ := spc.get(key, pageBy(date).Sort, p)

        return pages</span>
}

// ByLength sorts the Pages by length and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByLength() Pages <span class="cov0" title="0">{

        const key = "pageSort.ByLength"

        length := func(p1, p2 Page) bool </span><span class="cov0" title="0">{

                p1l, ok1 := p1.(resource.LengthProvider)
                p2l, ok2 := p2.(resource.LengthProvider)

                if !ok1 </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">if !ok2 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">return p1l.Len() &lt; p2l.Len()</span>
        }

        <span class="cov0" title="0">pages, _ := spc.get(key, pageBy(length).Sort, p)

        return pages</span>
}

// ByLanguage sorts the Pages by the language's Weight.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByLanguage() Pages <span class="cov0" title="0">{

        const key = "pageSort.ByLanguage"

        pages, _ := spc.get(key, pageBy(languagePageSort).Sort, p)

        return pages
}</span>

// SortByLanguage sorts the pages by language.
func SortByLanguage(pages Pages) <span class="cov0" title="0">{
        pageBy(languagePageSort).Sort(pages)
}</span>

// Reverse reverses the order in Pages and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) Reverse() Pages <span class="cov0" title="0">{
        const key = "pageSort.Reverse"

        reverseFunc := func(pages Pages) </span><span class="cov0" title="0">{
                for i, j := 0, len(pages)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                        pages[i], pages[j] = pages[j], pages[i]
                }</span>
        }

        <span class="cov0" title="0">pages, _ := spc.get(key, reverseFunc, p)

        return pages</span>
}

// ByParam sorts the pages according to the given page Params key.
//
// Adjacent invocations on the same receiver with the same paramsKey will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByParam(paramsKey interface{}) Pages <span class="cov0" title="0">{
        paramsKeyStr := cast.ToString(paramsKey)
        key := "pageSort.ByParam." + paramsKeyStr

        paramsKeyComparator := func(p1, p2 Page) bool </span><span class="cov0" title="0">{
                v1, _ := p1.Param(paramsKeyStr)
                v2, _ := p2.Param(paramsKeyStr)

                if v1 == nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">if v2 == nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">isNumeric := func(v interface{}) bool </span><span class="cov0" title="0">{
                        switch v.(type) </span>{
                        case uint8, uint16, uint32, uint64, int, int8, int16, int32, int64, float32, float64:<span class="cov0" title="0">
                                return true</span>
                        default:<span class="cov0" title="0">
                                return false</span>
                        }
                }

                <span class="cov0" title="0">if isNumeric(v1) &amp;&amp; isNumeric(v2) </span><span class="cov0" title="0">{
                        return cast.ToFloat64(v1) &lt; cast.ToFloat64(v2)
                }</span>

                <span class="cov0" title="0">s1 := cast.ToString(v1)
                s2 := cast.ToString(v2)

                return compare.LessStrings(s1, s2)</span>

        }

        <span class="cov0" title="0">pages, _ := spc.get(key, pageBy(paramsKeyComparator).Sort, p)

        return pages</span>
}
</pre>
		
		<pre class="file" id="file193" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "errors"
        "fmt"
        "html/template"
        "math"
        "reflect"

        "github.com/gohugoio/hugo/config"

        "github.com/spf13/cast"
)

// PaginatorProvider provides two ways to create a page paginator.
type PaginatorProvider interface {
        Paginator(options ...interface{}) (*Pager, error)
        Paginate(seq interface{}, options ...interface{}) (*Pager, error)
}

// Pager represents one of the elements in a paginator.
// The number, starting on 1, represents its place.
type Pager struct {
        number int
        *Paginator
}

func (p Pager) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Pager %d", p.number)
}</span>

type paginatedElement interface {
        Len() int
}

type pagers []*Pager

var (
        paginatorEmptyPages      Pages
        paginatorEmptyPageGroups PagesGroup
)

type Paginator struct {
        paginatedElements []paginatedElement
        pagers
        paginationURLFactory
        total int
        size  int
}

type paginationURLFactory func(int) string

// PageNumber returns the current page's number in the pager sequence.
func (p *Pager) PageNumber() int <span class="cov8" title="1">{
        return p.number
}</span>

// URL returns the URL to the current page.
func (p *Pager) URL() template.HTML <span class="cov0" title="0">{
        return template.HTML(p.paginationURLFactory(p.PageNumber()))
}</span>

// Pages returns the Pages on this page.
// Note: If this return a non-empty result, then PageGroups() will return empty.
func (p *Pager) Pages() Pages <span class="cov8" title="1">{
        if len(p.paginatedElements) == 0 </span><span class="cov0" title="0">{
                return paginatorEmptyPages
        }</span>

        <span class="cov8" title="1">if pages, ok := p.element().(Pages); ok </span><span class="cov8" title="1">{
                return pages
        }</span>

        <span class="cov0" title="0">return paginatorEmptyPages</span>
}

// PageGroups return Page groups for this page.
// Note: If this return non-empty result, then Pages() will return empty.
func (p *Pager) PageGroups() PagesGroup <span class="cov0" title="0">{
        if len(p.paginatedElements) == 0 </span><span class="cov0" title="0">{
                return paginatorEmptyPageGroups
        }</span>

        <span class="cov0" title="0">if groups, ok := p.element().(PagesGroup); ok </span><span class="cov0" title="0">{
                return groups
        }</span>

        <span class="cov0" title="0">return paginatorEmptyPageGroups</span>
}

func (p *Pager) element() paginatedElement <span class="cov8" title="1">{
        if len(p.paginatedElements) == 0 </span><span class="cov0" title="0">{
                return paginatorEmptyPages
        }</span>
        <span class="cov8" title="1">return p.paginatedElements[p.PageNumber()-1]</span>
}

// page returns the Page with the given index
func (p *Pager) page(index int) (Page, error) <span class="cov0" title="0">{

        if pages, ok := p.element().(Pages); ok </span><span class="cov0" title="0">{
                if pages != nil &amp;&amp; len(pages) &gt; index </span><span class="cov0" title="0">{
                        return pages[index], nil
                }</span>
                <span class="cov0" title="0">return nil, nil</span>
        }

        // must be PagesGroup
        // this construction looks clumsy, but ...
        // ... it is the difference between 99.5% and 100% test coverage :-)
        <span class="cov0" title="0">groups := p.element().(PagesGroup)

        i := 0
        for _, v := range groups </span><span class="cov0" title="0">{
                for _, page := range v.Pages </span><span class="cov0" title="0">{
                        if i == index </span><span class="cov0" title="0">{
                                return page, nil
                        }</span>
                        <span class="cov0" title="0">i++</span>
                }
        }
        <span class="cov0" title="0">return nil, nil</span>
}

// NumberOfElements gets the number of elements on this page.
func (p *Pager) NumberOfElements() int <span class="cov0" title="0">{
        return p.element().Len()
}</span>

// HasPrev tests whether there are page(s) before the current.
func (p *Pager) HasPrev() bool <span class="cov0" title="0">{
        return p.PageNumber() &gt; 1
}</span>

// Prev returns the pager for the previous page.
func (p *Pager) Prev() *Pager <span class="cov0" title="0">{
        if !p.HasPrev() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return p.pagers[p.PageNumber()-2]</span>
}

// HasNext tests whether there are page(s) after the current.
func (p *Pager) HasNext() bool <span class="cov8" title="1">{
        return p.PageNumber() &lt; len(p.paginatedElements)
}</span>

// Next returns the pager for the next page.
func (p *Pager) Next() *Pager <span class="cov8" title="1">{
        if !p.HasNext() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return p.pagers[p.PageNumber()]</span>
}

// First returns the pager for the first page.
func (p *Pager) First() *Pager <span class="cov8" title="1">{
        return p.pagers[0]
}</span>

// Last returns the pager for the last page.
func (p *Pager) Last() *Pager <span class="cov0" title="0">{
        return p.pagers[len(p.pagers)-1]
}</span>

// Pagers returns a list of pagers that can be used to build a pagination menu.
func (p *Paginator) Pagers() pagers <span class="cov8" title="1">{
        return p.pagers
}</span>

// PageSize returns the size of each paginator page.
func (p *Paginator) PageSize() int <span class="cov0" title="0">{
        return p.size
}</span>

// TotalPages returns the number of pages in the paginator.
func (p *Paginator) TotalPages() int <span class="cov8" title="1">{
        return len(p.paginatedElements)
}</span>

// TotalNumberOfElements returns the number of elements on all pages in this paginator.
func (p *Paginator) TotalNumberOfElements() int <span class="cov0" title="0">{
        return p.total
}</span>

func splitPages(pages Pages, size int) []paginatedElement <span class="cov8" title="1">{
        var split []paginatedElement
        for low, j := 0, len(pages); low &lt; j; low += size </span><span class="cov8" title="1">{
                high := int(math.Min(float64(low+size), float64(len(pages))))
                split = append(split, pages[low:high])
        }</span>

        <span class="cov8" title="1">return split</span>
}

func splitPageGroups(pageGroups PagesGroup, size int) []paginatedElement <span class="cov0" title="0">{

        type keyPage struct {
                key  interface{}
                page Page
        }

        var (
                split     []paginatedElement
                flattened []keyPage
        )

        for _, g := range pageGroups </span><span class="cov0" title="0">{
                for _, p := range g.Pages </span><span class="cov0" title="0">{
                        flattened = append(flattened, keyPage{g.Key, p})
                }</span>
        }

        <span class="cov0" title="0">numPages := len(flattened)

        for low, j := 0, numPages; low &lt; j; low += size </span><span class="cov0" title="0">{
                high := int(math.Min(float64(low+size), float64(numPages)))

                var (
                        pg         PagesGroup
                        key        interface{}
                        groupIndex = -1
                )

                for k := low; k &lt; high; k++ </span><span class="cov0" title="0">{
                        kp := flattened[k]
                        if key == nil || key != kp.key </span><span class="cov0" title="0">{
                                key = kp.key
                                pg = append(pg, PageGroup{Key: key})
                                groupIndex++
                        }</span>
                        <span class="cov0" title="0">pg[groupIndex].Pages = append(pg[groupIndex].Pages, kp.page)</span>
                }
                <span class="cov0" title="0">split = append(split, pg)</span>
        }

        <span class="cov0" title="0">return split</span>
}

func ResolvePagerSize(cfg config.Provider, options ...interface{}) (int, error) <span class="cov8" title="1">{
        if len(options) == 0 </span><span class="cov8" title="1">{
                return cfg.GetInt("paginate"), nil
        }</span>

        <span class="cov0" title="0">if len(options) &gt; 1 </span><span class="cov0" title="0">{
                return -1, errors.New("too many arguments, 'pager size' is currently the only option")
        }</span>

        <span class="cov0" title="0">pas, err := cast.ToIntE(options[0])

        if err != nil || pas &lt;= 0 </span><span class="cov0" title="0">{
                return -1, errors.New(("'pager size' must be a positive integer"))
        }</span>

        <span class="cov0" title="0">return pas, nil</span>
}

func Paginate(td TargetPathDescriptor, seq interface{}, pagerSize int) (*Paginator, error) <span class="cov8" title="1">{

        if pagerSize &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("'paginate' configuration setting must be positive to paginate")
        }</span>

        <span class="cov8" title="1">urlFactory := newPaginationURLFactory(td)

        var paginator *Paginator

        groups, err := ToPagesGroup(seq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if groups != nil </span><span class="cov0" title="0">{
                paginator, _ = newPaginatorFromPageGroups(groups, pagerSize, urlFactory)
        }</span> else<span class="cov8" title="1"> {
                pages, err := ToPages(seq)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">paginator, _ = newPaginatorFromPages(pages, pagerSize, urlFactory)</span>
        }

        <span class="cov8" title="1">return paginator, nil</span>
}

// probablyEqual checks page lists for probable equality.
// It may return false positives.
// The motivation behind this is to avoid potential costly reflect.DeepEqual
// when "probably" is good enough.
func probablyEqualPageLists(a1 interface{}, a2 interface{}) bool <span class="cov0" title="0">{

        if a1 == nil || a2 == nil </span><span class="cov0" title="0">{
                return a1 == a2
        }</span>

        <span class="cov0" title="0">t1 := reflect.TypeOf(a1)
        t2 := reflect.TypeOf(a2)

        if t1 != t2 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if g1, ok := a1.(PagesGroup); ok </span><span class="cov0" title="0">{
                g2 := a2.(PagesGroup)
                if len(g1) != len(g2) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if len(g1) == 0 </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if g1.Len() != g2.Len() </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">return g1[0].Pages[0] == g2[0].Pages[0]</span>
        }

        <span class="cov0" title="0">p1, err1 := ToPages(a1)
        p2, err2 := ToPages(a2)

        // probably the same wrong type
        if err1 != nil &amp;&amp; err2 != nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if len(p1) != len(p2) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if len(p1) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return p1[0] == p2[0]</span>
}

func newPaginatorFromPages(pages Pages, size int, urlFactory paginationURLFactory) (*Paginator, error) <span class="cov8" title="1">{

        if size &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("Paginator size must be positive")
        }</span>

        <span class="cov8" title="1">split := splitPages(pages, size)

        return newPaginator(split, len(pages), size, urlFactory)</span>
}

func newPaginatorFromPageGroups(pageGroups PagesGroup, size int, urlFactory paginationURLFactory) (*Paginator, error) <span class="cov0" title="0">{

        if size &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("Paginator size must be positive")
        }</span>

        <span class="cov0" title="0">split := splitPageGroups(pageGroups, size)

        return newPaginator(split, pageGroups.Len(), size, urlFactory)</span>
}

func newPaginator(elements []paginatedElement, total, size int, urlFactory paginationURLFactory) (*Paginator, error) <span class="cov8" title="1">{
        p := &amp;Paginator{total: total, paginatedElements: elements, size: size, paginationURLFactory: urlFactory}

        var ps pagers

        if len(elements) &gt; 0 </span><span class="cov8" title="1">{
                ps = make(pagers, len(elements))
                for i := range p.paginatedElements </span><span class="cov8" title="1">{
                        ps[i] = &amp;Pager{number: (i + 1), Paginator: p}
                }</span>
        } else<span class="cov0" title="0"> {
                ps = make(pagers, 1)
                ps[0] = &amp;Pager{number: 1, Paginator: p}
        }</span>

        <span class="cov8" title="1">p.pagers = ps

        return p, nil</span>
}

func newPaginationURLFactory(d TargetPathDescriptor) paginationURLFactory <span class="cov8" title="1">{

        return func(pageNumber int) string </span><span class="cov0" title="0">{
                pathDescriptor := d
                var rel string
                if pageNumber &gt; 1 </span><span class="cov0" title="0">{
                        rel = fmt.Sprintf("/%s/%d/", d.PathSpec.PaginatePath, pageNumber)
                        pathDescriptor.Addends = rel
                }</span>

                <span class="cov0" title="0">return CreateTargetPaths(pathDescriptor).RelPermalink(d.PathSpec)</span>

        }
}
</pre>
		
		<pre class="file" id="file194" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/helpers"
)

// PermalinkExpander holds permalin mappings per section.
type PermalinkExpander struct {
        // knownPermalinkAttributes maps :tags in a permalink specification to a
        // function which, given a page and the tag, returns the resulting string
        // to be used to replace that tag.
        knownPermalinkAttributes map[string]pageToPermaAttribute

        expanders map[string]func(Page) (string, error)

        ps *helpers.PathSpec
}

// NewPermalinkExpander creates a new PermalinkExpander configured by the given
// PathSpec.
func NewPermalinkExpander(ps *helpers.PathSpec) (PermalinkExpander, error) <span class="cov8" title="1">{

        p := PermalinkExpander{ps: ps}

        p.knownPermalinkAttributes = map[string]pageToPermaAttribute{
                "year":        p.pageToPermalinkDate,
                "month":       p.pageToPermalinkDate,
                "monthname":   p.pageToPermalinkDate,
                "day":         p.pageToPermalinkDate,
                "weekday":     p.pageToPermalinkDate,
                "weekdayname": p.pageToPermalinkDate,
                "yearday":     p.pageToPermalinkDate,
                "section":     p.pageToPermalinkSection,
                "sections":    p.pageToPermalinkSections,
                "title":       p.pageToPermalinkTitle,
                "slug":        p.pageToPermalinkSlugElseTitle,
                "filename":    p.pageToPermalinkFilename,
        }

        patterns := ps.Cfg.GetStringMapString("permalinks")
        if patterns == nil </span><span class="cov0" title="0">{
                return p, nil
        }</span>

        <span class="cov8" title="1">e, err := p.parse(patterns)
        if err != nil </span><span class="cov0" title="0">{
                return p, err
        }</span>

        <span class="cov8" title="1">p.expanders = e

        return p, nil</span>
}

// Expand expands the path in p according to the rules defined for the given key.
// If no rules are found for the given key, an empty string is returned.
func (l PermalinkExpander) Expand(key string, p Page) (string, error) <span class="cov8" title="1">{
        expand, found := l.expanders[key]

        if !found </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov0" title="0">return expand(p)</span>

}

func (l PermalinkExpander) parse(patterns map[string]string) (map[string]func(Page) (string, error), error) <span class="cov8" title="1">{

        expanders := make(map[string]func(Page) (string, error))

        // Allow " " and / to represent the root section.
        const sectionCutSet = " /" + string(os.PathSeparator)

        for k, pattern := range patterns </span><span class="cov0" title="0">{
                k = strings.Trim(k, sectionCutSet)
                if !l.validate(pattern) </span><span class="cov0" title="0">{
                        return nil, &amp;permalinkExpandError{pattern: pattern, err: errPermalinkIllFormed}
                }</span>

                <span class="cov0" title="0">pattern := pattern
                matches := attributeRegexp.FindAllStringSubmatch(pattern, -1)

                callbacks := make([]pageToPermaAttribute, len(matches))
                replacements := make([]string, len(matches))
                for i, m := range matches </span><span class="cov0" title="0">{
                        replacement := m[0]
                        attr := replacement[1:]
                        replacements[i] = replacement
                        callback, ok := l.knownPermalinkAttributes[attr]

                        if !ok </span><span class="cov0" title="0">{
                                return nil, &amp;permalinkExpandError{pattern: pattern, err: errPermalinkAttributeUnknown}
                        }</span>

                        <span class="cov0" title="0">callbacks[i] = callback</span>
                }

                <span class="cov0" title="0">expanders[k] = func(p Page) (string, error) </span><span class="cov0" title="0">{

                        if matches == nil </span><span class="cov0" title="0">{
                                return pattern, nil
                        }</span>

                        <span class="cov0" title="0">newField := pattern

                        for i, replacement := range replacements </span><span class="cov0" title="0">{
                                attr := replacement[1:]
                                callback := callbacks[i]
                                newAttr, err := callback(p, attr)

                                if err != nil </span><span class="cov0" title="0">{
                                        return "", &amp;permalinkExpandError{pattern: pattern, err: err}
                                }</span>

                                <span class="cov0" title="0">newField = strings.Replace(newField, replacement, newAttr, 1)</span>

                        }

                        <span class="cov0" title="0">return newField, nil</span>

                }

        }

        <span class="cov8" title="1">return expanders, nil</span>
}

// pageToPermaAttribute is the type of a function which, given a page and a tag
// can return a string to go in that position in the page (or an error)
type pageToPermaAttribute func(Page, string) (string, error)

var attributeRegexp = regexp.MustCompile(`:\w+`)

// validate determines if a PathPattern is well-formed
func (l PermalinkExpander) validate(pp string) bool <span class="cov0" title="0">{
        fragments := strings.Split(pp[1:], "/")
        var bail = false
        for i := range fragments </span><span class="cov0" title="0">{
                if bail </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if len(fragments[i]) == 0 </span><span class="cov0" title="0">{
                        bail = true
                        continue</span>
                }

                <span class="cov0" title="0">matches := attributeRegexp.FindAllStringSubmatch(fragments[i], -1)
                if matches == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, match := range matches </span><span class="cov0" title="0">{
                        k := strings.ToLower(match[0][1:])
                        if _, ok := l.knownPermalinkAttributes[k]; !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}

type permalinkExpandError struct {
        pattern string
        err     error
}

func (pee *permalinkExpandError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error expanding %q: %s", pee.pattern, pee.err)
}</span>

var (
        errPermalinkIllFormed        = errors.New("permalink ill-formed")
        errPermalinkAttributeUnknown = errors.New("permalink attribute not recognised")
)

func (l PermalinkExpander) pageToPermalinkDate(p Page, dateField string) (string, error) <span class="cov0" title="0">{
        // a Page contains a Node which provides a field Date, time.Time
        switch dateField </span>{
        case "year":<span class="cov0" title="0">
                return strconv.Itoa(p.Date().Year()), nil</span>
        case "month":<span class="cov0" title="0">
                return fmt.Sprintf("%02d", int(p.Date().Month())), nil</span>
        case "monthname":<span class="cov0" title="0">
                return p.Date().Month().String(), nil</span>
        case "day":<span class="cov0" title="0">
                return fmt.Sprintf("%02d", p.Date().Day()), nil</span>
        case "weekday":<span class="cov0" title="0">
                return strconv.Itoa(int(p.Date().Weekday())), nil</span>
        case "weekdayname":<span class="cov0" title="0">
                return p.Date().Weekday().String(), nil</span>
        case "yearday":<span class="cov0" title="0">
                return strconv.Itoa(p.Date().YearDay()), nil</span>
        }
        //TODO: support classic strftime escapes too
        // (and pass those through despite not being in the map)
        <span class="cov0" title="0">panic("coding error: should not be here")</span>
}

// pageToPermalinkTitle returns the URL-safe form of the title
func (l PermalinkExpander) pageToPermalinkTitle(p Page, _ string) (string, error) <span class="cov0" title="0">{
        return l.ps.URLize(p.Title()), nil
}</span>

// pageToPermalinkFilename returns the URL-safe form of the filename
func (l PermalinkExpander) pageToPermalinkFilename(p Page, _ string) (string, error) <span class="cov0" title="0">{
        name := p.File().TranslationBaseName()
        if name == "index" </span><span class="cov0" title="0">{
                // Page bundles; the directory name will hopefully have a better name.
                dir := strings.TrimSuffix(p.File().Dir(), helpers.FilePathSeparator)
                _, name = filepath.Split(dir)
        }</span>

        <span class="cov0" title="0">return l.ps.URLize(name), nil</span>
}

// if the page has a slug, return the slug, else return the title
func (l PermalinkExpander) pageToPermalinkSlugElseTitle(p Page, a string) (string, error) <span class="cov0" title="0">{
        if p.Slug() != "" </span><span class="cov0" title="0">{
                return l.ps.URLize(p.Slug()), nil
        }</span>
        <span class="cov0" title="0">return l.pageToPermalinkTitle(p, a)</span>
}

func (l PermalinkExpander) pageToPermalinkSection(p Page, _ string) (string, error) <span class="cov0" title="0">{
        return p.Section(), nil
}</span>

func (l PermalinkExpander) pageToPermalinkSections(p Page, _ string) (string, error) <span class="cov0" title="0">{
        return p.CurrentSection().SectionsPath(), nil
}</span>
</pre>
		
		<pre class="file" id="file195" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "html/template"
        "time"

        "github.com/gohugoio/hugo/config"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/navigation"
)

// Site represents a site in the build. This is currently a very narrow interface,
// but the actual implementation will be richer, see hugolib.SiteInfo.
type Site interface {
        Language() *langs.Language
        RegularPages() Pages
        Pages() Pages
        IsServer() bool
        ServerPort() int
        Title() string
        Sites() Sites
        Hugo() hugo.Info
        BaseURL() template.URL
        Taxonomies() interface{}
        LastChange() time.Time
        Menus() navigation.Menus
        Params() map[string]interface{}
        Data() map[string]interface{}
}

// Sites represents an ordered list of sites (languages).
type Sites []Site

// First is a convenience method to get the first Site, i.e. the main language.
func (s Sites) First() Site <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return s[0]</span>
}

type testSite struct {
        h hugo.Info
        l *langs.Language
}

func (t testSite) Hugo() hugo.Info <span class="cov0" title="0">{
        return t.h
}</span>

func (t testSite) ServerPort() int <span class="cov0" title="0">{
        return 1313
}</span>

func (testSite) LastChange() (t time.Time) <span class="cov0" title="0">{
        return
}</span>

func (t testSite) Title() string <span class="cov0" title="0">{
        return "foo"
}</span>

func (t testSite) Sites() Sites <span class="cov0" title="0">{
        return nil
}</span>

func (t testSite) IsServer() bool <span class="cov0" title="0">{
        return false
}</span>

func (t testSite) Language() *langs.Language <span class="cov0" title="0">{
        return t.l
}</span>

func (t testSite) Pages() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (t testSite) RegularPages() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (t testSite) Menus() navigation.Menus <span class="cov0" title="0">{
        return nil
}</span>

func (t testSite) Taxonomies() interface{} <span class="cov0" title="0">{
        return nil
}</span>

func (t testSite) BaseURL() template.URL <span class="cov0" title="0">{
        return ""
}</span>

func (t testSite) Params() map[string]interface{} <span class="cov0" title="0">{
        return nil
}</span>

func (t testSite) Data() map[string]interface{} <span class="cov0" title="0">{
        return nil
}</span>

// NewDummyHugoSite creates a new minimal test site.
func NewDummyHugoSite(cfg config.Provider) Site <span class="cov0" title="0">{
        return testSite{
                h: hugo.NewInfo(hugo.EnvironmentProduction),
                l: langs.NewLanguage("en", cfg),
        }
}</span>
</pre>
		
		<pre class="file" id="file196" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "fmt"
        "sort"

        "github.com/gohugoio/hugo/common/collections"
)

var (
        _ collections.Slicer = WeightedPage{}
)

// WeightedPages is a list of Pages with their corresponding (and relative) weight
// [{Weight: 30, Page: *1}, {Weight: 40, Page: *2}]
type WeightedPages []WeightedPage

// Page will return the Page (of Kind taxonomyList) that represents this set
// of pages. This method will panic if p is empty, as that should never happen.
func (p WeightedPages) Page() Page <span class="cov0" title="0">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                panic("WeightedPages is empty")</span>
        }

        <span class="cov0" title="0">first := p[0]

        // TODO(bep) fix tests
        if first.owner == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return first.owner</span>
}

// A WeightedPage is a Page with a weight.
type WeightedPage struct {
        Weight int
        Page

        // Reference to the owning Page. This avoids having to do
        // manual .Site.GetPage lookups. It is implemented in this roundabout way
        // because we cannot add additional state to the WeightedPages slice
        // without breaking lots of templates in the wild.
        owner Page
}

func NewWeightedPage(weight int, p Page, owner Page) WeightedPage <span class="cov0" title="0">{
        return WeightedPage{Weight: weight, Page: p, owner: owner}
}</span>

func (w WeightedPage) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("WeightedPage(%d,%q)", w.Weight, w.Page.Title())
}</span>

// Slice is not meant to be used externally. It's a bridge function
// for the template functions. See collections.Slice.
func (p WeightedPage) Slice(in interface{}) (interface{}, error) <span class="cov0" title="0">{
        switch items := in.(type) </span>{
        case WeightedPages:<span class="cov0" title="0">
                return items, nil</span>
        case []interface{}:<span class="cov0" title="0">
                weighted := make(WeightedPages, len(items))
                for i, v := range items </span><span class="cov0" title="0">{
                        g, ok := v.(WeightedPage)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("type %T is not a WeightedPage", v)
                        }</span>
                        <span class="cov0" title="0">weighted[i] = g</span>
                }
                <span class="cov0" title="0">return weighted, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid slice type %T", items)</span>
        }
}

// Pages returns the Pages in this weighted page set.
func (wp WeightedPages) Pages() Pages <span class="cov0" title="0">{
        pages := make(Pages, len(wp))
        for i := range wp </span><span class="cov0" title="0">{
                pages[i] = wp[i].Page
        }</span>
        <span class="cov0" title="0">return pages</span>
}

// Prev returns the previous Page relative to the given Page in
// this weighted page set.
func (wp WeightedPages) Prev(cur Page) Page <span class="cov0" title="0">{
        for x, c := range wp </span><span class="cov0" title="0">{
                if c.Page == cur </span><span class="cov0" title="0">{
                        if x == 0 </span><span class="cov0" title="0">{
                                return wp[len(wp)-1].Page
                        }</span>
                        <span class="cov0" title="0">return wp[x-1].Page</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Next returns the next Page relative to the given Page in
// this weighted page set.
func (wp WeightedPages) Next(cur Page) Page <span class="cov0" title="0">{
        for x, c := range wp </span><span class="cov0" title="0">{
                if c.Page == cur </span><span class="cov0" title="0">{
                        if x &lt; len(wp)-1 </span><span class="cov0" title="0">{
                                return wp[x+1].Page
                        }</span>
                        <span class="cov0" title="0">return wp[0].Page</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (wp WeightedPages) Len() int      <span class="cov0" title="0">{ return len(wp) }</span>
func (wp WeightedPages) Swap(i, j int) <span class="cov0" title="0">{ wp[i], wp[j] = wp[j], wp[i] }</span>

// Sort stable sorts this weighted page set.
func (wp WeightedPages) Sort() <span class="cov0" title="0">{ sort.Stable(wp) }</span>

// Count returns the number of pages in this weighted page set.
func (wp WeightedPages) Count() int <span class="cov0" title="0">{ return len(wp) }</span>

func (wp WeightedPages) Less(i, j int) bool <span class="cov0" title="0">{
        if wp[i].Weight == wp[j].Weight </span><span class="cov0" title="0">{
                return DefaultPageSort(wp[i].Page, wp[j].Page)
        }</span>
        <span class="cov0" title="0">return wp[i].Weight &lt; wp[j].Weight</span>
}
</pre>
		
		<pre class="file" id="file197" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is autogenerated.

package page

import (
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/source"
)

// ZeroFile represents a zero value of source.File with warnings if invoked.
type zeroFile struct {
        log *helpers.DistinctLogger
}

func NewZeroFile(log *helpers.DistinctLogger) source.File <span class="cov8" title="1">{
        return zeroFile{log: log}
}</span>

func (zeroFile) IsZero() bool <span class="cov8" title="1">{
        return true
}</span>

func (z zeroFile) Path() (o0 string) <span class="cov0" title="0">{
        z.log.Println(".File.Path on zero object. Wrap it in if or with: {{ with .File }}{{ .Path }}{{ end }}")
        return
}</span>
func (z zeroFile) Section() (o0 string) <span class="cov0" title="0">{
        z.log.Println(".File.Section on zero object. Wrap it in if or with: {{ with .File }}{{ .Section }}{{ end }}")
        return
}</span>
func (z zeroFile) Lang() (o0 string) <span class="cov0" title="0">{
        z.log.Println(".File.Lang on zero object. Wrap it in if or with: {{ with .File }}{{ .Lang }}{{ end }}")
        return
}</span>
func (z zeroFile) Filename() (o0 string) <span class="cov0" title="0">{
        z.log.Println(".File.Filename on zero object. Wrap it in if or with: {{ with .File }}{{ .Filename }}{{ end }}")
        return
}</span>
func (z zeroFile) Dir() (o0 string) <span class="cov0" title="0">{
        z.log.Println(".File.Dir on zero object. Wrap it in if or with: {{ with .File }}{{ .Dir }}{{ end }}")
        return
}</span>
func (z zeroFile) Extension() (o0 string) <span class="cov0" title="0">{
        z.log.Println(".File.Extension on zero object. Wrap it in if or with: {{ with .File }}{{ .Extension }}{{ end }}")
        return
}</span>
func (z zeroFile) Ext() (o0 string) <span class="cov0" title="0">{
        z.log.Println(".File.Ext on zero object. Wrap it in if or with: {{ with .File }}{{ .Ext }}{{ end }}")
        return
}</span>
func (z zeroFile) LogicalName() (o0 string) <span class="cov0" title="0">{
        z.log.Println(".File.LogicalName on zero object. Wrap it in if or with: {{ with .File }}{{ .LogicalName }}{{ end }}")
        return
}</span>
func (z zeroFile) BaseFileName() (o0 string) <span class="cov0" title="0">{
        z.log.Println(".File.BaseFileName on zero object. Wrap it in if or with: {{ with .File }}{{ .BaseFileName }}{{ end }}")
        return
}</span>
func (z zeroFile) TranslationBaseName() (o0 string) <span class="cov0" title="0">{
        z.log.Println(".File.TranslationBaseName on zero object. Wrap it in if or with: {{ with .File }}{{ .TranslationBaseName }}{{ end }}")
        return
}</span>
func (z zeroFile) ContentBaseName() (o0 string) <span class="cov0" title="0">{
        z.log.Println(".File.ContentBaseName on zero object. Wrap it in if or with: {{ with .File }}{{ .ContentBaseName }}{{ end }}")
        return
}</span>
func (z zeroFile) UniqueID() (o0 string) <span class="cov0" title="0">{
        z.log.Println(".File.UniqueID on zero object. Wrap it in if or with: {{ with .File }}{{ .UniqueID }}{{ end }}")
        return
}</span>
func (z zeroFile) FileInfo() (o0 hugofs.FileMetaInfo) <span class="cov0" title="0">{
        z.log.Println(".File.FileInfo on zero object. Wrap it in if or with: {{ with .File }}{{ .FileInfo }}{{ end }}")
        return
}</span>
</pre>
		
		<pre class="file" id="file198" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "path"
        "path/filepath"
        "sync"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/source"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/hugio"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"

        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/helpers"
)

var (
        _ resource.ContentResource         = (*genericResource)(nil)
        _ resource.ReadSeekCloserResource  = (*genericResource)(nil)
        _ resource.Resource                = (*genericResource)(nil)
        _ resource.Source                  = (*genericResource)(nil)
        _ resource.Cloner                  = (*genericResource)(nil)
        _ resource.ResourcesLanguageMerger = (*resource.Resources)(nil)
        _ permalinker                      = (*genericResource)(nil)
        _ resource.Identifier              = (*genericResource)(nil)
        _ fileInfo                         = (*genericResource)(nil)
)

type ResourceSourceDescriptor struct {
        // TargetPaths is a callback to fetch paths's relative to its owner.
        TargetPaths func() page.TargetPaths

        // Need one of these to load the resource content.
        SourceFile         source.File
        OpenReadSeekCloser resource.OpenReadSeekCloser

        FileInfo os.FileInfo

        // If OpenReadSeekerCloser is not set, we use this to open the file.
        SourceFilename string

        Fs afero.Fs

        // The relative target filename without any language code.
        RelTargetFilename string

        // Any base paths prepended to the target path. This will also typically be the
        // language code, but setting it here means that it should not have any effect on
        // the permalink.
        // This may be several values. In multihost mode we may publish the same resources to
        // multiple targets.
        TargetBasePaths []string

        // Delay publishing until either Permalink or RelPermalink is called. Maybe never.
        LazyPublish bool
}

func (r ResourceSourceDescriptor) Filename() string <span class="cov0" title="0">{
        if r.SourceFile != nil </span><span class="cov0" title="0">{
                return r.SourceFile.Filename()
        }</span>
        <span class="cov0" title="0">return r.SourceFilename</span>
}

type ResourceTransformer interface {
        resource.Resource
        Transformer
}

type Transformer interface {
        Transform(...ResourceTransformation) (ResourceTransformer, error)
}

type baseResourceResource interface {
        resource.Cloner
        resource.ContentProvider
        resource.Resource
        resource.Identifier
}

type baseResourceInternal interface {
        resource.Source

        fileInfo
        metaAssigner
        targetPather

        ReadSeekCloser() (hugio.ReadSeekCloser, error)

        // Internal
        cloneWithUpdates(*transformationUpdate) (baseResource, error)
        tryTransformedFileCache(key string, u *transformationUpdate) io.ReadCloser

        specProvider
        getResourcePaths() *resourcePathDescriptor
        getTargetFilenames() []string
        openDestinationsForWriting() (io.WriteCloser, error)
        openPublishFileForWriting(relTargetPath string) (io.WriteCloser, error)

        relTargetPathForRel(rel string, addBaseTargetPath, isAbs, isURL bool) string
}

type specProvider interface {
        getSpec() *Spec
}

type baseResource interface {
        baseResourceResource
        baseResourceInternal
}

type commonResource struct {
}

// Slice is not meant to be used externally. It's a bridge function
// for the template functions. See collections.Slice.
func (commonResource) Slice(in interface{}) (interface{}, error) <span class="cov0" title="0">{
        switch items := in.(type) </span>{
        case resource.Resources:<span class="cov0" title="0">
                return items, nil</span>
        case []interface{}:<span class="cov0" title="0">
                groups := make(resource.Resources, len(items))
                for i, v := range items </span><span class="cov0" title="0">{
                        g, ok := v.(resource.Resource)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("type %T is not a Resource", v)
                        }</span>
                        <span class="cov0" title="0">groups[i] = g
                        </span>{<span class="cov0" title="0">
                        }</span>
                }
                <span class="cov0" title="0">return groups, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid slice type %T", items)</span>
        }
}

type dirFile struct {
        // This is the directory component with Unix-style slashes.
        dir string
        // This is the file component.
        file string
}

func (d dirFile) path() string <span class="cov0" title="0">{
        return path.Join(d.dir, d.file)
}</span>

type fileInfo interface {
        getSourceFilename() string
        setSourceFilename(string)
        setSourceFs(afero.Fs)
        getFileInfo() hugofs.FileMetaInfo
        hash() (string, error)
        size() int
}

// genericResource represents a generic linkable resource.
type genericResource struct {
        *resourcePathDescriptor
        *resourceFileInfo
        *resourceContent

        spec *Spec

        title  string
        name   string
        params map[string]interface{}
        data   map[string]interface{}

        resourceType string
        mediaType    media.Type
}

func (l *genericResource) Clone() resource.Resource <span class="cov0" title="0">{
        return l.clone()
}</span>

func (l *genericResource) Content() (interface{}, error) <span class="cov0" title="0">{
        if err := l.initContent(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return l.content, nil</span>
}

func (l *genericResource) Data() interface{} <span class="cov0" title="0">{
        return l.data
}</span>

func (l *genericResource) Key() string <span class="cov0" title="0">{
        return l.relTargetDirFile.path()
}</span>

func (l *genericResource) MediaType() media.Type <span class="cov0" title="0">{
        return l.mediaType
}</span>

func (l *genericResource) Name() string <span class="cov0" title="0">{
        return l.name
}</span>

func (l *genericResource) Params() map[string]interface{} <span class="cov0" title="0">{
        return l.params
}</span>

func (l *genericResource) Permalink() string <span class="cov0" title="0">{
        return l.spec.PermalinkForBaseURL(l.relPermalinkForRel(l.relTargetDirFile.path(), true), l.spec.BaseURL.HostURL())
}</span>

func (l *genericResource) Publish() error <span class="cov0" title="0">{
        var err error
        l.publishInit.Do(func() </span><span class="cov0" title="0">{
                var fr hugio.ReadSeekCloser
                fr, err = l.ReadSeekCloser()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">defer fr.Close()

                var fw io.WriteCloser
                fw, err = helpers.OpenFilesForWriting(l.spec.BaseFs.PublishFs, l.getTargetFilenames()...)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">defer fw.Close()

                _, err = io.Copy(fw, fr)</span>

        })

        <span class="cov0" title="0">return err</span>
}

func (l *genericResource) RelPermalink() string <span class="cov0" title="0">{
        return l.relPermalinkFor(l.relTargetDirFile.path())
}</span>

func (l *genericResource) ResourceType() string <span class="cov0" title="0">{
        return l.resourceType
}</span>

func (l *genericResource) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Resource(%s: %s)", l.resourceType, l.name)
}</span>

// Path is stored with Unix style slashes.
func (l *genericResource) TargetPath() string <span class="cov0" title="0">{
        return l.relTargetDirFile.path()
}</span>

func (l *genericResource) Title() string <span class="cov0" title="0">{
        return l.title
}</span>

func (l *genericResource) createBasePath(rel string, isURL bool) string <span class="cov0" title="0">{
        if l.targetPathBuilder == nil </span><span class="cov0" title="0">{
                return rel
        }</span>
        <span class="cov0" title="0">tp := l.targetPathBuilder()

        if isURL </span><span class="cov0" title="0">{
                return path.Join(tp.SubResourceBaseLink, rel)
        }</span>

        // TODO(bep) path
        <span class="cov0" title="0">return path.Join(filepath.ToSlash(tp.SubResourceBaseTarget), rel)</span>
}

func (l *genericResource) initContent() error <span class="cov0" title="0">{
        var err error
        l.contentInit.Do(func() </span><span class="cov0" title="0">{
                var r hugio.ReadSeekCloser
                r, err = l.ReadSeekCloser()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">defer r.Close()

                var b []byte
                b, err = ioutil.ReadAll(r)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">l.content = string(b)</span>
        })

        <span class="cov0" title="0">return err</span>
}

func (l *genericResource) setName(name string) <span class="cov0" title="0">{
        l.name = name
}</span>

func (l *genericResource) getResourcePaths() *resourcePathDescriptor <span class="cov0" title="0">{
        return l.resourcePathDescriptor
}</span>

func (l *genericResource) getSpec() *Spec <span class="cov0" title="0">{
        return l.spec
}</span>

func (l *genericResource) getTargetFilenames() []string <span class="cov0" title="0">{
        paths := l.relTargetPaths()
        for i, p := range paths </span><span class="cov0" title="0">{
                paths[i] = filepath.Clean(p)
        }</span>
        <span class="cov0" title="0">return paths</span>
}

func (l *genericResource) setTitle(title string) <span class="cov0" title="0">{
        l.title = title
}</span>

func (r *genericResource) tryTransformedFileCache(key string, u *transformationUpdate) io.ReadCloser <span class="cov0" title="0">{
        fi, f, meta, found := r.spec.ResourceCache.getFromFile(key)
        if !found </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">u.sourceFilename = &amp;fi.Name
        mt, _ := r.spec.MediaTypes.GetByType(meta.MediaTypeV)
        u.mediaType = mt
        u.data = meta.MetaData
        u.targetPath = meta.Target
        return f</span>
}

func (r *genericResource) mergeData(in map[string]interface{}) <span class="cov0" title="0">{
        if len(in) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if r.data == nil </span><span class="cov0" title="0">{
                r.data = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">for k, v := range in </span><span class="cov0" title="0">{
                if _, found := r.data[k]; !found </span><span class="cov0" title="0">{
                        r.data[k] = v
                }</span>
        }
}

func (rc *genericResource) cloneWithUpdates(u *transformationUpdate) (baseResource, error) <span class="cov0" title="0">{
        r := rc.clone()

        if u.content != nil </span><span class="cov0" title="0">{
                r.contentInit.Do(func() </span><span class="cov0" title="0">{
                        r.content = *u.content
                        r.openReadSeekerCloser = func() (hugio.ReadSeekCloser, error) </span><span class="cov0" title="0">{
                                return hugio.NewReadSeekerNoOpCloserFromString(r.content), nil
                        }</span>
                })
        }

        <span class="cov0" title="0">r.mediaType = u.mediaType

        if u.sourceFilename != nil </span><span class="cov0" title="0">{
                r.setSourceFilename(*u.sourceFilename)
        }</span>

        <span class="cov0" title="0">if u.sourceFs != nil </span><span class="cov0" title="0">{
                r.setSourceFs(u.sourceFs)
        }</span>

        <span class="cov0" title="0">if u.targetPath == "" </span><span class="cov0" title="0">{
                return nil, errors.New("missing targetPath")
        }</span>

        <span class="cov0" title="0">fpath, fname := path.Split(u.targetPath)
        r.resourcePathDescriptor.relTargetDirFile = dirFile{dir: fpath, file: fname}

        r.mergeData(u.data)

        return r, nil</span>
}

func (l genericResource) clone() *genericResource <span class="cov0" title="0">{
        gi := *l.resourceFileInfo
        rp := *l.resourcePathDescriptor
        l.resourceFileInfo = &amp;gi
        l.resourcePathDescriptor = &amp;rp
        l.resourceContent = &amp;resourceContent{}
        return &amp;l
}</span>

// returns an opened file or nil if nothing to write (it may already be published).
func (l *genericResource) openDestinationsForWriting() (w io.WriteCloser, err error) <span class="cov0" title="0">{

        l.publishInit.Do(func() </span><span class="cov0" title="0">{
                targetFilenames := l.getTargetFilenames()
                var changedFilenames []string

                // Fast path:
                // This is a processed version of the original;
                // check if it already existis at the destination.
                for _, targetFilename := range targetFilenames </span><span class="cov0" title="0">{
                        if _, err := l.getSpec().BaseFs.PublishFs.Stat(targetFilename); err == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">changedFilenames = append(changedFilenames, targetFilename)</span>
                }

                <span class="cov0" title="0">if len(changedFilenames) == 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">w, err = helpers.OpenFilesForWriting(l.getSpec().BaseFs.PublishFs, changedFilenames...)</span>

        })

        <span class="cov0" title="0">return</span>

}

func (r *genericResource) openPublishFileForWriting(relTargetPath string) (io.WriteCloser, error) <span class="cov0" title="0">{
        return helpers.OpenFilesForWriting(r.spec.BaseFs.PublishFs, r.relTargetPathsFor(relTargetPath)...)
}</span>

func (l *genericResource) permalinkFor(target string) string <span class="cov0" title="0">{
        return l.spec.PermalinkForBaseURL(l.relPermalinkForRel(target, true), l.spec.BaseURL.HostURL())
}</span>

func (l *genericResource) relPermalinkFor(target string) string <span class="cov0" title="0">{
        return l.relPermalinkForRel(target, false)
}</span>

func (l *genericResource) relPermalinkForRel(rel string, isAbs bool) string <span class="cov0" title="0">{
        return l.spec.PathSpec.URLizeFilename(l.relTargetPathForRel(rel, false, isAbs, true))
}</span>

func (l *genericResource) relTargetPathForRel(rel string, addBaseTargetPath, isAbs, isURL bool) string <span class="cov0" title="0">{
        if addBaseTargetPath &amp;&amp; len(l.baseTargetPathDirs) &gt; 1 </span><span class="cov0" title="0">{
                panic("multiple baseTargetPathDirs")</span>
        }
        <span class="cov0" title="0">var basePath string
        if addBaseTargetPath &amp;&amp; len(l.baseTargetPathDirs) &gt; 0 </span><span class="cov0" title="0">{
                basePath = l.baseTargetPathDirs[0]
        }</span>

        <span class="cov0" title="0">return l.relTargetPathForRelAndBasePath(rel, basePath, isAbs, isURL)</span>
}

func (l *genericResource) relTargetPathForRelAndBasePath(rel, basePath string, isAbs, isURL bool) string <span class="cov0" title="0">{
        rel = l.createBasePath(rel, isURL)

        if basePath != "" </span><span class="cov0" title="0">{
                rel = path.Join(basePath, rel)
        }</span>

        <span class="cov0" title="0">if l.baseOffset != "" </span><span class="cov0" title="0">{
                rel = path.Join(l.baseOffset, rel)
        }</span>

        <span class="cov0" title="0">if isURL </span><span class="cov0" title="0">{
                bp := l.spec.PathSpec.GetBasePath(!isAbs)
                if bp != "" </span><span class="cov0" title="0">{
                        rel = path.Join(bp, rel)
                }</span>
        }

        <span class="cov0" title="0">if len(rel) == 0 || rel[0] != '/' </span><span class="cov0" title="0">{
                rel = "/" + rel
        }</span>

        <span class="cov0" title="0">return rel</span>
}

func (l *genericResource) relTargetPaths() []string <span class="cov0" title="0">{
        return l.relTargetPathsForRel(l.TargetPath())
}</span>

func (l *genericResource) relTargetPathsFor(target string) []string <span class="cov0" title="0">{
        return l.relTargetPathsForRel(target)
}</span>

func (l *genericResource) relTargetPathsForRel(rel string) []string <span class="cov0" title="0">{
        if len(l.baseTargetPathDirs) == 0 </span><span class="cov0" title="0">{
                return []string{l.relTargetPathForRelAndBasePath(rel, "", false, false)}
        }</span>

        <span class="cov0" title="0">targetPaths := make([]string, len(l.baseTargetPathDirs))
        for i, dir := range l.baseTargetPathDirs </span><span class="cov0" title="0">{
                targetPaths[i] = l.relTargetPathForRelAndBasePath(rel, dir, false, false)
        }</span>
        <span class="cov0" title="0">return targetPaths</span>
}

func (l *genericResource) updateParams(params map[string]interface{}) <span class="cov0" title="0">{
        if l.params == nil </span><span class="cov0" title="0">{
                l.params = params
                return
        }</span>

        // Sets the params not already set
        <span class="cov0" title="0">for k, v := range params </span><span class="cov0" title="0">{
                if _, found := l.params[k]; !found </span><span class="cov0" title="0">{
                        l.params[k] = v
                }</span>
        }
}

type targetPather interface {
        TargetPath() string
}

type permalinker interface {
        targetPather
        permalinkFor(target string) string
        relPermalinkFor(target string) string
        relTargetPaths() []string
        relTargetPathsFor(target string) []string
}

type resourceContent struct {
        content     string
        contentInit sync.Once

        publishInit sync.Once
}

type resourceFileInfo struct {
        // Will be set if this resource is backed by something other than a file.
        openReadSeekerCloser resource.OpenReadSeekCloser

        // This may be set to tell us to look in another filesystem for this resource.
        // We, by default, use the sourceFs filesystem in the spec below.
        sourceFs afero.Fs

        // Absolute filename to the source, including any content folder path.
        // Note that this is absolute in relation to the filesystem it is stored in.
        // It can be a base path filesystem, and then this filename will not match
        // the path to the file on the real filesystem.
        sourceFilename string

        fi hugofs.FileMetaInfo

        // A hash of the source content. Is only calculated in caching situations.
        h *resourceHash
}

func (fi *resourceFileInfo) ReadSeekCloser() (hugio.ReadSeekCloser, error) <span class="cov0" title="0">{
        if fi.openReadSeekerCloser != nil </span><span class="cov0" title="0">{
                return fi.openReadSeekerCloser()
        }</span>

        <span class="cov0" title="0">f, err := fi.getSourceFs().Open(fi.getSourceFilename())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return f, nil</span>
}

func (fi *resourceFileInfo) getFileInfo() hugofs.FileMetaInfo <span class="cov0" title="0">{
        return fi.fi
}</span>

func (fi *resourceFileInfo) getSourceFilename() string <span class="cov0" title="0">{
        return fi.sourceFilename
}</span>

func (fi *resourceFileInfo) setSourceFilename(s string) <span class="cov0" title="0">{
        // Make sure it's always loaded by sourceFilename.
        fi.openReadSeekerCloser = nil
        fi.sourceFilename = s
}</span>

func (fi *resourceFileInfo) getSourceFs() afero.Fs <span class="cov0" title="0">{
        return fi.sourceFs
}</span>

func (fi *resourceFileInfo) setSourceFs(fs afero.Fs) <span class="cov0" title="0">{
        fi.sourceFs = fs
}</span>

func (fi *resourceFileInfo) hash() (string, error) <span class="cov0" title="0">{
        var err error
        fi.h.init.Do(func() </span><span class="cov0" title="0">{
                var hash string
                var f hugio.ReadSeekCloser
                f, err = fi.ReadSeekCloser()
                if err != nil </span><span class="cov0" title="0">{
                        err = errors.Wrap(err, "failed to open source file")
                        return
                }</span>
                <span class="cov0" title="0">defer f.Close()

                hash, err = helpers.MD5FromFileFast(f)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">fi.h.value = hash</span>
        })

        <span class="cov0" title="0">return fi.h.value, err</span>
}

func (fi *resourceFileInfo) size() int <span class="cov0" title="0">{
        if fi.fi == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return int(fi.fi.Size())</span>
}

type resourceHash struct {
        value string
        init  sync.Once
}

type resourcePathDescriptor struct {
        // The relative target directory and filename.
        relTargetDirFile dirFile

        // Callback used to construct a target path relative to its owner.
        targetPathBuilder func() page.TargetPaths

        // This will normally be the same as above, but this will only apply to publishing
        // of resources. It may be mulltiple values when in multihost mode.
        baseTargetPathDirs []string

        // baseOffset is set when the output format's path has a offset, e.g. for AMP.
        baseOffset string
}
</pre>
		
		<pre class="file" id="file199" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resource

import "time"

var _ Dated = Dates{}

// Dated wraps a "dated resource". These are the 4 dates that makes
// the date logic in Hugo.
type Dated interface {
        Date() time.Time
        Lastmod() time.Time
        PublishDate() time.Time
        ExpiryDate() time.Time
}

// Dates holds the 4 Hugo dates.
type Dates struct {
        FDate        time.Time
        FLastmod     time.Time
        FPublishDate time.Time
        FExpiryDate  time.Time
}

func (d *Dates) UpdateDateAndLastmodIfAfter(in Dated) <span class="cov8" title="1">{
        if in.Date().After(d.Date()) </span><span class="cov8" title="1">{
                d.FDate = in.Date()
        }</span>
        <span class="cov8" title="1">if in.Lastmod().After(d.Lastmod()) </span><span class="cov8" title="1">{
                d.FLastmod = in.Lastmod()
        }</span>
}

// IsFuture returns whether the argument represents the future.
func IsFuture(d Dated) bool <span class="cov0" title="0">{
        if d.PublishDate().IsZero() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return d.PublishDate().After(time.Now())</span>
}

// IsExpired returns whether the argument is expired.
func IsExpired(d Dated) bool <span class="cov0" title="0">{
        if d.ExpiryDate().IsZero() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return d.ExpiryDate().Before(time.Now())</span>
}

// IsZeroDates returns true if all of the dates are zero.
func IsZeroDates(d Dated) bool <span class="cov8" title="1">{
        return d.Date().IsZero() &amp;&amp; d.Lastmod().IsZero() &amp;&amp; d.ExpiryDate().IsZero() &amp;&amp; d.PublishDate().IsZero()
}</span>

func (p Dates) Date() time.Time <span class="cov8" title="1">{
        return p.FDate
}</span>

func (p Dates) Lastmod() time.Time <span class="cov8" title="1">{
        return p.FLastmod
}</span>

func (p Dates) PublishDate() time.Time <span class="cov8" title="1">{
        return p.FPublishDate
}</span>

func (p Dates) ExpiryDate() time.Time <span class="cov8" title="1">{
        return p.FExpiryDate
}</span>
</pre>
		
		<pre class="file" id="file200" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resource

import (
        "github.com/gohugoio/hugo/common/maps"

        "github.com/spf13/cast"
)

func Param(r ResourceParamsProvider, fallback map[string]interface{}, key interface{}) (interface{}, error) <span class="cov8" title="1">{
        keyStr, err := cast.ToStringE(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return maps.GetNestedParam(keyStr, ".", r.Params(), fallback)</span>

}
</pre>
		
		<pre class="file" id="file201" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resource

import (
        "strings"
        "time"

        "github.com/gohugoio/hugo/helpers"

        "github.com/spf13/cast"
)

// GetParam will return the param with the given key from the Resource,
// nil if not found.
func GetParam(r Resource, key string) interface{} <span class="cov0" title="0">{
        return getParam(r, key, false)
}</span>

// GetParamToLower is the same as GetParam but it will lower case any string
// result, including string slices.
func GetParamToLower(r Resource, key string) interface{} <span class="cov0" title="0">{
        return getParam(r, key, true)
}</span>

func getParam(r Resource, key string, stringToLower bool) interface{} <span class="cov0" title="0">{
        v := r.Params()[strings.ToLower(key)]

        if v == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch val := v.(type) </span>{
        case bool:<span class="cov0" title="0">
                return val</span>
        case string:<span class="cov0" title="0">
                if stringToLower </span><span class="cov0" title="0">{
                        return strings.ToLower(val)
                }</span>
                <span class="cov0" title="0">return val</span>
        case int64, int32, int16, int8, int:<span class="cov0" title="0">
                return cast.ToInt(v)</span>
        case float64, float32:<span class="cov0" title="0">
                return cast.ToFloat64(v)</span>
        case time.Time:<span class="cov0" title="0">
                return val</span>
        case []string:<span class="cov0" title="0">
                if stringToLower </span><span class="cov0" title="0">{
                        return helpers.SliceToLower(val)
                }</span>
                <span class="cov0" title="0">return v</span>
        case map[string]interface{}:<span class="cov0" title="0"> // JSON and TOML
                return v</span>
        case map[interface{}]interface{}:<span class="cov0" title="0"> // YAML
                return v</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file202" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resource

import (
        "fmt"
        "strings"

        "github.com/gohugoio/hugo/hugofs/glob"
)

// Resources represents a slice of resources, which can be a mix of different types.
// I.e. both pages and images etc.
type Resources []Resource

// ResourcesConverter converts a given slice of Resource objects to Resources.
type ResourcesConverter interface {
        ToResources() Resources
}

// ByType returns resources of a given resource type (ie. "image").
func (r Resources) ByType(tp string) Resources <span class="cov8" title="1">{
        var filtered Resources

        for _, resource := range r </span><span class="cov0" title="0">{
                if resource.ResourceType() == tp </span><span class="cov0" title="0">{
                        filtered = append(filtered, resource)
                }</span>
        }
        <span class="cov8" title="1">return filtered</span>
}

// GetMatch finds the first Resource matching the given pattern, or nil if none found.
// See Match for a more complete explanation about the rules used.
func (r Resources) GetMatch(pattern string) Resource <span class="cov8" title="1">{
        g, err := glob.GetGlob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, resource := range r </span><span class="cov0" title="0">{
                if g.Match(strings.ToLower(resource.Name())) </span><span class="cov0" title="0">{
                        return resource
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Match gets all resources matching the given base filename prefix, e.g
// "*.png" will match all png files. The "*" does not match path delimiters (/),
// so if you organize your resources in sub-folders, you need to be explicit about it, e.g.:
// "images/*.png". To match any PNG image anywhere in the bundle you can do "**.png", and
// to match all PNG images below the images folder, use "images/**.jpg".
// The matching is case insensitive.
// Match matches by using the value of Resource.Name, which, by default, is a filename with
// path relative to the bundle root with Unix style slashes (/) and no leading slash, e.g. "images/logo.png".
// See https://github.com/gobwas/glob for the full rules set.
func (r Resources) Match(pattern string) Resources <span class="cov0" title="0">{
        g, err := glob.GetGlob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var matches Resources
        for _, resource := range r </span><span class="cov0" title="0">{
                if g.Match(strings.ToLower(resource.Name())) </span><span class="cov0" title="0">{
                        matches = append(matches, resource)
                }</span>
        }
        <span class="cov0" title="0">return matches</span>
}

type translatedResource interface {
        TranslationKey() string
}

// MergeByLanguage adds missing translations in r1 from r2.
func (r Resources) MergeByLanguage(r2 Resources) Resources <span class="cov0" title="0">{
        result := append(Resources(nil), r...)
        m := make(map[string]bool)
        for _, rr := range r </span><span class="cov0" title="0">{
                if translated, ok := rr.(translatedResource); ok </span><span class="cov0" title="0">{
                        m[translated.TranslationKey()] = true
                }</span>
        }

        <span class="cov0" title="0">for _, rr := range r2 </span><span class="cov0" title="0">{
                if translated, ok := rr.(translatedResource); ok </span><span class="cov0" title="0">{
                        if _, found := m[translated.TranslationKey()]; !found </span><span class="cov0" title="0">{
                                result = append(result, rr)
                        }</span>
                }
        }
        <span class="cov0" title="0">return result</span>
}

// MergeByLanguageInterface is the generic version of MergeByLanguage. It
// is here just so it can be called from the tpl package.
func (r Resources) MergeByLanguageInterface(in interface{}) (interface{}, error) <span class="cov0" title="0">{
        r2, ok := in.(Resources)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%T cannot be merged by language", in)
        }</span>
        <span class="cov0" title="0">return r.MergeByLanguage(r2), nil</span>
}

// Source is an internal template and not meant for use in the templates. It
// may change without notice.
type Source interface {
        Publish() error
}
</pre>
		
		<pre class="file" id="file203" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resource

import (
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/resources/images/exif"

        "github.com/gohugoio/hugo/common/hugio"
)

// Cloner is an internal template and not meant for use in the templates. It
// may change without notice.
type Cloner interface {
        Clone() Resource
}

// Resource represents a linkable resource, i.e. a content page, image etc.
type Resource interface {
        ResourceTypesProvider
        ResourceLinksProvider
        ResourceMetaProvider
        ResourceParamsProvider
        ResourceDataProvider
}

// Image represents an image resource.
type Image interface {
        Resource
        ImageOps
}

type ImageOps interface {
        Height() int
        Width() int
        Fill(spec string) (Image, error)
        Fit(spec string) (Image, error)
        Resize(spec string) (Image, error)
        Filter(filters ...interface{}) (Image, error)
        Exif() (*exif.Exif, error)
}

type ResourceTypesProvider interface {
        // MediaType is this resource's MIME type.
        MediaType() media.Type

        // ResourceType is the resource type. For most file types, this is the main
        // part of the MIME type, e.g. "image", "application", "text" etc.
        // For content pages, this value is "page".
        ResourceType() string
}

type ResourceLinksProvider interface {
        // Permalink represents the absolute link to this resource.
        Permalink() string

        // RelPermalink represents the host relative link to this resource.
        RelPermalink() string
}

type ResourceMetaProvider interface {
        // Name is the logical name of this resource. This can be set in the front matter
        // metadata for this resource. If not set, Hugo will assign a value.
        // This will in most cases be the base filename.
        // So, for the image "/some/path/sunset.jpg" this will be "sunset.jpg".
        // The value returned by this method will be used in the GetByPrefix and ByPrefix methods
        // on Resources.
        Name() string

        // Title returns the title if set in front matter. For content pages, this will be the expected value.
        Title() string
}

type ResourceParamsProvider interface {
        // Params set in front matter for this resource.
        Params() map[string]interface{}
}

type ResourceDataProvider interface {
        // Resource specific data set by Hugo.
        // One example would be.Data.Digest for fingerprinted resources.
        Data() interface{}
}

// ResourcesLanguageMerger describes an interface for merging resources from a
// different language.
type ResourcesLanguageMerger interface {
        MergeByLanguage(other Resources) Resources
        // Needed for integration with the tpl package.
        MergeByLanguageInterface(other interface{}) (interface{}, error)
}

// Identifier identifies a resource.
type Identifier interface {
        Key() string
}

// ContentResource represents a Resource that provides a way to get to its content.
// Most Resource types in Hugo implements this interface, including Page.
type ContentResource interface {
        MediaType() media.Type
        ContentProvider
}

// ContentProvider provides Content.
// This should be used with care, as it will read the file content into memory, but it
// should be cached as effectively as possible by the implementation.
type ContentProvider interface {
        // Content returns this resource's content. It will be equivalent to reading the content
        // that RelPermalink points to in the published folder.
        // The return type will be contextual, and should be what you would expect:
        // * Page: template.HTML
        // * JSON: String
        // * Etc.
        Content() (interface{}, error)
}

// OpenReadSeekCloser allows setting some other way (than reading from a filesystem)
// to open or create a ReadSeekCloser.
type OpenReadSeekCloser func() (hugio.ReadSeekCloser, error)

// ReadSeekCloserResource is a Resource that supports loading its content.
type ReadSeekCloserResource interface {
        MediaType() media.Type
        ReadSeekCloserProvider
}

type ReadSeekCloserProvider interface {
        ReadSeekCloser() (hugio.ReadSeekCloser, error)
}

// LengthProvider is a Resource that provides a length
// (typically the length of the content).
type LengthProvider interface {
        Len() int
}

// LanguageProvider is a Resource in a language.
type LanguageProvider interface {
        Language() *langs.Language
}

// TranslationKeyProvider connects translations of the same Resource.
type TranslationKeyProvider interface {
        TranslationKey() string
}

type resourceTypesHolder struct {
        mediaType    media.Type
        resourceType string
}

func (r resourceTypesHolder) MediaType() media.Type <span class="cov0" title="0">{
        return r.mediaType
}</span>

func (r resourceTypesHolder) ResourceType() string <span class="cov0" title="0">{
        return r.resourceType
}</span>

func NewResourceTypesProvider(mediaType media.Type, resourceType string) ResourceTypesProvider <span class="cov8" title="1">{
        return resourceTypesHolder{mediaType: mediaType, resourceType: resourceType}
}</span>

type languageHolder struct {
        lang *langs.Language
}

func (l languageHolder) Language() *langs.Language <span class="cov0" title="0">{
        return l.lang
}</span>

func NewLanguageProvider(lang *langs.Language) LanguageProvider <span class="cov0" title="0">{
        return languageHolder{lang: lang}
}</span>
</pre>
		
		<pre class="file" id="file204" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "encoding/json"
        "io"
        "path"
        "path/filepath"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/gohugoio/hugo/resources/resource"

        "github.com/gohugoio/hugo/cache/filecache"

        "github.com/BurntSushi/locker"
)

const (
        CACHE_CLEAR_ALL = "clear_all"
        CACHE_OTHER     = "other"
)

type ResourceCache struct {
        rs *Spec

        sync.RWMutex

        // Either resource.Resource or resource.Resources.
        cache map[string]interface{}

        fileCache *filecache.Cache

        // Provides named resource locks.
        nlocker *locker.Locker
}

// ResourceCacheKey converts the filename into the format used in the resource
// cache.
func ResourceCacheKey(filename string) string <span class="cov0" title="0">{
        filename = filepath.ToSlash(filename)
        return path.Join(resourceKeyPartition(filename), filename)
}</span>

func resourceKeyPartition(filename string) string <span class="cov0" title="0">{
        ext := strings.TrimPrefix(path.Ext(filepath.ToSlash(filename)), ".")
        if ext == "" </span><span class="cov0" title="0">{
                ext = CACHE_OTHER
        }</span>
        <span class="cov0" title="0">return ext</span>
}

// Commonly used aliases and directory names used for some types.
var extAliasKeywords = map[string][]string{
        "sass": []string{"scss"},
        "scss": []string{"sass"},
}

// ResourceKeyPartitions resolves a ordered slice of partitions that is
// used to do resource cache invalidations.
//
// We use the first directory path element and the extension, so:
//     a/b.json =&gt; "a", "json"
//     b.json =&gt; "json"
//
// For some of the extensions we will also map to closely related types,
// e.g. "scss" will also return "sass".
//
func ResourceKeyPartitions(filename string) []string <span class="cov0" title="0">{
        var partitions []string
        filename = glob.NormalizePath(filename)
        dir, name := path.Split(filename)
        ext := strings.TrimPrefix(path.Ext(filepath.ToSlash(name)), ".")

        if dir != "" </span><span class="cov0" title="0">{
                partitions = append(partitions, strings.Split(dir, "/")[0])
        }</span>

        <span class="cov0" title="0">if ext != "" </span><span class="cov0" title="0">{
                partitions = append(partitions, ext)
        }</span>

        <span class="cov0" title="0">if aliases, found := extAliasKeywords[ext]; found </span><span class="cov0" title="0">{
                partitions = append(partitions, aliases...)
        }</span>

        <span class="cov0" title="0">if len(partitions) == 0 </span><span class="cov0" title="0">{
                partitions = []string{CACHE_OTHER}
        }</span>

        <span class="cov0" title="0">return helpers.UniqueStringsSorted(partitions)</span>
}

// ResourceKeyContainsAny returns whether the key is a member of any of the
// given partitions.
//
// This is used for resource cache invalidation.
func ResourceKeyContainsAny(key string, partitions []string) bool <span class="cov0" title="0">{
        parts := strings.Split(key, "/")
        for _, p1 := range partitions </span><span class="cov0" title="0">{
                for _, p2 := range parts </span><span class="cov0" title="0">{
                        if p1 == p2 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func newResourceCache(rs *Spec) *ResourceCache <span class="cov8" title="1">{
        return &amp;ResourceCache{
                rs:        rs,
                fileCache: rs.FileCaches.AssetsCache(),
                cache:     make(map[string]interface{}),
                nlocker:   locker.NewLocker(),
        }
}</span>

func (c *ResourceCache) clear() <span class="cov0" title="0">{
        c.Lock()
        defer c.Unlock()

        c.cache = make(map[string]interface{})
        c.nlocker = locker.NewLocker()
}</span>

func (c *ResourceCache) Contains(key string) bool <span class="cov0" title="0">{
        key = c.cleanKey(filepath.ToSlash(key))
        _, found := c.get(key)
        return found
}</span>

func (c *ResourceCache) cleanKey(key string) string <span class="cov0" title="0">{
        return strings.TrimPrefix(path.Clean(strings.ToLower(key)), "/")
}</span>

func (c *ResourceCache) get(key string) (interface{}, bool) <span class="cov0" title="0">{
        c.RLock()
        defer c.RUnlock()
        r, found := c.cache[key]
        return r, found
}</span>

func (c *ResourceCache) GetOrCreate(key string, f func() (resource.Resource, error)) (resource.Resource, error) <span class="cov0" title="0">{
        r, err := c.getOrCreate(key, func() (interface{}, error) </span><span class="cov0" title="0">{ return f() }</span>)
        <span class="cov0" title="0">if r == nil || err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.(resource.Resource), nil</span>
}

func (c *ResourceCache) GetOrCreateResources(key string, f func() (resource.Resources, error)) (resource.Resources, error) <span class="cov0" title="0">{
        r, err := c.getOrCreate(key, func() (interface{}, error) </span><span class="cov0" title="0">{ return f() }</span>)
        <span class="cov0" title="0">if r == nil || err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.(resource.Resources), nil</span>
}

func (c *ResourceCache) getOrCreate(key string, f func() (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        key = c.cleanKey(key)
        // First check in-memory cache.
        r, found := c.get(key)
        if found </span><span class="cov0" title="0">{
                return r, nil
        }</span>
        // This is a potentially long running operation, so get a named lock.
        <span class="cov0" title="0">c.nlocker.Lock(key)

        // Double check in-memory cache.
        r, found = c.get(key)
        if found </span><span class="cov0" title="0">{
                c.nlocker.Unlock(key)
                return r, nil
        }</span>

        <span class="cov0" title="0">defer c.nlocker.Unlock(key)

        r, err := f()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.set(key, r)

        return r, nil</span>

}

func (c *ResourceCache) getFilenames(key string) (string, string) <span class="cov0" title="0">{
        filenameMeta := key + ".json"
        filenameContent := key + ".content"

        return filenameMeta, filenameContent
}</span>

func (c *ResourceCache) getFromFile(key string) (filecache.ItemInfo, io.ReadCloser, transformedResourceMetadata, bool) <span class="cov0" title="0">{
        c.RLock()
        defer c.RUnlock()

        var meta transformedResourceMetadata
        filenameMeta, filenameContent := c.getFilenames(key)

        _, jsonContent, _ := c.fileCache.GetBytes(filenameMeta)
        if jsonContent == nil </span><span class="cov0" title="0">{
                return filecache.ItemInfo{}, nil, meta, false
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(jsonContent, &amp;meta); err != nil </span><span class="cov0" title="0">{
                return filecache.ItemInfo{}, nil, meta, false
        }</span>

        <span class="cov0" title="0">fi, rc, _ := c.fileCache.Get(filenameContent)

        return fi, rc, meta, rc != nil</span>

}

// writeMeta writes the metadata to file and returns a writer for the content part.
func (c *ResourceCache) writeMeta(key string, meta transformedResourceMetadata) (filecache.ItemInfo, io.WriteCloser, error) <span class="cov0" title="0">{
        filenameMeta, filenameContent := c.getFilenames(key)
        raw, err := json.Marshal(meta)
        if err != nil </span><span class="cov0" title="0">{
                return filecache.ItemInfo{}, nil, err
        }</span>

        <span class="cov0" title="0">_, fm, err := c.fileCache.WriteCloser(filenameMeta)
        if err != nil </span><span class="cov0" title="0">{
                return filecache.ItemInfo{}, nil, err
        }</span>
        <span class="cov0" title="0">defer fm.Close()

        if _, err := fm.Write(raw); err != nil </span><span class="cov0" title="0">{
                return filecache.ItemInfo{}, nil, err
        }</span>

        <span class="cov0" title="0">fi, fc, err := c.fileCache.WriteCloser(filenameContent)

        return fi, fc, err</span>

}

func (c *ResourceCache) set(key string, r interface{}) <span class="cov0" title="0">{
        c.Lock()
        defer c.Unlock()
        c.cache[key] = r
}</span>

func (c *ResourceCache) DeletePartitions(partitions ...string) <span class="cov0" title="0">{
        partitionsSet := map[string]bool{
                // Always clear out the resources not matching any partition.
                "other": true,
        }
        for _, p := range partitions </span><span class="cov0" title="0">{
                partitionsSet[p] = true
        }</span>

        <span class="cov0" title="0">if partitionsSet[CACHE_CLEAR_ALL] </span><span class="cov0" title="0">{
                c.clear()
                return
        }</span>

        <span class="cov0" title="0">c.Lock()
        defer c.Unlock()

        for k := range c.cache </span><span class="cov0" title="0">{
                clear := false
                for p := range partitionsSet </span><span class="cov0" title="0">{
                        if strings.Contains(k, p) </span><span class="cov0" title="0">{
                                // There will be some false positive, but that's fine.
                                clear = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if clear </span><span class="cov0" title="0">{
                        delete(c.cache, k)
                }</span>
        }

}
</pre>
		
		<pre class="file" id="file205" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package bundler contains functions for concatenation etc. of Resource objects.
package bundler

import (
        "fmt"
        "io"
        "path"
        "path/filepath"

        "github.com/gohugoio/hugo/common/hugio"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
)

// Client contains methods perform concatenation and other bundling related
// tasks to Resource objects.
type Client struct {
        rs *resources.Spec
}

// New creates a new Client with the given specification.
func New(rs *resources.Spec) *Client <span class="cov8" title="1">{
        return &amp;Client{rs: rs}
}</span>

type multiReadSeekCloser struct {
        mr      io.Reader
        sources []hugio.ReadSeekCloser
}

func toReaders(sources []hugio.ReadSeekCloser) []io.Reader <span class="cov0" title="0">{
        readers := make([]io.Reader, len(sources))
        for i, r := range sources </span><span class="cov0" title="0">{
                readers[i] = r
        }</span>
        <span class="cov0" title="0">return readers</span>
}

func newMultiReadSeekCloser(sources ...hugio.ReadSeekCloser) *multiReadSeekCloser <span class="cov0" title="0">{
        mr := io.MultiReader(toReaders(sources)...)
        return &amp;multiReadSeekCloser{mr, sources}
}</span>

func (r *multiReadSeekCloser) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        return r.mr.Read(p)
}</span>

func (r *multiReadSeekCloser) Seek(offset int64, whence int) (newOffset int64, err error) <span class="cov0" title="0">{
        for _, s := range r.sources </span><span class="cov0" title="0">{
                newOffset, err = s.Seek(offset, whence)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">r.mr = io.MultiReader(toReaders(r.sources)...)

        return</span>
}

func (r *multiReadSeekCloser) Close() error <span class="cov0" title="0">{
        for _, s := range r.sources </span><span class="cov0" title="0">{
                s.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Concat concatenates the list of Resource objects.
func (c *Client) Concat(targetPath string, r resource.Resources) (resource.Resource, error) <span class="cov0" title="0">{
        // The CACHE_OTHER will make sure this will be re-created and published on rebuilds.
        return c.rs.ResourceCache.GetOrCreate(path.Join(resources.CACHE_OTHER, targetPath), func() (resource.Resource, error) </span><span class="cov0" title="0">{
                var resolvedm media.Type

                // The given set of resources must be of the same Media Type.
                // We may improve on that in the future, but then we need to know more.
                for i, r := range r </span><span class="cov0" title="0">{
                        if i &gt; 0 &amp;&amp; r.MediaType().Type() != resolvedm.Type() </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("resources in Concat must be of the same Media Type, got %q and %q", r.MediaType().Type(), resolvedm.Type())
                        }</span>
                        <span class="cov0" title="0">resolvedm = r.MediaType()</span>
                }

                <span class="cov0" title="0">concatr := func() (hugio.ReadSeekCloser, error) </span><span class="cov0" title="0">{
                        var rcsources []hugio.ReadSeekCloser
                        for _, s := range r </span><span class="cov0" title="0">{
                                rcr, ok := s.(resource.ReadSeekCloserResource)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("resource %T does not implement resource.ReadSeekerCloserResource", s)
                                }</span>
                                <span class="cov0" title="0">rc, err := rcr.ReadSeekCloser()
                                if err != nil </span><span class="cov0" title="0">{
                                        // Close the already opened.
                                        for _, rcs := range rcsources </span><span class="cov0" title="0">{
                                                rcs.Close()
                                        }</span>
                                        <span class="cov0" title="0">return nil, err</span>
                                }

                                <span class="cov0" title="0">rcsources = append(rcsources, rc)</span>
                        }

                        // Arbitrary JavaScript files require a barrier between them to be safely concatenated together.
                        // Without this, the last line of one file can affect the first line of the next file and change how both files are interpreted.
                        <span class="cov0" title="0">if resolvedm.MainType == media.JavascriptType.MainType &amp;&amp; resolvedm.SubType == media.JavascriptType.SubType </span><span class="cov0" title="0">{
                                readers := make([]hugio.ReadSeekCloser, 2*len(rcsources)-1)
                                j := 0
                                for i := 0; i &lt; len(rcsources); i++ </span><span class="cov0" title="0">{
                                        if i &gt; 0 </span><span class="cov0" title="0">{
                                                readers[j] = hugio.NewReadSeekerNoOpCloserFromString("\n;\n")
                                                j++
                                        }</span>
                                        <span class="cov0" title="0">readers[j] = rcsources[i]
                                        j++</span>
                                }
                                <span class="cov0" title="0">return newMultiReadSeekCloser(readers...), nil</span>
                        }

                        <span class="cov0" title="0">return newMultiReadSeekCloser(rcsources...), nil</span>

                }

                <span class="cov0" title="0">composite, err := c.rs.New(
                        resources.ResourceSourceDescriptor{
                                Fs:                 c.rs.FileCaches.AssetsCache().Fs,
                                LazyPublish:        true,
                                OpenReadSeekCloser: concatr,
                                RelTargetFilename:  filepath.Clean(targetPath)})

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return composite, nil</span>
        })

}
</pre>
		
		<pre class="file" id="file206" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package create contains functions for to create Resource objects. This will
// typically non-files.
package create

import (
        "path"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/common/hugio"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
)

// Client contains methods to create Resource objects.
// tasks to Resource objects.
type Client struct {
        rs *resources.Spec
}

// New creates a new Client with the given specification.
func New(rs *resources.Spec) *Client <span class="cov8" title="1">{
        return &amp;Client{rs: rs}
}</span>

// Get creates a new Resource by opening the given filename in the assets filesystem.
func (c *Client) Get(filename string) (resource.Resource, error) <span class="cov0" title="0">{
        filename = filepath.Clean(filename)
        return c.rs.ResourceCache.GetOrCreate(resources.ResourceCacheKey(filename), func() (resource.Resource, error) </span><span class="cov0" title="0">{
                return c.rs.New(resources.ResourceSourceDescriptor{
                        Fs:             c.rs.BaseFs.Assets.Fs,
                        LazyPublish:    true,
                        SourceFilename: filename})
        }</span>)

}

// Match gets the resources matching the given pattern from the assets filesystem.
func (c *Client) Match(pattern string) (resource.Resources, error) <span class="cov0" title="0">{
        return c.match(pattern, false)
}</span>

// GetMatch gets first resource matching the given pattern from the assets filesystem.
func (c *Client) GetMatch(pattern string) (resource.Resource, error) <span class="cov0" title="0">{
        res, err := c.match(pattern, true)
        if err != nil || len(res) == 0 </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return res[0], err</span>
}

func (c *Client) match(pattern string, firstOnly bool) (resource.Resources, error) <span class="cov0" title="0">{
        var name string
        if firstOnly </span><span class="cov0" title="0">{
                name = "__get-match"
        }</span> else<span class="cov0" title="0"> {
                name = "__match"
        }</span>

        <span class="cov0" title="0">pattern = glob.NormalizePath(pattern)
        partitions := glob.FilterGlobParts(strings.Split(pattern, "/"))
        if len(partitions) == 0 </span><span class="cov0" title="0">{
                partitions = []string{resources.CACHE_OTHER}
        }</span>
        <span class="cov0" title="0">key := path.Join(name, path.Join(partitions...))
        key = path.Join(key, pattern)

        return c.rs.ResourceCache.GetOrCreateResources(key, func() (resource.Resources, error) </span><span class="cov0" title="0">{
                var res resource.Resources

                handle := func(info hugofs.FileMetaInfo) (bool, error) </span><span class="cov0" title="0">{
                        meta := info.Meta()
                        r, err := c.rs.New(resources.ResourceSourceDescriptor{
                                LazyPublish: true,
                                FileInfo:    info,
                                OpenReadSeekCloser: func() (hugio.ReadSeekCloser, error) </span><span class="cov0" title="0">{
                                        return meta.Open()
                                }</span>,
                                RelTargetFilename: meta.Path()})

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return true, err
                        }</span>

                        <span class="cov0" title="0">res = append(res, r)

                        return firstOnly, nil</span>

                }

                <span class="cov0" title="0">if err := hugofs.Glob(c.rs.BaseFs.Assets.Fs, pattern, handle); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return res, nil</span>

        })
}

// FromString creates a new Resource from a string with the given relative target path.
func (c *Client) FromString(targetPath, content string) (resource.Resource, error) <span class="cov0" title="0">{
        return c.rs.ResourceCache.GetOrCreate(path.Join(resources.CACHE_OTHER, targetPath), func() (resource.Resource, error) </span><span class="cov0" title="0">{
                return c.rs.New(
                        resources.ResourceSourceDescriptor{
                                Fs:          c.rs.FileCaches.AssetsCache().Fs,
                                LazyPublish: true,
                                OpenReadSeekCloser: func() (hugio.ReadSeekCloser, error) </span><span class="cov0" title="0">{
                                        return hugio.NewReadSeekerNoOpCloserFromString(content), nil
                                }</span>,
                                RelTargetFilename: filepath.Clean(targetPath)})

        })

}
</pre>
		
		<pre class="file" id="file207" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "fmt"
        "strconv"

        "github.com/gohugoio/hugo/hugofs/glob"
        "github.com/gohugoio/hugo/resources/resource"

        "github.com/pkg/errors"
        "github.com/spf13/cast"

        "strings"

        "github.com/gohugoio/hugo/common/maps"
)

var (
        _ metaAssigner         = (*genericResource)(nil)
        _ metaAssigner         = (*imageResource)(nil)
        _ metaAssignerProvider = (*resourceAdapter)(nil)
)

type metaAssignerProvider interface {
        getMetaAssigner() metaAssigner
}

// metaAssigner allows updating metadata in resources that supports it.
type metaAssigner interface {
        setTitle(title string)
        setName(name string)
        updateParams(params map[string]interface{})
}

const counterPlaceHolder = ":counter"

// AssignMetadata assigns the given metadata to those resources that supports updates
// and matching by wildcard given in `src` using `filepath.Match` with lower cased values.
// This assignment is additive, but the most specific match needs to be first.
// The `name` and `title` metadata field support shell-matched collection it got a match in.
// See https://golang.org/pkg/path/#Match
func AssignMetadata(metadata []map[string]interface{}, resources ...resource.Resource) error <span class="cov0" title="0">{
        counters := make(map[string]int)

        for _, r := range resources </span><span class="cov0" title="0">{
                var ma metaAssigner
                mp, ok := r.(metaAssignerProvider)
                if ok </span><span class="cov0" title="0">{
                        ma = mp.getMetaAssigner()
                }</span> else<span class="cov0" title="0"> {
                        ma, ok = r.(metaAssigner)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">var (
                        nameSet, titleSet                   bool
                        nameCounter, titleCounter           = 0, 0
                        nameCounterFound, titleCounterFound bool
                        resourceSrcKey                      = strings.ToLower(r.Name())
                )

                for _, meta := range metadata </span><span class="cov0" title="0">{
                        src, found := meta["src"]
                        if !found </span><span class="cov0" title="0">{
                                return fmt.Errorf("missing 'src' in metadata for resource")
                        }</span>

                        <span class="cov0" title="0">srcKey := strings.ToLower(cast.ToString(src))

                        glob, err := glob.GetGlob(srcKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to match resource with metadata")
                        }</span>

                        <span class="cov0" title="0">match := glob.Match(resourceSrcKey)

                        if match </span><span class="cov0" title="0">{
                                if !nameSet </span><span class="cov0" title="0">{
                                        name, found := meta["name"]
                                        if found </span><span class="cov0" title="0">{
                                                name := cast.ToString(name)
                                                if !nameCounterFound </span><span class="cov0" title="0">{
                                                        nameCounterFound = strings.Contains(name, counterPlaceHolder)
                                                }</span>
                                                <span class="cov0" title="0">if nameCounterFound &amp;&amp; nameCounter == 0 </span><span class="cov0" title="0">{
                                                        counterKey := "name_" + srcKey
                                                        nameCounter = counters[counterKey] + 1
                                                        counters[counterKey] = nameCounter
                                                }</span>

                                                <span class="cov0" title="0">ma.setName(replaceResourcePlaceholders(name, nameCounter))
                                                nameSet = true</span>
                                        }
                                }

                                <span class="cov0" title="0">if !titleSet </span><span class="cov0" title="0">{
                                        title, found := meta["title"]
                                        if found </span><span class="cov0" title="0">{
                                                title := cast.ToString(title)
                                                if !titleCounterFound </span><span class="cov0" title="0">{
                                                        titleCounterFound = strings.Contains(title, counterPlaceHolder)
                                                }</span>
                                                <span class="cov0" title="0">if titleCounterFound &amp;&amp; titleCounter == 0 </span><span class="cov0" title="0">{
                                                        counterKey := "title_" + srcKey
                                                        titleCounter = counters[counterKey] + 1
                                                        counters[counterKey] = titleCounter
                                                }</span>
                                                <span class="cov0" title="0">ma.setTitle((replaceResourcePlaceholders(title, titleCounter)))
                                                titleSet = true</span>
                                        }
                                }

                                <span class="cov0" title="0">params, found := meta["params"]
                                if found </span><span class="cov0" title="0">{
                                        m := cast.ToStringMap(params)
                                        // Needed for case insensitive fetching of params values
                                        maps.ToLower(m)
                                        ma.updateParams(m)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func replaceResourcePlaceholders(in string, counter int) string <span class="cov0" title="0">{
        return strings.Replace(in, counterPlaceHolder, strconv.Itoa(counter), -1)
}</span>
</pre>
		
		<pre class="file" id="file208" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "errors"
        "fmt"
        "mime"
        "os"
        "path"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/cache/filecache"
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources/images"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/gohugoio/hugo/tpl"
        "github.com/spf13/afero"
)

func NewSpec(
        s *helpers.PathSpec,
        fileCaches filecache.Caches,
        logger *loggers.Logger,
        outputFormats output.Formats,
        mimeTypes media.Types) (*Spec, error) <span class="cov8" title="1">{

        imgConfig, err := images.DecodeConfig(s.Cfg.GetStringMap("imaging"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">imaging, err := images.NewImageProcessor(imgConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if logger == nil </span><span class="cov0" title="0">{
                logger = loggers.NewErrorLogger()
        }</span>

        <span class="cov8" title="1">permalinks, err := page.NewPermalinkExpander(s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rs := &amp;Spec{PathSpec: s,
                Logger:        logger,
                imaging:       imaging,
                MediaTypes:    mimeTypes,
                OutputFormats: outputFormats,
                Permalinks:    permalinks,
                FileCaches:    fileCaches,
                imageCache: newImageCache(
                        fileCaches.ImageCache(),

                        s,
                )}

        rs.ResourceCache = newResourceCache(rs)

        return rs, nil</span>

}

type Spec struct {
        *helpers.PathSpec

        MediaTypes    media.Types
        OutputFormats output.Formats

        Logger *loggers.Logger

        TextTemplates tpl.TemplateParseFinder

        Permalinks page.PermalinkExpander

        // Holds default filter settings etc.
        imaging *images.ImageProcessor

        imageCache    *imageCache
        ResourceCache *ResourceCache
        FileCaches    filecache.Caches
}

func (r *Spec) New(fd ResourceSourceDescriptor) (resource.Resource, error) <span class="cov0" title="0">{
        return r.newResourceFor(fd)
}</span>

func (r *Spec) CacheStats() string <span class="cov0" title="0">{
        r.imageCache.mu.RLock()
        defer r.imageCache.mu.RUnlock()

        s := fmt.Sprintf("Cache entries: %d", len(r.imageCache.store))

        count := 0
        for k := range r.imageCache.store </span><span class="cov0" title="0">{
                if count &gt; 5 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">s += "\n" + k
                count++</span>
        }

        <span class="cov0" title="0">return s</span>
}

func (r *Spec) ClearCaches() <span class="cov0" title="0">{
        r.imageCache.clear()
        r.ResourceCache.clear()
}</span>

func (r *Spec) DeleteCacheByPrefix(prefix string) <span class="cov0" title="0">{
        r.imageCache.deleteByPrefix(prefix)
}</span>

// TODO(bep) unify
func (r *Spec) IsInImageCache(key string) bool <span class="cov0" title="0">{
        // This is used for cache pruning. We currently only have images, but we could
        // imagine expanding on this.
        return r.imageCache.isInCache(key)
}</span>

func (s *Spec) String() string <span class="cov0" title="0">{
        return "spec"
}</span>

// TODO(bep) clean up below
func (r *Spec) newGenericResource(sourceFs afero.Fs,
        targetPathBuilder func() page.TargetPaths,
        osFileInfo os.FileInfo,
        sourceFilename,
        baseFilename string,
        mediaType media.Type) *genericResource <span class="cov0" title="0">{
        return r.newGenericResourceWithBase(
                sourceFs,
                nil,
                nil,
                targetPathBuilder,
                osFileInfo,
                sourceFilename,
                baseFilename,
                mediaType,
        )

}</span>

func (r *Spec) newGenericResourceWithBase(
        sourceFs afero.Fs,
        openReadSeekerCloser resource.OpenReadSeekCloser,
        targetPathBaseDirs []string,
        targetPathBuilder func() page.TargetPaths,
        osFileInfo os.FileInfo,
        sourceFilename,
        baseFilename string,
        mediaType media.Type) *genericResource <span class="cov0" title="0">{

        if osFileInfo != nil &amp;&amp; osFileInfo.IsDir() </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("dirs not supported resource types: %v", osFileInfo))</span>
        }

        // This value is used both to construct URLs and file paths, but start
        // with a Unix-styled path.
        <span class="cov0" title="0">baseFilename = helpers.ToSlashTrimLeading(baseFilename)
        fpath, fname := path.Split(baseFilename)

        var resourceType string
        if mediaType.MainType == "image" </span><span class="cov0" title="0">{
                resourceType = mediaType.MainType
        }</span> else<span class="cov0" title="0"> {
                resourceType = mediaType.SubType
        }</span>

        <span class="cov0" title="0">pathDescriptor := &amp;resourcePathDescriptor{
                baseTargetPathDirs: helpers.UniqueStringsReuse(targetPathBaseDirs),
                targetPathBuilder:  targetPathBuilder,
                relTargetDirFile:   dirFile{dir: fpath, file: fname},
        }

        var fim hugofs.FileMetaInfo
        if osFileInfo != nil </span><span class="cov0" title="0">{
                fim = osFileInfo.(hugofs.FileMetaInfo)
        }</span>

        <span class="cov0" title="0">gfi := &amp;resourceFileInfo{
                fi:                   fim,
                openReadSeekerCloser: openReadSeekerCloser,
                sourceFs:             sourceFs,
                sourceFilename:       sourceFilename,
                h:                    &amp;resourceHash{},
        }

        g := &amp;genericResource{
                resourceFileInfo:       gfi,
                resourcePathDescriptor: pathDescriptor,
                mediaType:              mediaType,
                resourceType:           resourceType,
                spec:                   r,
                params:                 make(map[string]interface{}),
                name:                   baseFilename,
                title:                  baseFilename,
                resourceContent:        &amp;resourceContent{},
        }

        return g</span>

}

func (r *Spec) newResource(sourceFs afero.Fs, fd ResourceSourceDescriptor) (resource.Resource, error) <span class="cov0" title="0">{
        fi := fd.FileInfo
        var sourceFilename string

        if fd.OpenReadSeekCloser != nil </span>{<span class="cov0" title="0">
        }</span> else<span class="cov0" title="0"> if fd.SourceFilename != "" </span><span class="cov0" title="0">{
                var err error
                fi, err = sourceFs.Stat(fd.SourceFilename)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov0" title="0">sourceFilename = fd.SourceFilename</span>
        } else<span class="cov0" title="0"> {
                sourceFilename = fd.SourceFile.Filename()
        }</span>

        <span class="cov0" title="0">if fd.RelTargetFilename == "" </span><span class="cov0" title="0">{
                fd.RelTargetFilename = sourceFilename
        }</span>

        <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(fd.RelTargetFilename))
        mimeType, found := r.MediaTypes.GetFirstBySuffix(strings.TrimPrefix(ext, "."))
        // TODO(bep) we need to handle these ambigous types better, but in this context
        // we most likely want the application/xml type.
        if mimeType.Suffix() == "xml" &amp;&amp; mimeType.SubType == "rss" </span><span class="cov0" title="0">{
                mimeType, found = r.MediaTypes.GetByType("application/xml")
        }</span>

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                // A fallback. Note that mime.TypeByExtension is slow by Hugo standards,
                // so we should configure media types to avoid this lookup for most
                // situations.
                mimeStr := mime.TypeByExtension(ext)
                if mimeStr != "" </span><span class="cov0" title="0">{
                        mimeType, _ = media.FromStringAndExt(mimeStr, ext)
                }</span>
        }

        <span class="cov0" title="0">gr := r.newGenericResourceWithBase(
                sourceFs,
                fd.OpenReadSeekCloser,
                fd.TargetBasePaths,
                fd.TargetPaths,
                fi,
                sourceFilename,
                fd.RelTargetFilename,
                mimeType)

        if mimeType.MainType == "image" </span><span class="cov0" title="0">{
                imgFormat, ok := images.ImageFormatFromExt(ext)
                if ok </span><span class="cov0" title="0">{
                        ir := &amp;imageResource{
                                Image:        images.NewImage(imgFormat, r.imaging, nil, gr),
                                baseResource: gr,
                        }
                        ir.root = ir
                        return newResourceAdapter(gr.spec, fd.LazyPublish, ir), nil
                }</span>

        }

        <span class="cov0" title="0">return newResourceAdapter(gr.spec, fd.LazyPublish, gr), nil</span>

}

func (r *Spec) newResourceFor(fd ResourceSourceDescriptor) (resource.Resource, error) <span class="cov0" title="0">{
        if fd.OpenReadSeekCloser == nil </span><span class="cov0" title="0">{
                if fd.SourceFile != nil &amp;&amp; fd.SourceFilename != "" </span><span class="cov0" title="0">{
                        return nil, errors.New("both SourceFile and AbsSourceFilename provided")
                }</span> else<span class="cov0" title="0"> if fd.SourceFile == nil &amp;&amp; fd.SourceFilename == "" </span><span class="cov0" title="0">{
                        return nil, errors.New("either SourceFile or AbsSourceFilename must be provided")
                }</span>
        }

        <span class="cov0" title="0">if fd.RelTargetFilename == "" </span><span class="cov0" title="0">{
                fd.RelTargetFilename = fd.Filename()
        }</span>

        <span class="cov0" title="0">if len(fd.TargetBasePaths) == 0 </span><span class="cov0" title="0">{
                // If not set, we publish the same resource to all hosts.
                fd.TargetBasePaths = r.MultihostTargetBasePaths
        }</span>

        <span class="cov0" title="0">return r.newResource(fd.Fs, fd)</span>
}
</pre>
		
		<pre class="file" id="file209" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package integrity

import (
        "crypto/md5"
        "crypto/sha256"
        "crypto/sha512"
        "encoding/base64"
        "encoding/hex"
        "hash"
        "html/template"
        "io"

        "github.com/gohugoio/hugo/resources/internal"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
)

const defaultHashAlgo = "sha256"

// Client contains methods to fingerprint (cachebusting) and other integrity-related
// methods.
type Client struct {
        rs *resources.Spec
}

// New creates a new Client with the given specification.
func New(rs *resources.Spec) *Client <span class="cov8" title="1">{
        return &amp;Client{rs: rs}
}</span>

type fingerprintTransformation struct {
        algo string
}

func (t *fingerprintTransformation) Key() internal.ResourceTransformationKey <span class="cov0" title="0">{
        return internal.NewResourceTransformationKey("fingerprint", t.algo)
}</span>

// Transform creates a MD5 hash of the Resource content and inserts that hash before
// the extension in the filename.
func (t *fingerprintTransformation) Transform(ctx *resources.ResourceTransformationCtx) error <span class="cov0" title="0">{

        h, err := newHash(t.algo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var w io.Writer
        if rc, ok := ctx.From.(io.ReadSeeker); ok </span><span class="cov0" title="0">{
                // This transformation does not change the content, so try to
                // avoid writing to To if we can.
                defer rc.Seek(0, 0)
                w = h
        }</span> else<span class="cov0" title="0"> {
                w = io.MultiWriter(h, ctx.To)
        }</span>

        <span class="cov0" title="0">io.Copy(w, ctx.From)
        d, err := digest(h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ctx.Data["Integrity"] = integrity(t.algo, d)
        ctx.AddOutPathIdentifier("." + hex.EncodeToString(d[:]))
        return nil</span>
}

func newHash(algo string) (hash.Hash, error) <span class="cov0" title="0">{
        switch algo </span>{
        case "md5":<span class="cov0" title="0">
                return md5.New(), nil</span>
        case "sha256":<span class="cov0" title="0">
                return sha256.New(), nil</span>
        case "sha384":<span class="cov0" title="0">
                return sha512.New384(), nil</span>
        case "sha512":<span class="cov0" title="0">
                return sha512.New(), nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unsupported crypto algo: %q, use either md5, sha256, sha384 or sha512", algo)</span>
        }
}

// Fingerprint applies fingerprinting of the given resource and hash algorithm.
// It defaults to sha256 if none given, and the options are md5, sha256 or sha512.
// The same algo is used for both the fingerprinting part (aka cache busting) and
// the base64-encoded Subresource Integrity hash, so you will have to stay away from
// md5 if you plan to use both.
// See https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity
func (c *Client) Fingerprint(res resources.ResourceTransformer, algo string) (resource.Resource, error) <span class="cov0" title="0">{
        if algo == "" </span><span class="cov0" title="0">{
                algo = defaultHashAlgo
        }</span>

        <span class="cov0" title="0">return res.Transform(&amp;fingerprintTransformation{algo: algo})</span>
}

func integrity(algo string, sum []byte) template.HTMLAttr <span class="cov0" title="0">{
        encoded := base64.StdEncoding.EncodeToString(sum)
        return template.HTMLAttr(algo + "-" + encoded)
}</span>

func digest(h hash.Hash) ([]byte, error) <span class="cov0" title="0">{
        sum := h.Sum(nil)
        return sum, nil
}</span>
</pre>
		
		<pre class="file" id="file210" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package minifier

import (
        "github.com/gohugoio/hugo/minifiers"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/internal"
        "github.com/gohugoio/hugo/resources/resource"
)

// Client for minification of Resource objects. Supported minfiers are:
// css, html, js, json, svg and xml.
type Client struct {
        rs *resources.Spec
        m  minifiers.Client
}

// New creates a new Client given a specification. Note that it is the media types
// configured for the site that is used to match files to the correct minifier.
func New(rs *resources.Spec) *Client <span class="cov8" title="1">{
        return &amp;Client{rs: rs, m: minifiers.New(rs.MediaTypes, rs.OutputFormats)}
}</span>

type minifyTransformation struct {
        rs *resources.Spec
        m  minifiers.Client
}

func (t *minifyTransformation) Key() internal.ResourceTransformationKey <span class="cov0" title="0">{
        return internal.NewResourceTransformationKey("minify")
}</span>

func (t *minifyTransformation) Transform(ctx *resources.ResourceTransformationCtx) error <span class="cov0" title="0">{
        if err := t.m.Minify(ctx.InMediaType, ctx.To, ctx.From); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ctx.AddOutPathIdentifier(".min")
        return nil</span>
}

func (c *Client) Minify(res resources.ResourceTransformer) (resource.Resource, error) <span class="cov0" title="0">{
        return res.Transform(&amp;minifyTransformation{
                rs: c.rs,
                m:  c.m,
        })

}</span>
</pre>
		
		<pre class="file" id="file211" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package postcss

import (
        "io"
        "path/filepath"

        "github.com/gohugoio/hugo/resources/internal"
        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/hugofs"
        "github.com/pkg/errors"

        "os"
        "os/exec"

        "github.com/mitchellh/mapstructure"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
)

// Some of the options from https://github.com/postcss/postcss-cli
type Options struct {

        // Set a custom path to look for a config file.
        Config string

        NoMap bool // Disable the default inline sourcemaps

        // Options for when not using a config file
        Use         string // List of postcss plugins to use
        Parser      string //  Custom postcss parser
        Stringifier string // Custom postcss stringifier
        Syntax      string // Custom postcss syntax
}

func DecodeOptions(m map[string]interface{}) (opts Options, err error) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">err = mapstructure.WeakDecode(m, &amp;opts)

        if !opts.NoMap </span><span class="cov0" title="0">{
                // There was for a long time a discrepancy between documentation and
                // implementation for the noMap property, so we need to support both
                // camel and snake case.
                opts.NoMap = cast.ToBool(m["no-map"])
        }</span>

        <span class="cov0" title="0">return</span>
}

func (opts Options) toArgs() []string <span class="cov0" title="0">{
        var args []string
        if opts.NoMap </span><span class="cov0" title="0">{
                args = append(args, "--no-map")
        }</span>
        <span class="cov0" title="0">if opts.Use != "" </span><span class="cov0" title="0">{
                args = append(args, "--use", opts.Use)
        }</span>
        <span class="cov0" title="0">if opts.Parser != "" </span><span class="cov0" title="0">{
                args = append(args, "--parser", opts.Parser)
        }</span>
        <span class="cov0" title="0">if opts.Stringifier != "" </span><span class="cov0" title="0">{
                args = append(args, "--stringifier", opts.Stringifier)
        }</span>
        <span class="cov0" title="0">if opts.Syntax != "" </span><span class="cov0" title="0">{
                args = append(args, "--syntax", opts.Syntax)
        }</span>
        <span class="cov0" title="0">return args</span>
}

// Client is the client used to do PostCSS transformations.
type Client struct {
        rs *resources.Spec
}

// New creates a new Client with the given specification.
func New(rs *resources.Spec) *Client <span class="cov8" title="1">{
        return &amp;Client{rs: rs}
}</span>

type postcssTransformation struct {
        options Options
        rs      *resources.Spec
}

func (t *postcssTransformation) Key() internal.ResourceTransformationKey <span class="cov0" title="0">{
        return internal.NewResourceTransformationKey("postcss", t.options)
}</span>

// Transform shells out to postcss-cli to do the heavy lifting.
// For this to work, you need some additional tools. To install them globally:
// npm install -g postcss-cli
// npm install -g autoprefixer
func (t *postcssTransformation) Transform(ctx *resources.ResourceTransformationCtx) error <span class="cov0" title="0">{

        const localPostCSSPath = "node_modules/.bin/"
        const binaryName = "postcss"

        // Try first in the project's node_modules.
        csiBinPath := filepath.Join(t.rs.WorkingDir, localPostCSSPath, binaryName)

        binary := csiBinPath

        if _, err := exec.LookPath(binary); err != nil </span><span class="cov0" title="0">{
                // Try PATH
                binary = binaryName
                if _, err := exec.LookPath(binary); err != nil </span><span class="cov0" title="0">{
                        // This may be on a CI server etc. Will fall back to pre-built assets.
                        return herrors.ErrFeatureNotAvailable
                }</span>
        }

        <span class="cov0" title="0">var configFile string
        logger := t.rs.Logger

        if t.options.Config != "" </span><span class="cov0" title="0">{
                configFile = t.options.Config
        }</span> else<span class="cov0" title="0"> {
                configFile = "postcss.config.js"
        }</span>

        <span class="cov0" title="0">configFile = filepath.Clean(configFile)

        // We need an abolute filename to the config file.
        if !filepath.IsAbs(configFile) </span><span class="cov0" title="0">{
                // We resolve this against the virtual Work filesystem, to allow
                // this config file to live in one of the themes if needed.
                fi, err := t.rs.BaseFs.Work.Stat(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        if t.options.Config != "" </span><span class="cov0" title="0">{
                                // Only fail if the user specificed config file is not found.
                                return errors.Wrapf(err, "postcss config %q not found:", configFile)
                        }</span>
                        <span class="cov0" title="0">configFile = ""</span>
                } else<span class="cov0" title="0"> {
                        configFile = fi.(hugofs.FileMetaInfo).Meta().Filename()
                }</span>
        }

        <span class="cov0" title="0">var cmdArgs []string

        if configFile != "" </span><span class="cov0" title="0">{
                logger.INFO.Println("postcss: use config file", configFile)
                cmdArgs = []string{"--config", configFile}
        }</span>

        <span class="cov0" title="0">if optArgs := t.options.toArgs(); len(optArgs) &gt; 0 </span><span class="cov0" title="0">{
                cmdArgs = append(cmdArgs, optArgs...)
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(binary, cmdArgs...)

        cmd.Stdout = ctx.To
        cmd.Stderr = os.Stderr

        stdin, err := cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer stdin.Close()
                io.Copy(stdin, ctx.From)
        }</span>()

        <span class="cov0" title="0">err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Process transforms the given Resource with the PostCSS processor.
func (c *Client) Process(res resources.ResourceTransformer, options Options) (resource.Resource, error) <span class="cov0" title="0">{
        return res.Transform(&amp;postcssTransformation{rs: c.rs, options: options})
}</span>
</pre>
		
		<pre class="file" id="file212" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package templates contains functions for template processing of Resource objects.
package templates

import (
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/internal"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/gohugoio/hugo/tpl"
        "github.com/pkg/errors"
)

// Client contains methods to perform template processing of Resource objects.
type Client struct {
        rs *resources.Spec

        textTemplate tpl.TemplateParseFinder
}

// New creates a new Client with the given specification.
func New(rs *resources.Spec, textTemplate tpl.TemplateParseFinder) *Client <span class="cov8" title="1">{
        if rs == nil </span><span class="cov0" title="0">{
                panic("must provice a resource Spec")</span>
        }
        <span class="cov8" title="1">if textTemplate == nil </span><span class="cov0" title="0">{
                panic("must provide a textTemplate")</span>
        }
        <span class="cov8" title="1">return &amp;Client{rs: rs, textTemplate: textTemplate}</span>
}

type executeAsTemplateTransform struct {
        rs           *resources.Spec
        textTemplate tpl.TemplateParseFinder
        targetPath   string
        data         interface{}
}

func (t *executeAsTemplateTransform) Key() internal.ResourceTransformationKey <span class="cov0" title="0">{
        return internal.NewResourceTransformationKey("execute-as-template", t.targetPath)
}</span>

func (t *executeAsTemplateTransform) Transform(ctx *resources.ResourceTransformationCtx) error <span class="cov0" title="0">{
        tplStr := helpers.ReaderToString(ctx.From)
        templ, err := t.textTemplate.Parse(ctx.InPath, tplStr)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to parse Resource %q as Template:", ctx.InPath)
        }</span>

        <span class="cov0" title="0">ctx.OutPath = t.targetPath

        return templ.Execute(ctx.To, t.data)</span>
}

func (c *Client) ExecuteAsTemplate(res resources.ResourceTransformer, targetPath string, data interface{}) (resource.Resource, error) <span class="cov0" title="0">{
        return res.Transform(&amp;executeAsTemplateTransform{
                rs:           c.rs,
                targetPath:   helpers.ToSlashTrimLeading(targetPath),
                textTemplate: c.textTemplate,
                data:         data,
        })
}</span>
</pre>
		
		<pre class="file" id="file213" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package scss

import (
        "github.com/bep/go-tocss/scss"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugolib/filesystems"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/internal"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/spf13/afero"

        "github.com/mitchellh/mapstructure"
)

type Client struct {
        rs     *resources.Spec
        sfs    *filesystems.SourceFilesystem
        workFs afero.Fs
}

func New(fs *filesystems.SourceFilesystem, rs *resources.Spec) (*Client, error) <span class="cov8" title="1">{
        return &amp;Client{sfs: fs, workFs: rs.BaseFs.Work, rs: rs}, nil
}</span>

type Options struct {

        // Hugo, will by default, just replace the extension of the source
        // to .css, e.g. "scss/main.scss" becomes "scss/main.css". You can
        // control this by setting this, e.g. "styles/main.css" will create
        // a Resource with that as a base for RelPermalink etc.
        TargetPath string

        // Hugo automatically adds the entry directories (where the main.scss lives)
        // for project and themes to the list of include paths sent to LibSASS.
        // Any paths set in this setting will be appended. Note that these will be
        // treated as relative to the working dir, i.e. no include paths outside the
        // project/themes.
        IncludePaths []string

        // Default is nested.
        // One of nested, expanded, compact, compressed.
        OutputStyle string

        // Precision of floating point math.
        Precision int

        // When enabled, Hugo will generate a source map.
        EnableSourceMap bool
}

type options struct {
        // The options we receive from the end user.
        from Options

        // The options we send to the SCSS library.
        to scss.Options
}

func (c *Client) ToCSS(res resources.ResourceTransformer, opts Options) (resource.Resource, error) <span class="cov0" title="0">{
        internalOptions := options{
                from: opts,
        }

        // Transfer values from client.
        internalOptions.to.Precision = opts.Precision
        internalOptions.to.OutputStyle = scss.OutputStyleFromString(opts.OutputStyle)

        if internalOptions.to.Precision == 0 </span><span class="cov0" title="0">{
                // bootstrap-sass requires 8 digits precision. The libsass default is 5.
                // https://github.com/twbs/bootstrap-sass/blob/master/README.md#sass-number-precision
                internalOptions.to.Precision = 8
        }</span>

        <span class="cov0" title="0">return res.Transform(&amp;toCSSTransformation{c: c, options: internalOptions})</span>
}

type toCSSTransformation struct {
        c       *Client
        options options
}

func (t *toCSSTransformation) Key() internal.ResourceTransformationKey <span class="cov0" title="0">{
        return internal.NewResourceTransformationKey("tocss", t.options.from)
}</span>

func DecodeOptions(m map[string]interface{}) (opts Options, err error) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">err = mapstructure.WeakDecode(m, &amp;opts)

        if opts.TargetPath != "" </span><span class="cov0" title="0">{
                opts.TargetPath = helpers.ToSlashTrimLeading(opts.TargetPath)
        }</span>

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file214" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +build !extended

package scss

import (
        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/resources"
)

// Used in tests.
func Supports() bool <span class="cov0" title="0">{
        return false
}</span>

func (t *toCSSTransformation) Transform(ctx *resources.ResourceTransformationCtx) error <span class="cov0" title="0">{
        return herrors.ErrFeatureNotAvailable
}</span>
</pre>
		
		<pre class="file" id="file215" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "bytes"
        "fmt"
        "io"
        "path"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/resources/images/exif"
        "github.com/spf13/afero"

        bp "github.com/gohugoio/hugo/bufferpool"

        "github.com/gohugoio/hugo/resources/internal"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/hugio"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/resources/resource"

        "github.com/gohugoio/hugo/media"
)

var (
        _ resource.ContentResource        = (*resourceAdapter)(nil)
        _ resource.ReadSeekCloserResource = (*resourceAdapter)(nil)
        _ resource.Resource               = (*resourceAdapter)(nil)
        _ resource.Source                 = (*resourceAdapter)(nil)
        _ resource.Identifier             = (*resourceAdapter)(nil)
        _ resource.ResourceMetaProvider   = (*resourceAdapter)(nil)
)

// These are transformations that need special support in Hugo that may not
// be available when building the theme/site so we write the transformation
// result to disk and reuse if needed for these,
var transformationsToCacheOnDisk = map[string]bool{
        "postcss": true,
        "tocss":   true,
}

func newResourceAdapter(spec *Spec, lazyPublish bool, target transformableResource) *resourceAdapter <span class="cov0" title="0">{
        var po *publishOnce
        if lazyPublish </span><span class="cov0" title="0">{
                po = &amp;publishOnce{}
        }</span>
        <span class="cov0" title="0">return &amp;resourceAdapter{
                resourceTransformations: &amp;resourceTransformations{},
                resourceAdapterInner: &amp;resourceAdapterInner{
                        spec:        spec,
                        publishOnce: po,
                        target:      target,
                },
        }</span>
}

// ResourceTransformation is the interface that a resource transformation step
// needs to implement.
type ResourceTransformation interface {
        Key() internal.ResourceTransformationKey
        Transform(ctx *ResourceTransformationCtx) error
}

type ResourceTransformationCtx struct {
        // The content to transform.
        From io.Reader

        // The target of content transformation.
        // The current implementation requires that r is written to w
        // even if no transformation is performed.
        To io.Writer

        // This is the relative path to the original source. Unix styled slashes.
        SourcePath string

        // This is the relative target path to the resource. Unix styled slashes.
        InPath string

        // The relative target path to the transformed resource. Unix styled slashes.
        OutPath string

        // The input media type
        InMediaType media.Type

        // The media type of the transformed resource.
        OutMediaType media.Type

        // Data data can be set on the transformed Resource. Not that this need
        // to be simple types, as it needs to be serialized to JSON and back.
        Data map[string]interface{}

        // This is used to publis additional artifacts, e.g. source maps.
        // We may improve this.
        OpenResourcePublisher func(relTargetPath string) (io.WriteCloser, error)
}

// AddOutPathIdentifier transforming InPath to OutPath adding an identifier,
// eg '.min' before any extension.
func (ctx *ResourceTransformationCtx) AddOutPathIdentifier(identifier string) <span class="cov0" title="0">{
        ctx.OutPath = ctx.addPathIdentifier(ctx.InPath, identifier)
}</span>

// PublishSourceMap writes the content to the target folder of the main resource
// with the ".map" extension added.
func (ctx *ResourceTransformationCtx) PublishSourceMap(content string) error <span class="cov0" title="0">{
        target := ctx.OutPath + ".map"
        f, err := ctx.OpenResourcePublisher(target)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        _, err = f.Write([]byte(content))
        return err</span>
}

// ReplaceOutPathExtension transforming InPath to OutPath replacing the file
// extension, e.g. ".scss"
func (ctx *ResourceTransformationCtx) ReplaceOutPathExtension(newExt string) <span class="cov0" title="0">{
        dir, file := path.Split(ctx.InPath)
        base, _ := helpers.PathAndExt(file)
        ctx.OutPath = path.Join(dir, (base + newExt))
}</span>

func (ctx *ResourceTransformationCtx) addPathIdentifier(inPath, identifier string) string <span class="cov0" title="0">{
        dir, file := path.Split(inPath)
        base, ext := helpers.PathAndExt(file)
        return path.Join(dir, (base + identifier + ext))
}</span>

type publishOnce struct {
        publisherInit sync.Once
        publisherErr  error
}

type resourceAdapter struct {
        commonResource
        *resourceTransformations
        *resourceAdapterInner
}

func (r *resourceAdapter) Content() (interface{}, error) <span class="cov0" title="0">{
        r.init(false, true)
        if r.transformationsErr != nil </span><span class="cov0" title="0">{
                return nil, r.transformationsErr
        }</span>
        <span class="cov0" title="0">return r.target.Content()</span>
}

func (r *resourceAdapter) Data() interface{} <span class="cov0" title="0">{
        r.init(false, false)
        return r.target.Data()
}</span>

func (r *resourceAdapter) Fill(spec string) (resource.Image, error) <span class="cov0" title="0">{
        return r.getImageOps().Fill(spec)
}</span>

func (r *resourceAdapter) Fit(spec string) (resource.Image, error) <span class="cov0" title="0">{
        return r.getImageOps().Fit(spec)
}</span>

func (r *resourceAdapter) Filter(filters ...interface{}) (resource.Image, error) <span class="cov0" title="0">{
        return r.getImageOps().Filter(filters...)
}</span>

func (r *resourceAdapter) Height() int <span class="cov0" title="0">{
        return r.getImageOps().Height()
}</span>

func (r *resourceAdapter) Exif() (*exif.Exif, error) <span class="cov0" title="0">{
        return r.getImageOps().Exif()
}</span>

func (r *resourceAdapter) Key() string <span class="cov0" title="0">{
        r.init(false, false)
        return r.target.(resource.Identifier).Key()
}</span>

func (r *resourceAdapter) MediaType() media.Type <span class="cov0" title="0">{
        r.init(false, false)
        return r.target.MediaType()
}</span>

func (r *resourceAdapter) Name() string <span class="cov0" title="0">{
        r.init(false, false)
        return r.target.Name()
}</span>

func (r *resourceAdapter) Params() map[string]interface{} <span class="cov0" title="0">{
        r.init(false, false)
        return r.target.Params()
}</span>

func (r *resourceAdapter) Permalink() string <span class="cov0" title="0">{
        r.init(true, false)
        return r.target.Permalink()
}</span>

func (r *resourceAdapter) Publish() error <span class="cov0" title="0">{
        r.init(false, false)

        return r.target.Publish()
}</span>

func (r *resourceAdapter) ReadSeekCloser() (hugio.ReadSeekCloser, error) <span class="cov0" title="0">{
        r.init(false, false)
        return r.target.ReadSeekCloser()
}</span>

func (r *resourceAdapter) RelPermalink() string <span class="cov0" title="0">{
        r.init(true, false)
        return r.target.RelPermalink()
}</span>

func (r *resourceAdapter) Resize(spec string) (resource.Image, error) <span class="cov0" title="0">{
        return r.getImageOps().Resize(spec)
}</span>

func (r *resourceAdapter) ResourceType() string <span class="cov0" title="0">{
        r.init(false, false)
        return r.target.ResourceType()
}</span>

func (r *resourceAdapter) String() string <span class="cov0" title="0">{
        return r.Name()
}</span>

func (r *resourceAdapter) Title() string <span class="cov0" title="0">{
        r.init(false, false)
        return r.target.Title()
}</span>

func (r resourceAdapter) Transform(t ...ResourceTransformation) (ResourceTransformer, error) <span class="cov0" title="0">{
        r.resourceTransformations = &amp;resourceTransformations{
                transformations: append(r.transformations, t...),
        }

        r.resourceAdapterInner = &amp;resourceAdapterInner{
                spec:        r.spec,
                publishOnce: &amp;publishOnce{},
                target:      r.target,
        }

        return &amp;r, nil
}</span>

func (r *resourceAdapter) Width() int <span class="cov0" title="0">{
        return r.getImageOps().Width()
}</span>

func (r *resourceAdapter) getImageOps() resource.ImageOps <span class="cov0" title="0">{
        img, ok := r.target.(resource.ImageOps)
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("%T is not an image", r.target))</span>
        }
        <span class="cov0" title="0">r.init(false, false)
        return img</span>
}

func (r *resourceAdapter) getMetaAssigner() metaAssigner <span class="cov0" title="0">{
        return r.target
}</span>

func (r *resourceAdapter) getSpec() *Spec <span class="cov0" title="0">{
        return r.spec
}</span>

func (r *resourceAdapter) publish() <span class="cov0" title="0">{
        if r.publishOnce == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">r.publisherInit.Do(func() </span><span class="cov0" title="0">{
                r.publisherErr = r.target.Publish()

                if r.publisherErr != nil </span><span class="cov0" title="0">{
                        r.spec.Logger.ERROR.Printf("Failed to publish Resource: %s", r.publisherErr)
                }</span>
        })

}

func (r *resourceAdapter) transform(publish, setContent bool) error <span class="cov0" title="0">{
        cache := r.spec.ResourceCache

        // Files with a suffix will be stored in cache (both on disk and in memory)
        // partitioned by their suffix.
        var key string
        for _, tr := range r.transformations </span><span class="cov0" title="0">{
                key = key + "_" + tr.Key().Value()
        }</span>

        <span class="cov0" title="0">base := ResourceCacheKey(r.target.TargetPath())

        key = cache.cleanKey(base) + "_" + helpers.MD5String(key)

        cached, found := cache.get(key)

        if found </span><span class="cov0" title="0">{
                r.resourceAdapterInner = cached.(*resourceAdapterInner)
                return nil
        }</span>

        // Acquire a write lock for the named transformation.
        <span class="cov0" title="0">cache.nlocker.Lock(key)
        // Check the cache again.
        cached, found = cache.get(key)
        if found </span><span class="cov0" title="0">{
                r.resourceAdapterInner = cached.(*resourceAdapterInner)
                cache.nlocker.Unlock(key)
                return nil
        }</span>

        <span class="cov0" title="0">defer cache.nlocker.Unlock(key)
        defer cache.set(key, r.resourceAdapterInner)

        b1 := bp.GetBuffer()
        b2 := bp.GetBuffer()
        defer bp.PutBuffer(b1)
        defer bp.PutBuffer(b2)

        tctx := &amp;ResourceTransformationCtx{
                Data:                  make(map[string]interface{}),
                OpenResourcePublisher: r.target.openPublishFileForWriting,
        }

        tctx.InMediaType = r.target.MediaType()
        tctx.OutMediaType = r.target.MediaType()

        startCtx := *tctx
        updates := &amp;transformationUpdate{startCtx: startCtx}

        var contentrc hugio.ReadSeekCloser

        contentrc, err := contentReadSeekerCloser(r.target)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer contentrc.Close()

        tctx.From = contentrc
        tctx.To = b1

        tctx.InPath = r.target.TargetPath()
        tctx.SourcePath = tctx.InPath

        counter := 0
        writeToFileCache := false

        var transformedContentr io.Reader

        for i, tr := range r.transformations </span><span class="cov0" title="0">{
                if i != 0 </span><span class="cov0" title="0">{
                        tctx.InMediaType = tctx.OutMediaType
                }</span>

                <span class="cov0" title="0">if !writeToFileCache </span><span class="cov0" title="0">{
                        writeToFileCache = transformationsToCacheOnDisk[tr.Key().Name]
                }</span>

                <span class="cov0" title="0">if i &gt; 0 </span><span class="cov0" title="0">{
                        hasWrites := tctx.To.(*bytes.Buffer).Len() &gt; 0
                        if hasWrites </span><span class="cov0" title="0">{
                                counter++
                                // Switch the buffers
                                if counter%2 == 0 </span><span class="cov0" title="0">{
                                        tctx.From = b2
                                        b1.Reset()
                                        tctx.To = b1
                                }</span> else<span class="cov0" title="0"> {
                                        tctx.From = b1
                                        b2.Reset()
                                        tctx.To = b2
                                }</span>
                        }
                }

                <span class="cov0" title="0">if err = tr.Transform(tctx); err != nil </span><span class="cov0" title="0">{
                        if writeToFileCache &amp;&amp; err == herrors.ErrFeatureNotAvailable </span><span class="cov0" title="0">{
                                // This transformation is not available in this
                                // Hugo installation (scss not compiled in, PostCSS not available etc.)
                                // If a prepared bundle for this transformation chain is available, use that.
                                f := r.target.tryTransformedFileCache(key, updates)
                                if f == nil </span><span class="cov0" title="0">{
                                        errMsg := err.Error()
                                        if tr.Key().Name == "postcss" </span><span class="cov0" title="0">{
                                                errMsg = "PostCSS not found; install with \"npm install postcss-cli\". See https://gohugo.io/hugo-pipes/postcss/"
                                        }</span>
                                        <span class="cov0" title="0">return fmt.Errorf("%s: failed to transform %q (%s): %s", strings.ToUpper(tr.Key().Name), tctx.InPath, tctx.InMediaType.Type(), errMsg)</span>
                                }
                                <span class="cov0" title="0">transformedContentr = f
                                updates.sourceFs = cache.fileCache.Fs
                                defer f.Close()

                                // The reader above is all we need.
                                break</span>
                        }

                        // Abort.
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov0" title="0">if tctx.OutPath != "" </span><span class="cov0" title="0">{
                        tctx.InPath = tctx.OutPath
                        tctx.OutPath = ""
                }</span>
        }

        <span class="cov0" title="0">if transformedContentr == nil </span><span class="cov0" title="0">{
                updates.updateFromCtx(tctx)
        }</span>

        <span class="cov0" title="0">var publishwriters []io.WriteCloser

        if publish </span><span class="cov0" title="0">{
                publicw, err := r.target.openPublishFileForWriting(updates.targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">publishwriters = append(publishwriters, publicw)</span>
        }

        <span class="cov0" title="0">if transformedContentr == nil </span><span class="cov0" title="0">{
                if writeToFileCache </span><span class="cov0" title="0">{
                        // Also write it to the cache
                        fi, metaw, err := cache.writeMeta(key, updates.toTransformedResourceMetadata())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">updates.sourceFilename = &amp;fi.Name
                        updates.sourceFs = cache.fileCache.Fs
                        publishwriters = append(publishwriters, metaw)</span>
                }

                // Any transofrmations reading from From must also write to To.
                // This means that if the target buffer is empty, we can just reuse
                // the original reader.
                <span class="cov0" title="0">if b, ok := tctx.To.(*bytes.Buffer); ok &amp;&amp; b.Len() &gt; 0 </span><span class="cov0" title="0">{
                        transformedContentr = tctx.To.(*bytes.Buffer)
                }</span> else<span class="cov0" title="0"> {
                        transformedContentr = contentrc
                }</span>
        }

        // Also write it to memory
        <span class="cov0" title="0">var contentmemw *bytes.Buffer

        setContent = setContent || !writeToFileCache

        if setContent </span><span class="cov0" title="0">{
                contentmemw = bp.GetBuffer()
                defer bp.PutBuffer(contentmemw)
                publishwriters = append(publishwriters, hugio.ToWriteCloser(contentmemw))
        }</span>

        <span class="cov0" title="0">publishw := hugio.NewMultiWriteCloser(publishwriters...)
        _, err = io.Copy(publishw, transformedContentr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">publishw.Close()

        if setContent </span><span class="cov0" title="0">{
                s := contentmemw.String()
                updates.content = &amp;s
        }</span>

        <span class="cov0" title="0">newTarget, err := r.target.cloneWithUpdates(updates)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r.target = newTarget

        return nil</span>
}

func (r *resourceAdapter) init(publish, setContent bool) <span class="cov0" title="0">{
        r.initTransform(publish, setContent)
}</span>

func (r *resourceAdapter) initTransform(publish, setContent bool) <span class="cov0" title="0">{
        r.transformationsInit.Do(func() </span><span class="cov0" title="0">{
                if len(r.transformations) == 0 </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return
                }</span>

                <span class="cov0" title="0">if publish </span><span class="cov0" title="0">{
                        // The transformation will write the content directly to
                        // the destination.
                        r.publishOnce = nil
                }</span>

                <span class="cov0" title="0">r.transformationsErr = r.transform(publish, setContent)
                if r.transformationsErr != nil </span><span class="cov0" title="0">{
                        r.spec.Logger.ERROR.Printf("Transformation failed: %s", r.transformationsErr)
                }</span>
        })

        <span class="cov0" title="0">if publish &amp;&amp; r.publishOnce != nil </span><span class="cov0" title="0">{
                r.publish()
        }</span>
}

type resourceAdapterInner struct {
        target transformableResource

        spec *Spec

        // Handles publishing (to /public) if needed.
        *publishOnce
}

type resourceTransformations struct {
        transformationsInit sync.Once
        transformationsErr  error
        transformations     []ResourceTransformation
}

type transformableResource interface {
        baseResourceInternal

        resource.ContentProvider
        resource.Resource
}

type transformationUpdate struct {
        content        *string
        sourceFilename *string
        sourceFs       afero.Fs
        targetPath     string
        mediaType      media.Type
        data           map[string]interface{}

        startCtx ResourceTransformationCtx
}

func (u *transformationUpdate) isContenChanged() bool <span class="cov0" title="0">{
        return u.content != nil || u.sourceFilename != nil
}</span>

func (u *transformationUpdate) toTransformedResourceMetadata() transformedResourceMetadata <span class="cov0" title="0">{
        return transformedResourceMetadata{
                MediaTypeV: u.mediaType.Type(),
                Target:     u.targetPath,
                MetaData:   u.data,
        }
}</span>

func (u *transformationUpdate) updateFromCtx(ctx *ResourceTransformationCtx) <span class="cov0" title="0">{
        u.targetPath = ctx.OutPath
        u.mediaType = ctx.OutMediaType
        u.data = ctx.Data
        u.targetPath = ctx.InPath
}</span>

// We will persist this information to disk.
type transformedResourceMetadata struct {
        Target     string                 `json:"Target"`
        MediaTypeV string                 `json:"MediaType"`
        MetaData   map[string]interface{} `json:"Data"`
}

// contentReadSeekerCloser returns a ReadSeekerCloser if possible for a given Resource.
func contentReadSeekerCloser(r resource.Resource) (hugio.ReadSeekCloser, error) <span class="cov0" title="0">{
        switch rr := r.(type) </span>{
        case resource.ReadSeekCloserResource:<span class="cov0" title="0">
                rc, err := rr.ReadSeekCloser()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return rc, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot transform content of Resource of type %T", r)</span>

        }
}
</pre>
		
		<pre class="file" id="file216" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package source

import (
        "path/filepath"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/hugio"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/helpers"
)

// fileInfo implements the File interface.
var (
        _ File = (*FileInfo)(nil)
)

// File represents a source file.
// This is a temporary construct until we resolve page.Page conflicts.
// TODO(bep) remove this construct once we have resolved page deprecations
type File interface {
        fileOverlap
        FileWithoutOverlap
}

// Temporary to solve duplicate/deprecated names in page.Page
type fileOverlap interface {
        // Path gets the relative path including file name and extension.
        // The directory is relative to the content root.
        Path() string

        // Section is first directory below the content root.
        // For page bundles in root, the Section will be empty.
        Section() string

        // Lang is the language code for this page. It will be the
        // same as the site's language code.
        Lang() string

        IsZero() bool
}

type FileWithoutOverlap interface {

        // Filename gets the full path and filename to the file.
        Filename() string

        // Dir gets the name of the directory that contains this file.
        // The directory is relative to the content root.
        Dir() string

        // Extension gets the file extension, i.e "myblogpost.md" will return "md".
        Extension() string

        // Ext is an alias for Extension.
        Ext() string // Hmm... Deprecate Extension

        // LogicalName is filename and extension of the file.
        LogicalName() string

        // BaseFileName is a filename without extension.
        BaseFileName() string

        // TranslationBaseName is a filename with no extension,
        // not even the optional language extension part.
        TranslationBaseName() string

        // ContentBaseName is a either TranslationBaseName or name of containing folder
        // if file is a leaf bundle.
        ContentBaseName() string

        // UniqueID is the MD5 hash of the file's path and is for most practical applications,
        // Hugo content files being one of them, considered to be unique.
        UniqueID() string

        FileInfo() hugofs.FileMetaInfo
}

// FileInfo describes a source file.
type FileInfo struct {

        // Absolute filename to the file on disk.
        filename string

        sp *SourceSpec

        fi hugofs.FileMetaInfo

        // Derived from filename
        ext  string // Extension without any "."
        lang string

        name string

        dir                 string
        relDir              string
        relPath             string
        baseName            string
        translationBaseName string
        contentBaseName     string
        section             string
        isLeafBundle        bool

        uniqueID string

        lazyInit sync.Once
}

// Filename returns a file's absolute path and filename on disk.
func (fi *FileInfo) Filename() string <span class="cov0" title="0">{ return fi.filename }</span>

// Path gets the relative path including file name and extension.  The directory
// is relative to the content root.
func (fi *FileInfo) Path() string <span class="cov8" title="1">{ return fi.relPath }</span>

// Dir gets the name of the directory that contains this file.  The directory is
// relative to the content root.
func (fi *FileInfo) Dir() string <span class="cov8" title="1">{ return fi.relDir }</span>

// Extension is an alias to Ext().
func (fi *FileInfo) Extension() string <span class="cov8" title="1">{ return fi.Ext() }</span>

// Ext returns a file's extension without the leading period (ie. "md").
func (fi *FileInfo) Ext() string <span class="cov8" title="1">{ return fi.ext }</span>

// Lang returns a file's language (ie. "sv").
func (fi *FileInfo) Lang() string <span class="cov0" title="0">{ return fi.lang }</span>

// LogicalName returns a file's name and extension (ie. "page.sv.md").
func (fi *FileInfo) LogicalName() string <span class="cov8" title="1">{ return fi.name }</span>

// BaseFileName returns a file's name without extension (ie. "page.sv").
func (fi *FileInfo) BaseFileName() string <span class="cov8" title="1">{ return fi.baseName }</span>

// TranslationBaseName returns a file's translation base name without the
// language segement (ie. "page").
func (fi *FileInfo) TranslationBaseName() string <span class="cov8" title="1">{ return fi.translationBaseName }</span>

// ContentBaseName is a either TranslationBaseName or name of containing folder
// if file is a leaf bundle.
func (fi *FileInfo) ContentBaseName() string <span class="cov8" title="1">{
        fi.init()
        return fi.contentBaseName
}</span>

// Section returns a file's section.
func (fi *FileInfo) Section() string <span class="cov8" title="1">{
        fi.init()
        return fi.section
}</span>

// UniqueID returns a file's unique, MD5 hash identifier.
func (fi *FileInfo) UniqueID() string <span class="cov8" title="1">{
        fi.init()
        return fi.uniqueID
}</span>

// FileInfo returns a file's underlying os.FileInfo.
func (fi *FileInfo) FileInfo() hugofs.FileMetaInfo <span class="cov8" title="1">{ return fi.fi }</span>

func (fi *FileInfo) String() string <span class="cov0" title="0">{ return fi.BaseFileName() }</span>

// Open implements ReadableFile.
func (fi *FileInfo) Open() (hugio.ReadSeekCloser, error) <span class="cov0" title="0">{
        f, err := fi.fi.Meta().Open()

        return f, err
}</span>

func (fi *FileInfo) IsZero() bool <span class="cov8" title="1">{
        return fi == nil
}</span>

// We create a lot of these FileInfo objects, but there are parts of it used only
// in some cases that is slightly expensive to construct.
func (fi *FileInfo) init() <span class="cov8" title="1">{
        fi.lazyInit.Do(func() </span><span class="cov8" title="1">{
                relDir := strings.Trim(fi.relDir, helpers.FilePathSeparator)
                parts := strings.Split(relDir, helpers.FilePathSeparator)
                var section string
                if (!fi.isLeafBundle &amp;&amp; len(parts) == 1) || len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        section = parts[0]
                }</span>
                <span class="cov8" title="1">fi.section = section

                if fi.isLeafBundle &amp;&amp; len(parts) &gt; 0 </span><span class="cov0" title="0">{
                        fi.contentBaseName = parts[len(parts)-1]
                }</span> else<span class="cov8" title="1"> {
                        fi.contentBaseName = fi.translationBaseName
                }</span>

                <span class="cov8" title="1">fi.uniqueID = helpers.MD5String(filepath.ToSlash(fi.relPath))</span>
        })
}

// NewTestFile creates a partially filled File used in unit tests.
// TODO(bep) improve this package
func NewTestFile(filename string) *FileInfo <span class="cov0" title="0">{
        base := filepath.Base(filepath.Dir(filename))
        return &amp;FileInfo{
                filename:            filename,
                translationBaseName: base,
        }
}</span>

func (sp *SourceSpec) NewFileInfoFrom(path, filename string) (*FileInfo, error) <span class="cov0" title="0">{
        meta := hugofs.FileMeta{
                "filename": filename,
                "path":     path,
        }

        return sp.NewFileInfo(hugofs.NewFileMetaInfo(nil, meta))
}</span>

func (sp *SourceSpec) NewFileInfo(fi hugofs.FileMetaInfo) (*FileInfo, error) <span class="cov8" title="1">{

        m := fi.Meta()

        filename := m.Filename()
        relPath := m.Path()
        isLeafBundle := m.Classifier() == files.ContentClassLeaf

        if relPath == "" </span><span class="cov0" title="0">{
                return nil, errors.Errorf("no Path provided by %v (%T)", m, m.Fs())
        }</span>

        <span class="cov8" title="1">if filename == "" </span><span class="cov0" title="0">{
                return nil, errors.Errorf("no Filename provided by %v (%T)", m, m.Fs())
        }</span>

        <span class="cov8" title="1">relDir := filepath.Dir(relPath)
        if relDir == "." </span><span class="cov8" title="1">{
                relDir = ""
        }</span>
        <span class="cov8" title="1">if !strings.HasSuffix(relDir, helpers.FilePathSeparator) </span><span class="cov8" title="1">{
                relDir = relDir + helpers.FilePathSeparator
        }</span>

        <span class="cov8" title="1">lang := m.Lang()
        translationBaseName := m.GetString("translationBaseName")

        dir, name := filepath.Split(relPath)
        if !strings.HasSuffix(dir, helpers.FilePathSeparator) </span><span class="cov8" title="1">{
                dir = dir + helpers.FilePathSeparator
        }</span>

        <span class="cov8" title="1">ext := strings.ToLower(strings.TrimPrefix(filepath.Ext(name), "."))
        baseName := helpers.Filename(name)

        if translationBaseName == "" </span><span class="cov8" title="1">{
                // This is usyally provided by the filesystem. But this FileInfo is also
                // created in a standalone context when doing "hugo new". This is
                // an approximate implementation, which is "good enough" in that case.
                fileLangExt := filepath.Ext(baseName)
                translationBaseName = strings.TrimSuffix(baseName, fileLangExt)
        }</span>

        <span class="cov8" title="1">f := &amp;FileInfo{
                sp:                  sp,
                filename:            filename,
                fi:                  fi,
                lang:                lang,
                ext:                 ext,
                dir:                 dir,
                relDir:              relDir,  // Dir()
                relPath:             relPath, // Path()
                name:                name,
                baseName:            baseName, // BaseFileName()
                translationBaseName: translationBaseName,
                isLeafBundle:        isLeafBundle,
        }

        return f, nil</span>

}
</pre>
		
		<pre class="file" id="file217" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package source

import (
        "path/filepath"
        "sync"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/hugofs"
)

// Filesystem represents a source filesystem.
type Filesystem struct {
        files        []File
        filesInit    sync.Once
        filesInitErr error

        Base string

        fi hugofs.FileMetaInfo

        SourceSpec
}

// NewFilesystem returns a new filesytem for a given source spec.
func (sp SourceSpec) NewFilesystem(base string) *Filesystem <span class="cov0" title="0">{
        return &amp;Filesystem{SourceSpec: sp, Base: base}
}</span>

func (sp SourceSpec) NewFilesystemFromFileMetaInfo(fi hugofs.FileMetaInfo) *Filesystem <span class="cov8" title="1">{
        return &amp;Filesystem{SourceSpec: sp, fi: fi}
}</span>

// Files returns a slice of readable files.
func (f *Filesystem) Files() ([]File, error) <span class="cov8" title="1">{
        f.filesInit.Do(func() </span><span class="cov8" title="1">{
                err := f.captureFiles()
                if err != nil </span><span class="cov0" title="0">{
                        f.filesInitErr = errors.Wrap(err, "capture files")
                }</span>
        })
        <span class="cov8" title="1">return f.files, f.filesInitErr</span>
}

// add populates a file in the Filesystem.files
func (f *Filesystem) add(name string, fi hugofs.FileMetaInfo) (err error) <span class="cov8" title="1">{
        var file File

        file, err = f.SourceSpec.NewFileInfo(fi)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">f.files = append(f.files, file)

        return err</span>
}

func (f *Filesystem) captureFiles() error <span class="cov8" title="1">{
        walker := func(path string, fi hugofs.FileMetaInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if fi.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">meta := fi.Meta()
                filename := meta.Filename()

                b, err := f.shouldRead(filename, fi)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if b </span><span class="cov8" title="1">{
                        err = f.add(filename, fi)
                }</span>

                <span class="cov8" title="1">return err</span>
        }

        <span class="cov8" title="1">w := hugofs.NewWalkway(hugofs.WalkwayConfig{
                Fs:     f.SourceFs,
                Info:   f.fi,
                Root:   f.Base,
                WalkFn: walker,
        })

        return w.Walk()</span>

}

func (f *Filesystem) shouldRead(filename string, fi hugofs.FileMetaInfo) (bool, error) <span class="cov8" title="1">{

        ignore := f.SourceSpec.IgnoreFile(fi.Meta().Filename())

        if fi.IsDir() </span><span class="cov0" title="0">{
                if ignore </span><span class="cov0" title="0">{
                        return false, filepath.SkipDir
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        }

        <span class="cov8" title="1">if ignore </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file218" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package source

import (
        "os"
        "path/filepath"
        "regexp"
        "runtime"

        "github.com/gohugoio/hugo/langs"
        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/cast"
)

// SourceSpec abstracts language-specific file creation.
// TODO(bep) rename to Spec
type SourceSpec struct {
        *helpers.PathSpec

        SourceFs afero.Fs

        // This is set if the ignoreFiles config is set.
        ignoreFilesRe []*regexp.Regexp

        Languages              map[string]interface{}
        DefaultContentLanguage string
        DisabledLanguages      map[string]bool
}

// NewSourceSpec initializes SourceSpec using languages the given filesystem and PathSpec.
func NewSourceSpec(ps *helpers.PathSpec, fs afero.Fs) *SourceSpec <span class="cov8" title="1">{
        cfg := ps.Cfg
        defaultLang := cfg.GetString("defaultContentLanguage")
        languages := cfg.GetStringMap("languages")

        disabledLangsSet := make(map[string]bool)

        for _, disabledLang := range cfg.GetStringSlice("disableLanguages") </span><span class="cov0" title="0">{
                disabledLangsSet[disabledLang] = true
        }</span>

        <span class="cov8" title="1">if len(languages) == 0 </span><span class="cov8" title="1">{
                l := langs.NewDefaultLanguage(cfg)
                languages[l.Lang] = l
                defaultLang = l.Lang
        }</span>

        <span class="cov8" title="1">ignoreFiles := cast.ToStringSlice(cfg.Get("ignoreFiles"))
        var regexps []*regexp.Regexp
        if len(ignoreFiles) &gt; 0 </span><span class="cov0" title="0">{
                for _, ignorePattern := range ignoreFiles </span><span class="cov0" title="0">{
                        re, err := regexp.Compile(ignorePattern)
                        if err != nil </span><span class="cov0" title="0">{
                                helpers.DistinctErrorLog.Printf("Invalid regexp %q in ignoreFiles: %s", ignorePattern, err)
                        }</span> else<span class="cov0" title="0"> {
                                regexps = append(regexps, re)
                        }</span>

                }
        }

        <span class="cov8" title="1">return &amp;SourceSpec{ignoreFilesRe: regexps, PathSpec: ps, SourceFs: fs, Languages: languages, DefaultContentLanguage: defaultLang, DisabledLanguages: disabledLangsSet}</span>

}

// IgnoreFile returns whether a given file should be ignored.
func (s *SourceSpec) IgnoreFile(filename string) bool <span class="cov8" title="1">{
        if filename == "" </span><span class="cov0" title="0">{
                if _, ok := s.SourceFs.(*afero.OsFs); ok </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov8" title="1">base := filepath.Base(filename)

        if len(base) &gt; 0 </span><span class="cov8" title="1">{
                first := base[0]
                last := base[len(base)-1]
                if first == '.' ||
                        first == '#' ||
                        last == '~' </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">if len(s.ignoreFilesRe) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov0" title="0">for _, re := range s.ignoreFilesRe </span><span class="cov0" title="0">{
                if re.MatchString(filename) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Also check the forward slash variant if different.
                unixFilename := filepath.ToSlash(filename)
                if unixFilename != filename </span><span class="cov0" title="0">{
                        for _, re := range s.ignoreFilesRe </span><span class="cov0" title="0">{
                                if re.MatchString(unixFilename) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false</span>
}

// IsRegularSourceFile returns whether filename represents a regular file in the
// source filesystem.
func (s *SourceSpec) IsRegularSourceFile(filename string) (bool, error) <span class="cov0" title="0">{
        fi, err := helpers.LstatIfPossible(s.SourceFs, filename)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if fi.Mode()&amp;os.ModeSymlink == os.ModeSymlink </span><span class="cov0" title="0">{
                link, err := filepath.EvalSymlinks(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">fi, err = helpers.LstatIfPossible(s.SourceFs, link)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file219" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package cast provides template functions for data type conversions.
package cast

import (
        "html/template"

        _cast "github.com/spf13/cast"
)

// New returns a new instance of the cast-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "cast" namespace.
type Namespace struct {
}

// ToInt converts the given value to an int.
func (ns *Namespace) ToInt(v interface{}) (int, error) <span class="cov0" title="0">{
        v = convertTemplateToString(v)
        return _cast.ToIntE(v)
}</span>

// ToString converts the given value to a string.
func (ns *Namespace) ToString(v interface{}) (string, error) <span class="cov0" title="0">{
        return _cast.ToStringE(v)
}</span>

// ToFloat converts the given value to a float.
func (ns *Namespace) ToFloat(v interface{}) (float64, error) <span class="cov0" title="0">{
        v = convertTemplateToString(v)
        return _cast.ToFloat64E(v)
}</span>

func convertTemplateToString(v interface{}) interface{} <span class="cov0" title="0">{
        switch vv := v.(type) </span>{
        case template.HTML:<span class="cov0" title="0">
                v = string(vv)</span>
        case template.CSS:<span class="cov0" title="0">
                v = string(vv)</span>
        case template.HTMLAttr:<span class="cov0" title="0">
                v = string(vv)</span>
        case template.JS:<span class="cov0" title="0">
                v = string(vv)</span>
        case template.JSStr:<span class="cov0" title="0">
                v = string(vv)</span>
        }
        <span class="cov0" title="0">return v</span>
}
</pre>
		
		<pre class="file" id="file220" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cast

import (
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/docshelper"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/tpl/internal"
        "github.com/spf13/viper"
)

// This file provides documentation support and is randomly put into this package.
func init() <span class="cov8" title="1">{
        docsProvider := func() map[string]interface{} </span><span class="cov0" title="0">{
                docs := make(map[string]interface{})
                d := &amp;deps.Deps{
                        Cfg:                 viper.New(),
                        Log:                 loggers.NewErrorLogger(),
                        BuildStartListeners: &amp;deps.Listeners{},
                        Site:                page.NewDummyHugoSite(newTestConfig()),
                }

                var namespaces internal.TemplateFuncsNamespaces

                for _, nsf := range internal.TemplateFuncsNamespaceRegistry </span><span class="cov0" title="0">{
                        nf := nsf(d)
                        namespaces = append(namespaces, nf)

                }</span>

                <span class="cov0" title="0">docs["funcs"] = namespaces
                return docs</span>
        }

        <span class="cov8" title="1">docshelper.AddDocProvider("tpl", docsProvider)</span>
}

func newTestConfig() *viper.Viper <span class="cov0" title="0">{
        v := viper.New()
        v.Set("contentDir", "content")
        return v
}</span>
</pre>
		
		<pre class="file" id="file221" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cast

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "cast"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.ToInt,
                        []string{"int"},
                        [][2]string{
                                {`{{ "1234" | int | printf "%T" }}`, `int`},
                        },
                )

                ns.AddMethodMapping(ctx.ToString,
                        []string{"string"},
                        [][2]string{
                                {`{{ 1234 | string | printf "%T" }}`, `string`},
                        },
                )

                ns.AddMethodMapping(ctx.ToFloat,
                        []string{"float"},
                        [][2]string{
                                {`{{ "1234" | float | printf "%T" }}`, `float64`},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file222" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "errors"

        "github.com/gohugoio/hugo/common/collections"
)

// Append appends the arguments up to the last one to the slice in the last argument.
// This construct allows template constructs like this:
//     {{ $pages = $pages | append $p2 $p1 }}
// Note that with 2 arguments where both are slices of the same type,
// the first slice will be appended to the second:
//     {{ $pages = $pages | append .Site.RegularPages }}
func (ns *Namespace) Append(args ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("need at least 2 arguments to append")
        }</span>

        <span class="cov0" title="0">to := args[len(args)-1]
        from := args[:len(args)-1]

        return collections.Append(to, from...)</span>

}
</pre>
		
		<pre class="file" id="file223" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "errors"
        "fmt"
        "reflect"
        "strings"

        "github.com/gohugoio/hugo/tpl"
)

// Apply takes a map, array, or slice and returns a new slice with the function fname applied over it.
func (ns *Namespace) Apply(seq interface{}, fname string, args ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        if seq == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0), nil
        }</span>

        <span class="cov0" title="0">if fname == "apply" </span><span class="cov0" title="0">{
                return nil, errors.New("can't apply myself (no turtles allowed)")
        }</span>

        <span class="cov0" title="0">seqv := reflect.ValueOf(seq)
        seqv, isNil := indirect(seqv)
        if isNil </span><span class="cov0" title="0">{
                return nil, errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov0" title="0">fnv, found := ns.lookupFunc(fname)
        if !found </span><span class="cov0" title="0">{
                return nil, errors.New("can't find function " + fname)
        }</span>

        // fnv := reflect.ValueOf(fn)

        <span class="cov0" title="0">switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                r := make([]interface{}, seqv.Len())
                for i := 0; i &lt; seqv.Len(); i++ </span><span class="cov0" title="0">{
                        vv := seqv.Index(i)

                        vvv, err := applyFnToThis(fnv, vv, args...)

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">r[i] = vvv.Interface()</span>
                }

                <span class="cov0" title="0">return r, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("can't apply over %v", seq)</span>
        }
}

func applyFnToThis(fn, this reflect.Value, args ...interface{}) (reflect.Value, error) <span class="cov0" title="0">{
        n := make([]reflect.Value, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                if arg == "." </span><span class="cov0" title="0">{
                        n[i] = this
                }</span> else<span class="cov0" title="0"> {
                        n[i] = reflect.ValueOf(arg)
                }</span>
        }

        <span class="cov0" title="0">num := fn.Type().NumIn()

        if fn.Type().IsVariadic() </span><span class="cov0" title="0">{
                num--
        }</span>

        // TODO(bep) see #1098 - also see template_tests.go
        /*if len(args) &lt; num {
                return reflect.ValueOf(nil), errors.New("Too few arguments")
        } else if len(args) &gt; num {
                return reflect.ValueOf(nil), errors.New("Too many arguments")
        }*/

        <span class="cov0" title="0">for i := 0; i &lt; num; i++ </span><span class="cov0" title="0">{
                // AssignableTo reports whether xt is assignable to type targ.
                if xt, targ := n[i].Type(), fn.Type().In(i); !xt.AssignableTo(targ) </span><span class="cov0" title="0">{
                        return reflect.ValueOf(nil), errors.New("called apply using " + xt.String() + " as type " + targ.String())
                }</span>
        }

        <span class="cov0" title="0">res := fn.Call(n)

        if len(res) == 1 || res[1].IsNil() </span><span class="cov0" title="0">{
                return res[0], nil
        }</span>
        <span class="cov0" title="0">return reflect.ValueOf(nil), res[1].Interface().(error)</span>
}

func (ns *Namespace) lookupFunc(fname string) (reflect.Value, bool) <span class="cov0" title="0">{
        if !strings.ContainsRune(fname, '.') </span><span class="cov0" title="0">{
                templ, ok := ns.deps.Tmpl.(tpl.TemplateFuncsGetter)
                if !ok </span><span class="cov0" title="0">{
                        panic("Needs a tpl.TemplateFuncsGetter")</span>
                }
                <span class="cov0" title="0">fm := templ.GetFuncs()
                fn, found := fm[fname]
                if !found </span><span class="cov0" title="0">{
                        return reflect.Value{}, false
                }</span>

                <span class="cov0" title="0">return reflect.ValueOf(fn), true</span>
        }

        <span class="cov0" title="0">ss := strings.SplitN(fname, ".", 2)

        // namespace
        nv, found := ns.lookupFunc(ss[0])
        if !found </span><span class="cov0" title="0">{
                return reflect.Value{}, false
        }</span>

        // method
        <span class="cov0" title="0">m := nv.MethodByName(ss[1])
        // if reflect.DeepEqual(m, reflect.Value{}) {
        if m.Kind() == reflect.Invalid </span><span class="cov0" title="0">{
                return reflect.Value{}, false
        }</span>
        <span class="cov0" title="0">return m, true</span>
}

// indirect is borrowed from the Go stdlib: 'text/template/exec.go'
func indirect(v reflect.Value) (rv reflect.Value, isNil bool) <span class="cov8" title="1">{
        for ; v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface; v = v.Elem() </span><span class="cov8" title="1">{
                if v.IsNil() </span><span class="cov0" title="0">{
                        return v, true
                }</span>
                <span class="cov8" title="1">if v.Kind() == reflect.Interface &amp;&amp; v.NumMethod() &gt; 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return v, false</span>
}

func indirectInterface(v reflect.Value) (rv reflect.Value, isNil bool) <span class="cov8" title="1">{
        for ; v.Kind() == reflect.Interface; v = v.Elem() </span><span class="cov0" title="0">{
                if v.IsNil() </span><span class="cov0" title="0">{
                        return v, true
                }</span>
                <span class="cov0" title="0">if v.Kind() == reflect.Interface &amp;&amp; v.NumMethod() &gt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return v, false</span>
}
</pre>
		
		<pre class="file" id="file224" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package collections provides template functions for manipulating collections
// such as arrays, maps, and slices.
package collections

import (
        "fmt"
        "html/template"
        "math/rand"
        "net/url"
        "reflect"
        "strings"
        "time"

        "github.com/gohugoio/hugo/common/collections"
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/pkg/errors"
        "github.com/spf13/cast"
)

func init() <span class="cov8" title="1">{
        rand.Seed(time.Now().UTC().UnixNano())
}</span>

// New returns a new instance of the collections-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                deps: deps,
        }
}</span>

// Namespace provides template functions for the "collections" namespace.
type Namespace struct {
        deps *deps.Deps
}

// After returns all the items after the first N in a rangeable list.
func (ns *Namespace) After(index interface{}, seq interface{}) (interface{}, error) <span class="cov0" title="0">{
        if index == nil || seq == nil </span><span class="cov0" title="0">{
                return nil, errors.New("both limit and seq must be provided")
        }</span>

        <span class="cov0" title="0">indexv, err := cast.ToIntE(index)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if indexv &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("can't return negative/empty count of items from sequence")
        }</span>

        <span class="cov0" title="0">seqv := reflect.ValueOf(seq)
        seqv, isNil := indirect(seqv)
        if isNil </span><span class="cov0" title="0">{
                return nil, errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov0" title="0">switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice, reflect.String:<span class="cov0" title="0"></span>
                // okay
        default:<span class="cov0" title="0">
                return nil, errors.New("can't iterate over " + reflect.ValueOf(seq).Type().String())</span>
        }

        <span class="cov0" title="0">if indexv &gt;= seqv.Len() </span><span class="cov0" title="0">{
                return seqv.Slice(0, 0).Interface(), nil
        }</span>

        <span class="cov0" title="0">return seqv.Slice(indexv, seqv.Len()).Interface(), nil</span>
}

// Delimit takes a given sequence and returns a delimited HTML string.
// If last is passed to the function, it will be used as the final delimiter.
func (ns *Namespace) Delimit(seq, delimiter interface{}, last ...interface{}) (template.HTML, error) <span class="cov0" title="0">{
        d, err := cast.ToStringE(delimiter)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var dLast *string
        if len(last) &gt; 0 </span><span class="cov0" title="0">{
                l := last[0]
                dStr, err := cast.ToStringE(l)
                if err != nil </span><span class="cov0" title="0">{
                        dLast = nil
                }</span> else<span class="cov0" title="0"> {
                        dLast = &amp;dStr
                }</span>
        }

        <span class="cov0" title="0">seqv := reflect.ValueOf(seq)
        seqv, isNil := indirect(seqv)
        if isNil </span><span class="cov0" title="0">{
                return "", errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov0" title="0">var str string
        switch seqv.Kind() </span>{
        case reflect.Map:<span class="cov0" title="0">
                sortSeq, err := ns.Sort(seq)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">seqv = reflect.ValueOf(sortSeq)
                fallthrough</span>
        case reflect.Array, reflect.Slice, reflect.String:<span class="cov0" title="0">
                for i := 0; i &lt; seqv.Len(); i++ </span><span class="cov0" title="0">{
                        val := seqv.Index(i).Interface()
                        valStr, err := cast.ToStringE(val)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">switch </span>{
                        case i == seqv.Len()-2 &amp;&amp; dLast != nil:<span class="cov0" title="0">
                                str += valStr + *dLast</span>
                        case i == seqv.Len()-1:<span class="cov0" title="0">
                                str += valStr</span>
                        default:<span class="cov0" title="0">
                                str += valStr + d</span>
                        }
                }

        default:<span class="cov0" title="0">
                return "", fmt.Errorf("can't iterate over %v", seq)</span>
        }

        <span class="cov0" title="0">return template.HTML(str), nil</span>
}

// Dictionary creates a map[string]interface{} from the given parameters by
// walking the parameters and treating them as key-value pairs.  The number
// of parameters must be even.
func (ns *Namespace) Dictionary(values ...interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        if len(values)%2 != 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid dictionary call")
        }</span>

        <span class="cov0" title="0">dict := make(map[string]interface{}, len(values)/2)

        for i := 0; i &lt; len(values); i += 2 </span><span class="cov0" title="0">{
                key, ok := values[i].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("dictionary keys must be strings")
                }</span>
                <span class="cov0" title="0">dict[key] = values[i+1]</span>
        }

        <span class="cov0" title="0">return dict, nil</span>
}

// EchoParam returns a given value if it is set; otherwise, it returns an
// empty string.
func (ns *Namespace) EchoParam(a, key interface{}) interface{} <span class="cov0" title="0">{
        av, isNil := indirect(reflect.ValueOf(a))
        if isNil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var avv reflect.Value
        switch av.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                index, ok := key.(int)
                if ok &amp;&amp; av.Len() &gt; index </span><span class="cov0" title="0">{
                        avv = av.Index(index)
                }</span>
        case reflect.Map:<span class="cov0" title="0">
                kv := reflect.ValueOf(key)
                if kv.Type().AssignableTo(av.Type().Key()) </span><span class="cov0" title="0">{
                        avv = av.MapIndex(kv)
                }</span>
        }

        <span class="cov0" title="0">avv, isNil = indirect(avv)

        if isNil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if avv.IsValid() </span><span class="cov0" title="0">{
                switch avv.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                        return avv.Int()</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                        return avv.Uint()</span>
                case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                        return avv.Float()</span>
                case reflect.String:<span class="cov0" title="0">
                        return avv.String()</span>
                }
        }

        <span class="cov0" title="0">return ""</span>
}

// First returns the first N items in a rangeable list.
func (ns *Namespace) First(limit interface{}, seq interface{}) (interface{}, error) <span class="cov8" title="1">{
        if limit == nil || seq == nil </span><span class="cov0" title="0">{
                return nil, errors.New("both limit and seq must be provided")
        }</span>

        <span class="cov8" title="1">limitv, err := cast.ToIntE(limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if limitv &lt; 0 </span><span class="cov0" title="0">{
                return nil, errors.New("can't return negative count of items from sequence")
        }</span>

        <span class="cov8" title="1">seqv := reflect.ValueOf(seq)
        seqv, isNil := indirect(seqv)
        if isNil </span><span class="cov0" title="0">{
                return nil, errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov8" title="1">switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice, reflect.String:<span class="cov8" title="1"></span>
                // okay
        default:<span class="cov0" title="0">
                return nil, errors.New("can't iterate over " + reflect.ValueOf(seq).Type().String())</span>
        }

        <span class="cov8" title="1">if limitv &gt; seqv.Len() </span><span class="cov8" title="1">{
                limitv = seqv.Len()
        }</span>

        <span class="cov8" title="1">return seqv.Slice(0, limitv).Interface(), nil</span>
}

// In returns whether v is in the set l.  l may be an array or slice.
func (ns *Namespace) In(l interface{}, v interface{}) (bool, error) <span class="cov8" title="1">{
        if l == nil || v == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">lv := reflect.ValueOf(l)
        vv := reflect.ValueOf(v)

        if !vv.Type().Comparable() </span><span class="cov0" title="0">{
                return false, errors.Errorf("value to check must be comparable: %T", v)
        }</span>

        // Normalize numeric types to float64 etc.
        <span class="cov8" title="1">vvk := normalize(vv)

        switch lv.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                for i := 0; i &lt; lv.Len(); i++ </span><span class="cov8" title="1">{
                        lvv, isNil := indirectInterface(lv.Index(i))
                        if isNil || !lvv.Type().Comparable() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">lvvk := normalize(lvv)

                        if lvvk == vvk </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                }
        case reflect.String:<span class="cov0" title="0">
                if vv.Type() == lv.Type() &amp;&amp; strings.Contains(lv.String(), vv.String()) </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

// Intersect returns the common elements in the given sets, l1 and l2.  l1 and
// l2 must be of the same type and may be either arrays or slices.
func (ns *Namespace) Intersect(l1, l2 interface{}) (interface{}, error) <span class="cov0" title="0">{
        if l1 == nil || l2 == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0), nil
        }</span>

        <span class="cov0" title="0">var ins *intersector

        l1v := reflect.ValueOf(l1)
        l2v := reflect.ValueOf(l2)

        switch l1v.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                ins = &amp;intersector{r: reflect.MakeSlice(l1v.Type(), 0, 0), seen: make(map[interface{}]bool)}
                switch l2v.Kind() </span>{
                case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                        for i := 0; i &lt; l1v.Len(); i++ </span><span class="cov0" title="0">{
                                l1vv := l1v.Index(i)
                                if !l1vv.Type().Comparable() </span><span class="cov0" title="0">{
                                        return make([]interface{}, 0), errors.New("intersect does not support slices or arrays of uncomparable types")
                                }</span>

                                <span class="cov0" title="0">for j := 0; j &lt; l2v.Len(); j++ </span><span class="cov0" title="0">{
                                        l2vv := l2v.Index(j)
                                        if !l2vv.Type().Comparable() </span><span class="cov0" title="0">{
                                                return make([]interface{}, 0), errors.New("intersect does not support slices or arrays of uncomparable types")
                                        }</span>

                                        <span class="cov0" title="0">ins.handleValuePair(l1vv, l2vv)</span>
                                }
                        }
                        <span class="cov0" title="0">return ins.r.Interface(), nil</span>
                default:<span class="cov0" title="0">
                        return nil, errors.New("can't iterate over " + reflect.ValueOf(l2).Type().String())</span>
                }
        default:<span class="cov0" title="0">
                return nil, errors.New("can't iterate over " + reflect.ValueOf(l1).Type().String())</span>
        }
}

// Group groups a set of elements by the given key.
// This is currently only supported for Pages.
func (ns *Namespace) Group(key interface{}, items interface{}) (interface{}, error) <span class="cov0" title="0">{
        if key == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil is not a valid key to group by")
        }</span>

        <span class="cov0" title="0">if g, ok := items.(collections.Grouper); ok </span><span class="cov0" title="0">{
                return g.Group(key, items)
        }</span>

        <span class="cov0" title="0">in := newSliceElement(items)

        if g, ok := in.(collections.Grouper); ok </span><span class="cov0" title="0">{
                return g.Group(key, items)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("grouping not supported for type %T %T", items, in)</span>
}

// IsSet returns whether a given array, channel, slice, or map has a key
// defined.
func (ns *Namespace) IsSet(a interface{}, key interface{}) (bool, error) <span class="cov0" title="0">{
        av := reflect.ValueOf(a)
        kv := reflect.ValueOf(key)

        switch av.Kind() </span>{
        case reflect.Array, reflect.Chan, reflect.Slice:<span class="cov0" title="0">
                k, err := cast.ToIntE(key)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("isset unable to use key of type %T as index", key)
                }</span>
                <span class="cov0" title="0">if av.Len() &gt; k </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        case reflect.Map:<span class="cov0" title="0">
                if kv.Type() == av.Type().Key() </span><span class="cov0" title="0">{
                        return av.MapIndex(kv).IsValid(), nil
                }</span>
        default:<span class="cov0" title="0">
                helpers.DistinctFeedbackLog.Printf("WARNING: calling IsSet with unsupported type %q (%T) will always return false.\n", av.Kind(), a)</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

// Last returns the last N items in a rangeable list.
func (ns *Namespace) Last(limit interface{}, seq interface{}) (interface{}, error) <span class="cov0" title="0">{
        if limit == nil || seq == nil </span><span class="cov0" title="0">{
                return nil, errors.New("both limit and seq must be provided")
        }</span>

        <span class="cov0" title="0">limitv, err := cast.ToIntE(limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if limitv &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("can't return negative/empty count of items from sequence")
        }</span>

        <span class="cov0" title="0">seqv := reflect.ValueOf(seq)
        seqv, isNil := indirect(seqv)
        if isNil </span><span class="cov0" title="0">{
                return nil, errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov0" title="0">switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice, reflect.String:<span class="cov0" title="0"></span>
                // okay
        default:<span class="cov0" title="0">
                return nil, errors.New("can't iterate over " + reflect.ValueOf(seq).Type().String())</span>
        }

        <span class="cov0" title="0">if limitv &gt; seqv.Len() </span><span class="cov0" title="0">{
                limitv = seqv.Len()
        }</span>

        <span class="cov0" title="0">return seqv.Slice(seqv.Len()-limitv, seqv.Len()).Interface(), nil</span>
}

// Querify encodes the given parameters in URL-encoded form ("bar=baz&amp;foo=quux") sorted by key.
func (ns *Namespace) Querify(params ...interface{}) (string, error) <span class="cov0" title="0">{
        qs := url.Values{}
        vals, err := ns.Dictionary(params...)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("querify keys must be strings")
        }</span>

        <span class="cov0" title="0">for name, value := range vals </span><span class="cov0" title="0">{
                qs.Add(name, fmt.Sprintf("%v", value))
        }</span>

        <span class="cov0" title="0">return qs.Encode(), nil</span>
}

// Seq creates a sequence of integers.  It's named and used as GNU's seq.
//
// Examples:
//     3 =&gt; 1, 2, 3
//     1 2 4 =&gt; 1, 3
//     -3 =&gt; -1, -2, -3
//     1 4 =&gt; 1, 2, 3, 4
//     1 -2 =&gt; 1, 0, -1, -2
func (ns *Namespace) Seq(args ...interface{}) ([]int, error) <span class="cov0" title="0">{
        if len(args) &lt; 1 || len(args) &gt; 3 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid number of arguments to Seq")
        }</span>

        <span class="cov0" title="0">intArgs := cast.ToIntSlice(args)
        if len(intArgs) &lt; 1 || len(intArgs) &gt; 3 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid arguments to Seq")
        }</span>

        <span class="cov0" title="0">var inc = 1
        var last int
        var first = intArgs[0]

        if len(intArgs) == 1 </span><span class="cov0" title="0">{
                last = first
                if last == 0 </span><span class="cov0" title="0">{
                        return []int{}, nil
                }</span> else<span class="cov0" title="0"> if last &gt; 0 </span><span class="cov0" title="0">{
                        first = 1
                }</span> else<span class="cov0" title="0"> {
                        first = -1
                        inc = -1
                }</span>
        } else<span class="cov0" title="0"> if len(intArgs) == 2 </span><span class="cov0" title="0">{
                last = intArgs[1]
                if last &lt; first </span><span class="cov0" title="0">{
                        inc = -1
                }</span>
        } else<span class="cov0" title="0"> {
                inc = intArgs[1]
                last = intArgs[2]
                if inc == 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("'increment' must not be 0")
                }</span>
                <span class="cov0" title="0">if first &lt; last &amp;&amp; inc &lt; 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("'increment' must be &gt; 0")
                }</span>
                <span class="cov0" title="0">if first &gt; last &amp;&amp; inc &gt; 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("'increment' must be &lt; 0")
                }</span>
        }

        // sanity check
        <span class="cov0" title="0">if last &lt; -100000 </span><span class="cov0" title="0">{
                return nil, errors.New("size of result exceeds limit")
        }</span>
        <span class="cov0" title="0">size := ((last - first) / inc) + 1

        // sanity check
        if size &lt;= 0 || size &gt; 2000 </span><span class="cov0" title="0">{
                return nil, errors.New("size of result exceeds limit")
        }</span>

        <span class="cov0" title="0">seq := make([]int, size)
        val := first
        for i := 0; ; i++ </span><span class="cov0" title="0">{
                seq[i] = val
                val += inc
                if (inc &lt; 0 &amp;&amp; val &lt; last) || (inc &gt; 0 &amp;&amp; val &gt; last) </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return seq, nil</span>
}

// Shuffle returns the given rangeable list in a randomised order.
func (ns *Namespace) Shuffle(seq interface{}) (interface{}, error) <span class="cov0" title="0">{
        if seq == nil </span><span class="cov0" title="0">{
                return nil, errors.New("both count and seq must be provided")
        }</span>

        <span class="cov0" title="0">seqv := reflect.ValueOf(seq)
        seqv, isNil := indirect(seqv)
        if isNil </span><span class="cov0" title="0">{
                return nil, errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov0" title="0">switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice, reflect.String:<span class="cov0" title="0"></span>
                // okay
        default:<span class="cov0" title="0">
                return nil, errors.New("can't iterate over " + reflect.ValueOf(seq).Type().String())</span>
        }

        <span class="cov0" title="0">shuffled := reflect.MakeSlice(reflect.TypeOf(seq), seqv.Len(), seqv.Len())

        randomIndices := rand.Perm(seqv.Len())

        for index, value := range randomIndices </span><span class="cov0" title="0">{
                shuffled.Index(value).Set(seqv.Index(index))
        }</span>

        <span class="cov0" title="0">return shuffled.Interface(), nil</span>
}

// Slice returns a slice of all passed arguments.
func (ns *Namespace) Slice(args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return args
        }</span>

        <span class="cov8" title="1">return collections.Slice(args...)</span>
}

type intersector struct {
        r    reflect.Value
        seen map[interface{}]bool
}

func (i *intersector) appendIfNotSeen(v reflect.Value) <span class="cov0" title="0">{

        vi := v.Interface()
        if !i.seen[vi] </span><span class="cov0" title="0">{
                i.r = reflect.Append(i.r, v)
                i.seen[vi] = true
        }</span>
}

func (i *intersector) handleValuePair(l1vv, l2vv reflect.Value) <span class="cov0" title="0">{
        switch kind := l1vv.Kind(); </span>{
        case kind == reflect.String:<span class="cov0" title="0">
                l2t, err := toString(l2vv)
                if err == nil &amp;&amp; l1vv.String() == l2t </span><span class="cov0" title="0">{
                        i.appendIfNotSeen(l1vv)
                }</span>
        case isNumber(kind):<span class="cov0" title="0">
                f1, err1 := numberToFloat(l1vv)
                f2, err2 := numberToFloat(l2vv)
                if err1 == nil &amp;&amp; err2 == nil &amp;&amp; f1 == f2 </span><span class="cov0" title="0">{
                        i.appendIfNotSeen(l1vv)
                }</span>
        case kind == reflect.Ptr, kind == reflect.Struct:<span class="cov0" title="0">
                if l1vv.Interface() == l2vv.Interface() </span><span class="cov0" title="0">{
                        i.appendIfNotSeen(l1vv)
                }</span>
        case kind == reflect.Interface:<span class="cov0" title="0">
                i.handleValuePair(reflect.ValueOf(l1vv.Interface()), l2vv)</span>
        }
}

// Union returns the union of the given sets, l1 and l2. l1 and
// l2 must be of the same type and may be either arrays or slices.
// If l1 and l2 aren't of the same type then l1 will be returned.
// If either l1 or l2 is nil then the non-nil list will be returned.
func (ns *Namespace) Union(l1, l2 interface{}) (interface{}, error) <span class="cov0" title="0">{
        if l1 == nil &amp;&amp; l2 == nil </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span> else<span class="cov0" title="0"> if l1 == nil &amp;&amp; l2 != nil </span><span class="cov0" title="0">{
                return l2, nil
        }</span> else<span class="cov0" title="0"> if l1 != nil &amp;&amp; l2 == nil </span><span class="cov0" title="0">{
                return l1, nil
        }</span>

        <span class="cov0" title="0">l1v := reflect.ValueOf(l1)
        l2v := reflect.ValueOf(l2)

        var ins *intersector

        switch l1v.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                switch l2v.Kind() </span>{
                case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                        ins = &amp;intersector{r: reflect.MakeSlice(l1v.Type(), 0, 0), seen: make(map[interface{}]bool)}

                        if l1v.Type() != l2v.Type() &amp;&amp;
                                l1v.Type().Elem().Kind() != reflect.Interface &amp;&amp;
                                l2v.Type().Elem().Kind() != reflect.Interface </span><span class="cov0" title="0">{
                                return ins.r.Interface(), nil
                        }</span>

                        <span class="cov0" title="0">var (
                                l1vv  reflect.Value
                                isNil bool
                        )

                        for i := 0; i &lt; l1v.Len(); i++ </span><span class="cov0" title="0">{
                                l1vv, isNil = indirectInterface(l1v.Index(i))

                                if !l1vv.Type().Comparable() </span><span class="cov0" title="0">{
                                        return []interface{}{}, errors.New("union does not support slices or arrays of uncomparable types")
                                }</span>

                                <span class="cov0" title="0">if !isNil </span><span class="cov0" title="0">{
                                        ins.appendIfNotSeen(l1vv)
                                }</span>
                        }

                        <span class="cov0" title="0">if !l1vv.IsValid() </span><span class="cov0" title="0">{
                                // The first slice may be empty. Pick the first value of the second
                                // to use as a prototype.
                                if l2v.Len() &gt; 0 </span><span class="cov0" title="0">{
                                        l1vv = l2v.Index(0)
                                }</span>
                        }

                        <span class="cov0" title="0">for j := 0; j &lt; l2v.Len(); j++ </span><span class="cov0" title="0">{
                                l2vv := l2v.Index(j)

                                switch kind := l1vv.Kind(); </span>{
                                case kind == reflect.String:<span class="cov0" title="0">
                                        l2t, err := toString(l2vv)
                                        if err == nil </span><span class="cov0" title="0">{
                                                ins.appendIfNotSeen(reflect.ValueOf(l2t))
                                        }</span>
                                case isNumber(kind):<span class="cov0" title="0">
                                        var err error
                                        l2vv, err = convertNumber(l2vv, kind)
                                        if err == nil </span><span class="cov0" title="0">{
                                                ins.appendIfNotSeen(l2vv)
                                        }</span>
                                case kind == reflect.Interface, kind == reflect.Struct, kind == reflect.Ptr:<span class="cov0" title="0">
                                        ins.appendIfNotSeen(l2vv)</span>

                                }
                        }

                        <span class="cov0" title="0">return ins.r.Interface(), nil</span>
                default:<span class="cov0" title="0">
                        return nil, errors.New("can't iterate over " + reflect.ValueOf(l2).Type().String())</span>
                }
        default:<span class="cov0" title="0">
                return nil, errors.New("can't iterate over " + reflect.ValueOf(l1).Type().String())</span>
        }
}

// Uniq takes in a slice or array and returns a slice with subsequent
// duplicate elements removed.
func (ns *Namespace) Uniq(seq interface{}) (interface{}, error) <span class="cov0" title="0">{
        if seq == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0), nil
        }</span>

        <span class="cov0" title="0">v := reflect.ValueOf(seq)
        var slice reflect.Value

        switch v.Kind() </span>{
        case reflect.Slice:<span class="cov0" title="0">
                slice = reflect.MakeSlice(v.Type(), 0, 0)</span>
        case reflect.Array:<span class="cov0" title="0">
                slice = reflect.MakeSlice(reflect.SliceOf(v.Type().Elem()), 0, 0)</span>
        default:<span class="cov0" title="0">
                return nil, errors.Errorf("type %T not supported", seq)</span>
        }

        <span class="cov0" title="0">seen := make(map[interface{}]bool)
        for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                ev, _ := indirectInterface(v.Index(i))
                if !ev.Type().Comparable() </span><span class="cov0" title="0">{
                        return nil, errors.New("elements must be comparable")
                }</span>
                <span class="cov0" title="0">key := normalize(ev)
                if _, found := seen[key]; !found </span><span class="cov0" title="0">{
                        slice = reflect.Append(slice, ev)
                        seen[key] = true
                }</span>
        }

        <span class="cov0" title="0">return slice.Interface(), nil</span>

}

// KeyVals creates a key and values wrapper.
func (ns *Namespace) KeyVals(key interface{}, vals ...interface{}) (types.KeyValues, error) <span class="cov0" title="0">{
        return types.KeyValues{Key: key, Values: vals}, nil
}</span>

// NewScratch creates a new Scratch which can be used to store values in a
// thread safe way.
func (ns *Namespace) NewScratch() *maps.Scratch <span class="cov0" title="0">{
        return maps.NewScratch()
}</span>
</pre>
		
		<pre class="file" id="file225" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "errors"
        "fmt"
        "reflect"
)

// Complement gives the elements in the last element of seqs that are not in
// any of the others.
// All elements of seqs must be slices or arrays of comparable types.
//
// The reasoning behind this rather clumsy API is so we can do this in the templates:
//    {{ $c := .Pages | complement $last4 }}
func (ns *Namespace) Complement(seqs ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(seqs) &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("complement needs at least two arguments")
        }</span>

        <span class="cov0" title="0">universe := seqs[len(seqs)-1]
        as := seqs[:len(seqs)-1]

        aset, err := collectIdentities(as...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">v := reflect.ValueOf(universe)
        switch v.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                sl := reflect.MakeSlice(v.Type(), 0, 0)
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                        ev, _ := indirectInterface(v.Index(i))
                        if !ev.Type().Comparable() </span><span class="cov0" title="0">{
                                return nil, errors.New("elements in complement must be comparable")
                        }</span>
                        <span class="cov0" title="0">if _, found := aset[normalize(ev)]; !found </span><span class="cov0" title="0">{
                                sl = reflect.Append(sl, ev)
                        }</span>
                }
                <span class="cov0" title="0">return sl.Interface(), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("arguments to complement must be slices or arrays")</span>
        }
}
</pre>
		
		<pre class="file" id="file226" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "errors"
        "fmt"
        "reflect"
)

// Index returns the result of indexing its first argument by the following
// arguments. Thus "index x 1 2 3" is, in Go syntax, x[1][2][3]. Each
// indexed item must be a map, slice, or array.
//
// Copied from Go stdlib src/text/template/funcs.go.
//
// We deviate from the stdlib due to https://github.com/golang/go/issues/14751.
//
// TODO(moorereason): merge upstream changes.
func (ns *Namespace) Index(item interface{}, indices ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        v := reflect.ValueOf(item)
        if !v.IsValid() </span><span class="cov0" title="0">{
                return nil, errors.New("index of untyped nil")
        }</span>
        <span class="cov8" title="1">for _, i := range indices </span><span class="cov8" title="1">{
                index := reflect.ValueOf(i)
                var isNil bool
                if v, isNil = indirect(v); isNil </span><span class="cov0" title="0">{
                        return nil, errors.New("index of nil pointer")
                }</span>
                <span class="cov8" title="1">switch v.Kind() </span>{
                case reflect.Array, reflect.Slice, reflect.String:<span class="cov8" title="1">
                        var x int64
                        switch index.Kind() </span>{
                        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                                x = index.Int()</span>
                        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                                x = int64(index.Uint())</span>
                        case reflect.Invalid:<span class="cov0" title="0">
                                return nil, errors.New("cannot index slice/array with nil")</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("cannot index slice/array with type %s", index.Type())</span>
                        }
                        <span class="cov8" title="1">if x &lt; 0 || x &gt;= int64(v.Len()) </span><span class="cov0" title="0">{
                                // We deviate from stdlib here.  Don't return an error if the
                                // index is out of range.
                                return nil, nil
                        }</span>
                        <span class="cov8" title="1">v = v.Index(int(x))</span>
                case reflect.Map:<span class="cov0" title="0">
                        index, err := prepareArg(index, v.Type().Key())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if x := v.MapIndex(index); x.IsValid() </span><span class="cov0" title="0">{
                                v = x
                        }</span> else<span class="cov0" title="0"> {
                                v = reflect.Zero(v.Type().Elem())
                        }</span>
                case reflect.Invalid:<span class="cov0" title="0">
                        // the loop holds invariant: v.IsValid()
                        panic("unreachable")</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("can't index item of type %s", v.Type())</span>
                }
        }
        <span class="cov8" title="1">return v.Interface(), nil</span>
}

// prepareArg checks if value can be used as an argument of type argType, and
// converts an invalid value to appropriate zero if possible.
//
// Copied from Go stdlib src/text/template/funcs.go.
func prepareArg(value reflect.Value, argType reflect.Type) (reflect.Value, error) <span class="cov0" title="0">{
        if !value.IsValid() </span><span class="cov0" title="0">{
                if !canBeNil(argType) </span><span class="cov0" title="0">{
                        return reflect.Value{}, fmt.Errorf("value is nil; should be of type %s", argType)
                }</span>
                <span class="cov0" title="0">value = reflect.Zero(argType)</span>
        }
        <span class="cov0" title="0">if !value.Type().AssignableTo(argType) </span><span class="cov0" title="0">{
                return reflect.Value{}, fmt.Errorf("value has type %s; should be %s", value.Type(), argType)
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

// canBeNil reports whether an untyped nil can be assigned to the type. See reflect.Zero.
//
// Copied from Go stdlib src/text/template/exec.go.
func canBeNil(typ reflect.Type) bool <span class="cov0" title="0">{
        switch typ.Kind() </span>{
        case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file227" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "collections"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.After,
                        []string{"after"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Apply,
                        []string{"apply"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Complement,
                        []string{"complement"},
                        [][2]string{
                                {`{{ slice "a" "b" "c" "d" "e" "f" | complement (slice "b" "c") (slice "d" "e")  }}`, `[a f]`},
                        },
                )

                ns.AddMethodMapping(ctx.SymDiff,
                        []string{"symdiff"},
                        [][2]string{
                                {`{{ slice 1 2 3 | symdiff (slice 3 4) }}`, `[1 2 4]`},
                        },
                )

                ns.AddMethodMapping(ctx.Delimit,
                        []string{"delimit"},
                        [][2]string{
                                {`{{ delimit (slice "A" "B" "C") ", " " and " }}`, `A, B and C`},
                        },
                )

                ns.AddMethodMapping(ctx.Dictionary,
                        []string{"dict"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.EchoParam,
                        []string{"echoParam"},
                        [][2]string{
                                {`{{ echoParam .Params "langCode" }}`, `en`},
                        },
                )

                ns.AddMethodMapping(ctx.First,
                        []string{"first"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.KeyVals,
                        []string{"keyVals"},
                        [][2]string{
                                {`{{ keyVals "key" "a" "b" }}`, `key: [a b]`},
                        },
                )

                ns.AddMethodMapping(ctx.In,
                        []string{"in"},
                        [][2]string{
                                {`{{ if in "this string contains a substring" "substring" }}Substring found!{{ end }}`, `Substring found!`},
                        },
                )

                ns.AddMethodMapping(ctx.Index,
                        []string{"index"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Intersect,
                        []string{"intersect"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.IsSet,
                        []string{"isSet", "isset"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Last,
                        []string{"last"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Querify,
                        []string{"querify"},
                        [][2]string{
                                {
                                        `{{ (querify "foo" 1 "bar" 2 "baz" "with spaces" "qux" "this&amp;that=those") | safeHTML }}`,
                                        `bar=2&amp;baz=with+spaces&amp;foo=1&amp;qux=this%26that%3Dthose`},
                                {
                                        `&lt;a href="https://www.google.com?{{ (querify "q" "test" "page" 3) | safeURL }}"&gt;Search&lt;/a&gt;`,
                                        `&lt;a href="https://www.google.com?page=3&amp;amp;q=test"&gt;Search&lt;/a&gt;`},
                        },
                )

                ns.AddMethodMapping(ctx.Shuffle,
                        []string{"shuffle"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Slice,
                        []string{"slice"},
                        [][2]string{
                                {`{{ slice "B" "C" "A" | sort }}`, `[A B C]`},
                        },
                )

                ns.AddMethodMapping(ctx.Sort,
                        []string{"sort"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Union,
                        []string{"union"},
                        [][2]string{
                                {`{{ union (slice 1 2 3) (slice 3 4 5) }}`, `[1 2 3 4 5]`},
                        },
                )

                ns.AddMethodMapping(ctx.Where,
                        []string{"where"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Append,
                        []string{"append"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Group,
                        []string{"group"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Seq,
                        []string{"seq"},
                        [][2]string{
                                {`{{ seq 3 }}`, `[1 2 3]`},
                        },
                )

                ns.AddMethodMapping(ctx.NewScratch,
                        []string{"newScratch"},
                        [][2]string{
                                {`{{ $scratch := newScratch }}{{ $scratch.Add "b" 2 }}{{ $scratch.Add "b" 2 }}{{ $scratch.Get "b" }}`, `4`},
                        },
                )

                ns.AddMethodMapping(ctx.Uniq,
                        []string{"uniq"},
                        [][2]string{
                                {`{{ slice 1 2 3 2 | uniq }}`, `[1 2 3]`},
                        },
                )

                ns.AddMethodMapping(ctx.Merge,
                        []string{"merge"},
                        [][2]string{
                                {`{{ dict "title" "Hugo Rocks!" | collections.Merge (dict "title" "Default Title" "description" "Yes, Hugo Rocks!") | sort }}`,
                                        `[Yes, Hugo Rocks! Hugo Rocks!]`},
                                {`{{  merge (dict "title" "Default Title" "description" "Yes, Hugo Rocks!") (dict "title" "Hugo Rocks!") | sort }}`,
                                        `[Yes, Hugo Rocks! Hugo Rocks!]`},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file228" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "reflect"
        "strings"

        "github.com/gohugoio/hugo/common/hreflect"

        "github.com/pkg/errors"
)

// Merge creates a copy of dst and merges src into it.
// Currently only maps supported. Key handling is case insensitive.
func (ns *Namespace) Merge(src, dst interface{}) (interface{}, error) <span class="cov0" title="0">{

        vdst, vsrc := reflect.ValueOf(dst), reflect.ValueOf(src)

        if vdst.Kind() != reflect.Map </span><span class="cov0" title="0">{
                return nil, errors.Errorf("destination must be a map, got %T", dst)
        }</span>

        <span class="cov0" title="0">if !hreflect.IsTruthfulValue(vsrc) </span><span class="cov0" title="0">{
                return dst, nil
        }</span>

        <span class="cov0" title="0">if vsrc.Kind() != reflect.Map </span><span class="cov0" title="0">{
                return nil, errors.Errorf("source must be a map, got %T", src)
        }</span>

        <span class="cov0" title="0">if vsrc.Type() != vdst.Type() </span><span class="cov0" title="0">{
                return nil, errors.Errorf("incompatible map types, got %T to %T", src, dst)
        }</span>

        <span class="cov0" title="0">return mergeMap(vdst, vsrc).Interface(), nil</span>
}

func caseInsensitiveLookup(m, k reflect.Value) (reflect.Value, bool) <span class="cov0" title="0">{
        if m.Type().Key().Kind() != reflect.String || k.Kind() != reflect.String </span><span class="cov0" title="0">{
                // Fall back to direct lookup.
                v := m.MapIndex(k)
                return v, hreflect.IsTruthfulValue(v)
        }</span>

        <span class="cov0" title="0">for _, key := range m.MapKeys() </span><span class="cov0" title="0">{
                if strings.EqualFold(k.String(), key.String()) </span><span class="cov0" title="0">{
                        return m.MapIndex(key), true
                }</span>

        }

        <span class="cov0" title="0">return reflect.Value{}, false</span>
}

func mergeMap(dst, src reflect.Value) reflect.Value <span class="cov0" title="0">{

        out := reflect.MakeMap(dst.Type())

        // Copy the destination map.
        for _, key := range dst.MapKeys() </span><span class="cov0" title="0">{
                v := dst.MapIndex(key)
                out.SetMapIndex(key, v)
        }</span>

        // Add all keys in src not already in destination.
        // Maps of the same type will be merged.
        <span class="cov0" title="0">for _, key := range src.MapKeys() </span><span class="cov0" title="0">{
                sv := src.MapIndex(key)
                dv, found := caseInsensitiveLookup(dst, key)

                if found </span><span class="cov0" title="0">{
                        // If both are the same map type, merge.
                        dve := dv.Elem()
                        if dve.Kind() == reflect.Map </span><span class="cov0" title="0">{
                                sve := sv.Elem()
                                if dve.Type() == sve.Type() </span><span class="cov0" title="0">{
                                        out.SetMapIndex(key, mergeMap(dve, sve))
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        out.SetMapIndex(key, sv)
                }</span>
        }

        <span class="cov0" title="0">return out</span>
}
</pre>
		
		<pre class="file" id="file229" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "fmt"
        "reflect"
        "time"

        "github.com/pkg/errors"
)

var (
        zero      reflect.Value
        errorType = reflect.TypeOf((*error)(nil)).Elem()
        timeType  = reflect.TypeOf((*time.Time)(nil)).Elem()
)

func numberToFloat(v reflect.Value) (float64, error) <span class="cov0" title="0">{
        switch kind := v.Kind(); </span>{
        case isFloat(kind):<span class="cov0" title="0">
                return v.Float(), nil</span>
        case isInt(kind):<span class="cov0" title="0">
                return float64(v.Int()), nil</span>
        case isUint(kind):<span class="cov0" title="0">
                return float64(v.Uint()), nil</span>
        case kind == reflect.Interface:<span class="cov0" title="0">
                return numberToFloat(v.Elem())</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("invalid kind %s in numberToFloat", kind)</span>
        }
}

// normalizes different numeric types to make them comparable.
func normalize(v reflect.Value) interface{} <span class="cov8" title="1">{
        k := v.Kind()

        switch </span>{
        case isNumber(k):<span class="cov0" title="0">
                f, err := numberToFloat(v)
                if err == nil </span><span class="cov0" title="0">{
                        return f
                }</span>
        }

        <span class="cov8" title="1">return v.Interface()</span>
}

// collects identities from the slices in seqs into a set. Numeric values are normalized,
// pointers unwrapped.
func collectIdentities(seqs ...interface{}) (map[interface{}]bool, error) <span class="cov0" title="0">{
        seen := make(map[interface{}]bool)
        for _, seq := range seqs </span><span class="cov0" title="0">{
                v := reflect.ValueOf(seq)
                switch v.Kind() </span>{
                case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                                ev, _ := indirectInterface(v.Index(i))

                                if !ev.Type().Comparable() </span><span class="cov0" title="0">{
                                        return nil, errors.New("elements must be comparable")
                                }</span>

                                <span class="cov0" title="0">seen[normalize(ev)] = true</span>
                        }
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("arguments must be slices or arrays")</span>
                }
        }

        <span class="cov0" title="0">return seen, nil</span>
}

// We have some different numeric and string types that we try to behave like
// they were the same.
func convertValue(v reflect.Value, to reflect.Type) (reflect.Value, error) <span class="cov0" title="0">{
        if v.Type().AssignableTo(to) </span><span class="cov0" title="0">{
                return v, nil
        }</span>
        <span class="cov0" title="0">switch kind := to.Kind(); </span>{
        case kind == reflect.String:<span class="cov0" title="0">
                s, err := toString(v)
                return reflect.ValueOf(s), err</span>
        case isNumber(kind):<span class="cov0" title="0">
                return convertNumber(v, kind)</span>
        default:<span class="cov0" title="0">
                return reflect.Value{}, errors.Errorf("%s is not assignable to %s", v.Type(), to)</span>
        }
}

// There are potential overflows in this function, but the downconversion of
// int64 etc. into int8 etc. is coming from the synthetic unit tests for Union etc.
// TODO(bep) We should consider normalizing the slices to int64 etc.
func convertNumber(v reflect.Value, to reflect.Kind) (reflect.Value, error) <span class="cov0" title="0">{
        var n reflect.Value
        if isFloat(to) </span><span class="cov0" title="0">{
                f, err := toFloat(v)
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
                <span class="cov0" title="0">switch to </span>{
                case reflect.Float32:<span class="cov0" title="0">
                        n = reflect.ValueOf(float32(f))</span>
                default:<span class="cov0" title="0">
                        n = reflect.ValueOf(float64(f))</span>
                }
        } else<span class="cov0" title="0"> if isInt(to) </span><span class="cov0" title="0">{
                i, err := toInt(v)
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
                <span class="cov0" title="0">switch to </span>{
                case reflect.Int:<span class="cov0" title="0">
                        n = reflect.ValueOf(int(i))</span>
                case reflect.Int8:<span class="cov0" title="0">
                        n = reflect.ValueOf(int8(i))</span>
                case reflect.Int16:<span class="cov0" title="0">
                        n = reflect.ValueOf(int16(i))</span>
                case reflect.Int32:<span class="cov0" title="0">
                        n = reflect.ValueOf(int32(i))</span>
                case reflect.Int64:<span class="cov0" title="0">
                        n = reflect.ValueOf(int64(i))</span>
                }
        } else<span class="cov0" title="0"> if isUint(to) </span><span class="cov0" title="0">{
                i, err := toUint(v)
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
                <span class="cov0" title="0">switch to </span>{
                case reflect.Uint:<span class="cov0" title="0">
                        n = reflect.ValueOf(uint(i))</span>
                case reflect.Uint8:<span class="cov0" title="0">
                        n = reflect.ValueOf(uint8(i))</span>
                case reflect.Uint16:<span class="cov0" title="0">
                        n = reflect.ValueOf(uint16(i))</span>
                case reflect.Uint32:<span class="cov0" title="0">
                        n = reflect.ValueOf(uint32(i))</span>
                case reflect.Uint64:<span class="cov0" title="0">
                        n = reflect.ValueOf(uint64(i))</span>
                }

        }

        <span class="cov0" title="0">if !n.IsValid() </span><span class="cov0" title="0">{
                return n, errors.New("invalid values")
        }</span>

        <span class="cov0" title="0">return n, nil</span>

}

func newSliceElement(items interface{}) interface{} <span class="cov0" title="0">{
        tp := reflect.TypeOf(items)
        if tp == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">switch tp.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                tp = tp.Elem()
                if tp.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        tp = tp.Elem()
                }</span>

                <span class="cov0" title="0">return reflect.New(tp).Interface()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func isNumber(kind reflect.Kind) bool <span class="cov8" title="1">{
        return isInt(kind) || isUint(kind) || isFloat(kind)
}</span>

func isInt(kind reflect.Kind) bool <span class="cov8" title="1">{
        switch kind </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func isUint(kind reflect.Kind) bool <span class="cov8" title="1">{
        switch kind </span>{
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func isFloat(kind reflect.Kind) bool <span class="cov8" title="1">{
        switch kind </span>{
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file230" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "errors"
        "reflect"
        "sort"
        "strings"

        "github.com/gohugoio/hugo/tpl/compare"
        "github.com/spf13/cast"
)

var sortComp = compare.New(true)

// Sort returns a sorted sequence.
func (ns *Namespace) Sort(seq interface{}, args ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        if seq == nil </span><span class="cov0" title="0">{
                return nil, errors.New("sequence must be provided")
        }</span>

        <span class="cov0" title="0">seqv, isNil := indirect(reflect.ValueOf(seq))
        if isNil </span><span class="cov0" title="0">{
                return nil, errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov0" title="0">var sliceType reflect.Type
        switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                sliceType = seqv.Type()</span>
        case reflect.Map:<span class="cov0" title="0">
                sliceType = reflect.SliceOf(seqv.Type().Elem())</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("can't sort " + reflect.ValueOf(seq).Type().String())</span>
        }

        // Create a list of pairs that will be used to do the sort
        <span class="cov0" title="0">p := pairList{SortAsc: true, SliceType: sliceType}
        p.Pairs = make([]pair, seqv.Len())

        var sortByField string
        for i, l := range args </span><span class="cov0" title="0">{
                dStr, err := cast.ToStringE(l)
                switch </span>{
                case i == 0 &amp;&amp; err != nil:<span class="cov0" title="0">
                        sortByField = ""</span>
                case i == 0 &amp;&amp; err == nil:<span class="cov0" title="0">
                        sortByField = dStr</span>
                case i == 1 &amp;&amp; err == nil &amp;&amp; dStr == "desc":<span class="cov0" title="0">
                        p.SortAsc = false</span>
                case i == 1:<span class="cov0" title="0">
                        p.SortAsc = true</span>
                }
        }
        <span class="cov0" title="0">path := strings.Split(strings.Trim(sortByField, "."), ".")

        switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                for i := 0; i &lt; seqv.Len(); i++ </span><span class="cov0" title="0">{
                        p.Pairs[i].Value = seqv.Index(i)
                        if sortByField == "" || sortByField == "value" </span><span class="cov0" title="0">{
                                p.Pairs[i].Key = p.Pairs[i].Value
                        }</span> else<span class="cov0" title="0"> {
                                v := p.Pairs[i].Value
                                var err error
                                for _, elemName := range path </span><span class="cov0" title="0">{
                                        v, err = evaluateSubElem(v, elemName)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                }
                                <span class="cov0" title="0">p.Pairs[i].Key = v</span>
                        }
                }

        case reflect.Map:<span class="cov0" title="0">
                keys := seqv.MapKeys()
                for i := 0; i &lt; seqv.Len(); i++ </span><span class="cov0" title="0">{
                        p.Pairs[i].Value = seqv.MapIndex(keys[i])
                        if sortByField == "" </span><span class="cov0" title="0">{
                                p.Pairs[i].Key = keys[i]
                        }</span> else<span class="cov0" title="0"> if sortByField == "value" </span><span class="cov0" title="0">{
                                p.Pairs[i].Key = p.Pairs[i].Value
                        }</span> else<span class="cov0" title="0"> {
                                v := p.Pairs[i].Value
                                var err error
                                for _, elemName := range path </span><span class="cov0" title="0">{
                                        v, err = evaluateSubElem(v, elemName)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                }
                                <span class="cov0" title="0">p.Pairs[i].Key = v</span>
                        }
                }
        }
        <span class="cov0" title="0">return p.sort(), nil</span>
}

// Credit for pair sorting method goes to Andrew Gerrand
// https://groups.google.com/forum/#!topic/golang-nuts/FT7cjmcL7gw
// A data structure to hold a key/value pair.
type pair struct {
        Key   reflect.Value
        Value reflect.Value
}

// A slice of pairs that implements sort.Interface to sort by Value.
type pairList struct {
        Pairs     []pair
        SortAsc   bool
        SliceType reflect.Type
}

func (p pairList) Swap(i, j int) <span class="cov0" title="0">{ p.Pairs[i], p.Pairs[j] = p.Pairs[j], p.Pairs[i] }</span>
func (p pairList) Len() int      <span class="cov0" title="0">{ return len(p.Pairs) }</span>
func (p pairList) Less(i, j int) bool <span class="cov0" title="0">{
        iv := p.Pairs[i].Key
        jv := p.Pairs[j].Key

        if iv.IsValid() </span><span class="cov0" title="0">{
                if jv.IsValid() </span><span class="cov0" title="0">{
                        // can only call Interface() on valid reflect Values
                        return sortComp.Lt(iv.Interface(), jv.Interface())
                }</span>
                // if j is invalid, test i against i's zero value
                <span class="cov0" title="0">return sortComp.Lt(iv.Interface(), reflect.Zero(iv.Type()))</span>
        }

        <span class="cov0" title="0">if jv.IsValid() </span><span class="cov0" title="0">{
                // if i is invalid, test j against j's zero value
                return sortComp.Lt(reflect.Zero(jv.Type()), jv.Interface())
        }</span>

        <span class="cov0" title="0">return false</span>
}

// sorts a pairList and returns a slice of sorted values
func (p pairList) sort() interface{} <span class="cov0" title="0">{
        if p.SortAsc </span><span class="cov0" title="0">{
                sort.Sort(p)
        }</span> else<span class="cov0" title="0"> {
                sort.Sort(sort.Reverse(p))
        }</span>
        <span class="cov0" title="0">sorted := reflect.MakeSlice(p.SliceType, len(p.Pairs), len(p.Pairs))
        for i, v := range p.Pairs </span><span class="cov0" title="0">{
                sorted.Index(i).Set(v.Value)
        }</span>

        <span class="cov0" title="0">return sorted.Interface()</span>
}
</pre>
		
		<pre class="file" id="file231" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "fmt"
        "reflect"

        "github.com/pkg/errors"
)

// SymDiff returns the symmetric difference of s1 and s2.
// Arguments must be either a slice or an array of comparable types.
func (ns *Namespace) SymDiff(s2, s1 interface{}) (interface{}, error) <span class="cov0" title="0">{
        ids1, err := collectIdentities(s1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ids2, err := collectIdentities(s2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var slice reflect.Value
        var sliceElemType reflect.Type

        for i, s := range []interface{}{s1, s2} </span><span class="cov0" title="0">{
                v := reflect.ValueOf(s)

                switch v.Kind() </span>{
                case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                        if i == 0 </span><span class="cov0" title="0">{
                                sliceType := v.Type()
                                sliceElemType = sliceType.Elem()
                                slice = reflect.MakeSlice(sliceType, 0, 0)
                        }</span>

                        <span class="cov0" title="0">for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                                ev, _ := indirectInterface(v.Index(i))
                                if !ev.Type().Comparable() </span><span class="cov0" title="0">{
                                        return nil, errors.New("symdiff: elements must be comparable")
                                }</span>
                                <span class="cov0" title="0">key := normalize(ev)
                                // Append if the key is not in their intersection.
                                if ids1[key] != ids2[key] </span><span class="cov0" title="0">{
                                        v, err := convertValue(ev, sliceElemType)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, errors.WithMessage(err, "symdiff: failed to convert value")
                                        }</span>
                                        <span class="cov0" title="0">slice = reflect.Append(slice, v)</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("arguments to symdiff must be slices or arrays")</span>
                }
        }

        <span class="cov0" title="0">return slice.Interface(), nil</span>

}
</pre>
		
		<pre class="file" id="file232" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "errors"
        "fmt"
        "reflect"
        "strings"
)

// Where returns a filtered subset of a given data type.
func (ns *Namespace) Where(seq, key interface{}, args ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        seqv, isNil := indirect(reflect.ValueOf(seq))
        if isNil </span><span class="cov0" title="0">{
                return nil, errors.New("can't iterate over a nil value of type " + reflect.ValueOf(seq).Type().String())
        }</span>

        <span class="cov8" title="1">mv, op, err := parseWhereArgs(args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var path []string
        kv := reflect.ValueOf(key)
        if kv.Kind() == reflect.String </span><span class="cov8" title="1">{
                path = strings.Split(strings.Trim(kv.String(), "."), ".")
        }</span>

        <span class="cov8" title="1">switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                return ns.checkWhereArray(seqv, kv, mv, path, op)</span>
        case reflect.Map:<span class="cov0" title="0">
                return ns.checkWhereMap(seqv, kv, mv, path, op)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("can't iterate over %v", seq)</span>
        }
}

func (ns *Namespace) checkCondition(v, mv reflect.Value, op string) (bool, error) <span class="cov8" title="1">{
        v, vIsNil := indirect(v)
        if !v.IsValid() </span><span class="cov0" title="0">{
                vIsNil = true
        }</span>

        <span class="cov8" title="1">mv, mvIsNil := indirect(mv)
        if !mv.IsValid() </span><span class="cov0" title="0">{
                mvIsNil = true
        }</span>
        <span class="cov8" title="1">if vIsNil || mvIsNil </span><span class="cov0" title="0">{
                switch op </span>{
                case "", "=", "==", "eq":<span class="cov0" title="0">
                        return vIsNil == mvIsNil, nil</span>
                case "!=", "&lt;&gt;", "ne":<span class="cov0" title="0">
                        return vIsNil != mvIsNil, nil</span>
                }
                <span class="cov0" title="0">return false, nil</span>
        }

        <span class="cov8" title="1">if v.Kind() == reflect.Bool &amp;&amp; mv.Kind() == reflect.Bool </span><span class="cov0" title="0">{
                switch op </span>{
                case "", "=", "==", "eq":<span class="cov0" title="0">
                        return v.Bool() == mv.Bool(), nil</span>
                case "!=", "&lt;&gt;", "ne":<span class="cov0" title="0">
                        return v.Bool() != mv.Bool(), nil</span>
                }
                <span class="cov0" title="0">return false, nil</span>
        }

        <span class="cov8" title="1">var ivp, imvp *int64
        var fvp, fmvp *float64
        var svp, smvp *string
        var slv, slmv interface{}
        var ima []int64
        var fma []float64
        var sma []string
        if mv.Type() == v.Type() </span><span class="cov0" title="0">{
                switch v.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                        iv := v.Int()
                        ivp = &amp;iv
                        imv := mv.Int()
                        imvp = &amp;imv</span>
                case reflect.String:<span class="cov0" title="0">
                        sv := v.String()
                        svp = &amp;sv
                        smv := mv.String()
                        smvp = &amp;smv</span>
                case reflect.Float64:<span class="cov0" title="0">
                        fv := v.Float()
                        fvp = &amp;fv
                        fmv := mv.Float()
                        fmvp = &amp;fmv</span>
                case reflect.Struct:<span class="cov0" title="0">
                        switch v.Type() </span>{
                        case timeType:<span class="cov0" title="0">
                                iv := toTimeUnix(v)
                                ivp = &amp;iv
                                imv := toTimeUnix(mv)
                                imvp = &amp;imv</span>
                        }
                case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                        slv = v.Interface()
                        slmv = mv.Interface()</span>
                }
        } else<span class="cov8" title="1"> if isNumber(v.Kind()) &amp;&amp; isNumber(mv.Kind()) </span><span class="cov0" title="0">{
                fv, err := toFloat(v)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">fvp = &amp;fv
                fmv, err := toFloat(mv)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">fmvp = &amp;fmv</span>
        } else<span class="cov8" title="1"> {
                if mv.Kind() != reflect.Array &amp;&amp; mv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">if mv.Len() == 0 </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">if v.Kind() != reflect.Interface &amp;&amp; mv.Type().Elem().Kind() != reflect.Interface &amp;&amp; mv.Type().Elem() != v.Type() &amp;&amp; v.Kind() != reflect.Array &amp;&amp; v.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">switch v.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                        iv := v.Int()
                        ivp = &amp;iv
                        for i := 0; i &lt; mv.Len(); i++ </span><span class="cov0" title="0">{
                                if anInt, err := toInt(mv.Index(i)); err == nil </span><span class="cov0" title="0">{
                                        ima = append(ima, anInt)
                                }</span>
                        }
                case reflect.String:<span class="cov8" title="1">
                        sv := v.String()
                        svp = &amp;sv
                        for i := 0; i &lt; mv.Len(); i++ </span><span class="cov8" title="1">{
                                if aString, err := toString(mv.Index(i)); err == nil </span><span class="cov8" title="1">{
                                        sma = append(sma, aString)
                                }</span>
                        }
                case reflect.Float64:<span class="cov0" title="0">
                        fv := v.Float()
                        fvp = &amp;fv
                        for i := 0; i &lt; mv.Len(); i++ </span><span class="cov0" title="0">{
                                if aFloat, err := toFloat(mv.Index(i)); err == nil </span><span class="cov0" title="0">{
                                        fma = append(fma, aFloat)
                                }</span>
                        }
                case reflect.Struct:<span class="cov0" title="0">
                        switch v.Type() </span>{
                        case timeType:<span class="cov0" title="0">
                                iv := toTimeUnix(v)
                                ivp = &amp;iv
                                for i := 0; i &lt; mv.Len(); i++ </span><span class="cov0" title="0">{
                                        ima = append(ima, toTimeUnix(mv.Index(i)))
                                }</span>
                        }
                case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                        slv = v.Interface()
                        slmv = mv.Interface()</span>
                }
        }

        <span class="cov8" title="1">switch op </span>{
        case "", "=", "==", "eq":<span class="cov0" title="0">
                switch </span>{
                case ivp != nil &amp;&amp; imvp != nil:<span class="cov0" title="0">
                        return *ivp == *imvp, nil</span>
                case svp != nil &amp;&amp; smvp != nil:<span class="cov0" title="0">
                        return *svp == *smvp, nil</span>
                case fvp != nil &amp;&amp; fmvp != nil:<span class="cov0" title="0">
                        return *fvp == *fmvp, nil</span>
                }
        case "!=", "&lt;&gt;", "ne":<span class="cov0" title="0">
                switch </span>{
                case ivp != nil &amp;&amp; imvp != nil:<span class="cov0" title="0">
                        return *ivp != *imvp, nil</span>
                case svp != nil &amp;&amp; smvp != nil:<span class="cov0" title="0">
                        return *svp != *smvp, nil</span>
                case fvp != nil &amp;&amp; fmvp != nil:<span class="cov0" title="0">
                        return *fvp != *fmvp, nil</span>
                }
        case "&gt;=", "ge":<span class="cov0" title="0">
                switch </span>{
                case ivp != nil &amp;&amp; imvp != nil:<span class="cov0" title="0">
                        return *ivp &gt;= *imvp, nil</span>
                case svp != nil &amp;&amp; smvp != nil:<span class="cov0" title="0">
                        return *svp &gt;= *smvp, nil</span>
                case fvp != nil &amp;&amp; fmvp != nil:<span class="cov0" title="0">
                        return *fvp &gt;= *fmvp, nil</span>
                }
        case "&gt;", "gt":<span class="cov0" title="0">
                switch </span>{
                case ivp != nil &amp;&amp; imvp != nil:<span class="cov0" title="0">
                        return *ivp &gt; *imvp, nil</span>
                case svp != nil &amp;&amp; smvp != nil:<span class="cov0" title="0">
                        return *svp &gt; *smvp, nil</span>
                case fvp != nil &amp;&amp; fmvp != nil:<span class="cov0" title="0">
                        return *fvp &gt; *fmvp, nil</span>
                }
        case "&lt;=", "le":<span class="cov0" title="0">
                switch </span>{
                case ivp != nil &amp;&amp; imvp != nil:<span class="cov0" title="0">
                        return *ivp &lt;= *imvp, nil</span>
                case svp != nil &amp;&amp; smvp != nil:<span class="cov0" title="0">
                        return *svp &lt;= *smvp, nil</span>
                case fvp != nil &amp;&amp; fmvp != nil:<span class="cov0" title="0">
                        return *fvp &lt;= *fmvp, nil</span>
                }
        case "&lt;", "lt":<span class="cov0" title="0">
                switch </span>{
                case ivp != nil &amp;&amp; imvp != nil:<span class="cov0" title="0">
                        return *ivp &lt; *imvp, nil</span>
                case svp != nil &amp;&amp; smvp != nil:<span class="cov0" title="0">
                        return *svp &lt; *smvp, nil</span>
                case fvp != nil &amp;&amp; fmvp != nil:<span class="cov0" title="0">
                        return *fvp &lt; *fmvp, nil</span>
                }
        case "in", "not in":<span class="cov8" title="1">
                var r bool
                switch </span>{
                case ivp != nil &amp;&amp; len(ima) &gt; 0:<span class="cov0" title="0">
                        r, _ = ns.In(ima, *ivp)</span>
                case fvp != nil &amp;&amp; len(fma) &gt; 0:<span class="cov0" title="0">
                        r, _ = ns.In(fma, *fvp)</span>
                case svp != nil:<span class="cov8" title="1">
                        if len(sma) &gt; 0 </span><span class="cov8" title="1">{
                                r, _ = ns.In(sma, *svp)
                        }</span> else<span class="cov0" title="0"> if smvp != nil </span><span class="cov0" title="0">{
                                r, _ = ns.In(*smvp, *svp)
                        }</span>
                default:<span class="cov0" title="0">
                        return false, nil</span>
                }
                <span class="cov8" title="1">if op == "not in" </span><span class="cov0" title="0">{
                        return !r, nil
                }</span>
                <span class="cov8" title="1">return r, nil</span>
        case "intersect":<span class="cov0" title="0">
                r, err := ns.Intersect(slv, slmv)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">if reflect.TypeOf(r).Kind() == reflect.Slice </span><span class="cov0" title="0">{
                        s := reflect.ValueOf(r)

                        if s.Len() &gt; 0 </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                        <span class="cov0" title="0">return false, nil</span>
                }
                <span class="cov0" title="0">return false, errors.New("invalid intersect values")</span>
        default:<span class="cov0" title="0">
                return false, errors.New("no such operator")</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func evaluateSubElem(obj reflect.Value, elemName string) (reflect.Value, error) <span class="cov8" title="1">{
        if !obj.IsValid() </span><span class="cov0" title="0">{
                return zero, errors.New("can't evaluate an invalid value")
        }</span>
        <span class="cov8" title="1">typ := obj.Type()
        obj, isNil := indirect(obj)

        if obj.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                // If obj is an interface, we need to inspect the value it contains
                // to see the full set of methods and fields.
                // Indirect returns the value that it points to, which is what's needed
                // below to be able to reflect on its fields.
                obj = reflect.Indirect(obj.Elem())
        }</span>

        // first, check whether obj has a method. In this case, obj is
        // a struct or its pointer. If obj is a struct,
        // to check all T and *T method, use obj pointer type Value
        <span class="cov8" title="1">objPtr := obj
        if objPtr.Kind() != reflect.Interface &amp;&amp; objPtr.CanAddr() </span><span class="cov8" title="1">{
                objPtr = objPtr.Addr()
        }</span>
        <span class="cov8" title="1">mt, ok := objPtr.Type().MethodByName(elemName)
        if ok </span><span class="cov8" title="1">{
                switch </span>{
                case mt.PkgPath != "":<span class="cov0" title="0">
                        return zero, fmt.Errorf("%s is an unexported method of type %s", elemName, typ)</span>
                case mt.Type.NumIn() &gt; 1:<span class="cov0" title="0">
                        return zero, fmt.Errorf("%s is a method of type %s but requires more than 1 parameter", elemName, typ)</span>
                case mt.Type.NumOut() == 0:<span class="cov0" title="0">
                        return zero, fmt.Errorf("%s is a method of type %s but returns no output", elemName, typ)</span>
                case mt.Type.NumOut() &gt; 2:<span class="cov0" title="0">
                        return zero, fmt.Errorf("%s is a method of type %s but returns more than 2 outputs", elemName, typ)</span>
                case mt.Type.NumOut() == 1 &amp;&amp; mt.Type.Out(0).Implements(errorType):<span class="cov0" title="0">
                        return zero, fmt.Errorf("%s is a method of type %s but only returns an error type", elemName, typ)</span>
                case mt.Type.NumOut() == 2 &amp;&amp; !mt.Type.Out(1).Implements(errorType):<span class="cov0" title="0">
                        return zero, fmt.Errorf("%s is a method of type %s returning two values but the second value is not an error type", elemName, typ)</span>
                }
                <span class="cov8" title="1">res := objPtr.Method(mt.Index).Call([]reflect.Value{})
                if len(res) == 2 &amp;&amp; !res[1].IsNil() </span><span class="cov0" title="0">{
                        return zero, fmt.Errorf("error at calling a method %s of type %s: %s", elemName, typ, res[1].Interface().(error))
                }</span>
                <span class="cov8" title="1">return res[0], nil</span>
        }

        // elemName isn't a method so next start to check whether it is
        // a struct field or a map value. In both cases, it mustn't be
        // a nil value
        <span class="cov0" title="0">if isNil </span><span class="cov0" title="0">{
                return zero, fmt.Errorf("can't evaluate a nil pointer of type %s by a struct field or map key name %s", typ, elemName)
        }</span>
        <span class="cov0" title="0">switch obj.Kind() </span>{
        case reflect.Struct:<span class="cov0" title="0">
                ft, ok := obj.Type().FieldByName(elemName)
                if ok </span><span class="cov0" title="0">{
                        if ft.PkgPath != "" &amp;&amp; !ft.Anonymous </span><span class="cov0" title="0">{
                                return zero, fmt.Errorf("%s is an unexported field of struct type %s", elemName, typ)
                        }</span>
                        <span class="cov0" title="0">return obj.FieldByIndex(ft.Index), nil</span>
                }
                <span class="cov0" title="0">return zero, fmt.Errorf("%s isn't a field of struct type %s", elemName, typ)</span>
        case reflect.Map:<span class="cov0" title="0">
                kv := reflect.ValueOf(elemName)
                if kv.Type().AssignableTo(obj.Type().Key()) </span><span class="cov0" title="0">{
                        return obj.MapIndex(kv), nil
                }</span>
                <span class="cov0" title="0">return zero, fmt.Errorf("%s isn't a key of map type %s", elemName, typ)</span>
        }
        <span class="cov0" title="0">return zero, fmt.Errorf("%s is neither a struct field, a method nor a map element of type %s", elemName, typ)</span>
}

// parseWhereArgs parses the end arguments to the where function.  Return a
// match value and an operator, if one is defined.
func parseWhereArgs(args ...interface{}) (mv reflect.Value, op string, err error) <span class="cov8" title="1">{
        switch len(args) </span>{
        case 1:<span class="cov0" title="0">
                mv = reflect.ValueOf(args[0])</span>
        case 2:<span class="cov8" title="1">
                var ok bool
                if op, ok = args[0].(string); !ok </span><span class="cov0" title="0">{
                        err = errors.New("operator argument must be string type")
                        return
                }</span>
                <span class="cov8" title="1">op = strings.TrimSpace(strings.ToLower(op))
                mv = reflect.ValueOf(args[1])</span>
        default:<span class="cov0" title="0">
                err = errors.New("can't evaluate the array by no match argument or more than or equal to two arguments")</span>
        }
        <span class="cov8" title="1">return</span>
}

// checkWhereArray handles the where-matching logic when the seqv value is an
// Array or Slice.
func (ns *Namespace) checkWhereArray(seqv, kv, mv reflect.Value, path []string, op string) (interface{}, error) <span class="cov8" title="1">{
        rv := reflect.MakeSlice(seqv.Type(), 0, 0)
        for i := 0; i &lt; seqv.Len(); i++ </span><span class="cov8" title="1">{
                var vvv reflect.Value
                rvv := seqv.Index(i)
                if kv.Kind() == reflect.String </span><span class="cov8" title="1">{
                        vvv = rvv
                        for _, elemName := range path </span><span class="cov8" title="1">{
                                var err error
                                vvv, err = evaluateSubElem(vvv, elemName)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        vv, _ := indirect(rvv)
                        if vv.Kind() == reflect.Map &amp;&amp; kv.Type().AssignableTo(vv.Type().Key()) </span><span class="cov0" title="0">{
                                vvv = vv.MapIndex(kv)
                        }</span>
                }

                <span class="cov8" title="1">if ok, err := ns.checkCondition(vvv, mv, op); ok </span><span class="cov8" title="1">{
                        rv = reflect.Append(rv, rvv)
                }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return rv.Interface(), nil</span>
}

// checkWhereMap handles the where-matching logic when the seqv value is a Map.
func (ns *Namespace) checkWhereMap(seqv, kv, mv reflect.Value, path []string, op string) (interface{}, error) <span class="cov0" title="0">{
        rv := reflect.MakeMap(seqv.Type())
        keys := seqv.MapKeys()
        for _, k := range keys </span><span class="cov0" title="0">{
                elemv := seqv.MapIndex(k)
                switch elemv.Kind() </span>{
                case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                        r, err := ns.checkWhereArray(elemv, kv, mv, path, op)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">switch rr := reflect.ValueOf(r); rr.Kind() </span>{
                        case reflect.Slice:<span class="cov0" title="0">
                                if rr.Len() &gt; 0 </span><span class="cov0" title="0">{
                                        rv.SetMapIndex(k, elemv)
                                }</span>
                        }
                case reflect.Interface:<span class="cov0" title="0">
                        elemvv, isNil := indirect(elemv)
                        if isNil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">switch elemvv.Kind() </span>{
                        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                                r, err := ns.checkWhereArray(elemvv, kv, mv, path, op)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov0" title="0">switch rr := reflect.ValueOf(r); rr.Kind() </span>{
                                case reflect.Slice:<span class="cov0" title="0">
                                        if rr.Len() &gt; 0 </span><span class="cov0" title="0">{
                                                rv.SetMapIndex(k, elemv)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return rv.Interface(), nil</span>
}

// toFloat returns the float value if possible.
func toFloat(v reflect.Value) (float64, error) <span class="cov0" title="0">{
        switch v.Kind() </span>{
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return v.Float(), nil</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return v.Convert(reflect.TypeOf(float64(0))).Float(), nil</span>
        case reflect.Interface:<span class="cov0" title="0">
                return toFloat(v.Elem())</span>
        }
        <span class="cov0" title="0">return -1, errors.New("unable to convert value to float")</span>
}

// toInt returns the int value if possible, -1 if not.
// TODO(bep) consolidate all these reflect funcs.
func toInt(v reflect.Value) (int64, error) <span class="cov0" title="0">{
        switch v.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return v.Int(), nil</span>
        case reflect.Interface:<span class="cov0" title="0">
                return toInt(v.Elem())</span>
        }
        <span class="cov0" title="0">return -1, errors.New("unable to convert value to int")</span>
}

func toUint(v reflect.Value) (uint64, error) <span class="cov0" title="0">{
        switch v.Kind() </span>{
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return v.Uint(), nil</span>
        case reflect.Interface:<span class="cov0" title="0">
                return toUint(v.Elem())</span>
        }
        <span class="cov0" title="0">return 0, errors.New("unable to convert value to uint")</span>
}

// toString returns the string value if possible, "" if not.
func toString(v reflect.Value) (string, error) <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                return v.String(), nil</span>
        case reflect.Interface:<span class="cov0" title="0">
                return toString(v.Elem())</span>
        }
        <span class="cov0" title="0">return "", errors.New("unable to convert value to string")</span>
}

func toTimeUnix(v reflect.Value) int64 <span class="cov0" title="0">{
        if v.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                return toTimeUnix(v.Elem())
        }</span>
        <span class="cov0" title="0">if v.Type() != timeType </span><span class="cov0" title="0">{
                panic("coding error: argument must be time.Time type reflect Value")</span>
        }
        <span class="cov0" title="0">return v.MethodByName("Unix").Call([]reflect.Value{})[0].Int()</span>
}
</pre>
		
		<pre class="file" id="file233" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package compare provides template functions for comparing values.
package compare

import (
        "fmt"
        "reflect"
        "strconv"
        "time"

        "github.com/gohugoio/hugo/compare"

        "github.com/gohugoio/hugo/common/types"
)

// New returns a new instance of the compare-namespaced template functions.
func New(caseInsensitive bool) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{caseInsensitive: caseInsensitive}
}</span>

// Namespace provides template functions for the "compare" namespace.
type Namespace struct {
        // Enable to do case insensitive string compares.
        caseInsensitive bool
}

// Default checks whether a given value is set and returns a default value if it
// is not.  "Set" in this context means non-zero for numeric types and times;
// non-zero length for strings, arrays, slices, and maps;
// any boolean or struct value; or non-nil for any other types.
func (*Namespace) Default(dflt interface{}, given ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        // given is variadic because the following construct will not pass a piped
        // argument when the key is missing:  {{ index . "key" | default "foo" }}
        // The Go template will complain that we got 1 argument when we expectd 2.

        if len(given) == 0 </span><span class="cov0" title="0">{
                return dflt, nil
        }</span>
        <span class="cov8" title="1">if len(given) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wrong number of args for default: want 2 got %d", len(given)+1)
        }</span>

        <span class="cov8" title="1">g := reflect.ValueOf(given[0])
        if !g.IsValid() </span><span class="cov8" title="1">{
                return dflt, nil
        }</span>

        <span class="cov8" title="1">set := false

        switch g.Kind() </span>{
        case reflect.Bool:<span class="cov0" title="0">
                set = true</span>
        case reflect.String, reflect.Array, reflect.Slice, reflect.Map:<span class="cov8" title="1">
                set = g.Len() != 0</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                set = g.Int() != 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                set = g.Uint() != 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                set = g.Float() != 0</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov0" title="0">
                set = g.Complex() != 0</span>
        case reflect.Struct:<span class="cov0" title="0">
                switch actual := given[0].(type) </span>{
                case time.Time:<span class="cov0" title="0">
                        set = !actual.IsZero()</span>
                default:<span class="cov0" title="0">
                        set = true</span>
                }
        default:<span class="cov0" title="0">
                set = !g.IsNil()</span>
        }

        <span class="cov8" title="1">if set </span><span class="cov8" title="1">{
                return given[0], nil
        }</span>

        <span class="cov0" title="0">return dflt, nil</span>
}

// Eq returns the boolean truth of arg1 == arg2 || arg1 == arg3 || arg1 == arg4.
func (n *Namespace) Eq(first interface{}, others ...interface{}) bool <span class="cov8" title="1">{
        if n.caseInsensitive </span><span class="cov0" title="0">{
                panic("caseInsensitive not implemented for Eq")</span>
        }
        <span class="cov8" title="1">if len(others) == 0 </span><span class="cov0" title="0">{
                panic("missing arguments for comparison")</span>
        }

        <span class="cov8" title="1">normalize := func(v interface{}) interface{} </span><span class="cov8" title="1">{
                if types.IsNil(v) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">vv := reflect.ValueOf(v)
                switch vv.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                        return vv.Int()</span>
                case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                        return vv.Float()</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                        return vv.Uint()</span>
                default:<span class="cov8" title="1">
                        return v</span>
                }
        }

        <span class="cov8" title="1">normFirst := normalize(first)
        for _, other := range others </span><span class="cov8" title="1">{
                if e, ok := first.(compare.Eqer); ok </span><span class="cov0" title="0">{
                        return e.Eq(other)
                }</span>

                <span class="cov8" title="1">if e, ok := other.(compare.Eqer); ok </span><span class="cov0" title="0">{
                        return e.Eq(first)
                }</span>

                <span class="cov8" title="1">other = normalize(other)
                if reflect.DeepEqual(normFirst, other) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// Ne returns the boolean truth of arg1 != arg2.
func (n *Namespace) Ne(x, y interface{}) bool <span class="cov8" title="1">{
        return !n.Eq(x, y)
}</span>

// Ge returns the boolean truth of arg1 &gt;= arg2.
func (n *Namespace) Ge(a, b interface{}) bool <span class="cov8" title="1">{
        left, right := n.compareGet(a, b)
        return left &gt;= right
}</span>

// Gt returns the boolean truth of arg1 &gt; arg2.
func (n *Namespace) Gt(a, b interface{}) bool <span class="cov8" title="1">{
        left, right := n.compareGet(a, b)
        return left &gt; right
}</span>

// Le returns the boolean truth of arg1 &lt;= arg2.
func (n *Namespace) Le(a, b interface{}) bool <span class="cov0" title="0">{
        left, right := n.compareGet(a, b)
        return left &lt;= right
}</span>

// Lt returns the boolean truth of arg1 &lt; arg2.
func (n *Namespace) Lt(a, b interface{}) bool <span class="cov0" title="0">{
        left, right := n.compareGet(a, b)
        return left &lt; right
}</span>

// Conditional can be used as a ternary operator.
// It returns a if condition, else b.
func (n *Namespace) Conditional(condition bool, a, b interface{}) interface{} <span class="cov8" title="1">{
        if condition </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (ns *Namespace) compareGet(a interface{}, b interface{}) (float64, float64) <span class="cov8" title="1">{
        if ac, ok := a.(compare.Comparer); ok </span><span class="cov0" title="0">{
                c := ac.Compare(b)
                if c &lt; 0 </span><span class="cov0" title="0">{
                        return 1, 0
                }</span> else<span class="cov0" title="0"> if c == 0 </span><span class="cov0" title="0">{
                        return 0, 0
                }</span> else<span class="cov0" title="0"> {
                        return 0, 1
                }</span>
        }

        <span class="cov8" title="1">if bc, ok := b.(compare.Comparer); ok </span><span class="cov0" title="0">{
                c := bc.Compare(a)
                if c &lt; 0 </span><span class="cov0" title="0">{
                        return 0, 1
                }</span> else<span class="cov0" title="0"> if c == 0 </span><span class="cov0" title="0">{
                        return 0, 0
                }</span> else<span class="cov0" title="0"> {
                        return 1, 0
                }</span>
        }

        <span class="cov8" title="1">var left, right float64
        var leftStr, rightStr *string
        av := reflect.ValueOf(a)

        switch av.Kind() </span>{
        case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:<span class="cov0" title="0">
                left = float64(av.Len())</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                left = float64(av.Int())</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                left = av.Float()</span>
        case reflect.String:<span class="cov0" title="0">
                var err error
                left, err = strconv.ParseFloat(av.String(), 64)
                if err != nil </span><span class="cov0" title="0">{
                        str := av.String()
                        leftStr = &amp;str
                }</span>
        case reflect.Struct:<span class="cov0" title="0">
                switch av.Type() </span>{
                case timeType:<span class="cov0" title="0">
                        left = float64(toTimeUnix(av))</span>
                }
        }

        <span class="cov8" title="1">bv := reflect.ValueOf(b)

        switch bv.Kind() </span>{
        case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:<span class="cov0" title="0">
                right = float64(bv.Len())</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                right = float64(bv.Int())</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                right = bv.Float()</span>
        case reflect.String:<span class="cov0" title="0">
                var err error
                right, err = strconv.ParseFloat(bv.String(), 64)
                if err != nil </span><span class="cov0" title="0">{
                        str := bv.String()
                        rightStr = &amp;str
                }</span>
        case reflect.Struct:<span class="cov0" title="0">
                switch bv.Type() </span>{
                case timeType:<span class="cov0" title="0">
                        right = float64(toTimeUnix(bv))</span>
                }
        }

        <span class="cov8" title="1">if ns.caseInsensitive &amp;&amp; leftStr != nil &amp;&amp; rightStr != nil </span><span class="cov0" title="0">{
                c := compare.Strings(*leftStr, *rightStr)
                if c &lt; 0 </span><span class="cov0" title="0">{
                        return 0, 1
                }</span> else<span class="cov0" title="0"> if c &gt; 0 </span><span class="cov0" title="0">{
                        return 1, 0
                }</span> else<span class="cov0" title="0"> {
                        return 0, 0
                }</span>
        }

        <span class="cov8" title="1">switch </span>{
        case leftStr == nil || rightStr == nil:<span class="cov8" title="1"></span>
        case *leftStr &lt; *rightStr:<span class="cov0" title="0">
                return 0, 1</span>
        case *leftStr &gt; *rightStr:<span class="cov0" title="0">
                return 1, 0</span>
        default:<span class="cov0" title="0">
                return 0, 0</span>
        }

        <span class="cov8" title="1">return left, right</span>
}

var timeType = reflect.TypeOf((*time.Time)(nil)).Elem()

func toTimeUnix(v reflect.Value) int64 <span class="cov0" title="0">{
        if v.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                return toTimeUnix(v.Elem())
        }</span>
        <span class="cov0" title="0">if v.Type() != timeType </span><span class="cov0" title="0">{
                panic("coding error: argument must be time.Time type reflect Value")</span>
        }
        <span class="cov0" title="0">return v.MethodByName("Unix").Call([]reflect.Value{})[0].Int()</span>
}
</pre>
		
		<pre class="file" id="file234" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package compare

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "compare"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(false)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Default,
                        []string{"default"},
                        [][2]string{
                                {`{{ "Hugo Rocks!" | default "Hugo Rules!" }}`, `Hugo Rocks!`},
                                {`{{ "" | default "Hugo Rules!" }}`, `Hugo Rules!`},
                        },
                )

                ns.AddMethodMapping(ctx.Eq,
                        []string{"eq"},
                        [][2]string{
                                {`{{ if eq .Section "blog" }}current{{ end }}`, `current`},
                        },
                )

                ns.AddMethodMapping(ctx.Ge,
                        []string{"ge"},
                        [][2]string{
                                {`{{ if ge .Hugo.Version "0.36" }}Reasonable new Hugo version!{{ end }}`, `Reasonable new Hugo version!`},
                        },
                )

                ns.AddMethodMapping(ctx.Gt,
                        []string{"gt"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Le,
                        []string{"le"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Lt,
                        []string{"lt"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Ne,
                        []string{"ne"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.And,
                        []string{"and"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Or,
                        []string{"or"},
                        [][2]string{},
                )

                // getif is used internally by Hugo. Do not document.
                ns.AddMethodMapping(ctx.getIf,
                        []string{"getif"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Not,
                        []string{"not"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Conditional,
                        []string{"cond"},
                        [][2]string{
                                {`{{ cond (eq (add 2 2) 4) "2+2 is 4" "what?" | safeHTML }}`, `2+2 is 4`},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file235" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
// The functions in this file is based on the Go source code, copyright
// The Go Authors and  governed by a BSD-style license.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package compare provides template functions for comparing values.
package compare

import (
        "reflect"

        "github.com/gohugoio/hugo/common/hreflect"
)

// Boolean logic, based on:
// https://github.com/golang/go/blob/178a2c42254166cffed1b25fb1d3c7a5727cada6/src/text/template/funcs.go#L302

func truth(arg reflect.Value) bool <span class="cov8" title="1">{
        return hreflect.IsTruthfulValue(arg)
}</span>

// getIf will return the given arg if it is considered truthful, else an empty string.
func (*Namespace) getIf(arg reflect.Value) reflect.Value <span class="cov8" title="1">{
        if truth(arg) </span><span class="cov8" title="1">{
                return arg
        }</span>
        <span class="cov8" title="1">return reflect.ValueOf("")</span>
}

// And computes the Boolean AND of its arguments, returning
// the first false argument it encounters, or the last argument.
func (*Namespace) And(arg0 reflect.Value, args ...reflect.Value) reflect.Value <span class="cov0" title="0">{
        if !truth(arg0) </span><span class="cov0" title="0">{
                return arg0
        }</span>
        <span class="cov0" title="0">for i := range args </span><span class="cov0" title="0">{
                arg0 = args[i]
                if !truth(arg0) </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return arg0</span>
}

// Or computes the Boolean OR of its arguments, returning
// the first true argument it encounters, or the last argument.
func (*Namespace) Or(arg0 reflect.Value, args ...reflect.Value) reflect.Value <span class="cov8" title="1">{
        if truth(arg0) </span><span class="cov0" title="0">{
                return arg0
        }</span>
        <span class="cov8" title="1">for i := range args </span><span class="cov8" title="1">{
                arg0 = args[i]
                if truth(arg0) </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return arg0</span>
}

// Not returns the Boolean negation of its argument.
func (*Namespace) Not(arg reflect.Value) bool <span class="cov8" title="1">{
        return !truth(arg)
}</span>
</pre>
		
		<pre class="file" id="file236" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package crypto provides template functions for cryptographic operations.
package crypto

import (
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "encoding/hex"

        "github.com/spf13/cast"
)

// New returns a new instance of the crypto-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "crypto" namespace.
type Namespace struct{}

// MD5 hashes the given input and returns its MD5 checksum.
func (ns *Namespace) MD5(in interface{}) (string, error) <span class="cov0" title="0">{
        conv, err := cast.ToStringE(in)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">hash := md5.Sum([]byte(conv))
        return hex.EncodeToString(hash[:]), nil</span>
}

// SHA1 hashes the given input and returns its SHA1 checksum.
func (ns *Namespace) SHA1(in interface{}) (string, error) <span class="cov0" title="0">{
        conv, err := cast.ToStringE(in)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">hash := sha1.Sum([]byte(conv))
        return hex.EncodeToString(hash[:]), nil</span>
}

// SHA256 hashes the given input and returns its SHA256 checksum.
func (ns *Namespace) SHA256(in interface{}) (string, error) <span class="cov0" title="0">{
        conv, err := cast.ToStringE(in)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">hash := sha256.Sum256([]byte(conv))
        return hex.EncodeToString(hash[:]), nil</span>
}
</pre>
		
		<pre class="file" id="file237" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package crypto

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "crypto"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.MD5,
                        []string{"md5"},
                        [][2]string{
                                {`{{ md5 "Hello world, gophers!" }}`, `b3029f756f98f79e7f1b7f1d1f0dd53b`},
                                {`{{ crypto.MD5 "Hello world, gophers!" }}`, `b3029f756f98f79e7f1b7f1d1f0dd53b`},
                        },
                )

                ns.AddMethodMapping(ctx.SHA1,
                        []string{"sha1"},
                        [][2]string{
                                {`{{ sha1 "Hello world, gophers!" }}`, `c8b5b0e33d408246e30f53e32b8f7627a7a649d4`},
                        },
                )

                ns.AddMethodMapping(ctx.SHA256,
                        []string{"sha256"},
                        [][2]string{
                                {`{{ sha256 "Hello world, gophers!" }}`, `6ec43b78da9669f50e4e422575c54bf87536954ccd58280219c393f2ce352b46`},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file238" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package data provides template functions for working with external data
// sources.
package data

import (
        "bytes"
        "encoding/csv"
        "encoding/json"
        "errors"
        "net/http"
        "strings"

        "github.com/gohugoio/hugo/cache/filecache"
        "github.com/gohugoio/hugo/deps"
        _errors "github.com/pkg/errors"
)

// New returns a new instance of the data-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{

        return &amp;Namespace{
                deps:         deps,
                cacheGetCSV:  deps.FileCaches.GetCSVCache(),
                cacheGetJSON: deps.FileCaches.GetJSONCache(),
                client:       http.DefaultClient,
        }
}</span>

// Namespace provides template functions for the "data" namespace.
type Namespace struct {
        deps *deps.Deps

        cacheGetJSON *filecache.Cache
        cacheGetCSV  *filecache.Cache

        client *http.Client
}

// GetCSV expects a data separator and one or n-parts of a URL to a resource which
// can either be a local or a remote one.
// The data separator can be a comma, semi-colon, pipe, etc, but only one character.
// If you provide multiple parts for the URL they will be joined together to the final URL.
// GetCSV returns nil or a slice slice to use in a short code.
func (ns *Namespace) GetCSV(sep string, urlParts ...string) (d [][]string, err error) <span class="cov0" title="0">{
        url := strings.Join(urlParts, "")
        cache := ns.cacheGetCSV

        unmarshal := func(b []byte) (bool, error) </span><span class="cov0" title="0">{
                if !bytes.Contains(b, []byte(sep)) </span><span class="cov0" title="0">{
                        return false, _errors.Errorf("cannot find separator %s in CSV for %s", sep, url)
                }</span>

                <span class="cov0" title="0">if d, err = parseCSV(b, sep); err != nil </span><span class="cov0" title="0">{
                        err = _errors.Wrapf(err, "failed to parse CSV file %s", url)

                        return true, err
                }</span>

                <span class="cov0" title="0">return false, nil</span>
        }

        <span class="cov0" title="0">var req *http.Request
        req, err = http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, _errors.Wrapf(err, "failed to create request for getCSV for resource %s", url)
        }</span>

        <span class="cov0" title="0">req.Header.Add("Accept", "text/csv")
        req.Header.Add("Accept", "text/plain")

        err = ns.getResource(cache, unmarshal, req)
        if err != nil </span><span class="cov0" title="0">{
                ns.deps.Log.ERROR.Printf("Failed to get CSV resource %q: %s", url, err)
                return nil, nil
        }</span>

        <span class="cov0" title="0">return</span>
}

// GetJSON expects one or n-parts of a URL to a resource which can either be a local or a remote one.
// If you provide multiple parts they will be joined together to the final URL.
// GetJSON returns nil or parsed JSON to use in a short code.
func (ns *Namespace) GetJSON(urlParts ...string) (interface{}, error) <span class="cov0" title="0">{
        var v interface{}
        url := strings.Join(urlParts, "")
        cache := ns.cacheGetJSON

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, _errors.Wrapf(err, "Failed to create request for getJSON resource %s", url)
        }</span>

        <span class="cov0" title="0">unmarshal := func(b []byte) (bool, error) </span><span class="cov0" title="0">{
                err := json.Unmarshal(b, &amp;v)
                if err != nil </span><span class="cov0" title="0">{
                        return true, err
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        }

        <span class="cov0" title="0">req.Header.Add("Accept", "application/json")

        err = ns.getResource(cache, unmarshal, req)
        if err != nil </span><span class="cov0" title="0">{
                ns.deps.Log.ERROR.Printf("Failed to get JSON resource %q: %s", url, err)
                return nil, nil
        }</span>

        <span class="cov0" title="0">return v, nil</span>
}

// parseCSV parses bytes of CSV data into a slice slice string or an error
func parseCSV(c []byte, sep string) ([][]string, error) <span class="cov0" title="0">{
        if len(sep) != 1 </span><span class="cov0" title="0">{
                return nil, errors.New("Incorrect length of CSV separator: " + sep)
        }</span>
        <span class="cov0" title="0">b := bytes.NewReader(c)
        r := csv.NewReader(b)
        rSep := []rune(sep)
        r.Comma = rSep[0]
        r.FieldsPerRecord = 0
        return r.ReadAll()</span>
}
</pre>
		
		<pre class="file" id="file239" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package data

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "data"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.GetCSV,
                        []string{"getCSV"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.GetJSON,
                        []string{"getJSON"},
                        [][2]string{},
                )
                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file240" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package data

import (
        "io/ioutil"
        "net/http"
        "path/filepath"
        "time"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/cache/filecache"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/afero"
)

var (
        resSleep   = time.Second * 2 // if JSON decoding failed sleep for n seconds before retrying
        resRetries = 1               // number of retries to load the JSON from URL
)

// getRemote loads the content of a remote file. This method is thread safe.
func (ns *Namespace) getRemote(cache *filecache.Cache, unmarshal func([]byte) (bool, error), req *http.Request) error <span class="cov0" title="0">{
        url := req.URL.String()
        id := helpers.MD5String(url)
        var handled bool
        var retry bool

        _, b, err := cache.GetOrCreateBytes(id, func() ([]byte, error) </span><span class="cov0" title="0">{
                var err error
                handled = true
                for i := 0; i &lt;= resRetries; i++ </span><span class="cov0" title="0">{
                        ns.deps.Log.INFO.Printf("Downloading: %s ...", url)
                        var res *http.Response
                        res, err = ns.client.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">if isHTTPError(res) </span><span class="cov0" title="0">{
                                return nil, errors.Errorf("Failed to retrieve remote file: %s", http.StatusText(res.StatusCode))
                        }</span>

                        <span class="cov0" title="0">var b []byte
                        b, err = ioutil.ReadAll(res.Body)

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">res.Body.Close()

                        retry, err = unmarshal(b)

                        if err == nil </span><span class="cov0" title="0">{
                                // Return it so it can be cached.
                                return b, nil
                        }</span>

                        <span class="cov0" title="0">if !retry </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">ns.deps.Log.INFO.Printf("Cannot read remote resource %s: %s", url, err)
                        ns.deps.Log.INFO.Printf("Retry #%d for %s and sleeping for %s", i+1, url, resSleep)
                        time.Sleep(resSleep)</span>
                }

                <span class="cov0" title="0">return nil, err</span>

        })

        <span class="cov0" title="0">if !handled </span><span class="cov0" title="0">{
                // This is cached content and should be correct.
                _, err = unmarshal(b)
        }</span>

        <span class="cov0" title="0">return err</span>
}

// getLocal loads the content of a local file
func getLocal(url string, fs afero.Fs, cfg config.Provider) ([]byte, error) <span class="cov0" title="0">{
        filename := filepath.Join(cfg.GetString("workingDir"), url)
        if e, err := helpers.Exists(filename, fs); !e </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return afero.ReadFile(fs, filename)</span>

}

// getResource loads the content of a local or remote file and returns its content and the
// cache ID used, if relevant.
func (ns *Namespace) getResource(cache *filecache.Cache, unmarshal func(b []byte) (bool, error), req *http.Request) error <span class="cov0" title="0">{
        switch req.URL.Scheme </span>{
        case "":<span class="cov0" title="0">
                b, err := getLocal(req.URL.String(), ns.deps.Fs.Source, ns.deps.Cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_, err = unmarshal(b)
                return err</span>
        default:<span class="cov0" title="0">
                return ns.getRemote(cache, unmarshal, req)</span>
        }
}

func isHTTPError(res *http.Response) bool <span class="cov0" title="0">{
        return res.StatusCode &lt; 200 || res.StatusCode &gt; 299
}</span>
</pre>
		
		<pre class="file" id="file241" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package encoding provides template functions for encoding content.
package encoding

import (
        "encoding/base64"
        "encoding/json"
        "html/template"

        "github.com/spf13/cast"
)

// New returns a new instance of the encoding-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "encoding" namespace.
type Namespace struct{}

// Base64Decode returns the base64 decoding of the given content.
func (ns *Namespace) Base64Decode(content interface{}) (string, error) <span class="cov0" title="0">{
        conv, err := cast.ToStringE(content)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">dec, err := base64.StdEncoding.DecodeString(conv)
        return string(dec), err</span>
}

// Base64Encode returns the base64 encoding of the given content.
func (ns *Namespace) Base64Encode(content interface{}) (string, error) <span class="cov0" title="0">{
        conv, err := cast.ToStringE(content)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString([]byte(conv)), nil</span>
}

// Jsonify encodes a given object to JSON.
func (ns *Namespace) Jsonify(v interface{}) (template.HTML, error) <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return template.HTML(b), nil</span>
}
</pre>
		
		<pre class="file" id="file242" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package encoding

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "encoding"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Base64Decode,
                        []string{"base64Decode"},
                        [][2]string{
                                {`{{ "SGVsbG8gd29ybGQ=" | base64Decode }}`, `Hello world`},
                                {`{{ 42 | base64Encode | base64Decode }}`, `42`},
                        },
                )

                ns.AddMethodMapping(ctx.Base64Encode,
                        []string{"base64Encode"},
                        [][2]string{
                                {`{{ "Hello world" | base64Encode }}`, `SGVsbG8gd29ybGQ=`},
                        },
                )

                ns.AddMethodMapping(ctx.Jsonify,
                        []string{"jsonify"},
                        [][2]string{
                                {`{{ (slice "A" "B" "C") | jsonify }}`, `["A","B","C"]`},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file243" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package fmt provides template functions for formatting strings.
package fmt

import (
        _fmt "fmt"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
)

// New returns a new instance of the fmt-namespaced template functions.
func New(d *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{helpers.NewDistinctLogger(d.Log.ERROR)}
}</span>

// Namespace provides template functions for the "fmt" namespace.
type Namespace struct {
        errorLogger *helpers.DistinctLogger
}

// Print returns string representation of the passed arguments.
func (ns *Namespace) Print(a ...interface{}) string <span class="cov0" title="0">{
        return _fmt.Sprint(a...)
}</span>

// Printf returns a formatted string representation of the passed arguments.
func (ns *Namespace) Printf(format string, a ...interface{}) string <span class="cov8" title="1">{
        return _fmt.Sprintf(format, a...)

}</span>

// Println returns string representation of the passed arguments ending with a newline.
func (ns *Namespace) Println(a ...interface{}) string <span class="cov0" title="0">{
        return _fmt.Sprintln(a...)
}</span>

// Errorf formats according to a format specifier and returns the string as a
// value that satisfies error.
func (ns *Namespace) Errorf(format string, a ...interface{}) string <span class="cov0" title="0">{
        ns.errorLogger.Printf(format, a...)
        return _fmt.Sprintf(format, a...)
}</span>
</pre>
		
		<pre class="file" id="file244" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package fmt

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "fmt"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Print,
                        []string{"print"},
                        [][2]string{
                                {`{{ print "works!" }}`, `works!`},
                        },
                )

                ns.AddMethodMapping(ctx.Println,
                        []string{"println"},
                        [][2]string{
                                {`{{ println "works!" }}`, "works!\n"},
                        },
                )

                ns.AddMethodMapping(ctx.Printf,
                        []string{"printf"},
                        [][2]string{
                                {`{{ printf "%s!" "works" }}`, `works!`},
                        },
                )

                ns.AddMethodMapping(ctx.Errorf,
                        []string{"errorf"},
                        [][2]string{
                                {`{{ errorf "%s." "failed" }}`, `failed.`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file245" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package hugo provides template functions for accessing the Site Hugo object.
package hugo

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "hugo"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{

                h := d.Site.Hugo()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return h }</span>,
                }

                // We just add the Hugo struct as the namespace here. No method mappings.

                <span class="cov8" title="1">return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file246" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package images provides template functions for manipulating images.
package images

import (
        "image"
        "sync"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/resources/images"
        "github.com/gohugoio/hugo/resources/resource"

        // Importing image codecs for image.DecodeConfig
        _ "image/gif"
        _ "image/jpeg"
        _ "image/png"

        // Import webp codec
        _ "golang.org/x/image/webp"

        "github.com/gohugoio/hugo/deps"
        "github.com/spf13/cast"
)

// New returns a new instance of the images-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                Filters: &amp;images.Filters{},
                cache:   map[string]image.Config{},
                deps:    deps,
        }
}</span>

// Namespace provides template functions for the "images" namespace.
type Namespace struct {
        *images.Filters
        cacheMu sync.RWMutex
        cache   map[string]image.Config

        deps *deps.Deps
}

// Config returns the image.Config for the specified path relative to the
// working directory.
func (ns *Namespace) Config(path interface{}) (image.Config, error) <span class="cov0" title="0">{
        filename, err := cast.ToStringE(path)
        if err != nil </span><span class="cov0" title="0">{
                return image.Config{}, err
        }</span>

        <span class="cov0" title="0">if filename == "" </span><span class="cov0" title="0">{
                return image.Config{}, errors.New("config needs a filename")
        }</span>

        // Check cache for image config.
        <span class="cov0" title="0">ns.cacheMu.RLock()
        config, ok := ns.cache[filename]
        ns.cacheMu.RUnlock()

        if ok </span><span class="cov0" title="0">{
                return config, nil
        }</span>

        <span class="cov0" title="0">f, err := ns.deps.Fs.WorkingDir.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return image.Config{}, err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        config, _, err = image.DecodeConfig(f)
        if err != nil </span><span class="cov0" title="0">{
                return config, err
        }</span>

        <span class="cov0" title="0">ns.cacheMu.Lock()
        ns.cache[filename] = config
        ns.cacheMu.Unlock()

        return config, nil</span>
}

func (ns *Namespace) Filter(args ...interface{}) (resource.Image, error) <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("must provide an image and one or more filters")
        }</span>

        <span class="cov0" title="0">img := args[len(args)-1].(resource.Image)
        filtersv := args[:len(args)-1]

        return img.Filter(filtersv...)</span>
}
</pre>
		
		<pre class="file" id="file247" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "images"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Config,
                        []string{"imageConfig"},
                        [][2]string{},
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file248" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package inflect provides template functions for the inflection of words.
package inflect

import (
        "strconv"

        _inflect "github.com/markbates/inflect"
        "github.com/spf13/cast"
)

// New returns a new instance of the inflect-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "inflect" namespace.
type Namespace struct{}

// Humanize returns the humanized form of a single parameter.
//
// If the parameter is either an integer or a string containing an integer
// value, the behavior is to add the appropriate ordinal.
//
//     Example:  "my-first-post" -&gt; "My first post"
//     Example:  "103" -&gt; "103rd"
//     Example:  52 -&gt; "52nd"
func (ns *Namespace) Humanize(in interface{}) (string, error) <span class="cov8" title="1">{
        word, err := cast.ToStringE(in)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if word == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">_, ok := in.(int)           // original param was literal int value
        _, err = strconv.Atoi(word) // original param was string containing an int value
        if ok || err == nil </span><span class="cov0" title="0">{
                return _inflect.Ordinalize(word), nil
        }</span>

        <span class="cov8" title="1">return _inflect.Humanize(word), nil</span>
}

// Pluralize returns the plural form of a single word.
func (ns *Namespace) Pluralize(in interface{}) (string, error) <span class="cov0" title="0">{
        word, err := cast.ToStringE(in)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return _inflect.Pluralize(word), nil</span>
}

// Singularize returns the singular form of a single word.
func (ns *Namespace) Singularize(in interface{}) (string, error) <span class="cov0" title="0">{
        word, err := cast.ToStringE(in)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return _inflect.Singularize(word), nil</span>
}
</pre>
		
		<pre class="file" id="file249" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package inflect

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "inflect"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Humanize,
                        []string{"humanize"},
                        [][2]string{
                                {`{{ humanize "my-first-post" }}`, `My first post`},
                                {`{{ humanize "myCamelPost" }}`, `My camel post`},
                                {`{{ humanize "52" }}`, `52nd`},
                                {`{{ humanize 103 }}`, `103rd`},
                        },
                )

                ns.AddMethodMapping(ctx.Pluralize,
                        []string{"pluralize"},
                        [][2]string{
                                {`{{ "cat" | pluralize }}`, `cats`},
                        },
                )

                ns.AddMethodMapping(ctx.Singularize,
                        []string{"singularize"},
                        [][2]string{
                                {`{{ "cats" | singularize }}`, `cat`},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file250" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Portions Copyright The Go Authors.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package internal

import (
        "bytes"
        "encoding/json"
        "fmt"
        "go/doc"
        "go/parser"
        "go/token"
        "io/ioutil"
        "log"
        "os"
        "path/filepath"
        "reflect"
        "runtime"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/deps"
)

// TemplateFuncsNamespaceRegistry describes a registry of functions that provide
// namespaces.
var TemplateFuncsNamespaceRegistry []func(d *deps.Deps) *TemplateFuncsNamespace

// AddTemplateFuncsNamespace adds a given function to a registry.
func AddTemplateFuncsNamespace(ns func(d *deps.Deps) *TemplateFuncsNamespace) <span class="cov8" title="1">{
        TemplateFuncsNamespaceRegistry = append(TemplateFuncsNamespaceRegistry, ns)
}</span>

// TemplateFuncsNamespace represents a template function namespace.
type TemplateFuncsNamespace struct {
        // The namespace name, "strings", "lang", etc.
        Name string

        // This is the method receiver.
        Context func(v ...interface{}) interface{}

        // Additional info, aliases and examples, per method name.
        MethodMappings map[string]TemplateFuncMethodMapping
}

// TemplateFuncsNamespaces is a slice of TemplateFuncsNamespace.
type TemplateFuncsNamespaces []*TemplateFuncsNamespace

// AddMethodMapping adds a method to a template function namespace.
func (t *TemplateFuncsNamespace) AddMethodMapping(m interface{}, aliases []string, examples [][2]string) <span class="cov8" title="1">{
        if t.MethodMappings == nil </span><span class="cov8" title="1">{
                t.MethodMappings = make(map[string]TemplateFuncMethodMapping)
        }</span>

        <span class="cov8" title="1">name := methodToName(m)

        // sanity check
        for _, e := range examples </span><span class="cov8" title="1">{
                if e[0] == "" </span><span class="cov0" title="0">{
                        panic(t.Name + ": Empty example for " + name)</span>
                }
        }
        <span class="cov8" title="1">for _, a := range aliases </span><span class="cov8" title="1">{
                if a == "" </span><span class="cov0" title="0">{
                        panic(t.Name + ": Empty alias for " + name)</span>
                }
        }

        <span class="cov8" title="1">t.MethodMappings[name] = TemplateFuncMethodMapping{
                Method:   m,
                Aliases:  aliases,
                Examples: examples,
        }</span>

}

// TemplateFuncMethodMapping represents a mapping of functions to methods for a
// given namespace.
type TemplateFuncMethodMapping struct {
        Method interface{}

        // Any template funcs aliases. This is mainly motivated by keeping
        // backwards compatibility, but some new template funcs may also make
        // sense to give short and snappy aliases.
        // Note that these aliases are global and will be merged, so the last
        // key will win.
        Aliases []string

        // A slice of input/expected examples.
        // We keep it a the namespace level for now, but may find a way to keep track
        // of the single template func, for documentation purposes.
        // Some of these, hopefully just a few, may depend on some test data to run.
        Examples [][2]string
}

func methodToName(m interface{}) string <span class="cov8" title="1">{
        name := runtime.FuncForPC(reflect.ValueOf(m).Pointer()).Name()
        name = filepath.Ext(name)
        name = strings.TrimPrefix(name, ".")
        name = strings.TrimSuffix(name, "-fm")
        return name
}</span>

type goDocFunc struct {
        Name        string
        Description string
        Args        []string
        Aliases     []string
        Examples    [][2]string
}

func (t goDocFunc) toJSON() ([]byte, error) <span class="cov0" title="0">{
        args, err := json.Marshal(t.Args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">aliases, err := json.Marshal(t.Aliases)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">examples, err := json.Marshal(t.Examples)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var buf bytes.Buffer
        buf.WriteString(fmt.Sprintf(`%q:
    { "Description": %q, "Args": %s, "Aliases": %s, "Examples": %s }        
`, t.Name, t.Description, args, aliases, examples))

        return buf.Bytes(), nil</span>
}

// MarshalJSON returns the JSON encoding of namespaces.
func (namespaces TemplateFuncsNamespaces) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer

        buf.WriteString("{")

        for i, ns := range namespaces </span><span class="cov0" title="0">{
                if i != 0 </span><span class="cov0" title="0">{
                        buf.WriteString(",")
                }</span>
                <span class="cov0" title="0">b, err := ns.toJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">buf.Write(b)</span>
        }

        <span class="cov0" title="0">buf.WriteString("}")

        return buf.Bytes(), nil</span>
}

func (t *TemplateFuncsNamespace) toJSON() ([]byte, error) <span class="cov0" title="0">{

        var buf bytes.Buffer

        godoc := getGetTplPackagesGoDoc()[t.Name]

        var funcs []goDocFunc

        buf.WriteString(fmt.Sprintf(`%q: {`, t.Name))

        ctx := t.Context()
        ctxType := reflect.TypeOf(ctx)
        for i := 0; i &lt; ctxType.NumMethod(); i++ </span><span class="cov0" title="0">{
                method := ctxType.Method(i)
                f := goDocFunc{
                        Name: method.Name,
                }

                methodGoDoc := godoc[method.Name]

                if mapping, ok := t.MethodMappings[method.Name]; ok </span><span class="cov0" title="0">{
                        f.Aliases = mapping.Aliases
                        f.Examples = mapping.Examples
                        f.Description = methodGoDoc.Description
                        f.Args = methodGoDoc.Args
                }</span>

                <span class="cov0" title="0">funcs = append(funcs, f)</span>
        }

        <span class="cov0" title="0">for i, f := range funcs </span><span class="cov0" title="0">{
                if i != 0 </span><span class="cov0" title="0">{
                        buf.WriteString(",")
                }</span>
                <span class="cov0" title="0">funcStr, err := f.toJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">buf.Write(funcStr)</span>
        }

        <span class="cov0" title="0">buf.WriteString("}")

        return buf.Bytes(), nil</span>
}

type methodGoDocInfo struct {
        Description string
        Args        []string
}

var (
        tplPackagesGoDoc     map[string]map[string]methodGoDocInfo
        tplPackagesGoDocInit sync.Once
)

func getGetTplPackagesGoDoc() map[string]map[string]methodGoDocInfo <span class="cov0" title="0">{
        tplPackagesGoDocInit.Do(func() </span><span class="cov0" title="0">{
                tplPackagesGoDoc = make(map[string]map[string]methodGoDocInfo)
                pwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">fset := token.NewFileSet()

                // pwd will be inside one of the namespace packages during tests
                var basePath string
                if strings.Contains(pwd, "tpl") </span><span class="cov0" title="0">{
                        basePath = filepath.Join(pwd, "..")
                }</span> else<span class="cov0" title="0"> {
                        basePath = filepath.Join(pwd, "tpl")
                }</span>

                <span class="cov0" title="0">files, err := ioutil.ReadDir(basePath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">for _, fi := range files </span><span class="cov0" title="0">{
                        if !fi.IsDir() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">namespaceDoc := make(map[string]methodGoDocInfo)
                        packagePath := filepath.Join(basePath, fi.Name())

                        d, err := parser.ParseDir(fset, packagePath, nil, parser.ParseComments)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>

                        <span class="cov0" title="0">for _, f := range d </span><span class="cov0" title="0">{
                                p := doc.New(f, "./", 0)

                                for _, t := range p.Types </span><span class="cov0" title="0">{
                                        if t.Name == "Namespace" </span><span class="cov0" title="0">{
                                                for _, tt := range t.Methods </span><span class="cov0" title="0">{
                                                        var args []string
                                                        for _, p := range tt.Decl.Type.Params.List </span><span class="cov0" title="0">{
                                                                for _, pp := range p.Names </span><span class="cov0" title="0">{
                                                                        args = append(args, pp.Name)
                                                                }</span>
                                                        }

                                                        <span class="cov0" title="0">description := strings.TrimSpace(tt.Doc)
                                                        di := methodGoDocInfo{Description: description, Args: args}
                                                        namespaceDoc[tt.Name] = di</span>
                                                }
                                        }
                                }
                        }

                        <span class="cov0" title="0">tplPackagesGoDoc[fi.Name()] = namespaceDoc</span>
                }
        })

        <span class="cov0" title="0">return tplPackagesGoDoc</span>
}
</pre>
		
		<pre class="file" id="file251" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lang

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "lang"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Translate,
                        []string{"i18n", "T"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.NumFmt,
                        nil,
                        [][2]string{
                                {`{{ lang.NumFmt 2 12345.6789 }}`, `12,345.68`},
                                {`{{ lang.NumFmt 2 12345.6789 "- , ." }}`, `12.345,68`},
                                {`{{ lang.NumFmt 6 -12345.6789 "- ." }}`, `-12345.678900`},
                                {`{{ lang.NumFmt 0 -12345.6789 "- . ," }}`, `-12,346`},
                                {`{{ -98765.4321 | lang.NumFmt 2 }}`, `-98,765.43`},
                        },
                )
                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file252" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package lang provides template functions for content internationalization.
package lang

import (
        "errors"
        "fmt"
        "math"
        "strconv"
        "strings"

        "github.com/gohugoio/hugo/deps"
        "github.com/spf13/cast"
)

// New returns a new instance of the lang-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                deps: deps,
        }
}</span>

// Namespace provides template functions for the "lang" namespace.
type Namespace struct {
        deps *deps.Deps
}

// Translate returns a translated string for id.
func (ns *Namespace) Translate(id interface{}, args ...interface{}) (string, error) <span class="cov8" title="1">{
        sid, err := cast.ToStringE(id)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return ns.deps.Translate(sid, args...), nil</span>
}

// NumFmt formats a number with the given precision using the
// negative, decimal, and grouping options.  The `options`
// parameter is a string consisting of `&lt;negative&gt; &lt;decimal&gt; &lt;grouping&gt;`.  The
// default `options` value is `- . ,`.
//
// Note that numbers are rounded up at 5 or greater.
// So, with precision set to 0, 1.5 becomes `2`, and 1.4 becomes `1`.
func (ns *Namespace) NumFmt(precision, number interface{}, options ...interface{}) (string, error) <span class="cov0" title="0">{
        prec, err := cast.ToIntE(precision)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">n, err := cast.ToFloat64E(number)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var neg, dec, grp string

        if len(options) == 0 </span><span class="cov0" title="0">{
                // defaults
                neg, dec, grp = "-", ".", ","
        }</span> else<span class="cov0" title="0"> {
                delim := " "

                if len(options) == 2 </span><span class="cov0" title="0">{
                        // custom delimiter
                        s, err := cast.ToStringE(options[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return "", nil
                        }</span>

                        <span class="cov0" title="0">delim = s</span>
                }

                <span class="cov0" title="0">s, err := cast.ToStringE(options[0])
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>

                <span class="cov0" title="0">rs := strings.Split(s, delim)
                switch len(rs) </span>{
                case 0:<span class="cov0" title="0"></span>
                case 1:<span class="cov0" title="0">
                        neg = rs[0]</span>
                case 2:<span class="cov0" title="0">
                        neg, dec = rs[0], rs[1]</span>
                case 3:<span class="cov0" title="0">
                        neg, dec, grp = rs[0], rs[1], rs[2]</span>
                default:<span class="cov0" title="0">
                        return "", errors.New("too many fields in options parameter to NumFmt")</span>
                }
        }

        // Logic from MIT Licensed github.com/go-playground/locales/
        // Original Copyright (c) 2016 Go Playground

        <span class="cov0" title="0">s := strconv.FormatFloat(math.Abs(n), 'f', prec, 64)
        L := len(s) + 2 + len(s[:len(s)-1-prec])/3

        var count int
        inWhole := prec == 0
        b := make([]byte, 0, L)

        for i := len(s) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if s[i] == '.' </span><span class="cov0" title="0">{
                        for j := len(dec) - 1; j &gt;= 0; j-- </span><span class="cov0" title="0">{
                                b = append(b, dec[j])
                        }</span>
                        <span class="cov0" title="0">inWhole = true
                        continue</span>
                }

                <span class="cov0" title="0">if inWhole </span><span class="cov0" title="0">{
                        if count == 3 </span><span class="cov0" title="0">{
                                for j := len(grp) - 1; j &gt;= 0; j-- </span><span class="cov0" title="0">{
                                        b = append(b, grp[j])
                                }</span>
                                <span class="cov0" title="0">count = 1</span>
                        } else<span class="cov0" title="0"> {
                                count++
                        }</span>
                }

                <span class="cov0" title="0">b = append(b, s[i])</span>
        }

        <span class="cov0" title="0">if n &lt; 0 </span><span class="cov0" title="0">{
                for j := len(neg) - 1; j &gt;= 0; j-- </span><span class="cov0" title="0">{
                        b = append(b, neg[j])
                }</span>
        }

        // reverse
        <span class="cov0" title="0">for i, j := 0, len(b)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                b[i], b[j] = b[j], b[i]
        }</span>

        <span class="cov0" title="0">return string(b), nil</span>
}

type pagesLanguageMerger interface {
        MergeByLanguageInterface(other interface{}) (interface{}, error)
}

// Merge creates a union of pages from two languages.
func (ns *Namespace) Merge(p2, p1 interface{}) (interface{}, error) <span class="cov0" title="0">{
        merger, ok := p1.(pagesLanguageMerger)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("language merge not supported for %T", p1)
        }</span>
        <span class="cov0" title="0">return merger.MergeByLanguageInterface(p2)</span>
}
</pre>
		
		<pre class="file" id="file253" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package math

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "math"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Add,
                        []string{"add"},
                        [][2]string{
                                {"{{add 1 2}}", "3"},
                        },
                )

                ns.AddMethodMapping(ctx.Ceil,
                        nil,
                        [][2]string{
                                {"{{math.Ceil 2.1}}", "3"},
                        },
                )

                ns.AddMethodMapping(ctx.Div,
                        []string{"div"},
                        [][2]string{
                                {"{{div 6 3}}", "2"},
                        },
                )

                ns.AddMethodMapping(ctx.Floor,
                        nil,
                        [][2]string{
                                {"{{math.Floor 1.9}}", "1"},
                        },
                )

                ns.AddMethodMapping(ctx.Log,
                        nil,
                        [][2]string{
                                {"{{math.Log 1}}", "0"},
                        },
                )

                ns.AddMethodMapping(ctx.Mod,
                        []string{"mod"},
                        [][2]string{
                                {"{{mod 15 3}}", "0"},
                        },
                )

                ns.AddMethodMapping(ctx.ModBool,
                        []string{"modBool"},
                        [][2]string{
                                {"{{modBool 15 3}}", "true"},
                        },
                )

                ns.AddMethodMapping(ctx.Mul,
                        []string{"mul"},
                        [][2]string{
                                {"{{mul 2 3}}", "6"},
                        },
                )

                ns.AddMethodMapping(ctx.Round,
                        nil,
                        [][2]string{
                                {"{{math.Round 1.5}}", "2"},
                        },
                )

                ns.AddMethodMapping(ctx.Sub,
                        []string{"sub"},
                        [][2]string{
                                {"{{sub 3 2}}", "1"},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file254" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package math provides template functions for mathmatical operations.
package math

import (
        "errors"
        "math"

        _math "github.com/gohugoio/hugo/common/math"

        "github.com/spf13/cast"
)

// New returns a new instance of the math-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "math" namespace.
type Namespace struct{}

// Add adds two numbers.
func (ns *Namespace) Add(a, b interface{}) (interface{}, error) <span class="cov8" title="1">{
        return _math.DoArithmetic(a, b, '+')
}</span>

// Ceil returns the least integer value greater than or equal to x.
func (ns *Namespace) Ceil(x interface{}) (float64, error) <span class="cov0" title="0">{
        xf, err := cast.ToFloat64E(x)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("Ceil operator can't be used with non-float value")
        }</span>

        <span class="cov0" title="0">return math.Ceil(xf), nil</span>
}

// Div divides two numbers.
func (ns *Namespace) Div(a, b interface{}) (interface{}, error) <span class="cov0" title="0">{
        return _math.DoArithmetic(a, b, '/')
}</span>

// Floor returns the greatest integer value less than or equal to x.
func (ns *Namespace) Floor(x interface{}) (float64, error) <span class="cov0" title="0">{
        xf, err := cast.ToFloat64E(x)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("Floor operator can't be used with non-float value")
        }</span>

        <span class="cov0" title="0">return math.Floor(xf), nil</span>
}

// Log returns the natural logarithm of a number.
func (ns *Namespace) Log(a interface{}) (float64, error) <span class="cov0" title="0">{
        af, err := cast.ToFloat64E(a)

        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("Log operator can't be used with non integer or float value")
        }</span>

        <span class="cov0" title="0">return math.Log(af), nil</span>
}

// Mod returns a % b.
func (ns *Namespace) Mod(a, b interface{}) (int64, error) <span class="cov0" title="0">{
        ai, erra := cast.ToInt64E(a)
        bi, errb := cast.ToInt64E(b)

        if erra != nil || errb != nil </span><span class="cov0" title="0">{
                return 0, errors.New("modulo operator can't be used with non integer value")
        }</span>

        <span class="cov0" title="0">if bi == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("the number can't be divided by zero at modulo operation")
        }</span>

        <span class="cov0" title="0">return ai % bi, nil</span>
}

// ModBool returns the boolean of a % b.  If a % b == 0, return true.
func (ns *Namespace) ModBool(a, b interface{}) (bool, error) <span class="cov0" title="0">{
        res, err := ns.Mod(a, b)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return res == int64(0), nil</span>
}

// Mul multiplies two numbers.
func (ns *Namespace) Mul(a, b interface{}) (interface{}, error) <span class="cov0" title="0">{
        return _math.DoArithmetic(a, b, '*')
}</span>

// Round returns the nearest integer, rounding half away from zero.
func (ns *Namespace) Round(x interface{}) (float64, error) <span class="cov0" title="0">{
        xf, err := cast.ToFloat64E(x)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("Round operator can't be used with non-float value")
        }</span>

        <span class="cov0" title="0">return _round(xf), nil</span>
}

// Sub subtracts two numbers.
func (ns *Namespace) Sub(a, b interface{}) (interface{}, error) <span class="cov0" title="0">{
        return _math.DoArithmetic(a, b, '-')
}</span>
</pre>
		
		<pre class="file" id="file255" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// According to https://github.com/golang/go/issues/20100, the Go stdlib will
// include math.Round beginning with Go 1.10.
//
// The following implementation was taken from https://golang.org/cl/43652.

package math

import "math"

const (
        mask  = 0x7FF
        shift = 64 - 11 - 1
        bias  = 1023
)

// Round returns the nearest integer, rounding half away from zero.
//
// Special cases are:
//        Round(0) = 0
//        Round(Inf) = Inf
//        Round(NaN) = NaN
func _round(x float64) float64 <span class="cov0" title="0">{
        // Round is a faster implementation of:
        //
        // func Round(x float64) float64 {
        //   t := Trunc(x)
        //   if Abs(x-t) &gt;= 0.5 {
        //     return t + Copysign(1, x)
        //   }
        //   return t
        // }
        const (
                signMask = 1 &lt;&lt; 63
                fracMask = 1&lt;&lt;shift - 1
                half     = 1 &lt;&lt; (shift - 1)
                one      = bias &lt;&lt; shift
        )

        bits := math.Float64bits(x)
        e := uint(bits&gt;&gt;shift) &amp; mask
        if e &lt; bias </span><span class="cov0" title="0">{
                // Round abs(x) &lt; 1 including denormals.
                bits &amp;= signMask // +-0
                if e == bias-1 </span><span class="cov0" title="0">{
                        bits |= one // +-1
                }</span>
        } else<span class="cov0" title="0"> if e &lt; bias+shift </span><span class="cov0" title="0">{
                // Round any abs(x) &gt;= 1 containing a fractional component [0,1).
                //
                // Numbers with larger exponents are returned unchanged since they
                // must be either an integer, infinity, or NaN.
                e -= bias
                bits += half &gt;&gt; e
                bits &amp;^= fracMask &gt;&gt; e
        }</span>
        <span class="cov0" title="0">return math.Float64frombits(bits)</span>
}
</pre>
		
		<pre class="file" id="file256" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package os

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "os"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Getenv,
                        []string{"getenv"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.ReadDir,
                        []string{"readDir"},
                        [][2]string{
                                {`{{ range (readDir "files") }}{{ .Name }}{{ end }}`, "README.txt"},
                        },
                )

                ns.AddMethodMapping(ctx.ReadFile,
                        []string{"readFile"},
                        [][2]string{
                                {`{{ readFile "files/README.txt" }}`, `Hugo Rocks!`},
                        },
                )

                ns.AddMethodMapping(ctx.FileExists,
                        []string{"fileExists"},
                        [][2]string{
                                {`{{ fileExists "foo.txt" }}`, `false`},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file257" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package os provides template functions for interacting with the operating
// system.
package os

import (
        "errors"
        "fmt"
        "os"
        _os "os"

        "github.com/gohugoio/hugo/deps"
        "github.com/spf13/afero"
        "github.com/spf13/cast"
)

// New returns a new instance of the os-namespaced template functions.
func New(d *deps.Deps) *Namespace <span class="cov8" title="1">{

        var rfs afero.Fs
        if d.Fs != nil </span><span class="cov8" title="1">{
                rfs = d.Fs.WorkingDir
                if d.PathSpec != nil &amp;&amp; d.PathSpec.BaseFs != nil </span><span class="cov8" title="1">{
                        rfs = afero.NewReadOnlyFs(afero.NewCopyOnWriteFs(d.PathSpec.BaseFs.Content.Fs, d.Fs.WorkingDir))
                }</span>

        }

        <span class="cov8" title="1">return &amp;Namespace{
                readFileFs: rfs,
                deps:       d,
        }</span>
}

// Namespace provides template functions for the "os" namespace.
type Namespace struct {
        readFileFs afero.Fs
        deps       *deps.Deps
}

// Getenv retrieves the value of the environment variable named by the key.
// It returns the value, which will be empty if the variable is not present.
func (ns *Namespace) Getenv(key interface{}) (string, error) <span class="cov8" title="1">{
        skey, err := cast.ToStringE(key)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return _os.Getenv(skey), nil</span>
}

// readFile reads the file named by filename in the given filesystem
// and returns the contents as a string.
// There is a upper size limit set at 1 megabytes.
func readFile(fs afero.Fs, filename string) (string, error) <span class="cov0" title="0">{
        if filename == "" </span><span class="cov0" title="0">{
                return "", errors.New("readFile needs a filename")
        }</span>

        <span class="cov0" title="0">if info, err := fs.Stat(filename); err == nil </span><span class="cov0" title="0">{
                if info.Size() &gt; 1000000 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("file %q is too big", filename)
                }</span>
        } else<span class="cov0" title="0"> {
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("file %q does not exist", filename)
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }
        <span class="cov0" title="0">b, err := afero.ReadFile(fs, filename)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(b), nil</span>
}

// ReadFile reads the file named by filename relative to the configured WorkingDir.
// It returns the contents as a string.
// There is an upper size limit set at 1 megabytes.
func (ns *Namespace) ReadFile(i interface{}) (string, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(i)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if ns.deps.PathSpec != nil </span><span class="cov0" title="0">{
                s = ns.deps.PathSpec.RelPathify(s)
        }</span>

        <span class="cov0" title="0">return readFile(ns.readFileFs, s)</span>
}

// ReadDir lists the directory contents relative to the configured WorkingDir.
func (ns *Namespace) ReadDir(i interface{}) ([]_os.FileInfo, error) <span class="cov0" title="0">{
        path, err := cast.ToStringE(i)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">list, err := afero.ReadDir(ns.deps.Fs.WorkingDir, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory %q: %s", path, err)
        }</span>

        <span class="cov0" title="0">return list, nil</span>
}

// FileExists checks whether a file exists under the given path.
func (ns *Namespace) FileExists(i interface{}) (bool, error) <span class="cov0" title="0">{
        path, err := cast.ToStringE(i)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if path == "" </span><span class="cov0" title="0">{
                return false, errors.New("fileExists needs a path to a file")
        }</span>

        <span class="cov0" title="0">status, err := afero.Exists(ns.readFileFs, path)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

// Stat returns the os.FileInfo structure describing file.
func (ns *Namespace) Stat(i interface{}) (_os.FileInfo, error) <span class="cov0" title="0">{
        path, err := cast.ToStringE(i)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if path == "" </span><span class="cov0" title="0">{
                return nil, errors.New("fileStat needs a path to a file")
        }</span>

        <span class="cov0" title="0">r, err := ns.readFileFs.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return r, nil</span>
}
</pre>
		
		<pre class="file" id="file258" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package partials

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "partials"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Include,
                        []string{"partial"},
                        [][2]string{
                                {`{{ partial "header.html" . }}`, `&lt;title&gt;Hugo Rocks!&lt;/title&gt;`},
                        },
                )

                // TODO(bep) we need the return to be a valid identifier, but
                // should consider another way of adding it.
                ns.AddMethodMapping(func() string </span><span class="cov0" title="0">{ return "" }</span>,
                        []string{"return"},
                        [][2]string{},
                )

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.IncludeCached,
                        []string{"partialCached"},
                        [][2]string{},
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file259" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package partials provides template functions for working with reusable
// templates.
package partials

import (
        "fmt"
        "html/template"
        "io"
        "io/ioutil"
        "strings"
        "sync"
        texttemplate "text/template"

        "github.com/gohugoio/hugo/tpl"

        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/deps"
)

// TestTemplateProvider is global deps.ResourceProvider.
// NOTE: It's currently unused.
var TestTemplateProvider deps.ResourceProvider

// partialCache represents a cache of partials protected by a mutex.
type partialCache struct {
        sync.RWMutex
        p map[string]interface{}
}

func (p *partialCache) clear() <span class="cov0" title="0">{
        p.Lock()
        defer p.Unlock()
        p.p = make(map[string]interface{})
}</span>

// New returns a new instance of the templates-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        cache := &amp;partialCache{p: make(map[string]interface{})}
        deps.BuildStartListeners.Add(
                func() </span><span class="cov0" title="0">{
                        cache.clear()
                }</span>)

        <span class="cov8" title="1">return &amp;Namespace{
                deps:           deps,
                cachedPartials: cache,
        }</span>
}

// Namespace provides template functions for the "templates" namespace.
type Namespace struct {
        deps           *deps.Deps
        cachedPartials *partialCache
}

// contextWrapper makes room for a return value in a partial invocation.
type contextWrapper struct {
        Arg    interface{}
        Result interface{}
}

// Set sets the return value and returns an empty string.
func (c *contextWrapper) Set(in interface{}) string <span class="cov0" title="0">{
        c.Result = in
        return ""
}</span>

// Include executes the named partial.
// If the partial contains a return statement, that value will be returned.
// Else, the rendered output will be returned:
// A string if the partial is a text/template, or template.HTML when html/template.
func (ns *Namespace) Include(name string, contextList ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        if strings.HasPrefix(name, "partials/") </span><span class="cov0" title="0">{
                name = name[8:]
        }</span>
        <span class="cov8" title="1">var context interface{}

        if len(contextList) == 0 </span><span class="cov0" title="0">{
                context = nil
        }</span> else<span class="cov8" title="1"> {
                context = contextList[0]
        }</span>

        <span class="cov8" title="1">n := "partials/" + name
        templ, found := ns.deps.Tmpl.Lookup(n)

        if !found </span><span class="cov0" title="0">{
                // For legacy reasons.
                templ, found = ns.deps.Tmpl.Lookup(n + ".html")
        }</span>

        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                return "", fmt.Errorf("partial %q not found", name)
        }</span>

        <span class="cov8" title="1">var info tpl.Info
        if ip, ok := templ.(tpl.TemplateInfoProvider); ok </span><span class="cov8" title="1">{
                info = ip.TemplateInfo()
        }</span>

        <span class="cov8" title="1">var w io.Writer

        if info.HasReturn </span><span class="cov0" title="0">{
                // Wrap the context sent to the template to capture the return value.
                // Note that the template is rewritten to make sure that the dot (".")
                // and the $ variable points to Arg.
                context = &amp;contextWrapper{
                        Arg: context,
                }

                // We don't care about any template output.
                w = ioutil.Discard
        }</span> else<span class="cov8" title="1"> {
                b := bp.GetBuffer()
                defer bp.PutBuffer(b)
                w = b
        }</span>

        <span class="cov8" title="1">if err := templ.Execute(w, context); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">var result interface{}

        if ctx, ok := context.(*contextWrapper); ok </span><span class="cov0" title="0">{
                result = ctx.Result
        }</span> else<span class="cov8" title="1"> if _, ok := templ.(*texttemplate.Template); ok </span><span class="cov0" title="0">{
                result = w.(fmt.Stringer).String()
        }</span> else<span class="cov8" title="1"> {
                result = template.HTML(w.(fmt.Stringer).String())
        }</span>

        <span class="cov8" title="1">if ns.deps.Metrics != nil </span><span class="cov0" title="0">{
                ns.deps.Metrics.TrackValue(n, result)
        }</span>

        <span class="cov8" title="1">return result, nil</span>

}

// IncludeCached executes and caches partial templates.  An optional variant
// string parameter (a string slice actually, but be only use a variadic
// argument to make it optional) can be passed so that a given partial can have
// multiple uses. The cache is created with name+variant as the key.
func (ns *Namespace) IncludeCached(name string, context interface{}, variant ...string) (interface{}, error) <span class="cov8" title="1">{
        key := name
        if len(variant) &gt; 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(variant); i++ </span><span class="cov0" title="0">{
                        key += variant[i]
                }</span>
        }
        <span class="cov8" title="1">return ns.getOrCreate(key, name, context)</span>
}

func (ns *Namespace) getOrCreate(key, name string, context interface{}) (interface{}, error) <span class="cov8" title="1">{

        ns.cachedPartials.RLock()
        p, ok := ns.cachedPartials.p[key]
        ns.cachedPartials.RUnlock()

        if ok </span><span class="cov8" title="1">{
                return p, nil
        }</span>

        <span class="cov8" title="1">p, err := ns.Include(name, context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ns.cachedPartials.Lock()
        defer ns.cachedPartials.Unlock()
        // Double-check.
        if p2, ok := ns.cachedPartials.p[key]; ok </span><span class="cov8" title="1">{
                return p2, nil
        }</span>
        <span class="cov8" title="1">ns.cachedPartials.p[key] = p

        return p, nil</span>
}
</pre>
		
		<pre class="file" id="file260" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package path

import (
        "fmt"
        "path/filepath"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "path"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Split,
                        nil,
                        [][2]string{
                                {`{{ "/my/path/filename.txt" | path.Split }}`, `/my/path/|filename.txt`},
                                {fmt.Sprintf(`{{ %q | path.Split }}`, filepath.FromSlash("/my/path/filename.txt")), `/my/path/|filename.txt`},
                        },
                )

                testDir := filepath.Join("my", "path")
                testFile := filepath.Join(testDir, "filename.txt")

                ns.AddMethodMapping(ctx.Join,
                        nil,
                        [][2]string{
                                {fmt.Sprintf(`{{ slice %q "filename.txt" | path.Join  }}`, testDir), `my/path/filename.txt`},
                                {`{{  path.Join "my" "path" "filename.txt" }}`, `my/path/filename.txt`},
                                {fmt.Sprintf(`{{ %q | path.Ext  }}`, testFile), `.txt`},
                                {fmt.Sprintf(`{{ %q | path.Base  }}`, testFile), `filename.txt`},
                                {fmt.Sprintf(`{{ %q | path.Dir  }}`, testFile), `my/path`},
                        },
                )

                return ns</span>

        }
        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file261" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package path provides template functions for manipulating paths.
package path

import (
        "fmt"
        _path "path"
        "path/filepath"

        "github.com/gohugoio/hugo/deps"
        "github.com/spf13/cast"
)

// New returns a new instance of the path-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                deps: deps,
        }
}</span>

// Namespace provides template functions for the "os" namespace.
type Namespace struct {
        deps *deps.Deps
}

// DirFile holds the result from path.Split.
type DirFile struct {
        Dir  string
        File string
}

// Used in test.
func (df DirFile) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s|%s", df.Dir, df.File)
}</span>

// Ext returns the file name extension used by path.
// The extension is the suffix beginning at the final dot
// in the final slash-separated element of path;
// it is empty if there is no dot.
// The input path is passed into filepath.ToSlash converting any Windows slashes
// to forward slashes.
func (ns *Namespace) Ext(path interface{}) (string, error) <span class="cov0" title="0">{
        spath, err := cast.ToStringE(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">spath = filepath.ToSlash(spath)
        return _path.Ext(spath), nil</span>
}

// Dir returns all but the last element of path, typically the path's directory.
// After dropping the final element using Split, the path is Cleaned and trailing
// slashes are removed.
// If the path is empty, Dir returns ".".
// If the path consists entirely of slashes followed by non-slash bytes, Dir
// returns a single slash. In any other case, the returned path does not end in a
// slash.
// The input path is passed into filepath.ToSlash converting any Windows slashes
// to forward slashes.
func (ns *Namespace) Dir(path interface{}) (string, error) <span class="cov0" title="0">{
        spath, err := cast.ToStringE(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">spath = filepath.ToSlash(spath)
        return _path.Dir(spath), nil</span>
}

// Base returns the last element of path.
// Trailing slashes are removed before extracting the last element.
// If the path is empty, Base returns ".".
// If the path consists entirely of slashes, Base returns "/".
// The input path is passed into filepath.ToSlash converting any Windows slashes
// to forward slashes.
func (ns *Namespace) Base(path interface{}) (string, error) <span class="cov0" title="0">{
        spath, err := cast.ToStringE(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">spath = filepath.ToSlash(spath)
        return _path.Base(spath), nil</span>
}

// Split splits path immediately following the final slash,
// separating it into a directory and file name component.
// If there is no slash in path, Split returns an empty dir and
// file set to path.
// The input path is passed into filepath.ToSlash converting any Windows slashes
// to forward slashes.
// The returned values have the property that path = dir+file.
func (ns *Namespace) Split(path interface{}) (DirFile, error) <span class="cov0" title="0">{
        spath, err := cast.ToStringE(path)
        if err != nil </span><span class="cov0" title="0">{
                return DirFile{}, err
        }</span>
        <span class="cov0" title="0">spath = filepath.ToSlash(spath)
        dir, file := _path.Split(spath)

        return DirFile{Dir: dir, File: file}, nil</span>
}

// Join joins any number of path elements into a single path, adding a
// separating slash if necessary. All the input
// path elements are passed into filepath.ToSlash converting any Windows slashes
// to forward slashes.
// The result is Cleaned; in particular,
// all empty strings are ignored.
func (ns *Namespace) Join(elements ...interface{}) (string, error) <span class="cov0" title="0">{
        var pathElements []string
        for _, elem := range elements </span><span class="cov0" title="0">{
                switch v := elem.(type) </span>{
                case []string:<span class="cov0" title="0">
                        for _, e := range v </span><span class="cov0" title="0">{
                                pathElements = append(pathElements, filepath.ToSlash(e))
                        }</span>
                case []interface{}:<span class="cov0" title="0">
                        for _, e := range v </span><span class="cov0" title="0">{
                                elemStr, err := cast.ToStringE(e)
                                if err != nil </span><span class="cov0" title="0">{
                                        return "", err
                                }</span>
                                <span class="cov0" title="0">pathElements = append(pathElements, filepath.ToSlash(elemStr))</span>
                        }
                default:<span class="cov0" title="0">
                        elemStr, err := cast.ToStringE(elem)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">pathElements = append(pathElements, filepath.ToSlash(elemStr))</span>
                }
        }
        <span class="cov0" title="0">return _path.Join(pathElements...), nil</span>
}
</pre>
		
		<pre class="file" id="file262" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package reflect provides template functions for run-time object reflection.
package reflect

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "reflect"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.IsMap,
                        nil,
                        [][2]string{
                                {`{{ if reflect.IsMap (dict "a" 1) }}Map{{ end }}`, `Map`},
                        },
                )

                ns.AddMethodMapping(ctx.IsSlice,
                        nil,
                        [][2]string{
                                {`{{ if reflect.IsSlice (slice 1 2 3) }}Slice{{ end }}`, `Slice`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file263" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package reflect

import (
        "reflect"
)

// New returns a new instance of the reflect-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "reflect" namespace.
type Namespace struct{}

// IsMap reports whether v is a map.
func (ns *Namespace) IsMap(v interface{}) bool <span class="cov0" title="0">{
        return reflect.ValueOf(v).Kind() == reflect.Map
}</span>

// IsSlice reports whether v is a slice.
func (ns *Namespace) IsSlice(v interface{}) bool <span class="cov0" title="0">{
        return reflect.ValueOf(v).Kind() == reflect.Slice
}</span>
</pre>
		
		<pre class="file" id="file264" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "resources"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx, err := New(d)
                if err != nil </span><span class="cov0" title="0">{
                        // TODO(bep) no panic.
                        panic(err)</span>
                }

                <span class="cov8" title="1">ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Get,
                        nil,
                        [][2]string{},
                )

                // Add aliases for the most common transformations.

                ns.AddMethodMapping(ctx.Fingerprint,
                        []string{"fingerprint"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Minify,
                        []string{"minify"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.ToCSS,
                        []string{"toCSS"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.PostCSS,
                        []string{"postCSS"},
                        [][2]string{},
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file265" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package resources provides template functions for working with resources.
package resources

import (
        "errors"
        "fmt"
        "path/filepath"

        _errors "github.com/pkg/errors"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"

        "github.com/gohugoio/hugo/resources/resource_factories/bundler"
        "github.com/gohugoio/hugo/resources/resource_factories/create"
        "github.com/gohugoio/hugo/resources/resource_transformers/integrity"
        "github.com/gohugoio/hugo/resources/resource_transformers/minifier"
        "github.com/gohugoio/hugo/resources/resource_transformers/postcss"
        "github.com/gohugoio/hugo/resources/resource_transformers/templates"
        "github.com/gohugoio/hugo/resources/resource_transformers/tocss/scss"
        "github.com/spf13/cast"
)

// New returns a new instance of the resources-namespaced template functions.
func New(deps *deps.Deps) (*Namespace, error) <span class="cov8" title="1">{
        if deps.ResourceSpec == nil </span><span class="cov0" title="0">{
                return &amp;Namespace{}, nil
        }</span>

        <span class="cov8" title="1">scssClient, err := scss.New(deps.BaseFs.Assets, deps.ResourceSpec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;Namespace{
                deps:            deps,
                scssClient:      scssClient,
                createClient:    create.New(deps.ResourceSpec),
                bundlerClient:   bundler.New(deps.ResourceSpec),
                integrityClient: integrity.New(deps.ResourceSpec),
                minifyClient:    minifier.New(deps.ResourceSpec),
                postcssClient:   postcss.New(deps.ResourceSpec),
                templatesClient: templates.New(deps.ResourceSpec, deps.TextTmpl),
        }, nil</span>
}

// Namespace provides template functions for the "resources" namespace.
type Namespace struct {
        deps *deps.Deps

        createClient    *create.Client
        bundlerClient   *bundler.Client
        scssClient      *scss.Client
        integrityClient *integrity.Client
        minifyClient    *minifier.Client
        postcssClient   *postcss.Client
        templatesClient *templates.Client
}

// Get locates the filename given in Hugo's assets filesystem
// and creates a Resource object that can be used for further transformations.
func (ns *Namespace) Get(filename interface{}) (resource.Resource, error) <span class="cov0" title="0">{
        filenamestr, err := cast.ToStringE(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filenamestr = filepath.Clean(filenamestr)

        return ns.createClient.Get(filenamestr)</span>

}

// GetMatch finds the first Resource matching the given pattern, or nil if none found.
//
// It looks for files in the assets file system.
//
// See Match for a more complete explanation about the rules used.
func (ns *Namespace) GetMatch(pattern interface{}) (resource.Resource, error) <span class="cov0" title="0">{
        patternStr, err := cast.ToStringE(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ns.createClient.GetMatch(patternStr)</span>

}

// Match gets all resources matching the given base path prefix, e.g
// "*.png" will match all png files. The "*" does not match path delimiters (/),
// so if you organize your resources in sub-folders, you need to be explicit about it, e.g.:
// "images/*.png". To match any PNG image anywhere in the bundle you can do "**.png", and
// to match all PNG images below the images folder, use "images/**.jpg".
//
// The matching is case insensitive.
//
// Match matches by using the files name with path relative to the file system root
// with Unix style slashes (/) and no leading slash, e.g. "images/logo.png".
//
// See https://github.com/gobwas/glob for the full rules set.
//
// It looks for files in the assets file system.
//
// See Match for a more complete explanation about the rules used.
func (ns *Namespace) Match(pattern interface{}) (resource.Resources, error) <span class="cov0" title="0">{
        patternStr, err := cast.ToStringE(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ns.createClient.Match(patternStr)</span>
}

// Concat concatenates a slice of Resource objects. These resources must
// (currently) be of the same Media Type.
func (ns *Namespace) Concat(targetPathIn interface{}, r interface{}) (resource.Resource, error) <span class="cov0" title="0">{
        targetPath, err := cast.ToStringE(targetPathIn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var rr resource.Resources

        switch v := r.(type) </span>{
        case resource.Resources:<span class="cov0" title="0">
                rr = v</span>
        case resource.ResourcesConverter:<span class="cov0" title="0">
                rr = v.ToResources()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("slice %T not supported in concat", r)</span>
        }

        <span class="cov0" title="0">if len(rr) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("must provide one or more Resource objects to concat")
        }</span>

        <span class="cov0" title="0">return ns.bundlerClient.Concat(targetPath, rr)</span>
}

// FromString creates a Resource from a string published to the relative target path.
func (ns *Namespace) FromString(targetPathIn, contentIn interface{}) (resource.Resource, error) <span class="cov0" title="0">{
        targetPath, err := cast.ToStringE(targetPathIn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">content, err := cast.ToStringE(contentIn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ns.createClient.FromString(targetPath, content)</span>
}

// ExecuteAsTemplate creates a Resource from a Go template, parsed and executed with
// the given data, and published to the relative target path.
func (ns *Namespace) ExecuteAsTemplate(args ...interface{}) (resource.Resource, error) <span class="cov0" title="0">{
        if len(args) != 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("must provide targetPath, the template data context and a Resource object")
        }</span>
        <span class="cov0" title="0">targetPath, err := cast.ToStringE(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">data := args[1]

        r, ok := args[2].(resources.ResourceTransformer)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("type %T not supported in Resource transformations", args[2])
        }</span>

        <span class="cov0" title="0">return ns.templatesClient.ExecuteAsTemplate(r, targetPath, data)</span>
}

// Fingerprint transforms the given Resource with a MD5 hash of the content in
// the RelPermalink and Permalink.
func (ns *Namespace) Fingerprint(args ...interface{}) (resource.Resource, error) <span class="cov0" title="0">{
        if len(args) &lt; 1 || len(args) &gt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("must provide a Resource and (optional) crypto algo")
        }</span>

        <span class="cov0" title="0">var algo string
        resIdx := 0

        if len(args) == 2 </span><span class="cov0" title="0">{
                resIdx = 1
                var err error
                algo, err = cast.ToStringE(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">r, ok := args[resIdx].(resources.ResourceTransformer)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%T can not be transformed", args[resIdx])
        }</span>

        <span class="cov0" title="0">return ns.integrityClient.Fingerprint(r, algo)</span>
}

// Minify minifies the given Resource using the MediaType to pick the correct
// minifier.
func (ns *Namespace) Minify(r resources.ResourceTransformer) (resource.Resource, error) <span class="cov0" title="0">{
        return ns.minifyClient.Minify(r)
}</span>

// ToCSS converts the given Resource to CSS. You can optional provide an Options
// object or a target path (string) as first argument.
func (ns *Namespace) ToCSS(args ...interface{}) (resource.Resource, error) <span class="cov0" title="0">{
        var (
                r          resources.ResourceTransformer
                m          map[string]interface{}
                targetPath string
                err        error
                ok         bool
        )

        r, targetPath, ok = ns.resolveIfFirstArgIsString(args)

        if !ok </span><span class="cov0" title="0">{
                r, m, err = ns.resolveArgs(args)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var options scss.Options
        if targetPath != "" </span><span class="cov0" title="0">{
                options.TargetPath = targetPath
        }</span> else<span class="cov0" title="0"> if m != nil </span><span class="cov0" title="0">{
                options, err = scss.DecodeOptions(m)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return ns.scssClient.ToCSS(r, options)</span>
}

// PostCSS processes the given Resource with PostCSS
func (ns *Namespace) PostCSS(args ...interface{}) (resource.Resource, error) <span class="cov0" title="0">{
        r, m, err := ns.resolveArgs(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var options postcss.Options
        if m != nil </span><span class="cov0" title="0">{
                options, err = postcss.DecodeOptions(m)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return ns.postcssClient.Process(r, options)</span>
}

// We allow string or a map as the first argument in some cases.
func (ns *Namespace) resolveIfFirstArgIsString(args []interface{}) (resources.ResourceTransformer, string, bool) <span class="cov0" title="0">{
        if len(args) != 2 </span><span class="cov0" title="0">{
                return nil, "", false
        }</span>

        <span class="cov0" title="0">v1, ok1 := args[0].(string)
        if !ok1 </span><span class="cov0" title="0">{
                return nil, "", false
        }</span>
        <span class="cov0" title="0">v2, ok2 := args[1].(resources.ResourceTransformer)

        return v2, v1, ok2</span>
}

// This roundabout way of doing it is needed to get both pipeline behaviour and options as arguments.
func (ns *Namespace) resolveArgs(args []interface{}) (resources.ResourceTransformer, map[string]interface{}, error) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return nil, nil, errors.New("no Resource provided in transformation")
        }</span>

        <span class="cov0" title="0">if len(args) == 1 </span><span class="cov0" title="0">{
                r, ok := args[0].(resources.ResourceTransformer)
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("type %T not supported in Resource transformations", args[0])
                }</span>
                <span class="cov0" title="0">return r, nil, nil</span>
        }

        <span class="cov0" title="0">r, ok := args[1].(resources.ResourceTransformer)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("type %T not supported in Resource transformations", args[0])
        }</span>

        <span class="cov0" title="0">m, err := cast.ToStringMapE(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, _errors.Wrap(err, "invalid options type")
        }</span>

        <span class="cov0" title="0">return r, m, nil</span>
}
</pre>
		
		<pre class="file" id="file266" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package safe

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "safe"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.CSS,
                        []string{"safeCSS"},
                        [][2]string{
                                {`{{ "Bat&amp;Man" | safeCSS | safeCSS }}`, `Bat&amp;amp;Man`},
                        },
                )

                ns.AddMethodMapping(ctx.HTML,
                        []string{"safeHTML"},
                        [][2]string{
                                {`{{ "Bat&amp;Man" | safeHTML | safeHTML }}`, `Bat&amp;Man`},
                                {`{{ "Bat&amp;Man" | safeHTML }}`, `Bat&amp;Man`},
                        },
                )

                ns.AddMethodMapping(ctx.HTMLAttr,
                        []string{"safeHTMLAttr"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.JS,
                        []string{"safeJS"},
                        [][2]string{
                                {`{{ "(1*2)" | safeJS | safeJS }}`, `(1*2)`},
                        },
                )

                ns.AddMethodMapping(ctx.JSStr,
                        []string{"safeJSStr"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.URL,
                        []string{"safeURL"},
                        [][2]string{
                                {`{{ "http://gohugo.io" | safeURL | safeURL }}`, `http://gohugo.io`},
                        },
                )

                ns.AddMethodMapping(ctx.SanitizeURL,
                        []string{"sanitizeURL", "sanitizeurl"},
                        [][2]string{},
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file267" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package safe provides template functions for escaping untrusted content or
// encapsulating trusted content.
package safe

import (
        "html/template"

        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/cast"
)

// New returns a new instance of the safe-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "safe" namespace.
type Namespace struct{}

// CSS returns a given string as html/template CSS content.
func (ns *Namespace) CSS(a interface{}) (template.CSS, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        return template.CSS(s), err
}</span>

// HTML returns a given string as html/template HTML content.
func (ns *Namespace) HTML(a interface{}) (template.HTML, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(a)
        return template.HTML(s), err
}</span>

// HTMLAttr returns a given string as html/template HTMLAttr content.
func (ns *Namespace) HTMLAttr(a interface{}) (template.HTMLAttr, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(a)
        return template.HTMLAttr(s), err
}</span>

// JS returns the given string as a html/template JS content.
func (ns *Namespace) JS(a interface{}) (template.JS, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        return template.JS(s), err
}</span>

// JSStr returns the given string as a html/template JSStr content.
func (ns *Namespace) JSStr(a interface{}) (template.JSStr, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        return template.JSStr(s), err
}</span>

// URL returns a given string as html/template URL content.
func (ns *Namespace) URL(a interface{}) (template.URL, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        return template.URL(s), err
}</span>

// SanitizeURL returns a given string as html/template URL content.
func (ns *Namespace) SanitizeURL(a interface{}) (string, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        return helpers.SanitizeURL(s), err
}</span>
</pre>
		
		<pre class="file" id="file268" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package site provides template functions for accessing the Site object.
package site

import (
        "github.com/gohugoio/hugo/deps"

        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "site"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{

                s := d.Site
                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return s }</span>,
                }

                <span class="cov8" title="1">if s == nil </span><span class="cov0" title="0">{
                        panic("no Site")</span>
                }

                // We just add the Site as the namespace here. No method mappings.

                <span class="cov8" title="1">return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file269" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package strings

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "strings"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Chomp,
                        []string{"chomp"},
                        [][2]string{
                                {`{{chomp "&lt;p&gt;Blockhead&lt;/p&gt;\n" | safeHTML }}`, `&lt;p&gt;Blockhead&lt;/p&gt;`},
                        },
                )

                ns.AddMethodMapping(ctx.CountRunes,
                        []string{"countrunes"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.RuneCount,
                        nil,
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.CountWords,
                        []string{"countwords"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.FindRE,
                        []string{"findRE"},
                        [][2]string{
                                {
                                        `{{ findRE "[G|g]o" "Hugo is a static side generator written in Go." "1" }}`,
                                        `[go]`},
                        },
                )

                ns.AddMethodMapping(ctx.HasPrefix,
                        []string{"hasPrefix"},
                        [][2]string{
                                {`{{ hasPrefix "Hugo" "Hu" }}`, `true`},
                                {`{{ hasPrefix "Hugo" "Fu" }}`, `false`},
                        },
                )

                ns.AddMethodMapping(ctx.ToLower,
                        []string{"lower"},
                        [][2]string{
                                {`{{lower "BatMan"}}`, `batman`},
                        },
                )

                ns.AddMethodMapping(ctx.Replace,
                        []string{"replace"},
                        [][2]string{
                                {
                                        `{{ replace "Batman and Robin" "Robin" "Catwoman" }}`,
                                        `Batman and Catwoman`},
                        },
                )

                ns.AddMethodMapping(ctx.ReplaceRE,
                        []string{"replaceRE"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.SliceString,
                        []string{"slicestr"},
                        [][2]string{
                                {`{{slicestr "BatMan" 0 3}}`, `Bat`},
                                {`{{slicestr "BatMan" 3}}`, `Man`},
                        },
                )

                ns.AddMethodMapping(ctx.Split,
                        []string{"split"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Substr,
                        []string{"substr"},
                        [][2]string{
                                {`{{substr "BatMan" 0 -3}}`, `Bat`},
                                {`{{substr "BatMan" 3 3}}`, `Man`},
                        },
                )

                ns.AddMethodMapping(ctx.Trim,
                        []string{"trim"},
                        [][2]string{
                                {`{{ trim "++Batman--" "+-" }}`, `Batman`},
                        },
                )

                ns.AddMethodMapping(ctx.TrimLeft,
                        nil,
                        [][2]string{
                                {`{{ "aabbaa" | strings.TrimLeft "a" }}`, `bbaa`},
                        },
                )

                ns.AddMethodMapping(ctx.TrimPrefix,
                        nil,
                        [][2]string{
                                {`{{ "aabbaa" | strings.TrimPrefix "a" }}`, `abbaa`},
                                {`{{ "aabbaa" | strings.TrimPrefix "aa" }}`, `bbaa`},
                        },
                )

                ns.AddMethodMapping(ctx.TrimRight,
                        nil,
                        [][2]string{
                                {`{{ "aabbaa" | strings.TrimRight "a" }}`, `aabb`},
                        },
                )

                ns.AddMethodMapping(ctx.TrimSuffix,
                        nil,
                        [][2]string{
                                {`{{ "aabbaa" | strings.TrimSuffix "a" }}`, `aabba`},
                                {`{{ "aabbaa" | strings.TrimSuffix "aa" }}`, `aabb`},
                        },
                )

                ns.AddMethodMapping(ctx.Title,
                        []string{"title"},
                        [][2]string{
                                {`{{title "Bat man"}}`, `Bat Man`},
                                {`{{title "somewhere over the rainbow"}}`, `Somewhere Over the Rainbow`},
                        },
                )

                ns.AddMethodMapping(ctx.FirstUpper,
                        nil,
                        [][2]string{
                                {`{{ "hugo rocks!" | strings.FirstUpper }}`, `Hugo rocks!`},
                        },
                )

                ns.AddMethodMapping(ctx.Truncate,
                        []string{"truncate"},
                        [][2]string{
                                {`{{ "this is a very long text" | truncate 10 " ..." }}`, `this is a ...`},
                                {`{{ "With [Markdown](/markdown) inside." | markdownify | truncate 14 }}`, `With &lt;a href="/markdown"&gt;Markdown &lt;/a&gt;`},
                        },
                )

                ns.AddMethodMapping(ctx.Repeat,
                        nil,
                        [][2]string{
                                {`{{ "yo" | strings.Repeat 4 }}`, `yoyoyoyo`},
                        },
                )

                ns.AddMethodMapping(ctx.ToUpper,
                        []string{"upper"},
                        [][2]string{
                                {`{{upper "BatMan"}}`, `BATMAN`},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file270" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package strings

import (
        "regexp"
        "sync"

        "github.com/spf13/cast"
)

// FindRE returns a list of strings that match the regular expression. By default all matches
// will be included. The number of matches can be limited with an optional third parameter.
func (ns *Namespace) FindRE(expr string, content interface{}, limit ...interface{}) ([]string, error) <span class="cov0" title="0">{
        re, err := reCache.Get(expr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">conv, err := cast.ToStringE(content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(limit) == 0 </span><span class="cov0" title="0">{
                return re.FindAllString(conv, -1), nil
        }</span>

        <span class="cov0" title="0">lim, err := cast.ToIntE(limit[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return re.FindAllString(conv, lim), nil</span>
}

// ReplaceRE returns a copy of s, replacing all matches of the regular
// expression pattern with the replacement text repl.
func (ns *Namespace) ReplaceRE(pattern, repl, s interface{}) (_ string, err error) <span class="cov0" title="0">{
        sp, err := cast.ToStringE(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">sr, err := cast.ToStringE(repl)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">re, err := reCache.Get(sp)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return re.ReplaceAllString(ss, sr), nil</span>
}

// regexpCache represents a cache of regexp objects protected by a mutex.
type regexpCache struct {
        mu sync.RWMutex
        re map[string]*regexp.Regexp
}

// Get retrieves a regexp object from the cache based upon the pattern.
// If the pattern is not found in the cache, create one
func (rc *regexpCache) Get(pattern string) (re *regexp.Regexp, err error) <span class="cov0" title="0">{
        var ok bool

        if re, ok = rc.get(pattern); !ok </span><span class="cov0" title="0">{
                re, err = regexp.Compile(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">rc.set(pattern, re)</span>
        }

        <span class="cov0" title="0">return re, nil</span>
}

func (rc *regexpCache) get(key string) (re *regexp.Regexp, ok bool) <span class="cov0" title="0">{
        rc.mu.RLock()
        re, ok = rc.re[key]
        rc.mu.RUnlock()
        return
}</span>

func (rc *regexpCache) set(key string, re *regexp.Regexp) <span class="cov0" title="0">{
        rc.mu.Lock()
        rc.re[key] = re
        rc.mu.Unlock()
}</span>

var reCache = regexpCache{re: make(map[string]*regexp.Regexp)}
</pre>
		
		<pre class="file" id="file271" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package strings provides template functions for manipulating strings.
package strings

import (
        "errors"
        "fmt"
        "html/template"
        _strings "strings"
        "unicode/utf8"

        _errors "github.com/pkg/errors"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/cast"
)

// New returns a new instance of the strings-namespaced template functions.
func New(d *deps.Deps) *Namespace <span class="cov8" title="1">{
        titleCaseStyle := d.Cfg.GetString("titleCaseStyle")
        titleFunc := helpers.GetTitleFunc(titleCaseStyle)
        return &amp;Namespace{deps: d, titleFunc: titleFunc}
}</span>

// Namespace provides template functions for the "strings" namespace.
// Most functions mimic the Go stdlib, but the order of the parameters may be
// different to ease their use in the Go template system.
type Namespace struct {
        titleFunc func(s string) string
        deps      *deps.Deps
}

// CountRunes returns the number of runes in s, excluding whitepace.
func (ns *Namespace) CountRunes(s interface{}) (int, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return 0, _errors.Wrap(err, "Failed to convert content to string")
        }</span>

        <span class="cov0" title="0">counter := 0
        for _, r := range helpers.StripHTML(ss) </span><span class="cov0" title="0">{
                if !helpers.IsWhitespace(r) </span><span class="cov0" title="0">{
                        counter++
                }</span>
        }

        <span class="cov0" title="0">return counter, nil</span>
}

// RuneCount returns the number of runes in s.
func (ns *Namespace) RuneCount(s interface{}) (int, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return 0, _errors.Wrap(err, "Failed to convert content to string")
        }</span>
        <span class="cov0" title="0">return utf8.RuneCountInString(ss), nil</span>
}

// CountWords returns the approximate word count in s.
func (ns *Namespace) CountWords(s interface{}) (int, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return 0, _errors.Wrap(err, "Failed to convert content to string")
        }</span>

        <span class="cov0" title="0">counter := 0
        for _, word := range _strings.Fields(helpers.StripHTML(ss)) </span><span class="cov0" title="0">{
                runeCount := utf8.RuneCountInString(word)
                if len(word) == runeCount </span><span class="cov0" title="0">{
                        counter++
                }</span> else<span class="cov0" title="0"> {
                        counter += runeCount
                }</span>
        }

        <span class="cov0" title="0">return counter, nil</span>
}

// Chomp returns a copy of s with all trailing newline characters removed.
func (ns *Namespace) Chomp(s interface{}) (interface{}, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">res := _strings.TrimRight(ss, "\r\n")
        switch s.(type) </span>{
        case template.HTML:<span class="cov0" title="0">
                return template.HTML(res), nil</span>
        default:<span class="cov0" title="0">
                return res, nil</span>
        }

}

// Contains reports whether substr is in s.
func (ns *Namespace) Contains(s, substr interface{}) (bool, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">su, err := cast.ToStringE(substr)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return _strings.Contains(ss, su), nil</span>
}

// ContainsAny reports whether any Unicode code points in chars are within s.
func (ns *Namespace) ContainsAny(s, chars interface{}) (bool, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">sc, err := cast.ToStringE(chars)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return _strings.ContainsAny(ss, sc), nil</span>
}

// HasPrefix tests whether the input s begins with prefix.
func (ns *Namespace) HasPrefix(s, prefix interface{}) (bool, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">sx, err := cast.ToStringE(prefix)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return _strings.HasPrefix(ss, sx), nil</span>
}

// HasSuffix tests whether the input s begins with suffix.
func (ns *Namespace) HasSuffix(s, suffix interface{}) (bool, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">sx, err := cast.ToStringE(suffix)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return _strings.HasSuffix(ss, sx), nil</span>
}

// Replace returns a copy of the string s with all occurrences of old replaced
// with new.
func (ns *Namespace) Replace(s, old, new interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">so, err := cast.ToStringE(old)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">sn, err := cast.ToStringE(new)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return _strings.Replace(ss, so, sn, -1), nil</span>
}

// SliceString slices a string by specifying a half-open range with
// two indices, start and end. 1 and 4 creates a slice including elements 1 through 3.
// The end index can be omitted, it defaults to the string's length.
func (ns *Namespace) SliceString(a interface{}, startEnd ...interface{}) (string, error) <span class="cov0" title="0">{
        aStr, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var argStart, argEnd int

        argNum := len(startEnd)

        if argNum &gt; 0 </span><span class="cov0" title="0">{
                if argStart, err = cast.ToIntE(startEnd[0]); err != nil </span><span class="cov0" title="0">{
                        return "", errors.New("start argument must be integer")
                }</span>
        }
        <span class="cov0" title="0">if argNum &gt; 1 </span><span class="cov0" title="0">{
                if argEnd, err = cast.ToIntE(startEnd[1]); err != nil </span><span class="cov0" title="0">{
                        return "", errors.New("end argument must be integer")
                }</span>
        }

        <span class="cov0" title="0">if argNum &gt; 2 </span><span class="cov0" title="0">{
                return "", errors.New("too many arguments")
        }</span>

        <span class="cov0" title="0">asRunes := []rune(aStr)

        if argNum &gt; 0 &amp;&amp; (argStart &lt; 0 || argStart &gt;= len(asRunes)) </span><span class="cov0" title="0">{
                return "", errors.New("slice bounds out of range")
        }</span>

        <span class="cov0" title="0">if argNum == 2 </span><span class="cov0" title="0">{
                if argEnd &lt; 0 || argEnd &gt; len(asRunes) </span><span class="cov0" title="0">{
                        return "", errors.New("slice bounds out of range")
                }</span>
                <span class="cov0" title="0">return string(asRunes[argStart:argEnd]), nil</span>
        } else<span class="cov0" title="0"> if argNum == 1 </span><span class="cov0" title="0">{
                return string(asRunes[argStart:]), nil
        }</span> else<span class="cov0" title="0"> {
                return string(asRunes[:]), nil
        }</span>

}

// Split slices an input string into all substrings separated by delimiter.
func (ns *Namespace) Split(a interface{}, delimiter string) ([]string, error) <span class="cov0" title="0">{
        aStr, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span>

        <span class="cov0" title="0">return _strings.Split(aStr, delimiter), nil</span>
}

// Substr extracts parts of a string, beginning at the character at the specified
// position, and returns the specified number of characters.
//
// It normally takes two parameters: start and length.
// It can also take one parameter: start, i.e. length is omitted, in which case
// the substring starting from start until the end of the string will be returned.
//
// To extract characters from the end of the string, use a negative start number.
//
// In addition, borrowing from the extended behavior described at http://php.net/substr,
// if length is given and is negative, then that many characters will be omitted from
// the end of string.
func (ns *Namespace) Substr(a interface{}, nums ...interface{}) (string, error) <span class="cov0" title="0">{
        aStr, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var start, length int

        asRunes := []rune(aStr)

        switch len(nums) </span>{
        case 0:<span class="cov0" title="0">
                return "", errors.New("too less arguments")</span>
        case 1:<span class="cov0" title="0">
                if start, err = cast.ToIntE(nums[0]); err != nil </span><span class="cov0" title="0">{
                        return "", errors.New("start argument must be integer")
                }</span>
                <span class="cov0" title="0">length = len(asRunes)</span>
        case 2:<span class="cov0" title="0">
                if start, err = cast.ToIntE(nums[0]); err != nil </span><span class="cov0" title="0">{
                        return "", errors.New("start argument must be integer")
                }</span>
                <span class="cov0" title="0">if length, err = cast.ToIntE(nums[1]); err != nil </span><span class="cov0" title="0">{
                        return "", errors.New("length argument must be integer")
                }</span>
        default:<span class="cov0" title="0">
                return "", errors.New("too many arguments")</span>
        }

        <span class="cov0" title="0">if start &lt; -len(asRunes) </span><span class="cov0" title="0">{
                start = 0
        }</span>
        <span class="cov0" title="0">if start &gt; len(asRunes) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("start position out of bounds for %d-byte string", len(aStr))
        }</span>

        <span class="cov0" title="0">var s, e int
        if start &gt;= 0 &amp;&amp; length &gt;= 0 </span><span class="cov0" title="0">{
                s = start
                e = start + length
        }</span> else<span class="cov0" title="0"> if start &lt; 0 &amp;&amp; length &gt;= 0 </span><span class="cov0" title="0">{
                s = len(asRunes) + start - length + 1
                e = len(asRunes) + start + 1
        }</span> else<span class="cov0" title="0"> if start &gt;= 0 &amp;&amp; length &lt; 0 </span><span class="cov0" title="0">{
                s = start
                e = len(asRunes) + length
        }</span> else<span class="cov0" title="0"> {
                s = len(asRunes) + start
                e = len(asRunes) + length
        }</span>

        <span class="cov0" title="0">if s &gt; e </span><span class="cov0" title="0">{
                return "", fmt.Errorf("calculated start position greater than end position: %d &gt; %d", s, e)
        }</span>
        <span class="cov0" title="0">if e &gt; len(asRunes) </span><span class="cov0" title="0">{
                e = len(asRunes)
        }</span>

        <span class="cov0" title="0">return string(asRunes[s:e]), nil</span>
}

// Title returns a copy of the input s with all Unicode letters that begin words
// mapped to their title case.
func (ns *Namespace) Title(s interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return ns.titleFunc(ss), nil</span>
}

// FirstUpper returns a string with the first character as upper case.
func (ns *Namespace) FirstUpper(s interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return helpers.FirstUpper(ss), nil</span>
}

// ToLower returns a copy of the input s with all Unicode letters mapped to their
// lower case.
func (ns *Namespace) ToLower(s interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return _strings.ToLower(ss), nil</span>
}

// ToUpper returns a copy of the input s with all Unicode letters mapped to their
// upper case.
func (ns *Namespace) ToUpper(s interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return _strings.ToUpper(ss), nil</span>
}

// Trim returns a string with all leading and trailing characters defined
// contained in cutset removed.
func (ns *Namespace) Trim(s, cutset interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">sc, err := cast.ToStringE(cutset)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return _strings.Trim(ss, sc), nil</span>
}

// TrimLeft returns a slice of the string s with all leading characters
// contained in cutset removed.
func (ns *Namespace) TrimLeft(cutset, s interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">sc, err := cast.ToStringE(cutset)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return _strings.TrimLeft(ss, sc), nil</span>
}

// TrimPrefix returns s without the provided leading prefix string. If s doesn't
// start with prefix, s is returned unchanged.
func (ns *Namespace) TrimPrefix(prefix, s interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">sx, err := cast.ToStringE(prefix)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return _strings.TrimPrefix(ss, sx), nil</span>
}

// TrimRight returns a slice of the string s with all trailing characters
// contained in cutset removed.
func (ns *Namespace) TrimRight(cutset, s interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">sc, err := cast.ToStringE(cutset)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return _strings.TrimRight(ss, sc), nil</span>
}

// TrimSuffix returns s without the provided trailing suffix string. If s
// doesn't end with suffix, s is returned unchanged.
func (ns *Namespace) TrimSuffix(suffix, s interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">sx, err := cast.ToStringE(suffix)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return _strings.TrimSuffix(ss, sx), nil</span>
}

// Repeat returns a new string consisting of count copies of the string s.
func (ns *Namespace) Repeat(n, s interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">sn, err := cast.ToIntE(n)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if sn &lt; 0 </span><span class="cov0" title="0">{
                return "", errors.New("strings: negative Repeat count")
        }</span>

        <span class="cov0" title="0">return _strings.Repeat(ss, sn), nil</span>
}
</pre>
		
		<pre class="file" id="file272" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package strings

import (
        "errors"
        "html"
        "html/template"
        "regexp"
        "unicode"
        "unicode/utf8"

        "github.com/spf13/cast"
)

var (
        tagRE        = regexp.MustCompile(`^&lt;(/)?([^ ]+?)(?:(\s*/)| .*?)?&gt;`)
        htmlSinglets = map[string]bool{
                "br": true, "col": true, "link": true,
                "base": true, "img": true, "param": true,
                "area": true, "hr": true, "input": true,
        }
)

type htmlTag struct {
        name    string
        pos     int
        openTag bool
}

// Truncate truncates a given string to the specified length.
func (ns *Namespace) Truncate(a interface{}, options ...interface{}) (template.HTML, error) <span class="cov0" title="0">{
        length, err := cast.ToIntE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">var textParam interface{}
        var ellipsis string

        switch len(options) </span>{
        case 0:<span class="cov0" title="0">
                return "", errors.New("truncate requires a length and a string")</span>
        case 1:<span class="cov0" title="0">
                textParam = options[0]
                ellipsis = " "</span>
        case 2:<span class="cov0" title="0">
                textParam = options[1]
                ellipsis, err = cast.ToStringE(options[0])
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.New("ellipsis must be a string")
                }</span>
                <span class="cov0" title="0">if _, ok := options[0].(template.HTML); !ok </span><span class="cov0" title="0">{
                        ellipsis = html.EscapeString(ellipsis)
                }</span>
        default:<span class="cov0" title="0">
                return "", errors.New("too many arguments passed to truncate")</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("text to truncate must be a string")
        }</span>
        <span class="cov0" title="0">text, err := cast.ToStringE(textParam)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("text must be a string")
        }</span>

        <span class="cov0" title="0">_, isHTML := textParam.(template.HTML)

        if utf8.RuneCountInString(text) &lt;= length </span><span class="cov0" title="0">{
                if isHTML </span><span class="cov0" title="0">{
                        return template.HTML(text), nil
                }</span>
                <span class="cov0" title="0">return template.HTML(html.EscapeString(text)), nil</span>
        }

        <span class="cov0" title="0">tags := []htmlTag{}
        var lastWordIndex, lastNonSpace, currentLen, endTextPos, nextTag int

        for i, r := range text </span><span class="cov0" title="0">{
                if i &lt; nextTag </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if isHTML </span><span class="cov0" title="0">{
                        // Make sure we keep tag of HTML tags
                        slice := text[i:]
                        m := tagRE.FindStringSubmatchIndex(slice)
                        if len(m) &gt; 0 &amp;&amp; m[0] == 0 </span><span class="cov0" title="0">{
                                nextTag = i + m[1]
                                tagname := slice[m[4]:m[5]]
                                lastWordIndex = lastNonSpace
                                _, singlet := htmlSinglets[tagname]
                                if !singlet &amp;&amp; m[6] == -1 </span><span class="cov0" title="0">{
                                        tags = append(tags, htmlTag{name: tagname, pos: i, openTag: m[2] == -1})
                                }</span>

                                <span class="cov0" title="0">continue</span>
                        }
                }

                <span class="cov0" title="0">currentLen++
                if unicode.IsSpace(r) </span><span class="cov0" title="0">{
                        lastWordIndex = lastNonSpace
                }</span> else<span class="cov0" title="0"> if unicode.In(r, unicode.Han, unicode.Hangul, unicode.Hiragana, unicode.Katakana) </span><span class="cov0" title="0">{
                        lastWordIndex = i
                }</span> else<span class="cov0" title="0"> {
                        lastNonSpace = i + utf8.RuneLen(r)
                }</span>

                <span class="cov0" title="0">if currentLen &gt; length </span><span class="cov0" title="0">{
                        if lastWordIndex == 0 </span><span class="cov0" title="0">{
                                endTextPos = i
                        }</span> else<span class="cov0" title="0"> {
                                endTextPos = lastWordIndex
                        }</span>
                        <span class="cov0" title="0">out := text[0:endTextPos]
                        if isHTML </span><span class="cov0" title="0">{
                                out += ellipsis
                                // Close out any open HTML tags
                                var currentTag *htmlTag
                                for i := len(tags) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                        tag := tags[i]
                                        if tag.pos &gt;= endTextPos || currentTag != nil </span><span class="cov0" title="0">{
                                                if currentTag != nil &amp;&amp; currentTag.name == tag.name </span><span class="cov0" title="0">{
                                                        currentTag = nil
                                                }</span>
                                                <span class="cov0" title="0">continue</span>
                                        }

                                        <span class="cov0" title="0">if tag.openTag </span><span class="cov0" title="0">{
                                                out += ("&lt;/" + tag.name + "&gt;")
                                        }</span> else<span class="cov0" title="0"> {
                                                currentTag = &amp;tag
                                        }</span>
                                }

                                <span class="cov0" title="0">return template.HTML(out), nil</span>
                        }
                        <span class="cov0" title="0">return template.HTML(html.EscapeString(out) + ellipsis), nil</span>
                }
        }

        <span class="cov0" title="0">if isHTML </span><span class="cov0" title="0">{
                return template.HTML(text), nil
        }</span>
        <span class="cov0" title="0">return template.HTML(html.EscapeString(text)), nil</span>
}
</pre>
		
		<pre class="file" id="file273" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tpl

import (
        "fmt"
        "io"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/gohugoio/hugo/output"

        "github.com/gohugoio/hugo/common/herrors"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/spf13/afero"

        "html/template"
        texttemplate "text/template"
        "text/template/parse"

        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/metrics"
        "github.com/pkg/errors"
)

var (
        _ TemplateExecutor     = (*TemplateAdapter)(nil)
        _ TemplateInfoProvider = (*TemplateAdapter)(nil)
)

// TemplateHandler manages the collection of templates.
type TemplateHandler interface {
        TemplateFinder
        AddTemplate(name, tpl string) error
        AddLateTemplate(name, tpl string) error
        LoadTemplates(prefix string) error

        NewTextTemplate() TemplateParseFinder

        MarkReady() error
        RebuildClone()
}

// TemplateVariants describes the possible variants of a template.
// All of these may be empty.
type TemplateVariants struct {
        Language     string
        OutputFormat output.Format
}

// TemplateFinder finds templates.
type TemplateFinder interface {
        TemplateLookup
        TemplateLookupVariant
}

type TemplateLookup interface {
        Lookup(name string) (Template, bool)
}

type TemplateLookupVariant interface {
        // TODO(bep) this currently only works for shortcodes.
        // We may unify and expand this variant pattern to the
        // other templates, but we need this now for the shortcodes to
        // quickly determine if a shortcode has a template for a given
        // output format.
        // It returns the template, if it was found or not and if there are
        // alternative representations (output format, language).
        // We are currently only interested in output formats, so we should improve
        // this for speed.
        LookupVariant(name string, variants TemplateVariants) (Template, bool, bool)
}

// Template is the common interface between text/template and html/template.
type Template interface {
        Execute(wr io.Writer, data interface{}) error
        Name() string
}

// TemplateInfoProvider provides some contextual information about a template.
type TemplateInfoProvider interface {
        TemplateInfo() Info
}

// TemplateParser is used to parse ad-hoc templates, e.g. in the Resource chain.
type TemplateParser interface {
        Parse(name, tpl string) (Template, error)
}

// TemplateParseFinder provides both parsing and finding.
type TemplateParseFinder interface {
        TemplateParser
        TemplateFinder
}

// TemplateExecutor adds some extras to Template.
type TemplateExecutor interface {
        Template
        ExecuteToString(data interface{}) (string, error)
        Tree() string
}

// TemplateDebugger prints some debug info to stdoud.
type TemplateDebugger interface {
        Debug()
}

// TemplateAdapter implements the TemplateExecutor interface.
type TemplateAdapter struct {
        Template
        Metrics metrics.Provider

        Info Info

        // The filesystem where the templates are stored.
        Fs afero.Fs

        // Maps to base template if relevant.
        NameBaseTemplateName map[string]string
}

var baseOfRe = regexp.MustCompile("template: (.*?):")

func extractBaseOf(err string) string <span class="cov0" title="0">{
        m := baseOfRe.FindStringSubmatch(err)
        if len(m) == 2 </span><span class="cov0" title="0">{
                return m[1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Execute executes the current template. The actual execution is performed
// by the embedded text or html template, but we add an implementation here so
// we can add a timer for some metrics.
func (t *TemplateAdapter) Execute(w io.Writer, data interface{}) (execErr error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                // Panics in templates are a little bit too common (nil pointers etc.)
                // See https://github.com/gohugoio/hugo/issues/5327
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        execErr = t.addFileContext(t.Name(), fmt.Errorf(`panic in Execute: %s. See "https://github.com/gohugoio/hugo/issues/5327" for the reason why we cannot provide a better error message for this`, r))
                }</span>
        }()

        <span class="cov8" title="1">if t.Metrics != nil </span><span class="cov0" title="0">{
                defer t.Metrics.MeasureSince(t.Name(), time.Now())
        }</span>

        <span class="cov8" title="1">execErr = t.Template.Execute(w, data)
        if execErr != nil </span><span class="cov0" title="0">{
                execErr = t.addFileContext(t.Name(), execErr)
        }</span>

        <span class="cov8" title="1">return</span>
}

func (t *TemplateAdapter) TemplateInfo() Info <span class="cov8" title="1">{
        return t.Info
}</span>

// The identifiers may be truncated in the log, e.g.
// "executing "main" at &lt;$scaled.SRelPermalin...&gt;: can't evaluate field SRelPermalink in type *resource.Image"
var identifiersRe = regexp.MustCompile(`at \&lt;(.*?)(\.{3})?\&gt;:`)

func (t *TemplateAdapter) extractIdentifiers(line string) []string <span class="cov0" title="0">{
        m := identifiersRe.FindAllStringSubmatch(line, -1)
        identifiers := make([]string, len(m))
        for i := 0; i &lt; len(m); i++ </span><span class="cov0" title="0">{
                identifiers[i] = m[i][1]
        }</span>
        <span class="cov0" title="0">return identifiers</span>
}

func (t *TemplateAdapter) addFileContext(name string, inerr error) error <span class="cov0" title="0">{
        if strings.HasPrefix(t.Name(), "_internal") </span><span class="cov0" title="0">{
                return inerr
        }</span>

        <span class="cov0" title="0">f, realFilename, err := t.fileAndFilename(t.Name())
        if err != nil </span><span class="cov0" title="0">{
                return inerr

        }</span>
        <span class="cov0" title="0">defer f.Close()

        master, hasMaster := t.NameBaseTemplateName[name]

        ferr := errors.Wrap(inerr, "execute of template failed")

        // Since this can be a composite of multiple template files (single.html + baseof.html etc.)
        // we potentially need to look in both -- and cannot rely on line number alone.
        lineMatcher := func(m herrors.LineMatcher) bool </span><span class="cov0" title="0">{
                if m.Position.LineNumber != m.LineNumber </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if !hasMaster </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">identifiers := t.extractIdentifiers(m.Error.Error())

                for _, id := range identifiers </span><span class="cov0" title="0">{
                        if strings.Contains(m.Line, id) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov0" title="0">fe, ok := herrors.WithFileContext(ferr, realFilename, f, lineMatcher)
        if ok || !hasMaster </span><span class="cov0" title="0">{
                return fe
        }</span>

        // Try the base template if relevant
        <span class="cov0" title="0">f, realFilename, err = t.fileAndFilename(master)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        fe, ok = herrors.WithFileContext(ferr, realFilename, f, lineMatcher)

        if !ok </span><span class="cov0" title="0">{
                // Return the most specific.
                return ferr

        }</span>
        <span class="cov0" title="0">return fe</span>

}

func (t *TemplateAdapter) fileAndFilename(name string) (afero.File, string, error) <span class="cov0" title="0">{
        fs := t.Fs
        filename := filepath.FromSlash(name)

        fi, err := fs.Stat(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">fim := fi.(hugofs.FileMetaInfo)
        meta := fim.Meta()

        f, err := meta.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", errors.Wrapf(err, "failed to open template file %q:", filename)
        }</span>

        <span class="cov0" title="0">return f, meta.Filename(), nil</span>
}

// ExecuteToString executes the current template and returns the result as a
// string.
func (t *TemplateAdapter) ExecuteToString(data interface{}) (string, error) <span class="cov0" title="0">{
        b := bp.GetBuffer()
        defer bp.PutBuffer(b)
        if err := t.Execute(b, data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return b.String(), nil</span>
}

// Tree returns the template Parse tree as a string.
// Note: this isn't safe for parallel execution on the same template
// vs Lookup and Execute.
func (t *TemplateAdapter) Tree() string <span class="cov0" title="0">{
        var tree *parse.Tree
        switch tt := t.Template.(type) </span>{
        case *template.Template:<span class="cov0" title="0">
                tree = tt.Tree</span>
        case *texttemplate.Template:<span class="cov0" title="0">
                tree = tt.Tree</span>
        default:<span class="cov0" title="0">
                panic("Unknown template")</span>
        }

        <span class="cov0" title="0">if tree == nil || tree.Root == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">s := tree.Root.String()

        return s</span>
}

// TemplateFuncsGetter allows to get a map of functions.
type TemplateFuncsGetter interface {
        GetFuncs() map[string]interface{}
}

// TemplateTestMocker adds a way to override some template funcs during tests.
// The interface is named so it's not used in regular application code.
type TemplateTestMocker interface {
        SetFuncs(funcMap map[string]interface{})
}
</pre>
		
		<pre class="file" id="file274" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tpl

// Increments on breaking changes.
const TemplateVersion = 2

// Info holds some info extracted from a parsed template.
type Info struct {

        // Set for shortcode templates with any {{ .Inner }}
        IsInner bool

        // Set for partials with a return statement.
        HasReturn bool

        // Config extracted from template.
        Config Config
}

func (info Info) IsZero() bool <span class="cov8" title="1">{
        return info.Config.Version == 0
}</span>

type Config struct {
        Version int
}

var DefaultConfig = Config{
        Version: TemplateVersion,
}
</pre>
		
		<pre class="file" id="file275" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package templates

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "templates"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Exists,
                        nil,
                        [][2]string{{`{{ if (templates.Exists "partials/header.html") }}Yes!{{ end }}`, `Yes!`},
                                {`{{ if not (templates.Exists "partials/doesnotexist.html") }}No!{{ end }}`, `No!`},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file276" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package templates provides template functions for working with templates.
package templates

import (
        "github.com/gohugoio/hugo/deps"
)

// New returns a new instance of the templates-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                deps: deps,
        }
}</span>

// Namespace provides template functions for the "templates" namespace.
type Namespace struct {
        deps *deps.Deps
}

// Exists returns whether the template with the given name exists.
// Note that this is the Unix-styled relative path including filename suffix,
// e.g. partials/header.html
func (ns *Namespace) Exists(name string) bool <span class="cov0" title="0">{
        _, found := ns.deps.Tmpl.Lookup(name)
        return found

}</span>
</pre>
		
		<pre class="file" id="file277" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package time

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "time"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name: name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                                // Handle overlapping "time" namespace and func.
                                //
                                // If no args are passed to `time`, assume namespace usage and
                                // return namespace context.
                                //
                                // If args are passed, call AsTime().

                                if len(args) == 0 </span><span class="cov0" title="0">{
                                        return ctx
                                }</span>

                                <span class="cov0" title="0">t, err := ctx.AsTime(args[0])
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">return t</span>
                        },
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Format,
                        []string{"dateFormat"},
                        [][2]string{
                                {`dateFormat: {{ dateFormat "Monday, Jan 2, 2006" "2015-01-21" }}`, `dateFormat: Wednesday, Jan 21, 2015`},
                        },
                )

                ns.AddMethodMapping(ctx.Now,
                        []string{"now"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.AsTime,
                        nil,
                        [][2]string{
                                {`{{ (time "2015-01-21").Year }}`, `2015`},
                        },
                )

                ns.AddMethodMapping(ctx.Duration,
                        []string{"duration"},
                        [][2]string{
                                {`{{ mul 60 60 | duration "second" }}`, `1h0m0s`},
                        },
                )

                ns.AddMethodMapping(ctx.ParseDuration,
                        nil,
                        [][2]string{
                                {`{{ "1h12m10s" | time.ParseDuration }}`, `1h12m10s`},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file278" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package time provides template functions for measuring and displaying time.
package time

import (
        "fmt"
        _time "time"

        "github.com/spf13/cast"
)

// New returns a new instance of the time-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "time" namespace.
type Namespace struct{}

// AsTime converts the textual representation of the datetime string into
// a time.Time interface.
func (ns *Namespace) AsTime(v interface{}) (interface{}, error) <span class="cov0" title="0">{
        t, err := cast.ToTimeE(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return t, nil</span>
}

// Format converts the textual representation of the datetime string into
// the other form or returns it of the time.Time value. These are formatted
// with the layout string
func (ns *Namespace) Format(layout string, v interface{}) (string, error) <span class="cov0" title="0">{
        t, err := cast.ToTimeE(v)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return t.Format(layout), nil</span>
}

// Now returns the current local time.
func (ns *Namespace) Now() _time.Time <span class="cov8" title="1">{
        return _time.Now()
}</span>

// ParseDuration parses a duration string.
// A duration string is a possibly signed sequence of
// decimal numbers, each with optional fraction and a unit suffix,
// such as "300ms", "-1.5h" or "2h45m".
// Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h".
// See https://golang.org/pkg/time/#ParseDuration
func (ns *Namespace) ParseDuration(in interface{}) (_time.Duration, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(in)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return _time.ParseDuration(s)</span>
}

var durationUnits = map[string]_time.Duration{
        "nanosecond":  _time.Nanosecond,
        "ns":          _time.Nanosecond,
        "microsecond": _time.Microsecond,
        "us":          _time.Microsecond,
        "s":          _time.Microsecond,
        "millisecond": _time.Millisecond,
        "ms":          _time.Millisecond,
        "second":      _time.Second,
        "s":           _time.Second,
        "minute":      _time.Minute,
        "m":           _time.Minute,
        "hour":        _time.Hour,
        "h":           _time.Hour,
}

// Duration converts the given number to a time.Duration.
// Unit is one of nanosecond/ns, microsecond/us/s, millisecond/ms, second/s, minute/m or hour/h.
func (ns *Namespace) Duration(unit interface{}, number interface{}) (_time.Duration, error) <span class="cov0" title="0">{
        unitStr, err := cast.ToStringE(unit)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">unitDuration, found := durationUnits[unitStr]
        if !found </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("%q is not a valid duration unit", unit)
        }</span>
        <span class="cov0" title="0">n, err := cast.ToInt64E(number)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return _time.Duration(n) * unitDuration, nil</span>
}
</pre>
		
		<pre class="file" id="file279" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "path/filepath"

        "strings"

        "github.com/yosssi/ace"
)

func (t *templateHandler) addAceTemplate(name, basePath, innerPath string, baseContent, innerContent []byte) error <span class="cov0" title="0">{
        t.checkState()
        var base, inner *ace.File
        withoutExt := name[:len(name)-len(filepath.Ext(innerPath))]
        name = withoutExt + ".html"

        // Fixes issue #1178
        basePath = strings.Replace(basePath, "\\", "/", -1)
        innerPath = strings.Replace(innerPath, "\\", "/", -1)

        if basePath != "" </span><span class="cov0" title="0">{
                base = ace.NewFile(basePath, baseContent)
                inner = ace.NewFile(innerPath, innerContent)
        }</span> else<span class="cov0" title="0"> {
                base = ace.NewFile(innerPath, innerContent)
                inner = ace.NewFile("", []byte{})
        }</span>

        <span class="cov0" title="0">parsed, err := ace.ParseSource(ace.NewSource(base, inner, []*ace.File{}), nil)
        if err != nil </span><span class="cov0" title="0">{
                t.errors = append(t.errors, &amp;templateErr{name: name, err: err})
                return err
        }</span>

        <span class="cov0" title="0">templ, err := ace.CompileResultWithTemplate(t.html.t.New(name), parsed, nil)
        if err != nil </span><span class="cov0" title="0">{
                t.errors = append(t.errors, &amp;templateErr{name: name, err: err})
                return err
        }</span>

        <span class="cov0" title="0">typ := resolveTemplateType(name)

        c, err := applyTemplateTransformersToHMLTTemplate(typ, templ)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if typ == templateShortcode </span><span class="cov0" title="0">{
                t.addShortcodeVariant(name, c.Info, templ)
        }</span> else<span class="cov0" title="0"> {
                t.templateInfo[name] = c.Info
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file280" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "html/template"

        "github.com/eknkc/amber"
        "github.com/spf13/afero"
)

func (t *templateHandler) compileAmberWithTemplate(b []byte, path string, templ *template.Template) (*template.Template, error) <span class="cov0" title="0">{
        c := amber.New()
        c.Options.VirtualFilesystem = afero.NewHttpFs(t.layoutsFs)

        if err := c.ParseData(b, path); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data, err := c.CompileString()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tpl, err := templ.Funcs(t.amberFuncMap).Parse(data)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tpl, nil</span>
}
</pre>
		
		<pre class="file" id="file281" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "strings"

        "github.com/gohugoio/hugo/tpl"
)

// Currently lang, outFormat, suffix
const numTemplateVariants = 3

type shortcodeVariant struct {

        // The possible variants: lang, outFormat, suffix
        // gtag
        // gtag.html
        // gtag.no.html
        // gtag.no.amp.html
        // A slice of length numTemplateVariants.
        variants []string

        info  tpl.Info
        templ tpl.Template
}

type shortcodeTemplates struct {
        variants []shortcodeVariant
}

func (s *shortcodeTemplates) indexOf(variants []string) int <span class="cov8" title="1">{
L:
        for i, v1 := range s.variants </span><span class="cov0" title="0">{
                for i, v2 := range v1.variants </span><span class="cov0" title="0">{
                        if v2 != variants[i] </span><span class="cov0" title="0">{
                                continue L</span>
                        }
                }
                <span class="cov0" title="0">return i</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func (s *shortcodeTemplates) fromVariants(variants tpl.TemplateVariants) (shortcodeVariant, bool) <span class="cov0" title="0">{
        return s.fromVariantsSlice([]string{
                variants.Language,
                strings.ToLower(variants.OutputFormat.Name),
                variants.OutputFormat.MediaType.Suffix(),
        })
}</span>

// Get the most specific template given a full name, e.g  gtag.no.amp.html.
func (s *shortcodeTemplates) fromName(name string) (shortcodeVariant, bool) <span class="cov0" title="0">{
        return s.fromVariantsSlice(templateVariants(name))
}</span>

func (s *shortcodeTemplates) fromVariantsSlice(variants []string) (shortcodeVariant, bool) <span class="cov0" title="0">{
        var (
                bestMatch       shortcodeVariant
                bestMatchWeight int
        )

        for _, variant := range s.variants </span><span class="cov0" title="0">{
                w := s.compareVariants(variants, variant.variants)
                if bestMatchWeight == 0 || w &gt; bestMatchWeight </span><span class="cov0" title="0">{
                        bestMatch = variant
                        bestMatchWeight = w
                }</span>
        }

        <span class="cov0" title="0">return bestMatch, true</span>
}

// calculate a weight for two string slices of same length.
// higher value means "better match".
func (s *shortcodeTemplates) compareVariants(a, b []string) int <span class="cov0" title="0">{

        weight := 0
        for i, av := range a </span><span class="cov0" title="0">{
                bv := b[i]
                if av == bv </span><span class="cov0" title="0">{
                        weight++
                }</span> else<span class="cov0" title="0"> {
                        weight--
                }</span>
        }
        <span class="cov0" title="0">return weight</span>
}

func templateVariants(name string) []string <span class="cov0" title="0">{
        _, variants := templateNameAndVariants(name)
        return variants
}</span>

func templateNameAndVariants(name string) (string, []string) <span class="cov8" title="1">{

        variants := make([]string, numTemplateVariants)

        parts := strings.Split(name, ".")

        if len(parts) &lt;= 1 </span><span class="cov0" title="0">{
                // No variants.
                return name, variants
        }</span>

        <span class="cov8" title="1">name = parts[0]
        parts = parts[1:]
        lp := len(parts)
        start := len(variants) - lp

        for i, j := start, 0; i &lt; len(variants); i, j = i+1, j+1 </span><span class="cov8" title="1">{
                variants[i] = parts[j]
        }</span>

        <span class="cov8" title="1">if lp &gt; 1 &amp;&amp; lp &lt; len(variants) </span><span class="cov0" title="0">{
                for i := lp - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{
                        variants[i-1] = variants[i]
                }</span>
        }

        <span class="cov8" title="1">if lp == 1 </span><span class="cov8" title="1">{
                // Suffix only. Duplicate it into the output format field to
                // make HTML win over AMP.
                variants[len(variants)-2] = variants[len(variants)-1]
        }</span>

        <span class="cov8" title="1">return name, variants</span>
}

func resolveTemplateType(name string) templateType <span class="cov8" title="1">{
        if isShortcode(name) </span><span class="cov8" title="1">{
                return templateShortcode
        }</span>

        <span class="cov8" title="1">if strings.Contains(name, "partials/") </span><span class="cov8" title="1">{
                return templatePartial
        }</span>

        <span class="cov8" title="1">return templateUndefined</span>
}

func isShortcode(name string) bool <span class="cov8" title="1">{
        return strings.Contains(name, shortcodesPathPrefix)
}</span>

func isInternal(name string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(name, internalPathPrefix)
}</span>
</pre>
		
		<pre class="file" id="file282" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "fmt"
        "html/template"
        "strings"
        texttemplate "text/template"
        "text/template/parse"

        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/tpl/tplimpl/embedded"
        "github.com/pkg/errors"

        "github.com/eknkc/amber"

        "os"

        "github.com/gohugoio/hugo/output"

        "path/filepath"
        "sync"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/tpl"
        "github.com/spf13/afero"
)

const (
        textTmplNamePrefix = "_text/"
)

var (
        _ tpl.TemplateHandler       = (*templateHandler)(nil)
        _ tpl.TemplateDebugger      = (*templateHandler)(nil)
        _ tpl.TemplateFuncsGetter   = (*templateHandler)(nil)
        _ tpl.TemplateTestMocker    = (*templateHandler)(nil)
        _ tpl.TemplateFinder        = (*htmlTemplates)(nil)
        _ tpl.TemplateFinder        = (*textTemplates)(nil)
        _ templateLoader            = (*htmlTemplates)(nil)
        _ templateLoader            = (*textTemplates)(nil)
        _ templateFuncsterTemplater = (*htmlTemplates)(nil)
        _ templateFuncsterTemplater = (*textTemplates)(nil)
)

// Protecting  global map access (Amber)
var amberMu sync.Mutex

type templateErr struct {
        name string
        err  error
}

type templateLoader interface {
        handleMaster(name, overlayFilename, masterFilename string, onMissing func(filename string) (templateInfo, error)) error
        addTemplate(name, tpl string) (*templateContext, error)
        addLateTemplate(name, tpl string) error
}

type templateFuncsterTemplater interface {
        templateFuncsterSetter
        tpl.TemplateFinder
        setFuncs(funcMap map[string]interface{})
}

type templateFuncsterSetter interface {
        setTemplateFuncster(f *templateFuncster)
}

// templateHandler holds the templates in play.
// It implements the templateLoader and tpl.TemplateHandler interfaces.
type templateHandler struct {
        mu sync.Mutex

        // shortcodes maps shortcode name to template variants
        // (language, output format etc.) of that shortcode.
        shortcodes map[string]*shortcodeTemplates

        // templateInfo maps template name to some additional information about that template.
        // Note that for shortcodes that same information is embedded in the
        // shortcodeTemplates type.
        templateInfo map[string]tpl.Info

        // text holds all the pure text templates.
        text *textTemplates
        html *htmlTemplates

        extTextTemplates []*textTemplate

        amberFuncMap template.FuncMap

        errors []*templateErr

        // This is the filesystem to load the templates from. All the templates are
        // stored in the root of this filesystem.
        layoutsFs afero.Fs

        *deps.Deps
}

const (
        shortcodesPathPrefix = "shortcodes/"
        internalPathPrefix   = "_internal/"
)

// resolves _internal/shortcodes/param.html =&gt; param.html etc.
func templateBaseName(typ templateType, name string) string <span class="cov8" title="1">{
        name = strings.TrimPrefix(name, internalPathPrefix)
        switch typ </span>{
        case templateShortcode:<span class="cov8" title="1">
                return strings.TrimPrefix(name, shortcodesPathPrefix)</span>
        default:<span class="cov0" title="0">
                panic("not implemented")</span>
        }

}

func (t *templateHandler) addShortcodeVariant(name string, info tpl.Info, templ tpl.Template) <span class="cov8" title="1">{
        base := templateBaseName(templateShortcode, name)

        shortcodename, variants := templateNameAndVariants(base)

        templs, found := t.shortcodes[shortcodename]
        if !found </span><span class="cov8" title="1">{
                templs = &amp;shortcodeTemplates{}
                t.shortcodes[shortcodename] = templs
        }</span>

        <span class="cov8" title="1">sv := shortcodeVariant{variants: variants, info: info, templ: templ}

        i := templs.indexOf(variants)

        if i != -1 </span><span class="cov0" title="0">{
                // Only replace if it's an override of an internal template.
                if !isInternal(name) </span><span class="cov0" title="0">{
                        templs.variants[i] = sv
                }</span>
        } else<span class="cov8" title="1"> {
                templs.variants = append(templs.variants, sv)
        }</span>
}

// NewTextTemplate provides a text template parser that has all the Hugo
// template funcs etc. built-in.
func (t *templateHandler) NewTextTemplate() tpl.TemplateParseFinder <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        tt := &amp;textTemplate{t: texttemplate.New("")}
        t.extTextTemplates = append(t.extTextTemplates, tt)

        return struct {
                tpl.TemplateParser
                tpl.TemplateLookup
                tpl.TemplateLookupVariant
        }{
                tt,
                tt,
                new(nopLookupVariant),
        }

}</span>

type nopLookupVariant int

func (l nopLookupVariant) LookupVariant(name string, variants tpl.TemplateVariants) (tpl.Template, bool, bool) <span class="cov0" title="0">{
        return nil, false, false
}</span>

func (t *templateHandler) Debug() <span class="cov0" title="0">{
        fmt.Println("HTML templates:\n", t.html.t.DefinedTemplates())
        fmt.Println("\n\nText templates:\n", t.text.t.DefinedTemplates())
}</span>

// Lookup tries to find a template with the given name in both template
// collections: First HTML, then the plain text template collection.
func (t *templateHandler) Lookup(name string) (tpl.Template, bool) <span class="cov8" title="1">{

        if strings.HasPrefix(name, textTmplNamePrefix) </span><span class="cov0" title="0">{
                // The caller has explicitly asked for a text template, so only look
                // in the text template collection.
                // The templates are stored without the prefix identificator.
                name = strings.TrimPrefix(name, textTmplNamePrefix)

                return t.applyTemplateInfo(t.text.Lookup(name))
        }</span>

        // Look in both
        <span class="cov8" title="1">if te, found := t.html.Lookup(name); found </span><span class="cov8" title="1">{
                return t.applyTemplateInfo(te, true)
        }</span>

        <span class="cov8" title="1">return t.applyTemplateInfo(t.text.Lookup(name))</span>

}

func (t *templateHandler) applyTemplateInfo(templ tpl.Template, found bool) (tpl.Template, bool) <span class="cov8" title="1">{
        if adapter, ok := templ.(*tpl.TemplateAdapter); ok </span><span class="cov8" title="1">{
                if adapter.Info.IsZero() </span><span class="cov8" title="1">{
                        if info, found := t.templateInfo[templ.Name()]; found </span><span class="cov8" title="1">{
                                adapter.Info = info
                        }</span>
                }
        }

        <span class="cov8" title="1">return templ, found</span>
}

// This currently only applies to shortcodes and what we get here is the
// shortcode name.
func (t *templateHandler) LookupVariant(name string, variants tpl.TemplateVariants) (tpl.Template, bool, bool) <span class="cov0" title="0">{
        name = templateBaseName(templateShortcode, name)
        s, found := t.shortcodes[name]
        if !found </span><span class="cov0" title="0">{
                return nil, false, false
        }</span>

        <span class="cov0" title="0">sv, found := s.fromVariants(variants)
        if !found </span><span class="cov0" title="0">{
                return nil, false, false
        }</span>

        <span class="cov0" title="0">more := len(s.variants) &gt; 1

        return &amp;tpl.TemplateAdapter{
                Template:             sv.templ,
                Info:                 sv.info,
                Metrics:              t.Deps.Metrics,
                Fs:                   t.layoutsFs,
                NameBaseTemplateName: t.html.nameBaseTemplateName}, true, more</span>

}

func (t *textTemplates) LookupVariant(name string, variants tpl.TemplateVariants) (tpl.Template, bool, bool) <span class="cov0" title="0">{
        return t.handler.LookupVariant(name, variants)
}</span>

func (t *htmlTemplates) LookupVariant(name string, variants tpl.TemplateVariants) (tpl.Template, bool, bool) <span class="cov0" title="0">{
        return t.handler.LookupVariant(name, variants)
}</span>

func (t *templateHandler) lookupTemplate(in interface{}) tpl.Template <span class="cov0" title="0">{
        switch templ := in.(type) </span>{
        case *texttemplate.Template:<span class="cov0" title="0">
                return t.text.lookup(templ.Name())</span>
        case *template.Template:<span class="cov0" title="0">
                return t.html.lookup(templ.Name())</span>
        }

        <span class="cov0" title="0">panic(fmt.Sprintf("%T is not a template", in))</span>
}

func (t *templateHandler) setFuncMapInTemplate(in interface{}, funcs map[string]interface{}) <span class="cov0" title="0">{
        switch templ := in.(type) </span>{
        case *texttemplate.Template:<span class="cov0" title="0">
                templ.Funcs(funcs)
                return</span>
        case *template.Template:<span class="cov0" title="0">
                templ.Funcs(funcs)
                return</span>
        }

        <span class="cov0" title="0">panic(fmt.Sprintf("%T is not a template", in))</span>
}

func (t *templateHandler) clone(d *deps.Deps) *templateHandler <span class="cov0" title="0">{
        c := &amp;templateHandler{
                Deps:         d,
                layoutsFs:    d.BaseFs.Layouts.Fs,
                shortcodes:   make(map[string]*shortcodeTemplates),
                templateInfo: t.templateInfo,
                html:         &amp;htmlTemplates{t: template.Must(t.html.t.Clone()), overlays: make(map[string]*template.Template), templatesCommon: t.html.templatesCommon},
                text:         &amp;textTemplates{textTemplate: &amp;textTemplate{t: texttemplate.Must(t.text.t.Clone())}, overlays: make(map[string]*texttemplate.Template), templatesCommon: t.text.templatesCommon},
                errors:       make([]*templateErr, 0),
        }

        for k, v := range t.shortcodes </span><span class="cov0" title="0">{
                other := *v
                variantsc := make([]shortcodeVariant, len(v.variants))
                for i, variant := range v.variants </span><span class="cov0" title="0">{
                        variantsc[i] = shortcodeVariant{
                                info:     variant.info,
                                variants: variant.variants,
                                templ:    c.lookupTemplate(variant.templ),
                        }
                }</span>
                <span class="cov0" title="0">other.variants = variantsc
                c.shortcodes[k] = &amp;other</span>
        }

        <span class="cov0" title="0">d.Tmpl = c

        c.initFuncs()

        for k, v := range t.html.overlays </span><span class="cov0" title="0">{
                vc := template.Must(v.Clone())
                // The extra lookup is a workaround, see
                // * https://github.com/golang/go/issues/16101
                // * https://github.com/gohugoio/hugo/issues/2549
                vc = vc.Lookup(vc.Name())
                vc.Funcs(c.html.funcster.funcMap)
                c.html.overlays[k] = vc
        }</span>

        <span class="cov0" title="0">for k, v := range t.text.overlays </span><span class="cov0" title="0">{
                vc := texttemplate.Must(v.Clone())
                vc = vc.Lookup(vc.Name())
                vc.Funcs(texttemplate.FuncMap(c.text.funcster.funcMap))
                c.text.overlays[k] = vc
        }</span>

        <span class="cov0" title="0">return c</span>

}

func newTemplateAdapter(deps *deps.Deps) *templateHandler <span class="cov8" title="1">{
        common := &amp;templatesCommon{
                nameBaseTemplateName: make(map[string]string),
                transformNotFound:    make(map[string]bool),
        }

        htmlT := &amp;htmlTemplates{
                t:               template.New(""),
                overlays:        make(map[string]*template.Template),
                templatesCommon: common,
        }
        textT := &amp;textTemplates{
                textTemplate:    &amp;textTemplate{t: texttemplate.New("")},
                overlays:        make(map[string]*texttemplate.Template),
                templatesCommon: common,
        }
        h := &amp;templateHandler{
                Deps:         deps,
                layoutsFs:    deps.BaseFs.Layouts.Fs,
                shortcodes:   make(map[string]*shortcodeTemplates),
                templateInfo: make(map[string]tpl.Info),
                html:         htmlT,
                text:         textT,
                errors:       make([]*templateErr, 0),
        }

        common.handler = h

        return h

}</span>

// Shared by both HTML and text templates.
type templatesCommon struct {
        handler  *templateHandler
        funcster *templateFuncster

        // Used to get proper filenames in errors
        nameBaseTemplateName map[string]string

        // Holds names of the templates not found during the first AST transformation
        // pass.
        transformNotFound map[string]bool
}
type htmlTemplates struct {
        mu sync.RWMutex

        *templatesCommon

        t *template.Template

        // This looks, and is, strange.
        // The clone is used by non-renderable content pages, and these need to be
        // re-parsed on content change, and to avoid the
        // "cannot Parse after Execute" error, we need to re-clone it from the original clone.
        clone      *template.Template
        cloneClone *template.Template

        // a separate storage for the overlays created from cloned master templates.
        // note: No mutex protection, so we add these in one Go routine, then just read.
        overlays map[string]*template.Template
}

func (t *htmlTemplates) setTemplateFuncster(f *templateFuncster) <span class="cov8" title="1">{
        t.funcster = f
}</span>

func (t *htmlTemplates) Lookup(name string) (tpl.Template, bool) <span class="cov8" title="1">{
        templ := t.lookup(name)
        if templ == nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">return &amp;tpl.TemplateAdapter{Template: templ, Metrics: t.funcster.Deps.Metrics, Fs: t.handler.layoutsFs, NameBaseTemplateName: t.nameBaseTemplateName}, true</span>
}

func (t *htmlTemplates) lookup(name string) *template.Template <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        // Need to check in the overlay registry first as it will also be found below.
        if t.overlays != nil </span><span class="cov8" title="1">{
                if templ, ok := t.overlays[name]; ok </span><span class="cov8" title="1">{
                        return templ
                }</span>
        }

        <span class="cov8" title="1">if templ := t.t.Lookup(name); templ != nil </span><span class="cov8" title="1">{
                return templ
        }</span>

        <span class="cov8" title="1">if t.clone != nil </span><span class="cov8" title="1">{
                return t.clone.Lookup(name)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (t *textTemplates) setTemplateFuncster(f *templateFuncster) <span class="cov8" title="1">{
        t.funcster = f
}</span>

type textTemplates struct {
        *templatesCommon
        *textTemplate
        clone      *texttemplate.Template
        cloneClone *texttemplate.Template

        overlays map[string]*texttemplate.Template
}

func (t *textTemplates) Lookup(name string) (tpl.Template, bool) <span class="cov8" title="1">{
        templ := t.lookup(name)
        if templ == nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return &amp;tpl.TemplateAdapter{Template: templ, Metrics: t.funcster.Deps.Metrics, Fs: t.handler.layoutsFs, NameBaseTemplateName: t.nameBaseTemplateName}, true</span>
}

func (t *textTemplates) lookup(name string) *texttemplate.Template <span class="cov8" title="1">{

        // Need to check in the overlay registry first as it will also be found below.
        if t.overlays != nil </span><span class="cov8" title="1">{
                if templ, ok := t.overlays[name]; ok </span><span class="cov0" title="0">{
                        return templ
                }</span>
        }

        <span class="cov8" title="1">if templ := t.t.Lookup(name); templ != nil </span><span class="cov0" title="0">{
                return templ
        }</span>

        <span class="cov8" title="1">if t.clone != nil </span><span class="cov8" title="1">{
                return t.clone.Lookup(name)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (t *templateHandler) setFuncs(funcMap map[string]interface{}) <span class="cov8" title="1">{
        t.html.setFuncs(funcMap)
        t.text.setFuncs(funcMap)
}</span>

// SetFuncs replaces the funcs in the func maps with new definitions.
// This is only used in tests.
func (t *templateHandler) SetFuncs(funcMap map[string]interface{}) <span class="cov0" title="0">{
        t.setFuncs(funcMap)
}</span>

func (t *templateHandler) GetFuncs() map[string]interface{} <span class="cov0" title="0">{
        return t.html.funcster.funcMap
}</span>

func (t *htmlTemplates) setFuncs(funcMap map[string]interface{}) <span class="cov8" title="1">{
        t.t.Funcs(funcMap)
}</span>

func (t *textTemplates) setFuncs(funcMap map[string]interface{}) <span class="cov8" title="1">{
        t.t.Funcs(funcMap)
}</span>

// LoadTemplates loads the templates from the layouts filesystem.
// A prefix can be given to indicate a template namespace to load the templates
// into, i.e. "_internal" etc.
func (t *templateHandler) LoadTemplates(prefix string) error <span class="cov8" title="1">{
        return t.loadTemplates(prefix)

}</span>

func (t *htmlTemplates) addTemplateIn(tt *template.Template, name, tpl string) (*templateContext, error) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        templ, err := tt.New(name).Parse(tpl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">typ := resolveTemplateType(name)

        c, err := applyTemplateTransformersToHMLTTemplate(typ, templ)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for k := range c.notFound </span><span class="cov8" title="1">{
                t.transformNotFound[k] = true
        }</span>

        <span class="cov8" title="1">if typ == templateShortcode </span><span class="cov8" title="1">{
                t.handler.addShortcodeVariant(name, c.Info, templ)
        }</span> else<span class="cov8" title="1"> {
                t.handler.templateInfo[name] = c.Info
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}

func (t *htmlTemplates) addTemplate(name, tpl string) (*templateContext, error) <span class="cov8" title="1">{
        return t.addTemplateIn(t.t, name, tpl)
}</span>

func (t *htmlTemplates) addLateTemplate(name, tpl string) error <span class="cov0" title="0">{
        _, err := t.addTemplateIn(t.clone, name, tpl)
        return err
}</span>

type textTemplate struct {
        mu sync.RWMutex
        t  *texttemplate.Template
}

func (t *textTemplate) Parse(name, tpl string) (tpl.Template, error) <span class="cov0" title="0">{
        return t.parseIn(t.t, name, tpl)
}</span>

func (t *textTemplate) Lookup(name string) (tpl.Template, bool) <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        tpl := t.t.Lookup(name)
        return tpl, tpl != nil
}</span>

func (t *textTemplate) parseIn(tt *texttemplate.Template, name, tpl string) (*texttemplate.Template, error) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        templ, err := tt.New(name).Parse(tpl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if _, err := applyTemplateTransformersToTextTemplate(templateUndefined, templ); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return templ, nil</span>
}

func (t *textTemplates) addTemplateIn(tt *texttemplate.Template, name, tpl string) (*templateContext, error) <span class="cov8" title="1">{
        name = strings.TrimPrefix(name, textTmplNamePrefix)
        templ, err := t.parseIn(tt, name, tpl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">typ := resolveTemplateType(name)

        c, err := applyTemplateTransformersToTextTemplate(typ, templ)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for k := range c.notFound </span><span class="cov0" title="0">{
                t.transformNotFound[k] = true
        }</span>

        <span class="cov8" title="1">if typ == templateShortcode </span><span class="cov0" title="0">{
                t.handler.addShortcodeVariant(name, c.Info, templ)
        }</span> else<span class="cov8" title="1"> {
                t.handler.templateInfo[name] = c.Info
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}

func (t *textTemplates) addTemplate(name, tpl string) (*templateContext, error) <span class="cov8" title="1">{
        return t.addTemplateIn(t.t, name, tpl)
}</span>

func (t *textTemplates) addLateTemplate(name, tpl string) error <span class="cov0" title="0">{
        _, err := t.addTemplateIn(t.clone, name, tpl)
        return err
}</span>

func (t *templateHandler) addTemplate(name, tpl string) error <span class="cov0" title="0">{
        return t.AddTemplate(name, tpl)
}</span>

func (t *templateHandler) postTransform() error <span class="cov8" title="1">{
        if len(t.html.transformNotFound) == 0 &amp;&amp; len(t.text.transformNotFound) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                t.text.transformNotFound = make(map[string]bool)
                t.html.transformNotFound = make(map[string]bool)
        }</span>()

        <span class="cov8" title="1">for _, s := range []struct {
                lookup            func(name string) *parse.Tree
                transformNotFound map[string]bool
        }{
                // html templates
                {func(name string) *parse.Tree </span><span class="cov8" title="1">{
                        templ := t.html.lookup(name)
                        if templ == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">return templ.Tree</span>
                }, t.html.transformNotFound},
                // text templates
                {func(name string) *parse.Tree <span class="cov8" title="1">{
                        templT := t.text.lookup(name)
                        if templT == nil </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return templT.Tree</span>
                }, t.text.transformNotFound},
        } <span class="cov8" title="1">{
                for name := range s.transformNotFound </span><span class="cov8" title="1">{
                        templ := s.lookup(name)
                        if templ != nil </span><span class="cov8" title="1">{
                                _, err := applyTemplateTransformers(templateUndefined, templ, s.lookup)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (t *templateHandler) addLateTemplate(name, tpl string) error <span class="cov0" title="0">{
        return t.AddLateTemplate(name, tpl)
}</span>

// AddLateTemplate is used to add a template late, i.e. after the
// regular templates have started its execution.
func (t *templateHandler) AddLateTemplate(name, tpl string) error <span class="cov0" title="0">{
        h := t.getTemplateHandler(name)
        if err := h.addLateTemplate(name, tpl); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AddTemplate parses and adds a template to the collection.
// Templates with name prefixed with "_text" will be handled as plain
// text templates.
// TODO(bep) clean up these addTemplate variants
func (t *templateHandler) AddTemplate(name, tpl string) error <span class="cov8" title="1">{
        h := t.getTemplateHandler(name)
        _, err := h.addTemplate(name, tpl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// MarkReady marks the templates as "ready for execution". No changes allowed
// after this is set.
// TODO(bep) if this proves to be resource heavy, we could detect
// earlier if we really need this, or make it lazy.
func (t *templateHandler) MarkReady() error <span class="cov8" title="1">{
        if err := t.postTransform(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if t.html.clone == nil </span><span class="cov8" title="1">{
                t.html.clone = template.Must(t.html.t.Clone())
                t.html.cloneClone = template.Must(t.html.clone.Clone())
        }</span>
        <span class="cov8" title="1">if t.text.clone == nil </span><span class="cov8" title="1">{
                t.text.clone = texttemplate.Must(t.text.t.Clone())
                t.text.cloneClone = texttemplate.Must(t.text.clone.Clone())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RebuildClone rebuilds the cloned templates. Used for live-reloads.
func (t *templateHandler) RebuildClone() <span class="cov8" title="1">{
        if t.html != nil &amp;&amp; t.html.cloneClone != nil </span><span class="cov8" title="1">{
                t.html.clone = template.Must(t.html.cloneClone.Clone())
        }</span>
        <span class="cov8" title="1">if t.text != nil &amp;&amp; t.text.cloneClone != nil </span><span class="cov8" title="1">{
                t.text.clone = texttemplate.Must(t.text.cloneClone.Clone())
        }</span>
}

func (t *templateHandler) loadTemplates(prefix string) error <span class="cov8" title="1">{

        walker := func(path string, fi hugofs.FileMetaInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil || fi.IsDir() </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if isDotFile(path) || isBackupFile(path) || isBaseTemplate(path) </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">workingDir := t.PathSpec.WorkingDir

                descriptor := output.TemplateLookupDescriptor{
                        WorkingDir:    workingDir,
                        RelPath:       path,
                        Prefix:        prefix,
                        OutputFormats: t.OutputFormatsConfig,
                        FileExists: func(filename string) (bool, error) </span><span class="cov8" title="1">{
                                return helpers.Exists(filename, t.Layouts.Fs)
                        }</span>,
                        ContainsAny: func(filename string, subslices [][]byte) (bool, error) <span class="cov8" title="1">{
                                return helpers.FileContainsAny(filename, subslices, t.Layouts.Fs)
                        }</span>,
                }

                <span class="cov8" title="1">tplID, err := output.CreateTemplateNames(descriptor)
                if err != nil </span><span class="cov0" title="0">{
                        t.Log.ERROR.Printf("Failed to resolve template in path %q: %s", path, err)
                        return nil
                }</span>

                <span class="cov8" title="1">if err := t.addTemplateFile(tplID.Name, tplID.MasterFilename, tplID.OverlayFilename); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if err := helpers.SymbolicWalk(t.Layouts.Fs, "", walker); err != nil </span><span class="cov0" title="0">{
                if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">return nil</span>

}

func (t *templateHandler) initFuncs() <span class="cov8" title="1">{

        // Both template types will get their own funcster instance, which
        // in the current case contains the same set of funcs.
        funcMap := createFuncMap(t.Deps)
        for _, funcsterHolder := range []templateFuncsterSetter{t.html, t.text} </span><span class="cov8" title="1">{
                funcster := newTemplateFuncster(t.Deps)

                // The URL funcs in the funcMap is somewhat language dependent,
                // so we need to wait until the language and site config is loaded.
                funcster.initFuncMap(funcMap)

                funcsterHolder.setTemplateFuncster(funcster)

        }</span>

        <span class="cov8" title="1">for _, v := range t.shortcodes </span><span class="cov0" title="0">{
                for _, variant := range v.variants </span><span class="cov0" title="0">{
                        t.setFuncMapInTemplate(variant.templ, funcMap)
                }</span>
        }

        <span class="cov8" title="1">for _, extText := range t.extTextTemplates </span><span class="cov8" title="1">{
                extText.t.Funcs(funcMap)
        }</span>

        // Amber is HTML only.
        <span class="cov8" title="1">t.amberFuncMap = template.FuncMap{}

        amberMu.Lock()
        for k, v := range amber.FuncMap </span><span class="cov8" title="1">{
                t.amberFuncMap[k] = v
        }</span>

        <span class="cov8" title="1">for k, v := range t.html.funcster.funcMap </span><span class="cov8" title="1">{
                t.amberFuncMap[k] = v
                // Hacky, but we need to make sure that the func names are in the global map.
                amber.FuncMap[k] = func() string </span><span class="cov0" title="0">{
                        panic("should never be invoked")</span>
                }
        }
        <span class="cov8" title="1">amberMu.Unlock()</span>

}

func (t *templateHandler) getTemplateHandler(name string) templateLoader <span class="cov8" title="1">{
        if strings.HasPrefix(name, textTmplNamePrefix) </span><span class="cov8" title="1">{
                return t.text
        }</span>
        <span class="cov8" title="1">return t.html</span>
}

func (t *templateHandler) handleMaster(name, overlayFilename, masterFilename string, onMissing func(filename string) (templateInfo, error)) error <span class="cov8" title="1">{
        h := t.getTemplateHandler(name)
        return h.handleMaster(name, overlayFilename, masterFilename, onMissing)
}</span>

func (t *htmlTemplates) handleMaster(name, overlayFilename, masterFilename string, onMissing func(filename string) (templateInfo, error)) error <span class="cov8" title="1">{

        masterTpl := t.lookup(masterFilename)

        if masterTpl == nil </span><span class="cov8" title="1">{
                templ, err := onMissing(masterFilename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">masterTpl, err = t.t.New(overlayFilename).Parse(templ.template)
                if err != nil </span><span class="cov0" title="0">{
                        return templ.errWithFileContext("parse master failed", err)
                }</span>
        }

        <span class="cov8" title="1">templ, err := onMissing(overlayFilename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">overlayTpl, err := template.Must(masterTpl.Clone()).Parse(templ.template)
        if err != nil </span><span class="cov0" title="0">{
                return templ.errWithFileContext("parse failed", err)
        }</span>

        // The extra lookup is a workaround, see
        // * https://github.com/golang/go/issues/16101
        // * https://github.com/gohugoio/hugo/issues/2549
        <span class="cov8" title="1">overlayTpl = overlayTpl.Lookup(overlayTpl.Name())
        if _, err := applyTemplateTransformersToHMLTTemplate(templateUndefined, overlayTpl); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">t.overlays[name] = overlayTpl
        t.nameBaseTemplateName[name] = masterFilename

        return err</span>

}

func (t *textTemplates) handleMaster(name, overlayFilename, masterFilename string, onMissing func(filename string) (templateInfo, error)) error <span class="cov0" title="0">{

        name = strings.TrimPrefix(name, textTmplNamePrefix)
        masterTpl := t.lookup(masterFilename)

        if masterTpl == nil </span><span class="cov0" title="0">{
                templ, err := onMissing(masterFilename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">masterTpl, err = t.t.New(masterFilename).Parse(templ.template)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to parse %q:", templ.filename)
                }</span>
                <span class="cov0" title="0">t.nameBaseTemplateName[masterFilename] = templ.filename</span>
        }

        <span class="cov0" title="0">templ, err := onMissing(overlayFilename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">overlayTpl, err := texttemplate.Must(masterTpl.Clone()).Parse(templ.template)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to parse %q:", templ.filename)
        }</span>

        <span class="cov0" title="0">overlayTpl = overlayTpl.Lookup(overlayTpl.Name())
        if _, err := applyTemplateTransformersToTextTemplate(templateUndefined, overlayTpl); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">t.overlays[name] = overlayTpl
        t.nameBaseTemplateName[name] = templ.filename

        return err</span>

}

func removeLeadingBOM(s string) string <span class="cov8" title="1">{
        const bom = '\ufeff'

        for i, r := range s </span><span class="cov8" title="1">{
                if i == 0 &amp;&amp; r != bom </span><span class="cov8" title="1">{
                        return s
                }</span>
                <span class="cov0" title="0">if i &gt; 0 </span><span class="cov0" title="0">{
                        return s[i:]
                }</span>
        }

        <span class="cov0" title="0">return s</span>

}

func (t *templateHandler) addTemplateFile(name, baseTemplatePath, path string) error <span class="cov8" title="1">{
        t.checkState()

        t.Log.DEBUG.Printf("Add template file: name %q, baseTemplatePath %q, path %q", name, baseTemplatePath, path)

        getTemplate := func(filename string) (templateInfo, error) </span><span class="cov8" title="1">{
                fs := t.Layouts.Fs
                b, err := afero.ReadFile(fs, filename)
                if err != nil </span><span class="cov0" title="0">{
                        return templateInfo{filename: filename, fs: fs}, err
                }</span>

                <span class="cov8" title="1">s := removeLeadingBOM(string(b))

                realFilename := filename
                if fi, err := fs.Stat(filename); err == nil </span><span class="cov8" title="1">{
                        if fim, ok := fi.(hugofs.FileMetaInfo); ok </span><span class="cov8" title="1">{
                                realFilename = fim.Meta().Filename()
                        }</span>
                }

                <span class="cov8" title="1">return templateInfo{template: s, filename: filename, realFilename: realFilename, fs: fs}, nil</span>
        }

        // get the suffix and switch on that
        <span class="cov8" title="1">ext := filepath.Ext(path)
        switch ext </span>{
        case ".amber":<span class="cov0" title="0">
                //        Only HTML support for Amber
                withoutExt := strings.TrimSuffix(name, filepath.Ext(name))
                templateName := withoutExt + ".html"
                b, err := afero.ReadFile(t.Layouts.Fs, path)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">amberMu.Lock()
                templ, err := t.compileAmberWithTemplate(b, path, t.html.t.New(templateName))
                amberMu.Unlock()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">typ := resolveTemplateType(name)

                c, err := applyTemplateTransformersToHMLTTemplate(typ, templ)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if typ == templateShortcode </span><span class="cov0" title="0">{
                        t.addShortcodeVariant(templateName, c.Info, templ)
                }</span> else<span class="cov0" title="0"> {
                        t.templateInfo[name] = c.Info
                }</span>

                <span class="cov0" title="0">return nil</span>

        case ".ace":<span class="cov0" title="0">
                //        Only HTML support for Ace
                var innerContent, baseContent []byte
                innerContent, err := afero.ReadFile(t.Layouts.Fs, path)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if baseTemplatePath != "" </span><span class="cov0" title="0">{
                        baseContent, err = afero.ReadFile(t.Layouts.Fs, baseTemplatePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">return t.addAceTemplate(name, baseTemplatePath, path, baseContent, innerContent)</span>
        default:<span class="cov8" title="1">

                if baseTemplatePath != "" </span><span class="cov8" title="1">{
                        return t.handleMaster(name, path, baseTemplatePath, getTemplate)
                }</span>

                <span class="cov8" title="1">templ, err := getTemplate(path)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">err = t.AddTemplate(name, templ.template)
                if err != nil </span><span class="cov0" title="0">{
                        return templ.errWithFileContext("parse failed", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

var embeddedTemplatesAliases = map[string][]string{
        "shortcodes/twitter.html": {"shortcodes/tweet.html"},
}

func (t *templateHandler) loadEmbedded() error <span class="cov8" title="1">{
        for _, kv := range embedded.EmbeddedTemplates </span><span class="cov8" title="1">{
                name, templ := kv[0], kv[1]
                if err := t.addInternalTemplate(name, templ); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if aliases, found := embeddedTemplatesAliases[name]; found </span><span class="cov8" title="1">{
                        for _, alias := range aliases </span><span class="cov8" title="1">{
                                if err := t.addInternalTemplate(alias, templ); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                }
        }

        <span class="cov8" title="1">return nil</span>

}

func (t *templateHandler) addInternalTemplate(name, tpl string) error <span class="cov8" title="1">{
        return t.AddTemplate("_internal/"+name, tpl)
}</span>

func (t *templateHandler) checkState() <span class="cov8" title="1">{
        if t.html.clone != nil || t.text.clone != nil </span><span class="cov0" title="0">{
                panic("template is cloned and cannot be modfified")</span>
        }
}

func isDotFile(path string) bool <span class="cov8" title="1">{
        return filepath.Base(path)[0] == '.'
}</span>

func isBackupFile(path string) bool <span class="cov8" title="1">{
        return path[len(path)-1] == '~'
}</span>

const baseFileBase = "baseof"

func isBaseTemplate(path string) bool <span class="cov8" title="1">{
        return strings.Contains(filepath.Base(path), baseFileBase)
}</span>
</pre>
		
		<pre class="file" id="file283" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "html/template"

        "github.com/gohugoio/hugo/deps"
)

// Some of the template funcs are'nt entirely stateless.
type templateFuncster struct {
        funcMap template.FuncMap

        *deps.Deps
}

func newTemplateFuncster(deps *deps.Deps) *templateFuncster <span class="cov8" title="1">{
        return &amp;templateFuncster{
                Deps: deps,
        }
}</span>
</pre>
		
		<pre class="file" id="file284" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "github.com/gohugoio/hugo/deps"
)

// TemplateProvider manages templates.
type TemplateProvider struct{}

// DefaultTemplateProvider is a globally available TemplateProvider.
var DefaultTemplateProvider *TemplateProvider

// Update updates the Hugo Template System in the provided Deps
// with all the additional features, templates &amp; functions.
func (*TemplateProvider) Update(deps *deps.Deps) error <span class="cov8" title="1">{

        newTmpl := newTemplateAdapter(deps)
        deps.Tmpl = newTmpl

        deps.TextTmpl = newTmpl.NewTextTemplate()

        newTmpl.initFuncs()

        if err := newTmpl.loadEmbedded(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if deps.WithTemplate != nil </span><span class="cov8" title="1">{
                err := deps.WithTemplate(newTmpl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }

        <span class="cov8" title="1">return newTmpl.MarkReady()</span>

}

// Clone clones.
func (*TemplateProvider) Clone(d *deps.Deps) error <span class="cov0" title="0">{

        t := d.Tmpl.(*templateHandler)
        clone := t.clone(d)

        d.Tmpl = clone

        return clone.MarkReady()

}</span>
</pre>
		
		<pre class="file" id="file285" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "html/template"
        "strings"
        texttemplate "text/template"
        "text/template/parse"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/tpl"
        "github.com/mitchellh/mapstructure"
        "github.com/spf13/cast"
)

// decl keeps track of the variable mappings, i.e. $mysite =&gt; .Site etc.
type decl map[string]string

const (
        paramsIdentifier = "Params"
)

// Containers that may contain Params that we will not touch.
var reservedContainers = map[string]bool{
        // Aka .Site.Data.Params which must stay case sensitive.
        "Data": true,
}

type templateType int

const (
        templateUndefined templateType = iota
        templateShortcode
        templatePartial
)

type templateContext struct {
        decl     decl
        visited  map[string]bool
        notFound map[string]bool
        lookupFn func(name string) *parse.Tree

        // The last error encountered.
        err error

        typ templateType

        // Set when we're done checking for config header.
        configChecked bool

        // Contains some info about the template
        tpl.Info

        // Store away the return node in partials.
        returnNode *parse.CommandNode
}

func (c templateContext) getIfNotVisited(name string) *parse.Tree <span class="cov8" title="1">{
        if c.visited[name] </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">c.visited[name] = true
        templ := c.lookupFn(name)
        if templ == nil </span><span class="cov8" title="1">{
                // This may be a inline template defined outside of this file
                // and not yet parsed. Unusual, but it happens.
                // Store the name to try again later.
                c.notFound[name] = true
        }</span>

        <span class="cov8" title="1">return templ</span>
}

func newTemplateContext(lookupFn func(name string) *parse.Tree) *templateContext <span class="cov8" title="1">{
        return &amp;templateContext{
                Info:     tpl.Info{Config: tpl.DefaultConfig},
                lookupFn: lookupFn,
                decl:     make(map[string]string),
                visited:  make(map[string]bool),
                notFound: make(map[string]bool)}
}</span>

func createParseTreeLookup(templ *template.Template) func(nn string) *parse.Tree <span class="cov8" title="1">{
        return func(nn string) *parse.Tree </span><span class="cov8" title="1">{
                tt := templ.Lookup(nn)
                if tt != nil </span><span class="cov8" title="1">{
                        return tt.Tree
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func applyTemplateTransformersToHMLTTemplate(typ templateType, templ *template.Template) (*templateContext, error) <span class="cov8" title="1">{
        return applyTemplateTransformers(typ, templ.Tree, createParseTreeLookup(templ))
}</span>

func applyTemplateTransformersToTextTemplate(typ templateType, templ *texttemplate.Template) (*templateContext, error) <span class="cov8" title="1">{
        return applyTemplateTransformers(typ, templ.Tree,
                func(nn string) *parse.Tree </span><span class="cov0" title="0">{
                        tt := templ.Lookup(nn)
                        if tt != nil </span><span class="cov0" title="0">{
                                return tt.Tree
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
}

func applyTemplateTransformers(typ templateType, templ *parse.Tree, lookupFn func(name string) *parse.Tree) (*templateContext, error) <span class="cov8" title="1">{
        if templ == nil </span><span class="cov0" title="0">{
                return nil, errors.New("expected template, but none provided")
        }</span>

        <span class="cov8" title="1">c := newTemplateContext(lookupFn)
        c.typ = typ

        _, err := c.applyTransformations(templ.Root)

        if err == nil &amp;&amp; c.returnNode != nil </span><span class="cov0" title="0">{
                // This is a partial with a return statement.
                c.Info.HasReturn = true
                templ.Root = c.wrapInPartialReturnWrapper(templ.Root)
        }</span>

        <span class="cov8" title="1">return c, err</span>
}

const (
        partialReturnWrapperTempl = `{{ $_hugo_dot := $ }}{{ $ := .Arg }}{{ with .Arg }}{{ $_hugo_dot.Set ("PLACEHOLDER") }}{{ end }}`
)

var partialReturnWrapper *parse.ListNode

func init() <span class="cov8" title="1">{
        templ, err := texttemplate.New("").Parse(partialReturnWrapperTempl)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">partialReturnWrapper = templ.Tree.Root</span>
}

func (c *templateContext) wrapInPartialReturnWrapper(n *parse.ListNode) *parse.ListNode <span class="cov0" title="0">{
        wrapper := partialReturnWrapper.CopyList()
        withNode := wrapper.Nodes[2].(*parse.WithNode)
        retn := withNode.List.Nodes[0]
        setCmd := retn.(*parse.ActionNode).Pipe.Cmds[0]
        setPipe := setCmd.Args[1].(*parse.PipeNode)
        // Replace PLACEHOLDER with the real return value.
        // Note that this is a PipeNode, so it will be wrapped in parens.
        setPipe.Cmds = []*parse.CommandNode{c.returnNode}
        withNode.List.Nodes = append(n.Nodes, retn)

        return wrapper

}</span>

// The truth logic in Go's template package is broken for certain values
// for the if and with keywords. This works around that problem by wrapping
// the node passed to if/with in a getif conditional.
// getif works slightly different than the Go built-in in that it also
// considers any IsZero methods on the values (as in time.Time).
// See https://github.com/gohugoio/hugo/issues/5738
func (c *templateContext) wrapWithGetIf(p *parse.PipeNode) <span class="cov8" title="1">{
        if len(p.Cmds) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // getif will return an empty string if not evaluated as truthful,
        // which is when we need the value in the with clause.
        <span class="cov8" title="1">firstArg := parse.NewIdentifier("getif")
        secondArg := p.CopyPipe()
        newCmd := p.Cmds[0].Copy().(*parse.CommandNode)

        // secondArg is a PipeNode and will behave as it was wrapped in parens, e.g:
        // {{ getif (len .Params | eq 2) }}
        newCmd.Args = []parse.Node{firstArg, secondArg}

        p.Cmds = []*parse.CommandNode{newCmd}</span>

}

// applyTransformations do 3 things:
// 1) Make all .Params.CamelCase and similar into lowercase.
// 2) Wraps every with and if pipe in getif
// 3) Collects some information about the template content.
func (c *templateContext) applyTransformations(n parse.Node) (bool, error) <span class="cov8" title="1">{
        switch x := n.(type) </span>{
        case *parse.ListNode:<span class="cov8" title="1">
                if x != nil </span><span class="cov8" title="1">{
                        c.applyTransformationsToNodes(x.Nodes...)
                }</span>
        case *parse.ActionNode:<span class="cov8" title="1">
                c.applyTransformationsToNodes(x.Pipe)</span>
        case *parse.IfNode:<span class="cov8" title="1">
                c.applyTransformationsToNodes(x.Pipe, x.List, x.ElseList)
                c.wrapWithGetIf(x.Pipe)</span>
        case *parse.WithNode:<span class="cov8" title="1">
                c.applyTransformationsToNodes(x.Pipe, x.List, x.ElseList)
                c.wrapWithGetIf(x.Pipe)</span>
        case *parse.RangeNode:<span class="cov8" title="1">
                c.applyTransformationsToNodes(x.Pipe, x.List, x.ElseList)</span>
        case *parse.TemplateNode:<span class="cov8" title="1">
                subTempl := c.getIfNotVisited(x.Name)
                if subTempl != nil </span><span class="cov8" title="1">{
                        c.applyTransformationsToNodes(subTempl.Root)
                }</span>
        case *parse.PipeNode:<span class="cov8" title="1">
                c.collectConfig(x)
                if len(x.Decl) == 1 &amp;&amp; len(x.Cmds) == 1 </span><span class="cov8" title="1">{
                        // maps $site =&gt; .Site etc.
                        c.decl[x.Decl[0].Ident[0]] = x.Cmds[0].String()
                }</span>

                <span class="cov8" title="1">for i, cmd := range x.Cmds </span><span class="cov8" title="1">{
                        keep, _ := c.applyTransformations(cmd)
                        if !keep </span><span class="cov0" title="0">{
                                x.Cmds = append(x.Cmds[:i], x.Cmds[i+1:]...)
                        }</span>
                }

        case *parse.CommandNode:<span class="cov8" title="1">
                c.collectInner(x)
                keep := c.collectReturnNode(x)

                for _, elem := range x.Args </span><span class="cov8" title="1">{
                        switch an := elem.(type) </span>{
                        case *parse.FieldNode:<span class="cov8" title="1">
                                c.updateIdentsIfNeeded(an.Ident)</span>
                        case *parse.VariableNode:<span class="cov8" title="1">
                                c.updateIdentsIfNeeded(an.Ident)</span>
                        case *parse.PipeNode:<span class="cov8" title="1">
                                c.applyTransformations(an)</span>
                        case *parse.ChainNode:<span class="cov8" title="1">
                                // site.Params...
                                if len(an.Field) &gt; 1 &amp;&amp; an.Field[0] == paramsIdentifier </span><span class="cov0" title="0">{
                                        c.updateIdentsIfNeeded(an.Field)
                                }</span>
                        }
                }
                <span class="cov8" title="1">return keep, c.err</span>
        }

        <span class="cov8" title="1">return true, c.err</span>
}

func (c *templateContext) applyTransformationsToNodes(nodes ...parse.Node) <span class="cov8" title="1">{
        for _, node := range nodes </span><span class="cov8" title="1">{
                c.applyTransformations(node)
        }</span>
}

func (c *templateContext) updateIdentsIfNeeded(idents []string) <span class="cov8" title="1">{
        index := c.decl.indexOfReplacementStart(idents)

        if index == -1 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">for i := index; i &lt; len(idents); i++ </span><span class="cov8" title="1">{
                idents[i] = strings.ToLower(idents[i])
        }</span>

}

func (c *templateContext) hasIdent(idents []string, ident string) bool <span class="cov8" title="1">{
        for _, id := range idents </span><span class="cov8" title="1">{
                if id == ident </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// collectConfig collects and parses any leading template config variable declaration.
// This will be the first PipeNode in the template, and will be a variable declaration
// on the form:
//    {{ $_hugo_config:= `{ "version": 1 }` }}
func (c *templateContext) collectConfig(n *parse.PipeNode) <span class="cov8" title="1">{
        if c.typ != templateShortcode </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if c.configChecked </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">c.configChecked = true

        if len(n.Decl) != 1 || len(n.Cmds) != 1 </span><span class="cov8" title="1">{
                // This cannot be a config declaration
                return
        }</span>

        <span class="cov8" title="1">v := n.Decl[0]

        if len(v.Ident) == 0 || v.Ident[0] != "$_hugo_config" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">cmd := n.Cmds[0]

        if len(cmd.Args) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if s, ok := cmd.Args[0].(*parse.StringNode); ok </span><span class="cov0" title="0">{
                errMsg := "failed to decode $_hugo_config in template"
                m, err := cast.ToStringMapE(s.Text)
                if err != nil </span><span class="cov0" title="0">{
                        c.err = errors.Wrap(err, errMsg)
                        return
                }</span>
                <span class="cov0" title="0">if err := mapstructure.WeakDecode(m, &amp;c.Info.Config); err != nil </span><span class="cov0" title="0">{
                        c.err = errors.Wrap(err, errMsg)
                }</span>
        }

}

// collectInner determines if the given CommandNode represents a
// shortcode call to its .Inner.
func (c *templateContext) collectInner(n *parse.CommandNode) <span class="cov8" title="1">{
        if c.typ != templateShortcode </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if c.Info.IsInner || len(n.Args) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">for _, arg := range n.Args </span><span class="cov8" title="1">{
                var idents []string
                switch nt := arg.(type) </span>{
                case *parse.FieldNode:<span class="cov8" title="1">
                        idents = nt.Ident</span>
                case *parse.VariableNode:<span class="cov8" title="1">
                        idents = nt.Ident</span>
                }

                <span class="cov8" title="1">if c.hasIdent(idents, "Inner") </span><span class="cov8" title="1">{
                        c.Info.IsInner = true
                        break</span>
                }
        }

}

func (c *templateContext) collectReturnNode(n *parse.CommandNode) bool <span class="cov8" title="1">{
        if c.typ != templatePartial || c.returnNode != nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if len(n.Args) &lt; 2 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">ident, ok := n.Args[0].(*parse.IdentifierNode)
        if !ok || ident.Ident != "return" </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">c.returnNode = n
        // Remove the "return" identifiers
        c.returnNode.Args = c.returnNode.Args[1:]

        return false</span>

}

// indexOfReplacementStart will return the index of where to start doing replacement,
// -1 if none needed.
func (d decl) indexOfReplacementStart(idents []string) int <span class="cov8" title="1">{

        l := len(idents)

        if l == 0 </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov8" title="1">if l == 1 </span><span class="cov8" title="1">{
                first := idents[0]
                if first == "" || first == paramsIdentifier || first[0] == '$' </span><span class="cov8" title="1">{
                        // This can not be a Params.x
                        return -1
                }</span>
        }

        <span class="cov8" title="1">var lookFurther bool
        var needsVarExpansion bool
        for _, ident := range idents </span><span class="cov8" title="1">{
                if ident[0] == '$' </span><span class="cov8" title="1">{
                        lookFurther = true
                        needsVarExpansion = true
                        break</span>
                } else<span class="cov8" title="1"> if ident == paramsIdentifier </span><span class="cov8" title="1">{
                        lookFurther = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !lookFurther </span><span class="cov8" title="1">{
                return -1
        }</span>

        <span class="cov8" title="1">var resolvedIdents []string

        if !needsVarExpansion </span><span class="cov8" title="1">{
                resolvedIdents = idents
        }</span> else<span class="cov8" title="1"> {
                var ok bool
                resolvedIdents, ok = d.resolveVariables(idents)
                if !ok </span><span class="cov8" title="1">{
                        return -1
                }</span>
        }

        <span class="cov8" title="1">var paramFound bool
        for i, ident := range resolvedIdents </span><span class="cov8" title="1">{
                if ident == paramsIdentifier </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                container := resolvedIdents[i-1]
                                if reservedContainers[container] </span><span class="cov0" title="0">{
                                        // .Data.Params.someKey
                                        return -1
                                }</span>
                        }

                        <span class="cov8" title="1">paramFound = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !paramFound </span><span class="cov8" title="1">{
                return -1
        }</span>

        <span class="cov8" title="1">var paramSeen bool
        idx := -1
        for i, ident := range idents </span><span class="cov8" title="1">{
                if ident == "" || ident[0] == '$' </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if ident == paramsIdentifier </span><span class="cov8" title="1">{
                        paramSeen = true
                        idx = -1

                }</span> else<span class="cov8" title="1"> {
                        if paramSeen </span><span class="cov8" title="1">{
                                return i
                        }</span>
                        <span class="cov8" title="1">if idx == -1 </span><span class="cov8" title="1">{
                                idx = i
                        }</span>
                }
        }
        <span class="cov0" title="0">return idx</span>

}

func (d decl) resolveVariables(idents []string) ([]string, bool) <span class="cov8" title="1">{
        var (
                replacements []string
                replaced     []string
        )

        // An Ident can start out as one of
        // [Params] [$blue] [$colors.Blue]
        // We need to resolve the variables, so
        // $blue =&gt; [Params Colors Blue]
        // etc.
        replacements = []string{idents[0]}

        // Loop until there are no more $vars to resolve.
        for i := 0; i &lt; len(replacements); i++ </span><span class="cov8" title="1">{

                if i &gt; 20 </span><span class="cov0" title="0">{
                        // bail out
                        return nil, false
                }</span>

                <span class="cov8" title="1">potentialVar := replacements[i]

                if potentialVar == "$" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if potentialVar == "" || potentialVar[0] != '$' </span><span class="cov8" title="1">{
                        // leave it as is
                        replaced = append(replaced, strings.Split(potentialVar, ".")...)
                        continue</span>
                }

                <span class="cov8" title="1">replacement, ok := d[potentialVar]

                if !ok </span><span class="cov8" title="1">{
                        // Temporary range vars. We do not care about those.
                        return nil, false
                }</span>

                <span class="cov8" title="1">if !d.isKeyword(replacement) </span><span class="cov8" title="1">{
                        // This can not be .Site.Params etc.
                        return nil, false
                }</span>

                <span class="cov8" title="1">replacement = strings.TrimPrefix(replacement, ".")

                if replacement == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if replacement[0] == '$' </span><span class="cov8" title="1">{
                        // Needs further expansion
                        replacements = append(replacements, strings.Split(replacement, ".")...)
                }</span> else<span class="cov8" title="1"> {
                        replaced = append(replaced, strings.Split(replacement, ".")...)
                }</span>
        }

        <span class="cov8" title="1">return append(replaced, idents[1:]...), true</span>

}

func (d decl) isKeyword(s string) bool <span class="cov8" title="1">{
        return !strings.ContainsAny(s, " -\"")
}</span>
</pre>
		
		<pre class="file" id="file286" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "github.com/gohugoio/hugo/common/herrors"
        "github.com/pkg/errors"
        "github.com/spf13/afero"
)

type templateInfo struct {
        template string

        // Used to create some error context in error situations
        fs afero.Fs

        // The filename relative to the fs above.
        filename string

        // The real filename (if possible). Used for logging.
        realFilename string
}

func (info templateInfo) errWithFileContext(what string, err error) error <span class="cov0" title="0">{
        err = errors.Wrapf(err, what)

        err, _ = herrors.WithFileContextForFile(
                err,
                info.realFilename,
                info.filename,
                info.fs,
                herrors.SimpleLineMatcher)

        return err
}</span>
</pre>
		
		<pre class="file" id="file287" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Portions Copyright The Go Authors.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "html/template"

        "github.com/gohugoio/hugo/deps"

        "github.com/gohugoio/hugo/tpl/internal"

        // Init the namespaces
        _ "github.com/gohugoio/hugo/tpl/cast"
        _ "github.com/gohugoio/hugo/tpl/collections"
        _ "github.com/gohugoio/hugo/tpl/compare"
        _ "github.com/gohugoio/hugo/tpl/crypto"
        _ "github.com/gohugoio/hugo/tpl/data"
        _ "github.com/gohugoio/hugo/tpl/encoding"
        _ "github.com/gohugoio/hugo/tpl/fmt"
        _ "github.com/gohugoio/hugo/tpl/hugo"
        _ "github.com/gohugoio/hugo/tpl/images"
        _ "github.com/gohugoio/hugo/tpl/inflect"
        _ "github.com/gohugoio/hugo/tpl/lang"
        _ "github.com/gohugoio/hugo/tpl/math"
        _ "github.com/gohugoio/hugo/tpl/os"
        _ "github.com/gohugoio/hugo/tpl/partials"
        _ "github.com/gohugoio/hugo/tpl/path"
        _ "github.com/gohugoio/hugo/tpl/reflect"
        _ "github.com/gohugoio/hugo/tpl/resources"
        _ "github.com/gohugoio/hugo/tpl/safe"
        _ "github.com/gohugoio/hugo/tpl/site"
        _ "github.com/gohugoio/hugo/tpl/strings"
        _ "github.com/gohugoio/hugo/tpl/templates"
        _ "github.com/gohugoio/hugo/tpl/time"
        _ "github.com/gohugoio/hugo/tpl/transform"
        _ "github.com/gohugoio/hugo/tpl/urls"
)

func createFuncMap(d *deps.Deps) map[string]interface{} <span class="cov8" title="1">{
        funcMap := template.FuncMap{}

        // Merge the namespace funcs
        for _, nsf := range internal.TemplateFuncsNamespaceRegistry </span><span class="cov8" title="1">{
                ns := nsf(d)
                if _, exists := funcMap[ns.Name]; exists </span><span class="cov0" title="0">{
                        panic(ns.Name + " is a duplicate template func")</span>
                }
                <span class="cov8" title="1">funcMap[ns.Name] = ns.Context
                for _, mm := range ns.MethodMappings </span><span class="cov8" title="1">{
                        for _, alias := range mm.Aliases </span><span class="cov8" title="1">{
                                if _, exists := funcMap[alias]; exists </span><span class="cov0" title="0">{
                                        panic(alias + " is a duplicate template func")</span>
                                }
                                <span class="cov8" title="1">funcMap[alias] = mm.Method</span>
                        }

                }

        }

        <span class="cov8" title="1">return funcMap</span>

}
func (t *templateFuncster) initFuncMap(funcMap template.FuncMap) <span class="cov8" title="1">{
        t.funcMap = funcMap
        t.Tmpl.(*templateHandler).setFuncs(funcMap)
}</span>
</pre>
		
		<pre class="file" id="file288" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package transform

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "transform"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Emojify,
                        []string{"emojify"},
                        [][2]string{
                                {`{{ "I :heart: Hugo" | emojify }}`, `I  Hugo`},
                        },
                )

                ns.AddMethodMapping(ctx.Highlight,
                        []string{"highlight"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.HTMLEscape,
                        []string{"htmlEscape"},
                        [][2]string{
                                {
                                        `{{ htmlEscape "Cathal Garvey &amp; The Sunshine Band &lt;cathal@foo.bar&gt;" | safeHTML}}`,
                                        `Cathal Garvey &amp;amp; The Sunshine Band &amp;lt;cathal@foo.bar&amp;gt;`},
                                {
                                        `{{ htmlEscape "Cathal Garvey &amp; The Sunshine Band &lt;cathal@foo.bar&gt;"}}`,
                                        `Cathal Garvey &amp;amp;amp; The Sunshine Band &amp;amp;lt;cathal@foo.bar&amp;amp;gt;`},
                                {
                                        `{{ htmlEscape "Cathal Garvey &amp; The Sunshine Band &lt;cathal@foo.bar&gt;" | htmlUnescape | safeHTML }}`,
                                        `Cathal Garvey &amp; The Sunshine Band &lt;cathal@foo.bar&gt;`},
                        },
                )

                ns.AddMethodMapping(ctx.HTMLUnescape,
                        []string{"htmlUnescape"},
                        [][2]string{
                                {
                                        `{{ htmlUnescape "Cathal Garvey &amp;amp; The Sunshine Band &amp;lt;cathal@foo.bar&amp;gt;" | safeHTML}}`,
                                        `Cathal Garvey &amp; The Sunshine Band &lt;cathal@foo.bar&gt;`},
                                {
                                        `{{"Cathal Garvey &amp;amp;amp; The Sunshine Band &amp;amp;lt;cathal@foo.bar&amp;amp;gt;" | htmlUnescape | htmlUnescape | safeHTML}}`,
                                        `Cathal Garvey &amp; The Sunshine Band &lt;cathal@foo.bar&gt;`},
                                {
                                        `{{"Cathal Garvey &amp;amp;amp; The Sunshine Band &amp;amp;lt;cathal@foo.bar&amp;amp;gt;" | htmlUnescape | htmlUnescape }}`,
                                        `Cathal Garvey &amp;amp; The Sunshine Band &amp;lt;cathal@foo.bar&amp;gt;`},
                                {
                                        `{{ htmlUnescape "Cathal Garvey &amp;amp; The Sunshine Band &amp;lt;cathal@foo.bar&amp;gt;" | htmlEscape | safeHTML }}`,
                                        `Cathal Garvey &amp;amp; The Sunshine Band &amp;lt;cathal@foo.bar&amp;gt;`},
                        },
                )

                ns.AddMethodMapping(ctx.Markdownify,
                        []string{"markdownify"},
                        [][2]string{
                                {`{{ .Title | markdownify}}`, `&lt;strong&gt;BatMan&lt;/strong&gt;`},
                        },
                )

                ns.AddMethodMapping(ctx.Plainify,
                        []string{"plainify"},
                        [][2]string{
                                {`{{ plainify  "Hello &lt;strong&gt;world&lt;/strong&gt;, gophers!" }}`, `Hello world, gophers!`},
                        },
                )

                ns.AddMethodMapping(ctx.Remarshal,
                        nil,
                        [][2]string{
                                {`{{ "title = \"Hello World\"" | transform.Remarshal "json" | safeHTML }}`, "{\n   \"title\": \"Hello World\"\n}\n"},
                        },
                )

                ns.AddMethodMapping(ctx.Unmarshal,
                        []string{"unmarshal"},
                        [][2]string{
                                {`{{ "hello = \"Hello World\"" | transform.Unmarshal }}`, "map[hello:Hello World]"},
                                {`{{ "hello = \"Hello World\"" | resources.FromString "data/greetings.toml" | transform.Unmarshal }}`, "map[hello:Hello World]"},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file289" style="display: none">package transform

import (
        "bytes"
        "strings"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/parser"
        "github.com/gohugoio/hugo/parser/metadecoders"
        "github.com/spf13/cast"
)

// Remarshal is used in the Hugo documentation to convert configuration
// examples from YAML to JSON, TOML (and possibly the other way around).
// The is primarily a helper for the Hugo docs site.
// It is not a general purpose YAML to TOML converter etc., and may
// change without notice if it serves a purpose in the docs.
// Format is one of json, yaml or toml.
func (ns *Namespace) Remarshal(format string, data interface{}) (string, error) <span class="cov0" title="0">{
        from, err := cast.ToStringE(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">from = strings.TrimSpace(from)
        format = strings.TrimSpace(strings.ToLower(format))

        if from == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">mark, err := toFormatMark(format)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">fromFormat := metadecoders.Default.FormatFromContentString(from)
        if fromFormat == "" </span><span class="cov0" title="0">{
                return "", errors.New("failed to detect format from content")
        }</span>

        <span class="cov0" title="0">meta, err := metadecoders.Default.UnmarshalToMap([]byte(from), fromFormat)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var result bytes.Buffer
        if err := parser.InterfaceToConfig(meta, mark, &amp;result); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return result.String(), nil</span>
}

func toFormatMark(format string) (metadecoders.Format, error) <span class="cov0" title="0">{
        if f := metadecoders.FormatFromString(format); f != "" </span><span class="cov0" title="0">{
                return f, nil
        }</span>

        <span class="cov0" title="0">return "", errors.New("failed to detect target data serialization format")</span>
}
</pre>
		
		<pre class="file" id="file290" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package transform provides template functions for transforming content.
package transform

import (
        "html"
        "html/template"

        "github.com/gohugoio/hugo/cache/namedmemcache"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/cast"
)

// New returns a new instance of the transform-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        cache := namedmemcache.New()
        deps.BuildStartListeners.Add(
                func() </span><span class="cov0" title="0">{
                        cache.Clear()
                }</span>)

        <span class="cov8" title="1">return &amp;Namespace{
                cache: cache,
                deps:  deps,
        }</span>
}

// Namespace provides template functions for the "transform" namespace.
type Namespace struct {
        cache *namedmemcache.Cache
        deps  *deps.Deps
}

// Emojify returns a copy of s with all emoji codes replaced with actual emojis.
//
// See http://www.emoji-cheat-sheet.com/
func (ns *Namespace) Emojify(s interface{}) (template.HTML, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return template.HTML(helpers.Emojify([]byte(ss))), nil</span>
}

// Highlight returns a copy of s as an HTML string with syntax
// highlighting applied.
func (ns *Namespace) Highlight(s interface{}, lang, opts string) (template.HTML, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">highlighted, _ := ns.deps.ContentSpec.Highlight(ss, lang, opts)
        return template.HTML(highlighted), nil</span>
}

// HTMLEscape returns a copy of s with reserved HTML characters escaped.
func (ns *Namespace) HTMLEscape(s interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return html.EscapeString(ss), nil</span>
}

// HTMLUnescape returns a copy of with HTML escape requences converted to plain
// text.
func (ns *Namespace) HTMLUnescape(s interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return html.UnescapeString(ss), nil</span>
}

// Markdownify renders a given input from Markdown to HTML.
func (ns *Namespace) Markdownify(s interface{}) (template.HTML, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">m := ns.deps.ContentSpec.RenderBytes(
                &amp;helpers.RenderingContext{
                        Cfg:     ns.deps.Cfg,
                        Content: []byte(ss),
                        PageFmt: "markdown",
                        Config:  ns.deps.ContentSpec.BlackFriday,
                },
        )

        // Strip if this is a short inline type of text.
        m = ns.deps.ContentSpec.TrimShortHTML(m)

        return helpers.BytesToHTML(m), nil</span>
}

// Plainify returns a copy of s with all HTML tags removed.
func (ns *Namespace) Plainify(s interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return helpers.StripHTML(ss), nil</span>
}
</pre>
		
		<pre class="file" id="file291" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package transform

import (
        "io/ioutil"
        "strings"

        "github.com/mitchellh/mapstructure"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/parser/metadecoders"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/pkg/errors"

        "github.com/spf13/cast"
)

// Unmarshal unmarshals the data given, which can be either a string
// or a Resource. Supported formats are JSON, TOML, YAML, and CSV.
// You can optionally provide an options map as the first argument.
func (ns *Namespace) Unmarshal(args ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) &lt; 1 || len(args) &gt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("unmarshal takes 1 or 2 arguments")
        }</span>

        <span class="cov0" title="0">var data interface{}
        var decoder = metadecoders.Default

        if len(args) == 1 </span><span class="cov0" title="0">{
                data = args[0]
        }</span> else<span class="cov0" title="0"> {
                m, ok := args[0].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("first argument must be a map")
                }</span>

                <span class="cov0" title="0">var err error

                data = args[1]
                decoder, err = decodeDecoder(m)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.WithMessage(err, "failed to decode options")
                }</span>
        }

        <span class="cov0" title="0">if r, ok := data.(unmarshableResource); ok </span><span class="cov0" title="0">{
                key := r.Key()

                if key == "" </span><span class="cov0" title="0">{
                        return nil, errors.New("no Key set in Resource")
                }</span>

                <span class="cov0" title="0">if decoder != metadecoders.Default </span><span class="cov0" title="0">{
                        key += decoder.OptionsKey()
                }</span>

                <span class="cov0" title="0">return ns.cache.GetOrCreate(key, func() (interface{}, error) </span><span class="cov0" title="0">{
                        f := metadecoders.FormatFromMediaType(r.MediaType())
                        if f == "" </span><span class="cov0" title="0">{
                                return nil, errors.Errorf("MIME %q not supported", r.MediaType())
                        }</span>

                        <span class="cov0" title="0">reader, err := r.ReadSeekCloser()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">defer reader.Close()

                        b, err := ioutil.ReadAll(reader)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return decoder.Unmarshal(b, f)</span>
                })
        }

        <span class="cov0" title="0">dataStr, err := cast.ToStringE(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("type %T not supported", data)
        }</span>

        <span class="cov0" title="0">key := helpers.MD5String(dataStr)

        return ns.cache.GetOrCreate(key, func() (interface{}, error) </span><span class="cov0" title="0">{
                f := decoder.FormatFromContentString(dataStr)
                if f == "" </span><span class="cov0" title="0">{
                        return nil, errors.New("unknown format")
                }</span>

                <span class="cov0" title="0">return decoder.Unmarshal([]byte(dataStr), f)</span>
        })
}

// All the relevant resources implements this interface.
type unmarshableResource interface {
        resource.ReadSeekCloserResource
        resource.Identifier
}

func decodeDecoder(m map[string]interface{}) (metadecoders.Decoder, error) <span class="cov0" title="0">{
        opts := metadecoders.Default

        if m == nil </span><span class="cov0" title="0">{
                return opts, nil
        }</span>

        // mapstructure does not support string to rune conversion, so do that manually.
        // See https://github.com/mitchellh/mapstructure/issues/151
        <span class="cov0" title="0">for k, v := range m </span><span class="cov0" title="0">{
                if strings.EqualFold(k, "Delimiter") </span><span class="cov0" title="0">{
                        r, err := stringToRune(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return opts, err
                        }</span>
                        <span class="cov0" title="0">opts.Delimiter = r
                        delete(m, k)</span>

                } else<span class="cov0" title="0"> if strings.EqualFold(k, "Comment") </span><span class="cov0" title="0">{
                        r, err := stringToRune(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return opts, err
                        }</span>
                        <span class="cov0" title="0">opts.Comment = r
                        delete(m, k)</span>
                }
        }

        <span class="cov0" title="0">err := mapstructure.WeakDecode(m, &amp;opts)

        return opts, err</span>
}

func stringToRune(v interface{}) (rune, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(v)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if len(s) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">var r rune

        for i, rr := range s </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        r = rr
                }</span> else<span class="cov0" title="0"> {
                        return 0, errors.Errorf("invalid character: %q", v)
                }</span>
        }

        <span class="cov0" title="0">return r, nil</span>
}
</pre>
		
		<pre class="file" id="file292" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package urls

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "urls"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) interface{} </span><span class="cov0" title="0">{ return ctx }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.AbsURL,
                        []string{"absURL"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.AbsLangURL,
                        []string{"absLangURL"},
                        [][2]string{},
                )
                ns.AddMethodMapping(ctx.Ref,
                        []string{"ref"},
                        [][2]string{},
                )
                ns.AddMethodMapping(ctx.RelURL,
                        []string{"relURL"},
                        [][2]string{},
                )
                ns.AddMethodMapping(ctx.RelLangURL,
                        []string{"relLangURL"},
                        [][2]string{},
                )
                ns.AddMethodMapping(ctx.RelRef,
                        []string{"relref"},
                        [][2]string{},
                )
                ns.AddMethodMapping(ctx.URLize,
                        []string{"urlize"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Anchorize,
                        []string{"anchorize"},
                        [][2]string{
                                {`{{ "This is a title" | anchorize }}`, `this-is-a-title`},
                        },
                )

                return ns</span>

        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file293" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package urls provides template functions to deal with URLs.
package urls

import (
        "errors"
        "fmt"

        "html/template"
        "net/url"

        "github.com/gohugoio/hugo/common/urls"
        "github.com/gohugoio/hugo/deps"
        _errors "github.com/pkg/errors"
        "github.com/russross/blackfriday"
        "github.com/spf13/cast"
)

// New returns a new instance of the urls-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                deps:      deps,
                multihost: deps.Cfg.GetBool("multihost"),
        }
}</span>

// Namespace provides template functions for the "urls" namespace.
type Namespace struct {
        deps      *deps.Deps
        multihost bool
}

// AbsURL takes a given string and converts it to an absolute URL.
func (ns *Namespace) AbsURL(a interface{}) (template.HTML, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">return template.HTML(ns.deps.PathSpec.AbsURL(s, false)), nil</span>
}

// Parse parses rawurl into a URL structure. The rawurl may be relative or
// absolute.
func (ns *Namespace) Parse(rawurl interface{}) (*url.URL, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(rawurl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, _errors.Wrap(err, "Error in Parse")
        }</span>

        <span class="cov0" title="0">return url.Parse(s)</span>
}

// RelURL takes a given string and prepends the relative path according to a
// page's position in the project directory structure.
func (ns *Namespace) RelURL(a interface{}) (template.HTML, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return template.HTML(ns.deps.PathSpec.RelURL(s, false)), nil</span>
}

// URLize returns the given argument formatted as URL.
func (ns *Namespace) URLize(a interface{}) (string, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return ns.deps.PathSpec.URLize(s), nil</span>
}

// Anchorize creates sanitized anchor names that are compatible with Blackfriday.
func (ns *Namespace) Anchorize(a interface{}) (string, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return blackfriday.SanitizedAnchorName(s), nil</span>
}

// Ref returns the absolute URL path to a given content item.
func (ns *Namespace) Ref(in interface{}, args interface{}) (template.HTML, error) <span class="cov0" title="0">{
        p, ok := in.(urls.RefLinker)
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("invalid Page received in Ref")
        }</span>
        <span class="cov0" title="0">argsm, err := ns.refArgsToMap(args)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">s, err := p.Ref(argsm)
        return template.HTML(s), err</span>
}

// RelRef returns the relative URL path to a given content item.
func (ns *Namespace) RelRef(in interface{}, args interface{}) (template.HTML, error) <span class="cov0" title="0">{
        p, ok := in.(urls.RefLinker)
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("invalid Page received in RelRef")
        }</span>
        <span class="cov0" title="0">argsm, err := ns.refArgsToMap(args)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">s, err := p.RelRef(argsm)
        return template.HTML(s), err</span>
}

func (ns *Namespace) refArgsToMap(args interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var (
                s  string
                of string
        )
        switch v := args.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                return v, nil</span>
        case map[string]string:<span class="cov0" title="0">
                m := make(map[string]interface{})
                for k, v := range v </span><span class="cov0" title="0">{
                        m[k] = v
                }</span>
                <span class="cov0" title="0">return m, nil</span>
        case []string:<span class="cov0" title="0">
                if len(v) == 0 || len(v) &gt; 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid numer of arguments to ref")
                }</span>
                // These where the options before we introduced the map type:
                <span class="cov0" title="0">s = v[0]
                if len(v) == 2 </span><span class="cov0" title="0">{
                        of = v[1]
                }</span>
        default:<span class="cov0" title="0">
                var err error
                s, err = cast.ToStringE(args)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        }
        <span class="cov0" title="0">return map[string]interface{}{
                "path":         s,
                "outputFormat": of,
        }, nil</span>
}

// RelLangURL takes a given string and prepends the relative path according to a
// page's position in the project directory structure and the current language.
func (ns *Namespace) RelLangURL(a interface{}) (template.HTML, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return template.HTML(ns.deps.PathSpec.RelURL(s, !ns.multihost)), nil</span>
}

// AbsLangURL takes a given string and converts it to an absolute URL according
// to a page's position in the project directory structure and the current
// language.
func (ns *Namespace) AbsLangURL(a interface{}) (template.HTML, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return template.HTML(ns.deps.PathSpec.AbsURL(s, !ns.multihost)), nil</span>
}
</pre>
		
		<pre class="file" id="file294" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package transform

import (
        "bytes"
        "io"

        bp "github.com/gohugoio/hugo/bufferpool"
)

// Transformer is the func that needs to be implemented by a transformation step.
type Transformer func(ft FromTo) error

// BytesReader wraps the Bytes method, usually implemented by bytes.Buffer, and an
// io.Reader.
type BytesReader interface {
        // The slice given by Bytes is valid for use only until the next buffer modification.
        // That is, if you want to use this value outside of the current transformer step,
        // you need to take a copy.
        Bytes() []byte

        io.Reader
}

// FromTo is sent to each transformation step in the chain.
type FromTo interface {
        From() BytesReader
        To() io.Writer
}

// Chain is an ordered processing chain. The next transform operation will
// receive the output from the previous.
type Chain []Transformer

// New creates a content transformer chain given the provided transform funcs.
func New(trs ...Transformer) Chain <span class="cov0" title="0">{
        return trs
}</span>

// NewEmpty creates a new slice of transformers with a capacity of 20.
func NewEmpty() Chain <span class="cov8" title="1">{
        return make(Chain, 0, 20)
}</span>

// Implements contentTransformer
// Content is read from the from-buffer and rewritten to to the to-buffer.
type fromToBuffer struct {
        from *bytes.Buffer
        to   *bytes.Buffer
}

func (ft fromToBuffer) From() BytesReader <span class="cov8" title="1">{
        return ft.from
}</span>

func (ft fromToBuffer) To() io.Writer <span class="cov8" title="1">{
        return ft.to
}</span>

// Apply passes the given from io.Reader through the transformation chain.
// The result is written to to.
func (c *Chain) Apply(to io.Writer, from io.Reader) error <span class="cov8" title="1">{
        if len(*c) == 0 </span><span class="cov0" title="0">{
                _, err := io.Copy(to, from)
                return err
        }</span>

        <span class="cov8" title="1">b1 := bp.GetBuffer()
        defer bp.PutBuffer(b1)

        if _, err := b1.ReadFrom(from); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">b2 := bp.GetBuffer()
        defer bp.PutBuffer(b2)

        fb := &amp;fromToBuffer{from: b1, to: b2}

        for i, tr := range *c </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        if fb.from == b1 </span><span class="cov0" title="0">{
                                fb.from = b2
                                fb.to = b1
                                fb.to.Reset()
                        }</span> else<span class="cov0" title="0"> {
                                fb.from = b1
                                fb.to = b2
                                fb.to.Reset()
                        }</span>
                }

                <span class="cov8" title="1">if err := tr(fb); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">_, err := fb.to.WriteTo(to)
        return err</span>
}
</pre>
		
		<pre class="file" id="file295" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package livereloadinject

import (
        "bytes"
        "fmt"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/transform"
)

// New creates a function that can be used
// to inject a script tag for the livereload JavaScript in a HTML document.
func New(port int) transform.Transformer <span class="cov0" title="0">{
        return func(ft transform.FromTo) error </span><span class="cov0" title="0">{
                b := ft.From().Bytes()
                endBodyTag := "&lt;/body&gt;"
                match := []byte(endBodyTag)
                replaceTemplate := `&lt;script data-no-instant&gt;document.write('&lt;script src="/livereload.js?port=%d&amp;mindelay=10&amp;v=2"&gt;&lt;/' + 'script&gt;')&lt;/script&gt;%s`
                replace := []byte(fmt.Sprintf(replaceTemplate, port, endBodyTag))

                newcontent := bytes.Replace(b, match, replace, 1)
                if len(newcontent) == len(b) </span><span class="cov0" title="0">{
                        endBodyTag = "&lt;/BODY&gt;"
                        replace := []byte(fmt.Sprintf(replaceTemplate, port, endBodyTag))
                        match := []byte(endBodyTag)
                        newcontent = bytes.Replace(b, match, replace, 1)
                }</span>

                <span class="cov0" title="0">if _, err := ft.To().Write(newcontent); err != nil </span><span class="cov0" title="0">{
                        helpers.DistinctWarnLog.Println("Failed to inject LiveReload script:", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file296" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metainject

import (
        "bytes"
        "fmt"
        "regexp"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/transform"
)

var metaTagsCheck = regexp.MustCompile(`(?i)&lt;meta\s+name=['|"]?generator['|"]?`)
var hugoGeneratorTag = fmt.Sprintf(`&lt;meta name="generator" content="Hugo %s" /&gt;`, hugo.CurrentVersion)

// HugoGenerator injects a meta generator tag for Hugo if none present.
func HugoGenerator(ft transform.FromTo) error <span class="cov8" title="1">{
        b := ft.From().Bytes()
        if metaTagsCheck.Match(b) </span><span class="cov8" title="1">{
                if _, err := ft.To().Write(b); err != nil </span><span class="cov0" title="0">{
                        helpers.DistinctWarnLog.Println("Failed to inject Hugo generator tag:", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov0" title="0">head := "&lt;head&gt;"
        replace := []byte(fmt.Sprintf("%s\n\t%s", head, hugoGeneratorTag))
        newcontent := bytes.Replace(b, []byte(head), replace, 1)

        if len(newcontent) == len(b) </span><span class="cov0" title="0">{
                head := "&lt;HEAD&gt;"
                replace := []byte(fmt.Sprintf("%s\n\t%s", head, hugoGeneratorTag))
                newcontent = bytes.Replace(b, []byte(head), replace, 1)
        }</span>

        <span class="cov0" title="0">if _, err := ft.To().Write(newcontent); err != nil </span><span class="cov0" title="0">{
                helpers.DistinctWarnLog.Println("Failed to inject Hugo generator tag:", err)
        }</span>

        <span class="cov0" title="0">return nil</span>

}
</pre>
		
		<pre class="file" id="file297" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package urlreplacers

import "github.com/gohugoio/hugo/transform"

var ar = newAbsURLReplacer()

// NewAbsURLTransformer replaces relative URLs with absolute ones
// in HTML files, using the baseURL setting.
func NewAbsURLTransformer(path string) transform.Transformer <span class="cov0" title="0">{
        return func(ft transform.FromTo) error </span><span class="cov0" title="0">{
                ar.replaceInHTML(path, ft)
                return nil
        }</span>
}

// NewAbsURLInXMLTransformer replaces relative URLs with absolute ones
// in XML files, using the baseURL setting.
func NewAbsURLInXMLTransformer(path string) transform.Transformer <span class="cov8" title="1">{
        return func(ft transform.FromTo) error </span><span class="cov8" title="1">{
                ar.replaceInXML(path, ft)
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file298" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package urlreplacers

import (
        "bytes"
        "io"
        "unicode"
        "unicode/utf8"

        "github.com/gohugoio/hugo/transform"
)

type absurllexer struct {
        // the source to absurlify
        content []byte
        // the target for the new absurlified content
        w io.Writer

        // path may be set to a "." relative path
        path []byte

        pos   int // input position
        start int // item start position

        quotes [][]byte
}

type prefix struct {
        disabled bool
        b        []byte
        f        func(l *absurllexer)

        nextPos int
}

func (p *prefix) find(bs []byte, start int) bool <span class="cov8" title="1">{
        if p.disabled </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if p.nextPos == -1 </span><span class="cov8" title="1">{
                idx := bytes.Index(bs[start:], p.b)

                if idx == -1 </span><span class="cov8" title="1">{
                        p.disabled = true
                        // Find the closest match
                        return false
                }</span>

                <span class="cov8" title="1">p.nextPos = start + idx + len(p.b)</span>
        }

        <span class="cov8" title="1">return true</span>
}

func newPrefixState() []*prefix <span class="cov8" title="1">{
        return []*prefix{
                {b: []byte("src="), f: checkCandidateBase},
                {b: []byte("href="), f: checkCandidateBase},
                {b: []byte("action="), f: checkCandidateBase},
                {b: []byte("srcset="), f: checkCandidateSrcset},
        }
}</span>

func (l *absurllexer) emit() <span class="cov8" title="1">{
        l.w.Write(l.content[l.start:l.pos])
        l.start = l.pos
}</span>

var (
        relURLPrefix    = []byte("/")
        relURLPrefixLen = len(relURLPrefix)
)

func (l *absurllexer) consumeQuote() []byte <span class="cov8" title="1">{
        for _, q := range l.quotes </span><span class="cov8" title="1">{
                if bytes.HasPrefix(l.content[l.pos:], q) </span><span class="cov0" title="0">{
                        l.pos += len(q)
                        l.emit()
                        return q
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// handle URLs in src and href.
func checkCandidateBase(l *absurllexer) <span class="cov8" title="1">{
        l.consumeQuote()

        if !bytes.HasPrefix(l.content[l.pos:], relURLPrefix) </span><span class="cov8" title="1">{
                return
        }</span>

        // check for schemaless URLs
        <span class="cov0" title="0">posAfter := l.pos + relURLPrefixLen
        if posAfter &gt;= len(l.content) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">r, _ := utf8.DecodeRune(l.content[posAfter:])
        if r == '/' </span><span class="cov0" title="0">{
                // schemaless: skip
                return
        }</span>
        <span class="cov0" title="0">if l.pos &gt; l.start </span><span class="cov0" title="0">{
                l.emit()
        }</span>
        <span class="cov0" title="0">l.pos += relURLPrefixLen
        l.w.Write(l.path)
        l.start = l.pos</span>
}

func (l *absurllexer) posAfterURL(q []byte) int <span class="cov0" title="0">{
        if len(q) &gt; 0 </span><span class="cov0" title="0">{
                // look for end quote
                return bytes.Index(l.content[l.pos:], q)
        }</span>

        <span class="cov0" title="0">return bytes.IndexFunc(l.content[l.pos:], func(r rune) bool </span><span class="cov0" title="0">{
                return r == '&gt;' || unicode.IsSpace(r)
        }</span>)

}

// handle URLs in srcset.
func checkCandidateSrcset(l *absurllexer) <span class="cov8" title="1">{
        q := l.consumeQuote()
        if q == nil </span><span class="cov8" title="1">{
                // srcset needs to be quoted.
                return
        }</span>

        // special case, not frequent (me think)
        <span class="cov0" title="0">if !bytes.HasPrefix(l.content[l.pos:], relURLPrefix) </span><span class="cov0" title="0">{
                return
        }</span>

        // check for schemaless URLs
        <span class="cov0" title="0">posAfter := l.pos + relURLPrefixLen
        if posAfter &gt;= len(l.content) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">r, _ := utf8.DecodeRune(l.content[posAfter:])
        if r == '/' </span><span class="cov0" title="0">{
                // schemaless: skip
                return
        }</span>

        <span class="cov0" title="0">posEnd := l.posAfterURL(q)

        // safe guard
        if posEnd &lt; 0 || posEnd &gt; 2000 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if l.pos &gt; l.start </span><span class="cov0" title="0">{
                l.emit()
        }</span>

        <span class="cov0" title="0">section := l.content[l.pos : l.pos+posEnd+1]

        fields := bytes.Fields(section)
        for i, f := range fields </span><span class="cov0" title="0">{
                if f[0] == '/' </span><span class="cov0" title="0">{
                        l.w.Write(l.path)
                        l.w.Write(f[1:])

                }</span> else<span class="cov0" title="0"> {
                        l.w.Write(f)
                }</span>

                <span class="cov0" title="0">if i &lt; len(fields)-1 </span><span class="cov0" title="0">{
                        l.w.Write([]byte(" "))
                }</span>
        }

        <span class="cov0" title="0">l.pos += len(section)
        l.start = l.pos</span>

}

// main loop
func (l *absurllexer) replace() <span class="cov8" title="1">{
        contentLength := len(l.content)

        prefixes := newPrefixState()

        for </span><span class="cov8" title="1">{
                if l.pos &gt;= contentLength </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">var match *prefix

                for _, p := range prefixes </span><span class="cov8" title="1">{
                        if !p.find(l.content, l.pos) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if match == nil || p.nextPos &lt; match.nextPos </span><span class="cov8" title="1">{
                                match = p
                        }</span>
                }

                <span class="cov8" title="1">if match == nil </span><span class="cov8" title="1">{
                        // Done!
                        l.pos = contentLength
                        break</span>
                } else<span class="cov8" title="1"> {
                        l.pos = match.nextPos
                        match.nextPos = -1
                        match.f(l)
                }</span>
        }
        // Done!
        <span class="cov8" title="1">if l.pos &gt; l.start </span><span class="cov8" title="1">{
                l.emit()
        }</span>
}

func doReplace(path string, ct transform.FromTo, quotes [][]byte) <span class="cov8" title="1">{

        lexer := &amp;absurllexer{
                content: ct.From().Bytes(),
                w:       ct.To(),
                path:    []byte(path),
                quotes:  quotes}

        lexer.replace()
}</span>

type absURLReplacer struct {
        htmlQuotes [][]byte
        xmlQuotes  [][]byte
}

func newAbsURLReplacer() *absURLReplacer <span class="cov8" title="1">{
        return &amp;absURLReplacer{
                htmlQuotes: [][]byte{[]byte("\""), []byte("'")},
                xmlQuotes:  [][]byte{[]byte("&amp;#34;"), []byte("&amp;#39;")}}
}</span>

func (au *absURLReplacer) replaceInHTML(path string, ct transform.FromTo) <span class="cov0" title="0">{
        doReplace(path, ct, au.htmlQuotes)
}</span>

func (au *absURLReplacer) replaceInXML(path string, ct transform.FromTo) <span class="cov8" title="1">{
        doReplace(path, ct, au.xmlQuotes)
}</span>
</pre>
		
		<pre class="file" id="file299" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package watcher

import (
        "time"

        "github.com/fsnotify/fsnotify"
)

// Batcher batches file watch events in a given interval.
type Batcher struct {
        *fsnotify.Watcher
        interval time.Duration
        done     chan struct{}

        Events chan []fsnotify.Event // Events are returned on this channel
}

// New creates and starts a Batcher with the given time interval.
func New(interval time.Duration) (*Batcher, error) <span class="cov0" title="0">{
        watcher, err := fsnotify.NewWatcher()

        batcher := &amp;Batcher{}
        batcher.Watcher = watcher
        batcher.interval = interval
        batcher.done = make(chan struct{}, 1)
        batcher.Events = make(chan []fsnotify.Event, 1)

        if err == nil </span><span class="cov0" title="0">{
                go batcher.run()
        }</span>

        <span class="cov0" title="0">return batcher, err</span>
}

func (b *Batcher) run() <span class="cov0" title="0">{
        tick := time.Tick(b.interval)
        evs := make([]fsnotify.Event, 0)
OuterLoop:
        for </span><span class="cov0" title="0">{
                select </span>{
                case ev := &lt;-b.Watcher.Events:<span class="cov0" title="0">
                        evs = append(evs, ev)</span>
                case &lt;-tick:<span class="cov0" title="0">
                        if len(evs) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">b.Events &lt;- evs
                        evs = make([]fsnotify.Event, 0)</span>
                case &lt;-b.done:<span class="cov0" title="0">
                        break OuterLoop</span>
                }
        }
        <span class="cov0" title="0">close(b.done)</span>
}

// Close stops the watching of the files.
func (b *Batcher) Close() <span class="cov0" title="0">{
        b.done &lt;- struct{}{}
        b.Watcher.Close()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
